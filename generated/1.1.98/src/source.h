/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.1.7
 */
#include <nan.h>

#include <vulkan/vulkan_win32.h>
#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "utils.h"
    
/** ## BEGIN VkDebugUtilsMessengerEXT ## **/
#ifndef __VK_VKDEBUGUTILSMESSENGEREXT_H__
#define __VK_VKDEBUGUTILSMESSENGEREXT_H__

class _VkDebugUtilsMessengerEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDebugUtilsMessengerEXT instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDebugUtilsMessengerEXT();
    ~_VkDebugUtilsMessengerEXT();

};

#endif
//#include "VkDebugUtilsMessengerEXT.h"

Nan::Persistent<v8::FunctionTemplate> _VkDebugUtilsMessengerEXT::constructor;

_VkDebugUtilsMessengerEXT::_VkDebugUtilsMessengerEXT() {}
_VkDebugUtilsMessengerEXT::~_VkDebugUtilsMessengerEXT() {}

void _VkDebugUtilsMessengerEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugUtilsMessengerEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugUtilsMessengerEXT").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDebugUtilsMessengerEXT").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDebugUtilsMessengerEXT::New) {
  _VkDebugUtilsMessengerEXT* self = new _VkDebugUtilsMessengerEXT();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDebugUtilsMessengerEXT ## **/

/** ## BEGIN VkDebugReportCallbackEXT ## **/
#ifndef __VK_VKDEBUGREPORTCALLBACKEXT_H__
#define __VK_VKDEBUGREPORTCALLBACKEXT_H__

class _VkDebugReportCallbackEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDebugReportCallbackEXT instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDebugReportCallbackEXT();
    ~_VkDebugReportCallbackEXT();

};

#endif
//#include "VkDebugReportCallbackEXT.h"

Nan::Persistent<v8::FunctionTemplate> _VkDebugReportCallbackEXT::constructor;

_VkDebugReportCallbackEXT::_VkDebugReportCallbackEXT() {}
_VkDebugReportCallbackEXT::~_VkDebugReportCallbackEXT() {}

void _VkDebugReportCallbackEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugReportCallbackEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugReportCallbackEXT").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDebugReportCallbackEXT").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDebugReportCallbackEXT::New) {
  _VkDebugReportCallbackEXT* self = new _VkDebugReportCallbackEXT();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDebugReportCallbackEXT ## **/

/** ## BEGIN VkSwapchainKHR ## **/
#ifndef __VK_VKSWAPCHAINKHR_H__
#define __VK_VKSWAPCHAINKHR_H__

class _VkSwapchainKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkSwapchainKHR instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkSwapchainKHR();
    ~_VkSwapchainKHR();

};

#endif
//#include "VkSwapchainKHR.h"

Nan::Persistent<v8::FunctionTemplate> _VkSwapchainKHR::constructor;

_VkSwapchainKHR::_VkSwapchainKHR() {}
_VkSwapchainKHR::~_VkSwapchainKHR() {}

void _VkSwapchainKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSwapchainKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSwapchainKHR").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkSwapchainKHR").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkSwapchainKHR::New) {
  _VkSwapchainKHR* self = new _VkSwapchainKHR();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkSwapchainKHR ## **/

/** ## BEGIN VkSurfaceKHR ## **/
#ifndef __VK_VKSURFACEKHR_H__
#define __VK_VKSURFACEKHR_H__

class _VkSurfaceKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkSurfaceKHR instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkSurfaceKHR();
    ~_VkSurfaceKHR();

};

#endif
//#include "VkSurfaceKHR.h"

Nan::Persistent<v8::FunctionTemplate> _VkSurfaceKHR::constructor;

_VkSurfaceKHR::_VkSurfaceKHR() {}
_VkSurfaceKHR::~_VkSurfaceKHR() {}

void _VkSurfaceKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSurfaceKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSurfaceKHR").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkSurfaceKHR").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkSurfaceKHR::New) {
  _VkSurfaceKHR* self = new _VkSurfaceKHR();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkSurfaceKHR ## **/

/** ## BEGIN VkDisplayModeKHR ## **/
#ifndef __VK_VKDISPLAYMODEKHR_H__
#define __VK_VKDISPLAYMODEKHR_H__

class _VkDisplayModeKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDisplayModeKHR instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDisplayModeKHR();
    ~_VkDisplayModeKHR();

};

#endif
//#include "VkDisplayModeKHR.h"

Nan::Persistent<v8::FunctionTemplate> _VkDisplayModeKHR::constructor;

_VkDisplayModeKHR::_VkDisplayModeKHR() {}
_VkDisplayModeKHR::~_VkDisplayModeKHR() {}

void _VkDisplayModeKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayModeKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayModeKHR").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDisplayModeKHR").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDisplayModeKHR::New) {
  _VkDisplayModeKHR* self = new _VkDisplayModeKHR();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDisplayModeKHR ## **/

/** ## BEGIN VkDisplayKHR ## **/
#ifndef __VK_VKDISPLAYKHR_H__
#define __VK_VKDISPLAYKHR_H__

class _VkDisplayKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDisplayKHR instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDisplayKHR();
    ~_VkDisplayKHR();

};

#endif
//#include "VkDisplayKHR.h"

Nan::Persistent<v8::FunctionTemplate> _VkDisplayKHR::constructor;

_VkDisplayKHR::_VkDisplayKHR() {}
_VkDisplayKHR::~_VkDisplayKHR() {}

void _VkDisplayKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayKHR").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDisplayKHR").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDisplayKHR::New) {
  _VkDisplayKHR* self = new _VkDisplayKHR();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDisplayKHR ## **/

/** ## BEGIN VkAccelerationStructureNV ## **/
#ifndef __VK_VKACCELERATIONSTRUCTURENV_H__
#define __VK_VKACCELERATIONSTRUCTURENV_H__

class _VkAccelerationStructureNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkAccelerationStructureNV instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkAccelerationStructureNV();
    ~_VkAccelerationStructureNV();

};

#endif
//#include "VkAccelerationStructureNV.h"

Nan::Persistent<v8::FunctionTemplate> _VkAccelerationStructureNV::constructor;

_VkAccelerationStructureNV::_VkAccelerationStructureNV() {}
_VkAccelerationStructureNV::~_VkAccelerationStructureNV() {}

void _VkAccelerationStructureNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAccelerationStructureNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAccelerationStructureNV").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkAccelerationStructureNV").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkAccelerationStructureNV::New) {
  _VkAccelerationStructureNV* self = new _VkAccelerationStructureNV();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkAccelerationStructureNV ## **/

/** ## BEGIN VkValidationCacheEXT ## **/
#ifndef __VK_VKVALIDATIONCACHEEXT_H__
#define __VK_VKVALIDATIONCACHEEXT_H__

class _VkValidationCacheEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkValidationCacheEXT instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkValidationCacheEXT();
    ~_VkValidationCacheEXT();

};

#endif
//#include "VkValidationCacheEXT.h"

Nan::Persistent<v8::FunctionTemplate> _VkValidationCacheEXT::constructor;

_VkValidationCacheEXT::_VkValidationCacheEXT() {}
_VkValidationCacheEXT::~_VkValidationCacheEXT() {}

void _VkValidationCacheEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkValidationCacheEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkValidationCacheEXT").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkValidationCacheEXT").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkValidationCacheEXT::New) {
  _VkValidationCacheEXT* self = new _VkValidationCacheEXT();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkValidationCacheEXT ## **/

/** ## BEGIN VkSamplerYcbcrConversion ## **/
#ifndef __VK_VKSAMPLERYCBCRCONVERSION_H__
#define __VK_VKSAMPLERYCBCRCONVERSION_H__

class _VkSamplerYcbcrConversion: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkSamplerYcbcrConversion instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkSamplerYcbcrConversion();
    ~_VkSamplerYcbcrConversion();

};

#endif
//#include "VkSamplerYcbcrConversion.h"

Nan::Persistent<v8::FunctionTemplate> _VkSamplerYcbcrConversion::constructor;

_VkSamplerYcbcrConversion::_VkSamplerYcbcrConversion() {}
_VkSamplerYcbcrConversion::~_VkSamplerYcbcrConversion() {}

void _VkSamplerYcbcrConversion::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerYcbcrConversion::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerYcbcrConversion").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkSamplerYcbcrConversion").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkSamplerYcbcrConversion::New) {
  _VkSamplerYcbcrConversion* self = new _VkSamplerYcbcrConversion();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkSamplerYcbcrConversion ## **/

/** ## BEGIN VkDescriptorUpdateTemplate ## **/
#ifndef __VK_VKDESCRIPTORUPDATETEMPLATE_H__
#define __VK_VKDESCRIPTORUPDATETEMPLATE_H__

class _VkDescriptorUpdateTemplate: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDescriptorUpdateTemplate instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDescriptorUpdateTemplate();
    ~_VkDescriptorUpdateTemplate();

};

#endif
//#include "VkDescriptorUpdateTemplate.h"

Nan::Persistent<v8::FunctionTemplate> _VkDescriptorUpdateTemplate::constructor;

_VkDescriptorUpdateTemplate::_VkDescriptorUpdateTemplate() {}
_VkDescriptorUpdateTemplate::~_VkDescriptorUpdateTemplate() {}

void _VkDescriptorUpdateTemplate::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorUpdateTemplate::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorUpdateTemplate").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDescriptorUpdateTemplate").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDescriptorUpdateTemplate::New) {
  _VkDescriptorUpdateTemplate* self = new _VkDescriptorUpdateTemplate();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDescriptorUpdateTemplate ## **/

/** ## BEGIN VkIndirectCommandsLayoutNVX ## **/
#ifndef __VK_VKINDIRECTCOMMANDSLAYOUTNVX_H__
#define __VK_VKINDIRECTCOMMANDSLAYOUTNVX_H__

class _VkIndirectCommandsLayoutNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkIndirectCommandsLayoutNVX instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkIndirectCommandsLayoutNVX();
    ~_VkIndirectCommandsLayoutNVX();

};

#endif
//#include "VkIndirectCommandsLayoutNVX.h"

Nan::Persistent<v8::FunctionTemplate> _VkIndirectCommandsLayoutNVX::constructor;

_VkIndirectCommandsLayoutNVX::_VkIndirectCommandsLayoutNVX() {}
_VkIndirectCommandsLayoutNVX::~_VkIndirectCommandsLayoutNVX() {}

void _VkIndirectCommandsLayoutNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkIndirectCommandsLayoutNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkIndirectCommandsLayoutNVX").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkIndirectCommandsLayoutNVX").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkIndirectCommandsLayoutNVX::New) {
  _VkIndirectCommandsLayoutNVX* self = new _VkIndirectCommandsLayoutNVX();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkIndirectCommandsLayoutNVX ## **/

/** ## BEGIN VkObjectTableNVX ## **/
#ifndef __VK_VKOBJECTTABLENVX_H__
#define __VK_VKOBJECTTABLENVX_H__

class _VkObjectTableNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkObjectTableNVX instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkObjectTableNVX();
    ~_VkObjectTableNVX();

};

#endif
//#include "VkObjectTableNVX.h"

Nan::Persistent<v8::FunctionTemplate> _VkObjectTableNVX::constructor;

_VkObjectTableNVX::_VkObjectTableNVX() {}
_VkObjectTableNVX::~_VkObjectTableNVX() {}

void _VkObjectTableNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkObjectTableNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkObjectTableNVX").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkObjectTableNVX").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkObjectTableNVX::New) {
  _VkObjectTableNVX* self = new _VkObjectTableNVX();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkObjectTableNVX ## **/

/** ## BEGIN VkPipelineCache ## **/
#ifndef __VK_VKPIPELINECACHE_H__
#define __VK_VKPIPELINECACHE_H__

class _VkPipelineCache: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkPipelineCache instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkPipelineCache();
    ~_VkPipelineCache();

};

#endif
//#include "VkPipelineCache.h"

Nan::Persistent<v8::FunctionTemplate> _VkPipelineCache::constructor;

_VkPipelineCache::_VkPipelineCache() {}
_VkPipelineCache::~_VkPipelineCache() {}

void _VkPipelineCache::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineCache::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineCache").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkPipelineCache").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkPipelineCache::New) {
  _VkPipelineCache* self = new _VkPipelineCache();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkPipelineCache ## **/

/** ## BEGIN VkRenderPass ## **/
#ifndef __VK_VKRENDERPASS_H__
#define __VK_VKRENDERPASS_H__

class _VkRenderPass: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkRenderPass instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkRenderPass();
    ~_VkRenderPass();

};

#endif
//#include "VkRenderPass.h"

Nan::Persistent<v8::FunctionTemplate> _VkRenderPass::constructor;

_VkRenderPass::_VkRenderPass() {}
_VkRenderPass::~_VkRenderPass() {}

void _VkRenderPass::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPass::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPass").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkRenderPass").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkRenderPass::New) {
  _VkRenderPass* self = new _VkRenderPass();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkRenderPass ## **/

/** ## BEGIN VkFramebuffer ## **/
#ifndef __VK_VKFRAMEBUFFER_H__
#define __VK_VKFRAMEBUFFER_H__

class _VkFramebuffer: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkFramebuffer instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkFramebuffer();
    ~_VkFramebuffer();

};

#endif
//#include "VkFramebuffer.h"

Nan::Persistent<v8::FunctionTemplate> _VkFramebuffer::constructor;

_VkFramebuffer::_VkFramebuffer() {}
_VkFramebuffer::~_VkFramebuffer() {}

void _VkFramebuffer::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFramebuffer::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFramebuffer").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkFramebuffer").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkFramebuffer::New) {
  _VkFramebuffer* self = new _VkFramebuffer();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkFramebuffer ## **/

/** ## BEGIN VkQueryPool ## **/
#ifndef __VK_VKQUERYPOOL_H__
#define __VK_VKQUERYPOOL_H__

class _VkQueryPool: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkQueryPool instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkQueryPool();
    ~_VkQueryPool();

};

#endif
//#include "VkQueryPool.h"

Nan::Persistent<v8::FunctionTemplate> _VkQueryPool::constructor;

_VkQueryPool::_VkQueryPool() {}
_VkQueryPool::~_VkQueryPool() {}

void _VkQueryPool::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkQueryPool::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkQueryPool").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkQueryPool").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkQueryPool::New) {
  _VkQueryPool* self = new _VkQueryPool();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkQueryPool ## **/

/** ## BEGIN VkEvent ## **/
#ifndef __VK_VKEVENT_H__
#define __VK_VKEVENT_H__

class _VkEvent: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkEvent instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkEvent();
    ~_VkEvent();

};

#endif
//#include "VkEvent.h"

Nan::Persistent<v8::FunctionTemplate> _VkEvent::constructor;

_VkEvent::_VkEvent() {}
_VkEvent::~_VkEvent() {}

void _VkEvent::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkEvent::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkEvent").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkEvent").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkEvent::New) {
  _VkEvent* self = new _VkEvent();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkEvent ## **/

/** ## BEGIN VkSemaphore ## **/
#ifndef __VK_VKSEMAPHORE_H__
#define __VK_VKSEMAPHORE_H__

class _VkSemaphore: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkSemaphore instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkSemaphore();
    ~_VkSemaphore();

};

#endif
//#include "VkSemaphore.h"

Nan::Persistent<v8::FunctionTemplate> _VkSemaphore::constructor;

_VkSemaphore::_VkSemaphore() {}
_VkSemaphore::~_VkSemaphore() {}

void _VkSemaphore::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSemaphore::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSemaphore").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkSemaphore").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkSemaphore::New) {
  _VkSemaphore* self = new _VkSemaphore();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkSemaphore ## **/

/** ## BEGIN VkFence ## **/
#ifndef __VK_VKFENCE_H__
#define __VK_VKFENCE_H__

class _VkFence: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkFence instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkFence();
    ~_VkFence();

};

#endif
//#include "VkFence.h"

Nan::Persistent<v8::FunctionTemplate> _VkFence::constructor;

_VkFence::_VkFence() {}
_VkFence::~_VkFence() {}

void _VkFence::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFence::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFence").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkFence").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkFence::New) {
  _VkFence* self = new _VkFence();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkFence ## **/

/** ## BEGIN VkDescriptorPool ## **/
#ifndef __VK_VKDESCRIPTORPOOL_H__
#define __VK_VKDESCRIPTORPOOL_H__

class _VkDescriptorPool: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDescriptorPool instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDescriptorPool();
    ~_VkDescriptorPool();

};

#endif
//#include "VkDescriptorPool.h"

Nan::Persistent<v8::FunctionTemplate> _VkDescriptorPool::constructor;

_VkDescriptorPool::_VkDescriptorPool() {}
_VkDescriptorPool::~_VkDescriptorPool() {}

void _VkDescriptorPool::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorPool::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorPool").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDescriptorPool").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDescriptorPool::New) {
  _VkDescriptorPool* self = new _VkDescriptorPool();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDescriptorPool ## **/

/** ## BEGIN VkDescriptorSetLayout ## **/
#ifndef __VK_VKDESCRIPTORSETLAYOUT_H__
#define __VK_VKDESCRIPTORSETLAYOUT_H__

class _VkDescriptorSetLayout: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDescriptorSetLayout instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDescriptorSetLayout();
    ~_VkDescriptorSetLayout();

};

#endif
//#include "VkDescriptorSetLayout.h"

Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetLayout::constructor;

_VkDescriptorSetLayout::_VkDescriptorSetLayout() {}
_VkDescriptorSetLayout::~_VkDescriptorSetLayout() {}

void _VkDescriptorSetLayout::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetLayout::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetLayout").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDescriptorSetLayout").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDescriptorSetLayout::New) {
  _VkDescriptorSetLayout* self = new _VkDescriptorSetLayout();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDescriptorSetLayout ## **/

/** ## BEGIN VkDescriptorSet ## **/
#ifndef __VK_VKDESCRIPTORSET_H__
#define __VK_VKDESCRIPTORSET_H__

class _VkDescriptorSet: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDescriptorSet instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDescriptorSet();
    ~_VkDescriptorSet();

};

#endif
//#include "VkDescriptorSet.h"

Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSet::constructor;

_VkDescriptorSet::_VkDescriptorSet() {}
_VkDescriptorSet::~_VkDescriptorSet() {}

void _VkDescriptorSet::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSet::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSet").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDescriptorSet").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDescriptorSet::New) {
  _VkDescriptorSet* self = new _VkDescriptorSet();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDescriptorSet ## **/

/** ## BEGIN VkSampler ## **/
#ifndef __VK_VKSAMPLER_H__
#define __VK_VKSAMPLER_H__

class _VkSampler: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkSampler instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkSampler();
    ~_VkSampler();

};

#endif
//#include "VkSampler.h"

Nan::Persistent<v8::FunctionTemplate> _VkSampler::constructor;

_VkSampler::_VkSampler() {}
_VkSampler::~_VkSampler() {}

void _VkSampler::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSampler::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSampler").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkSampler").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkSampler::New) {
  _VkSampler* self = new _VkSampler();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkSampler ## **/

/** ## BEGIN VkPipelineLayout ## **/
#ifndef __VK_VKPIPELINELAYOUT_H__
#define __VK_VKPIPELINELAYOUT_H__

class _VkPipelineLayout: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkPipelineLayout instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkPipelineLayout();
    ~_VkPipelineLayout();

};

#endif
//#include "VkPipelineLayout.h"

Nan::Persistent<v8::FunctionTemplate> _VkPipelineLayout::constructor;

_VkPipelineLayout::_VkPipelineLayout() {}
_VkPipelineLayout::~_VkPipelineLayout() {}

void _VkPipelineLayout::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineLayout::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineLayout").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkPipelineLayout").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkPipelineLayout::New) {
  _VkPipelineLayout* self = new _VkPipelineLayout();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkPipelineLayout ## **/

/** ## BEGIN VkPipeline ## **/
#ifndef __VK_VKPIPELINE_H__
#define __VK_VKPIPELINE_H__

class _VkPipeline: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkPipeline instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkPipeline();
    ~_VkPipeline();

};

#endif
//#include "VkPipeline.h"

Nan::Persistent<v8::FunctionTemplate> _VkPipeline::constructor;

_VkPipeline::_VkPipeline() {}
_VkPipeline::~_VkPipeline() {}

void _VkPipeline::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipeline::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipeline").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkPipeline").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkPipeline::New) {
  _VkPipeline* self = new _VkPipeline();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkPipeline ## **/

/** ## BEGIN VkShaderModule ## **/
#ifndef __VK_VKSHADERMODULE_H__
#define __VK_VKSHADERMODULE_H__

class _VkShaderModule: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkShaderModule instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkShaderModule();
    ~_VkShaderModule();

};

#endif
//#include "VkShaderModule.h"

Nan::Persistent<v8::FunctionTemplate> _VkShaderModule::constructor;

_VkShaderModule::_VkShaderModule() {}
_VkShaderModule::~_VkShaderModule() {}

void _VkShaderModule::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkShaderModule::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkShaderModule").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkShaderModule").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkShaderModule::New) {
  _VkShaderModule* self = new _VkShaderModule();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkShaderModule ## **/

/** ## BEGIN VkImageView ## **/
#ifndef __VK_VKIMAGEVIEW_H__
#define __VK_VKIMAGEVIEW_H__

class _VkImageView: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkImageView instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkImageView();
    ~_VkImageView();

};

#endif
//#include "VkImageView.h"

Nan::Persistent<v8::FunctionTemplate> _VkImageView::constructor;

_VkImageView::_VkImageView() {}
_VkImageView::~_VkImageView() {}

void _VkImageView::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageView::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageView").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkImageView").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkImageView::New) {
  _VkImageView* self = new _VkImageView();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkImageView ## **/

/** ## BEGIN VkImage ## **/
#ifndef __VK_VKIMAGE_H__
#define __VK_VKIMAGE_H__

class _VkImage: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkImage instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkImage();
    ~_VkImage();

};

#endif
//#include "VkImage.h"

Nan::Persistent<v8::FunctionTemplate> _VkImage::constructor;

_VkImage::_VkImage() {}
_VkImage::~_VkImage() {}

void _VkImage::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImage::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImage").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkImage").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkImage::New) {
  _VkImage* self = new _VkImage();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkImage ## **/

/** ## BEGIN VkBufferView ## **/
#ifndef __VK_VKBUFFERVIEW_H__
#define __VK_VKBUFFERVIEW_H__

class _VkBufferView: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkBufferView instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkBufferView();
    ~_VkBufferView();

};

#endif
//#include "VkBufferView.h"

Nan::Persistent<v8::FunctionTemplate> _VkBufferView::constructor;

_VkBufferView::_VkBufferView() {}
_VkBufferView::~_VkBufferView() {}

void _VkBufferView::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferView::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferView").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkBufferView").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkBufferView::New) {
  _VkBufferView* self = new _VkBufferView();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkBufferView ## **/

/** ## BEGIN VkBuffer ## **/
#ifndef __VK_VKBUFFER_H__
#define __VK_VKBUFFER_H__

class _VkBuffer: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkBuffer instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkBuffer();
    ~_VkBuffer();

};

#endif
//#include "VkBuffer.h"

Nan::Persistent<v8::FunctionTemplate> _VkBuffer::constructor;

_VkBuffer::_VkBuffer() {}
_VkBuffer::~_VkBuffer() {}

void _VkBuffer::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBuffer::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBuffer").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkBuffer").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkBuffer::New) {
  _VkBuffer* self = new _VkBuffer();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkBuffer ## **/

/** ## BEGIN VkCommandPool ## **/
#ifndef __VK_VKCOMMANDPOOL_H__
#define __VK_VKCOMMANDPOOL_H__

class _VkCommandPool: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkCommandPool instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkCommandPool();
    ~_VkCommandPool();

};

#endif
//#include "VkCommandPool.h"

Nan::Persistent<v8::FunctionTemplate> _VkCommandPool::constructor;

_VkCommandPool::_VkCommandPool() {}
_VkCommandPool::~_VkCommandPool() {}

void _VkCommandPool::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCommandPool::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCommandPool").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkCommandPool").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkCommandPool::New) {
  _VkCommandPool* self = new _VkCommandPool();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkCommandPool ## **/

/** ## BEGIN VkDeviceMemory ## **/
#ifndef __VK_VKDEVICEMEMORY_H__
#define __VK_VKDEVICEMEMORY_H__

class _VkDeviceMemory: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDeviceMemory instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDeviceMemory();
    ~_VkDeviceMemory();

};

#endif
//#include "VkDeviceMemory.h"

Nan::Persistent<v8::FunctionTemplate> _VkDeviceMemory::constructor;

_VkDeviceMemory::_VkDeviceMemory() {}
_VkDeviceMemory::~_VkDeviceMemory() {}

void _VkDeviceMemory::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceMemory::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceMemory").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDeviceMemory").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDeviceMemory::New) {
  _VkDeviceMemory* self = new _VkDeviceMemory();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDeviceMemory ## **/

/** ## BEGIN VkCommandBuffer ## **/
#ifndef __VK_VKCOMMANDBUFFER_H__
#define __VK_VKCOMMANDBUFFER_H__

class _VkCommandBuffer: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkCommandBuffer instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkCommandBuffer();
    ~_VkCommandBuffer();

};

#endif
//#include "VkCommandBuffer.h"

Nan::Persistent<v8::FunctionTemplate> _VkCommandBuffer::constructor;

_VkCommandBuffer::_VkCommandBuffer() {}
_VkCommandBuffer::~_VkCommandBuffer() {}

void _VkCommandBuffer::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCommandBuffer::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCommandBuffer").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkCommandBuffer").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkCommandBuffer::New) {
  _VkCommandBuffer* self = new _VkCommandBuffer();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkCommandBuffer ## **/

/** ## BEGIN VkQueue ## **/
#ifndef __VK_VKQUEUE_H__
#define __VK_VKQUEUE_H__

class _VkQueue: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkQueue instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkQueue();
    ~_VkQueue();

};

#endif
//#include "VkQueue.h"

Nan::Persistent<v8::FunctionTemplate> _VkQueue::constructor;

_VkQueue::_VkQueue() {}
_VkQueue::~_VkQueue() {}

void _VkQueue::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkQueue::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkQueue").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkQueue").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkQueue::New) {
  _VkQueue* self = new _VkQueue();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkQueue ## **/

/** ## BEGIN VkDevice ## **/
#ifndef __VK_VKDEVICE_H__
#define __VK_VKDEVICE_H__

class _VkDevice: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkDevice instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkDevice();
    ~_VkDevice();

};

#endif
//#include "VkDevice.h"

Nan::Persistent<v8::FunctionTemplate> _VkDevice::constructor;

_VkDevice::_VkDevice() {}
_VkDevice::~_VkDevice() {}

void _VkDevice::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDevice::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDevice").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkDevice").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkDevice::New) {
  _VkDevice* self = new _VkDevice();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkDevice ## **/

/** ## BEGIN VkPhysicalDevice ## **/
#ifndef __VK_VKPHYSICALDEVICE_H__
#define __VK_VKPHYSICALDEVICE_H__

class _VkPhysicalDevice: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkPhysicalDevice instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkPhysicalDevice();
    ~_VkPhysicalDevice();

};

#endif
//#include "VkPhysicalDevice.h"

Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDevice::constructor;

_VkPhysicalDevice::_VkPhysicalDevice() {}
_VkPhysicalDevice::~_VkPhysicalDevice() {}

void _VkPhysicalDevice::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDevice::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDevice").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkPhysicalDevice").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkPhysicalDevice::New) {
  _VkPhysicalDevice* self = new _VkPhysicalDevice();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkPhysicalDevice ## **/

/** ## BEGIN VkInstance ## **/
#ifndef __VK_VKINSTANCE_H__
#define __VK_VKINSTANCE_H__

class _VkInstance: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);

    // real instance
    VkInstance instance;

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);

  private:
    _VkInstance();
    ~_VkInstance();

};

#endif
//#include "VkInstance.h"

Nan::Persistent<v8::FunctionTemplate> _VkInstance::constructor;

_VkInstance::_VkInstance() {}
_VkInstance::~_VkInstance() {}

void _VkInstance::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // Constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkInstance::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkInstance").ToLocalChecked());

  // Prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();

  Nan::Set(target, Nan::New("VkInstance").ToLocalChecked(), ctor->GetFunction());
}

NAN_METHOD(_VkInstance::New) {
  _VkInstance* self = new _VkInstance();
  self->Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
};

/** ## END VkInstance ## **/

/** ## BEGIN VkClearColorValue ## **/

class _VkClearColorValue: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    std::vector<float>* vfloat32;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> float32;
    static NAN_GETTER(Getfloat32);
    static NAN_SETTER(Setfloat32);
    
    std::vector<int32_t>* vint32;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> int32;
    static NAN_GETTER(Getint32);
    static NAN_SETTER(Setint32);
    
    std::vector<uint32_t>* vuint32;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> uint32;
    static NAN_GETTER(Getuint32);
    static NAN_SETTER(Setuint32);
    

    // real instance
    VkClearColorValue instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkClearColorValue();
    ~_VkClearColorValue();

};

/*
#include <string.h>
#include "index.h"
#include "VkClearColorValue.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkClearColorValue::constructor;

_VkClearColorValue::_VkClearColorValue() {
  
  vfloat32 = new std::vector<float>;
  vint32 = new std::vector<int32_t>;
  vuint32 = new std::vector<uint32_t>;
  
}

_VkClearColorValue::~_VkClearColorValue() {
  //printf("VkClearColorValue deconstructed!!\n");
  
  vfloat32->clear();
  delete vfloat32;
  
  
  vint32->clear();
  delete vint32;
  
  
  vuint32->clear();
  delete vuint32;
  
  
}

void _VkClearColorValue::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkClearColorValue::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkClearColorValue").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("float32").ToLocalChecked(), Getfloat32, Setfloat32, ctor);
  SetPrototypeAccessor(proto, Nan::New("int32").ToLocalChecked(), Getint32, Setint32, ctor);
  SetPrototypeAccessor(proto, Nan::New("uint32").ToLocalChecked(), Getuint32, Setuint32, ctor);
  Nan::Set(target, Nan::New("VkClearColorValue").ToLocalChecked(), ctor->GetFunction());
}

bool _VkClearColorValue::flush() {
  _VkClearColorValue *self = this;
  if (!(self->float32.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->float32);
    
    if (value->IsArray()) {
      // validate length
      if (v8::Local<v8::Array>::Cast(value)->Length() != 4) {
        Nan::ThrowRangeError("Invalid array length, expected array length of '4' for 'VkClearColorValue.float32'");
        return false;
      }
      std::vector<float> array = createArrayOfV8Numbers<float>(value);
      memcpy(self->instance.float32, array.data(), sizeof(float) * 4);
    } else if (value->IsNull()) {
      memset(&self->instance.float32, 0, sizeof(float));
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkClearColorValue.float32", "Array");
  
      return false;
    }
  }if (!(self->int32.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->int32);
    
    if (value->IsArray()) {
      // validate length
      if (v8::Local<v8::Array>::Cast(value)->Length() != 4) {
        Nan::ThrowRangeError("Invalid array length, expected array length of '4' for 'VkClearColorValue.int32'");
        return false;
      }
      std::vector<int32_t> array = createArrayOfV8Numbers<int32_t>(value);
      memcpy(self->instance.int32, array.data(), sizeof(int32_t) * 4);
    } else if (value->IsNull()) {
      memset(&self->instance.int32, 0, sizeof(int32_t));
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkClearColorValue.int32", "Array");
  
      return false;
    }
  }if (!(self->uint32.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->uint32);
    
    if (value->IsArray()) {
      // validate length
      if (v8::Local<v8::Array>::Cast(value)->Length() != 4) {
        Nan::ThrowRangeError("Invalid array length, expected array length of '4' for 'VkClearColorValue.uint32'");
        return false;
      }
      std::vector<uint32_t> array = createArrayOfV8Numbers<uint32_t>(value);
      memcpy(self->instance.uint32, array.data(), sizeof(uint32_t) * 4);
    } else if (value->IsNull()) {
      memset(&self->instance.uint32, 0, sizeof(uint32_t));
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkClearColorValue.uint32", "Array");
  
      return false;
    }
  }
  return true;
}

NAN_METHOD(_VkClearColorValue::New) {
  if (info.IsConstructCall()) {
    _VkClearColorValue* self = new _VkClearColorValue();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("float32").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("int32").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("uint32").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkClearColorValue constructor cannot be invoked without 'new'");
  }
};

// float32
NAN_GETTER(_VkClearColorValue::Getfloat32) {
  _VkClearColorValue *self = Nan::ObjectWrap::Unwrap<_VkClearColorValue>(info.This());
  if (self->float32.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->float32));
  }
}NAN_SETTER(_VkClearColorValue::Setfloat32) {
  _VkClearColorValue *self = Nan::ObjectWrap::Unwrap<_VkClearColorValue>(info.This());
  // js
  if (value->IsArray()) {
    self->float32.Reset<v8::Array>(value.As<v8::Array>());
  } else if (value->IsNull()) {
    self->float32.Reset();
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearColorValue.float32", "Array");
  
    return;
  }
}// int32
NAN_GETTER(_VkClearColorValue::Getint32) {
  _VkClearColorValue *self = Nan::ObjectWrap::Unwrap<_VkClearColorValue>(info.This());
  if (self->int32.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->int32));
  }
}NAN_SETTER(_VkClearColorValue::Setint32) {
  _VkClearColorValue *self = Nan::ObjectWrap::Unwrap<_VkClearColorValue>(info.This());
  // js
  if (value->IsArray()) {
    self->int32.Reset<v8::Array>(value.As<v8::Array>());
  } else if (value->IsNull()) {
    self->int32.Reset();
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearColorValue.int32", "Array");
  
    return;
  }
}// uint32
NAN_GETTER(_VkClearColorValue::Getuint32) {
  _VkClearColorValue *self = Nan::ObjectWrap::Unwrap<_VkClearColorValue>(info.This());
  if (self->uint32.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->uint32));
  }
}NAN_SETTER(_VkClearColorValue::Setuint32) {
  _VkClearColorValue *self = Nan::ObjectWrap::Unwrap<_VkClearColorValue>(info.This());
  // js
  if (value->IsArray()) {
    self->uint32.Reset<v8::Array>(value.As<v8::Array>());
  } else if (value->IsNull()) {
    self->uint32.Reset();
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearColorValue.uint32", "Array");
  
    return;
  }
}
/** ## END VkClearColorValue ## **/

/** ## BEGIN VkBufferDeviceAddressCreateInfoEXT ## **/

class _VkBufferDeviceAddressCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdeviceAddress);
    static NAN_SETTER(SetdeviceAddress);
    

    // real instance
    VkBufferDeviceAddressCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferDeviceAddressCreateInfoEXT();
    ~_VkBufferDeviceAddressCreateInfoEXT();

};

/*
#include "index.h"
#include "VkBufferDeviceAddressCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferDeviceAddressCreateInfoEXT::constructor;

_VkBufferDeviceAddressCreateInfoEXT::_VkBufferDeviceAddressCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT;
  
}

_VkBufferDeviceAddressCreateInfoEXT::~_VkBufferDeviceAddressCreateInfoEXT() {
  //printf("VkBufferDeviceAddressCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkBufferDeviceAddressCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferDeviceAddressCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferDeviceAddressCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceAddress").ToLocalChecked(), GetdeviceAddress, SetdeviceAddress, ctor);
  Nan::Set(target, Nan::New("VkBufferDeviceAddressCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferDeviceAddressCreateInfoEXT::flush() {
  _VkBufferDeviceAddressCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkBufferDeviceAddressCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkBufferDeviceAddressCreateInfoEXT* self = new _VkBufferDeviceAddressCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("deviceAddress").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferDeviceAddressCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBufferDeviceAddressCreateInfoEXT::GetsType) {
  _VkBufferDeviceAddressCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkBufferDeviceAddressCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBufferDeviceAddressCreateInfoEXT::SetsType) {
  _VkBufferDeviceAddressCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkBufferDeviceAddressCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferDeviceAddressCreateInfoEXT.sType", "Number");
  
    return;
  }
}// deviceAddress
NAN_GETTER(_VkBufferDeviceAddressCreateInfoEXT::GetdeviceAddress) {
  _VkBufferDeviceAddressCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkBufferDeviceAddressCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceAddress));
}NAN_SETTER(_VkBufferDeviceAddressCreateInfoEXT::SetdeviceAddress) {
  _VkBufferDeviceAddressCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkBufferDeviceAddressCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceAddress = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferDeviceAddressCreateInfoEXT.deviceAddress", "Number");
  
    return;
  }
}
/** ## END VkBufferDeviceAddressCreateInfoEXT ## **/

/** ## BEGIN VkBufferDeviceAddressInfoEXT ## **/

class _VkBufferDeviceAddressInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    

    // real instance
    VkBufferDeviceAddressInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferDeviceAddressInfoEXT();
    ~_VkBufferDeviceAddressInfoEXT();

};

/*
#include "index.h"
#include "VkBufferDeviceAddressInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferDeviceAddressInfoEXT::constructor;

_VkBufferDeviceAddressInfoEXT::_VkBufferDeviceAddressInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT;
  
}

_VkBufferDeviceAddressInfoEXT::~_VkBufferDeviceAddressInfoEXT() {
  //printf("VkBufferDeviceAddressInfoEXT deconstructed!!\n");
  
  
  
}

void _VkBufferDeviceAddressInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferDeviceAddressInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferDeviceAddressInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  Nan::Set(target, Nan::New("VkBufferDeviceAddressInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferDeviceAddressInfoEXT::flush() {
  _VkBufferDeviceAddressInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkBufferDeviceAddressInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkBufferDeviceAddressInfoEXT* self = new _VkBufferDeviceAddressInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("buffer").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferDeviceAddressInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBufferDeviceAddressInfoEXT::GetsType) {
  _VkBufferDeviceAddressInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkBufferDeviceAddressInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBufferDeviceAddressInfoEXT::SetsType) {
  _VkBufferDeviceAddressInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkBufferDeviceAddressInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferDeviceAddressInfoEXT.sType", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkBufferDeviceAddressInfoEXT::Getbuffer) {
  _VkBufferDeviceAddressInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkBufferDeviceAddressInfoEXT>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBufferDeviceAddressInfoEXT::Setbuffer) {
  _VkBufferDeviceAddressInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkBufferDeviceAddressInfoEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBufferDeviceAddressInfoEXT.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferDeviceAddressInfoEXT.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkBufferDeviceAddressInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceBufferAddressFeaturesEXT ## **/

class _VkPhysicalDeviceBufferAddressFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetbufferDeviceAddress);
    static NAN_SETTER(SetbufferDeviceAddress);
    
    static NAN_GETTER(GetbufferDeviceAddressCaptureReplay);
    static NAN_SETTER(SetbufferDeviceAddressCaptureReplay);
    
    static NAN_GETTER(GetbufferDeviceAddressMultiDevice);
    static NAN_SETTER(SetbufferDeviceAddressMultiDevice);
    

    // real instance
    VkPhysicalDeviceBufferAddressFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceBufferAddressFeaturesEXT();
    ~_VkPhysicalDeviceBufferAddressFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceBufferAddressFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceBufferAddressFeaturesEXT::constructor;

_VkPhysicalDeviceBufferAddressFeaturesEXT::_VkPhysicalDeviceBufferAddressFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT;
  
}

_VkPhysicalDeviceBufferAddressFeaturesEXT::~_VkPhysicalDeviceBufferAddressFeaturesEXT() {
  //printf("VkPhysicalDeviceBufferAddressFeaturesEXT deconstructed!!\n");
  
  
  
  
  
}

void _VkPhysicalDeviceBufferAddressFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceBufferAddressFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceBufferAddressFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("bufferDeviceAddress").ToLocalChecked(), GetbufferDeviceAddress, SetbufferDeviceAddress, ctor);
  SetPrototypeAccessor(proto, Nan::New("bufferDeviceAddressCaptureReplay").ToLocalChecked(), GetbufferDeviceAddressCaptureReplay, SetbufferDeviceAddressCaptureReplay, ctor);
  SetPrototypeAccessor(proto, Nan::New("bufferDeviceAddressMultiDevice").ToLocalChecked(), GetbufferDeviceAddressMultiDevice, SetbufferDeviceAddressMultiDevice, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceBufferAddressFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceBufferAddressFeaturesEXT::flush() {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceBufferAddressFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceBufferAddressFeaturesEXT* self = new _VkPhysicalDeviceBufferAddressFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("bufferDeviceAddress").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("bufferDeviceAddressCaptureReplay").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("bufferDeviceAddressMultiDevice").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceBufferAddressFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceBufferAddressFeaturesEXT::GetsType) {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBufferAddressFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceBufferAddressFeaturesEXT::SetsType) {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBufferAddressFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceBufferAddressFeaturesEXT.sType", "Number");
  
    return;
  }
}// bufferDeviceAddress
NAN_GETTER(_VkPhysicalDeviceBufferAddressFeaturesEXT::GetbufferDeviceAddress) {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBufferAddressFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferDeviceAddress));
}NAN_SETTER(_VkPhysicalDeviceBufferAddressFeaturesEXT::SetbufferDeviceAddress) {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBufferAddressFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.bufferDeviceAddress = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceBufferAddressFeaturesEXT.bufferDeviceAddress", "Number");
  
    return;
  }
}// bufferDeviceAddressCaptureReplay
NAN_GETTER(_VkPhysicalDeviceBufferAddressFeaturesEXT::GetbufferDeviceAddressCaptureReplay) {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBufferAddressFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferDeviceAddressCaptureReplay));
}NAN_SETTER(_VkPhysicalDeviceBufferAddressFeaturesEXT::SetbufferDeviceAddressCaptureReplay) {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBufferAddressFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.bufferDeviceAddressCaptureReplay = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceBufferAddressFeaturesEXT.bufferDeviceAddressCaptureReplay", "Number");
  
    return;
  }
}// bufferDeviceAddressMultiDevice
NAN_GETTER(_VkPhysicalDeviceBufferAddressFeaturesEXT::GetbufferDeviceAddressMultiDevice) {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBufferAddressFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferDeviceAddressMultiDevice));
}NAN_SETTER(_VkPhysicalDeviceBufferAddressFeaturesEXT::SetbufferDeviceAddressMultiDevice) {
  _VkPhysicalDeviceBufferAddressFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBufferAddressFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.bufferDeviceAddressMultiDevice = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceBufferAddressFeaturesEXT.bufferDeviceAddressMultiDevice", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceBufferAddressFeaturesEXT ## **/

/** ## BEGIN VkMemoryPriorityAllocateInfoEXT ## **/

class _VkMemoryPriorityAllocateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getpriority);
    static NAN_SETTER(Setpriority);
    

    // real instance
    VkMemoryPriorityAllocateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryPriorityAllocateInfoEXT();
    ~_VkMemoryPriorityAllocateInfoEXT();

};

/*
#include "index.h"
#include "VkMemoryPriorityAllocateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryPriorityAllocateInfoEXT::constructor;

_VkMemoryPriorityAllocateInfoEXT::_VkMemoryPriorityAllocateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT;
  
}

_VkMemoryPriorityAllocateInfoEXT::~_VkMemoryPriorityAllocateInfoEXT() {
  //printf("VkMemoryPriorityAllocateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkMemoryPriorityAllocateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryPriorityAllocateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryPriorityAllocateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("priority").ToLocalChecked(), Getpriority, Setpriority, ctor);
  Nan::Set(target, Nan::New("VkMemoryPriorityAllocateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryPriorityAllocateInfoEXT::flush() {
  _VkMemoryPriorityAllocateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryPriorityAllocateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkMemoryPriorityAllocateInfoEXT* self = new _VkMemoryPriorityAllocateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("priority").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryPriorityAllocateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryPriorityAllocateInfoEXT::GetsType) {
  _VkMemoryPriorityAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkMemoryPriorityAllocateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkMemoryPriorityAllocateInfoEXT::SetsType) {
  _VkMemoryPriorityAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkMemoryPriorityAllocateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryPriorityAllocateInfoEXT.sType", "Number");
  
    return;
  }
}// priority
NAN_GETTER(_VkMemoryPriorityAllocateInfoEXT::Getpriority) {
  _VkMemoryPriorityAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkMemoryPriorityAllocateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.priority));
}NAN_SETTER(_VkMemoryPriorityAllocateInfoEXT::Setpriority) {
  _VkMemoryPriorityAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkMemoryPriorityAllocateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.priority = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryPriorityAllocateInfoEXT.priority", "Number");
  
    return;
  }
}
/** ## END VkMemoryPriorityAllocateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceMemoryPriorityFeaturesEXT ## **/

class _VkPhysicalDeviceMemoryPriorityFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetmemoryPriority);
    static NAN_SETTER(SetmemoryPriority);
    

    // real instance
    VkPhysicalDeviceMemoryPriorityFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMemoryPriorityFeaturesEXT();
    ~_VkPhysicalDeviceMemoryPriorityFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMemoryPriorityFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMemoryPriorityFeaturesEXT::constructor;

_VkPhysicalDeviceMemoryPriorityFeaturesEXT::_VkPhysicalDeviceMemoryPriorityFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
  
}

_VkPhysicalDeviceMemoryPriorityFeaturesEXT::~_VkPhysicalDeviceMemoryPriorityFeaturesEXT() {
  //printf("VkPhysicalDeviceMemoryPriorityFeaturesEXT deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceMemoryPriorityFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMemoryPriorityFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMemoryPriorityFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryPriority").ToLocalChecked(), GetmemoryPriority, SetmemoryPriority, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMemoryPriorityFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMemoryPriorityFeaturesEXT::flush() {
  _VkPhysicalDeviceMemoryPriorityFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMemoryPriorityFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMemoryPriorityFeaturesEXT* self = new _VkPhysicalDeviceMemoryPriorityFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("memoryPriority").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMemoryPriorityFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMemoryPriorityFeaturesEXT::GetsType) {
  _VkPhysicalDeviceMemoryPriorityFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryPriorityFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceMemoryPriorityFeaturesEXT::SetsType) {
  _VkPhysicalDeviceMemoryPriorityFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryPriorityFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMemoryPriorityFeaturesEXT.sType", "Number");
  
    return;
  }
}// memoryPriority
NAN_GETTER(_VkPhysicalDeviceMemoryPriorityFeaturesEXT::GetmemoryPriority) {
  _VkPhysicalDeviceMemoryPriorityFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryPriorityFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryPriority));
}NAN_SETTER(_VkPhysicalDeviceMemoryPriorityFeaturesEXT::SetmemoryPriority) {
  _VkPhysicalDeviceMemoryPriorityFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryPriorityFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.memoryPriority = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMemoryPriorityFeaturesEXT.memoryPriority", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceMemoryPriorityFeaturesEXT ## **/

/** ## BEGIN VkPhysicalDeviceMemoryBudgetPropertiesEXT ## **/

class _VkPhysicalDeviceMemoryBudgetPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    std::vector<uint64_t>* vheapBudget;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> heapBudget;
    static NAN_GETTER(GetheapBudget);
    std::vector<uint64_t>* vheapUsage;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> heapUsage;
    static NAN_GETTER(GetheapUsage);

    // real instance
    VkPhysicalDeviceMemoryBudgetPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMemoryBudgetPropertiesEXT();
    ~_VkPhysicalDeviceMemoryBudgetPropertiesEXT();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceMemoryBudgetPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMemoryBudgetPropertiesEXT::constructor;

_VkPhysicalDeviceMemoryBudgetPropertiesEXT::_VkPhysicalDeviceMemoryBudgetPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
  vheapBudget = new std::vector<uint64_t>;
  vheapUsage = new std::vector<uint64_t>;
  
}

_VkPhysicalDeviceMemoryBudgetPropertiesEXT::~_VkPhysicalDeviceMemoryBudgetPropertiesEXT() {
  //printf("VkPhysicalDeviceMemoryBudgetPropertiesEXT deconstructed!!\n");
  
  
  vheapBudget->clear();
  delete vheapBudget;
  
  
  vheapUsage->clear();
  delete vheapUsage;
  
  
}

void _VkPhysicalDeviceMemoryBudgetPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMemoryBudgetPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMemoryBudgetPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("heapBudget").ToLocalChecked(), GetheapBudget, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("heapUsage").ToLocalChecked(), GetheapUsage, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMemoryBudgetPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMemoryBudgetPropertiesEXT::flush() {
  _VkPhysicalDeviceMemoryBudgetPropertiesEXT *self = this;
  if (!(self->heapBudget.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->heapBudget);
    
  }if (!(self->heapUsage.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->heapUsage);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMemoryBudgetPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMemoryBudgetPropertiesEXT* self = new _VkPhysicalDeviceMemoryBudgetPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMemoryBudgetPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMemoryBudgetPropertiesEXT::GetsType) {
  _VkPhysicalDeviceMemoryBudgetPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryBudgetPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// heapBudget
NAN_GETTER(_VkPhysicalDeviceMemoryBudgetPropertiesEXT::GetheapBudget) {
  _VkPhysicalDeviceMemoryBudgetPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryBudgetPropertiesEXT>(info.This());
  if (self->heapBudget.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->heapBudget));
  }
}// heapUsage
NAN_GETTER(_VkPhysicalDeviceMemoryBudgetPropertiesEXT::GetheapUsage) {
  _VkPhysicalDeviceMemoryBudgetPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryBudgetPropertiesEXT>(info.This());
  if (self->heapUsage.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->heapUsage));
  }
}
/** ## END VkPhysicalDeviceMemoryBudgetPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceScalarBlockLayoutFeaturesEXT ## **/

class _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetscalarBlockLayout);
    static NAN_SETTER(SetscalarBlockLayout);
    

    // real instance
    VkPhysicalDeviceScalarBlockLayoutFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT();
    ~_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::constructor;

_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT;
  
}

_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::~_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT() {
  //printf("VkPhysicalDeviceScalarBlockLayoutFeaturesEXT deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceScalarBlockLayoutFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("scalarBlockLayout").ToLocalChecked(), GetscalarBlockLayout, SetscalarBlockLayout, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceScalarBlockLayoutFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::flush() {
  _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT* self = new _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("scalarBlockLayout").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceScalarBlockLayoutFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::GetsType) {
  _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::SetsType) {
  _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.sType", "Number");
  
    return;
  }
}// scalarBlockLayout
NAN_GETTER(_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::GetscalarBlockLayout) {
  _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.scalarBlockLayout));
}NAN_SETTER(_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT::SetscalarBlockLayout) {
  _VkPhysicalDeviceScalarBlockLayoutFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.scalarBlockLayout = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.scalarBlockLayout", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceScalarBlockLayoutFeaturesEXT ## **/

/** ## BEGIN VkAttachmentReference ## **/

class _VkAttachmentReference: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getattachment);
    static NAN_SETTER(Setattachment);
    
    static NAN_GETTER(Getlayout);
    static NAN_SETTER(Setlayout);
    

    // real instance
    VkAttachmentReference instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAttachmentReference();
    ~_VkAttachmentReference();

};

/*
#include "index.h"
#include "VkAttachmentReference.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAttachmentReference::constructor;

_VkAttachmentReference::_VkAttachmentReference() {
  
  
}

_VkAttachmentReference::~_VkAttachmentReference() {
  //printf("VkAttachmentReference deconstructed!!\n");
  
  
  
}

void _VkAttachmentReference::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAttachmentReference::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAttachmentReference").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("attachment").ToLocalChecked(), Getattachment, Setattachment, ctor);
  SetPrototypeAccessor(proto, Nan::New("layout").ToLocalChecked(), Getlayout, Setlayout, ctor);
  Nan::Set(target, Nan::New("VkAttachmentReference").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAttachmentReference::flush() {
  _VkAttachmentReference *self = this;
  
  return true;
}

NAN_METHOD(_VkAttachmentReference::New) {
  if (info.IsConstructCall()) {
    _VkAttachmentReference* self = new _VkAttachmentReference();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("attachment").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("layout").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAttachmentReference constructor cannot be invoked without 'new'");
  }
};

// attachment
NAN_GETTER(_VkAttachmentReference::Getattachment) {
  _VkAttachmentReference *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.attachment));
}NAN_SETTER(_VkAttachmentReference::Setattachment) {
  _VkAttachmentReference *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(info.This());
  if (value->IsNumber()) {
    self->instance.attachment = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentReference.attachment", "Number");
  
    return;
  }
}// layout
NAN_GETTER(_VkAttachmentReference::Getlayout) {
  _VkAttachmentReference *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.layout));
}NAN_SETTER(_VkAttachmentReference::Setlayout) {
  _VkAttachmentReference *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(info.This());
  if (value->IsNumber()) {
    self->instance.layout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentReference.layout", "Number");
  
    return;
  }
}
/** ## END VkAttachmentReference ## **/

/** ## BEGIN VkRenderPassFragmentDensityMapCreateInfoEXT ## **/

class _VkRenderPassFragmentDensityMapCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> fragmentDensityMapAttachment;
      static NAN_GETTER(GetfragmentDensityMapAttachment);
    static NAN_SETTER(SetfragmentDensityMapAttachment);
    

    // real instance
    VkRenderPassFragmentDensityMapCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassFragmentDensityMapCreateInfoEXT();
    ~_VkRenderPassFragmentDensityMapCreateInfoEXT();

};

/*
#include "index.h"
#include "VkRenderPassFragmentDensityMapCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassFragmentDensityMapCreateInfoEXT::constructor;

_VkRenderPassFragmentDensityMapCreateInfoEXT::_VkRenderPassFragmentDensityMapCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT;
  
}

_VkRenderPassFragmentDensityMapCreateInfoEXT::~_VkRenderPassFragmentDensityMapCreateInfoEXT() {
  //printf("VkRenderPassFragmentDensityMapCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkRenderPassFragmentDensityMapCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassFragmentDensityMapCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassFragmentDensityMapCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fragmentDensityMapAttachment").ToLocalChecked(), GetfragmentDensityMapAttachment, SetfragmentDensityMapAttachment, ctor);
  Nan::Set(target, Nan::New("VkRenderPassFragmentDensityMapCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassFragmentDensityMapCreateInfoEXT::flush() {
  _VkRenderPassFragmentDensityMapCreateInfoEXT *self = this;
  if (!(self->fragmentDensityMapAttachment.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->fragmentDensityMapAttachment);
    
    _VkAttachmentReference* result = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.fragmentDensityMapAttachment = result->instance;
  }
  return true;
}

NAN_METHOD(_VkRenderPassFragmentDensityMapCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassFragmentDensityMapCreateInfoEXT* self = new _VkRenderPassFragmentDensityMapCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("fragmentDensityMapAttachment").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassFragmentDensityMapCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRenderPassFragmentDensityMapCreateInfoEXT::GetsType) {
  _VkRenderPassFragmentDensityMapCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassFragmentDensityMapCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRenderPassFragmentDensityMapCreateInfoEXT::SetsType) {
  _VkRenderPassFragmentDensityMapCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassFragmentDensityMapCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassFragmentDensityMapCreateInfoEXT.sType", "Number");
  
    return;
  }
}// fragmentDensityMapAttachment
NAN_GETTER(_VkRenderPassFragmentDensityMapCreateInfoEXT::GetfragmentDensityMapAttachment) {
  _VkRenderPassFragmentDensityMapCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassFragmentDensityMapCreateInfoEXT>(info.This());
  if (self->fragmentDensityMapAttachment.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->fragmentDensityMapAttachment);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassFragmentDensityMapCreateInfoEXT::SetfragmentDensityMapAttachment) {
  _VkRenderPassFragmentDensityMapCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassFragmentDensityMapCreateInfoEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkAttachmentReference::constructor)->HasInstance(obj)) {
      self->fragmentDensityMapAttachment.Reset<v8::Object>(value.As<v8::Object>());
      _VkAttachmentReference* inst = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(obj);
      inst->flush();
      self->instance.fragmentDensityMapAttachment = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassFragmentDensityMapCreateInfoEXT.fragmentDensityMapAttachment", "[object VkAttachmentReference]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->fragmentDensityMapAttachment.Reset();
    memset(&self->instance.fragmentDensityMapAttachment, 0, sizeof(VkAttachmentReference));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassFragmentDensityMapCreateInfoEXT.fragmentDensityMapAttachment", "[object VkAttachmentReference]");
  
    return;
  }
}
/** ## END VkRenderPassFragmentDensityMapCreateInfoEXT ## **/

/** ## BEGIN VkExtent2D ## **/

class _VkExtent2D: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getwidth);
    static NAN_SETTER(Setwidth);
    
    static NAN_GETTER(Getheight);
    static NAN_SETTER(Setheight);
    

    // real instance
    VkExtent2D instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExtent2D();
    ~_VkExtent2D();

};

/*
#include "index.h"
#include "VkExtent2D.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExtent2D::constructor;

_VkExtent2D::_VkExtent2D() {
  
  
}

_VkExtent2D::~_VkExtent2D() {
  //printf("VkExtent2D deconstructed!!\n");
  
  
  
}

void _VkExtent2D::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExtent2D::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExtent2D").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("width").ToLocalChecked(), Getwidth, Setwidth, ctor);
  SetPrototypeAccessor(proto, Nan::New("height").ToLocalChecked(), Getheight, Setheight, ctor);
  Nan::Set(target, Nan::New("VkExtent2D").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExtent2D::flush() {
  _VkExtent2D *self = this;
  
  return true;
}

NAN_METHOD(_VkExtent2D::New) {
  if (info.IsConstructCall()) {
    _VkExtent2D* self = new _VkExtent2D();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("width").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("height").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExtent2D constructor cannot be invoked without 'new'");
  }
};

// width
NAN_GETTER(_VkExtent2D::Getwidth) {
  _VkExtent2D *self = Nan::ObjectWrap::Unwrap<_VkExtent2D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.width));
}NAN_SETTER(_VkExtent2D::Setwidth) {
  _VkExtent2D *self = Nan::ObjectWrap::Unwrap<_VkExtent2D>(info.This());
  if (value->IsNumber()) {
    self->instance.width = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExtent2D.width", "Number");
  
    return;
  }
}// height
NAN_GETTER(_VkExtent2D::Getheight) {
  _VkExtent2D *self = Nan::ObjectWrap::Unwrap<_VkExtent2D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.height));
}NAN_SETTER(_VkExtent2D::Setheight) {
  _VkExtent2D *self = Nan::ObjectWrap::Unwrap<_VkExtent2D>(info.This());
  if (value->IsNumber()) {
    self->instance.height = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExtent2D.height", "Number");
  
    return;
  }
}
/** ## END VkExtent2D ## **/

/** ## BEGIN VkPhysicalDeviceFragmentDensityMapPropertiesEXT ## **/

class _VkPhysicalDeviceFragmentDensityMapPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> minFragmentDensityTexelSize;
      static NAN_GETTER(GetminFragmentDensityTexelSize);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxFragmentDensityTexelSize;
      static NAN_GETTER(GetmaxFragmentDensityTexelSize);
    static NAN_GETTER(GetfragmentDensityInvocations);

    // real instance
    VkPhysicalDeviceFragmentDensityMapPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceFragmentDensityMapPropertiesEXT();
    ~_VkPhysicalDeviceFragmentDensityMapPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceFragmentDensityMapPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceFragmentDensityMapPropertiesEXT::constructor;

_VkPhysicalDeviceFragmentDensityMapPropertiesEXT::_VkPhysicalDeviceFragmentDensityMapPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceFragmentDensityMapPropertiesEXT::~_VkPhysicalDeviceFragmentDensityMapPropertiesEXT() {
  //printf("VkPhysicalDeviceFragmentDensityMapPropertiesEXT deconstructed!!\n");
  
  
  
  
  
}

void _VkPhysicalDeviceFragmentDensityMapPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceFragmentDensityMapPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceFragmentDensityMapPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minFragmentDensityTexelSize").ToLocalChecked(), GetminFragmentDensityTexelSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFragmentDensityTexelSize").ToLocalChecked(), GetmaxFragmentDensityTexelSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("fragmentDensityInvocations").ToLocalChecked(), GetfragmentDensityInvocations, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceFragmentDensityMapPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceFragmentDensityMapPropertiesEXT::flush() {
  _VkPhysicalDeviceFragmentDensityMapPropertiesEXT *self = this;
  if (!(self->minFragmentDensityTexelSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->minFragmentDensityTexelSize);
    
  }if (!(self->maxFragmentDensityTexelSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxFragmentDensityTexelSize);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceFragmentDensityMapPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceFragmentDensityMapPropertiesEXT* self = new _VkPhysicalDeviceFragmentDensityMapPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceFragmentDensityMapPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceFragmentDensityMapPropertiesEXT::GetsType) {
  _VkPhysicalDeviceFragmentDensityMapPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// minFragmentDensityTexelSize
NAN_GETTER(_VkPhysicalDeviceFragmentDensityMapPropertiesEXT::GetminFragmentDensityTexelSize) {
  _VkPhysicalDeviceFragmentDensityMapPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(info.This());
  if (self->minFragmentDensityTexelSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->minFragmentDensityTexelSize);
    info.GetReturnValue().Set(obj);
  }
}// maxFragmentDensityTexelSize
NAN_GETTER(_VkPhysicalDeviceFragmentDensityMapPropertiesEXT::GetmaxFragmentDensityTexelSize) {
  _VkPhysicalDeviceFragmentDensityMapPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(info.This());
  if (self->maxFragmentDensityTexelSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxFragmentDensityTexelSize);
    info.GetReturnValue().Set(obj);
  }
}// fragmentDensityInvocations
NAN_GETTER(_VkPhysicalDeviceFragmentDensityMapPropertiesEXT::GetfragmentDensityInvocations) {
  _VkPhysicalDeviceFragmentDensityMapPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fragmentDensityInvocations));
}
/** ## END VkPhysicalDeviceFragmentDensityMapPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceFragmentDensityMapFeaturesEXT ## **/

class _VkPhysicalDeviceFragmentDensityMapFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetfragmentDensityMap);
    static NAN_GETTER(GetfragmentDensityMapDynamic);
    static NAN_GETTER(GetfragmentDensityMapNonSubsampledImages);

    // real instance
    VkPhysicalDeviceFragmentDensityMapFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceFragmentDensityMapFeaturesEXT();
    ~_VkPhysicalDeviceFragmentDensityMapFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceFragmentDensityMapFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceFragmentDensityMapFeaturesEXT::constructor;

_VkPhysicalDeviceFragmentDensityMapFeaturesEXT::_VkPhysicalDeviceFragmentDensityMapFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
  
}

_VkPhysicalDeviceFragmentDensityMapFeaturesEXT::~_VkPhysicalDeviceFragmentDensityMapFeaturesEXT() {
  //printf("VkPhysicalDeviceFragmentDensityMapFeaturesEXT deconstructed!!\n");
  
  
  
  
  
}

void _VkPhysicalDeviceFragmentDensityMapFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceFragmentDensityMapFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceFragmentDensityMapFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("fragmentDensityMap").ToLocalChecked(), GetfragmentDensityMap, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("fragmentDensityMapDynamic").ToLocalChecked(), GetfragmentDensityMapDynamic, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("fragmentDensityMapNonSubsampledImages").ToLocalChecked(), GetfragmentDensityMapNonSubsampledImages, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceFragmentDensityMapFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceFragmentDensityMapFeaturesEXT::flush() {
  _VkPhysicalDeviceFragmentDensityMapFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceFragmentDensityMapFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceFragmentDensityMapFeaturesEXT* self = new _VkPhysicalDeviceFragmentDensityMapFeaturesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceFragmentDensityMapFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceFragmentDensityMapFeaturesEXT::GetsType) {
  _VkPhysicalDeviceFragmentDensityMapFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// fragmentDensityMap
NAN_GETTER(_VkPhysicalDeviceFragmentDensityMapFeaturesEXT::GetfragmentDensityMap) {
  _VkPhysicalDeviceFragmentDensityMapFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fragmentDensityMap));
}// fragmentDensityMapDynamic
NAN_GETTER(_VkPhysicalDeviceFragmentDensityMapFeaturesEXT::GetfragmentDensityMapDynamic) {
  _VkPhysicalDeviceFragmentDensityMapFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fragmentDensityMapDynamic));
}// fragmentDensityMapNonSubsampledImages
NAN_GETTER(_VkPhysicalDeviceFragmentDensityMapFeaturesEXT::GetfragmentDensityMapNonSubsampledImages) {
  _VkPhysicalDeviceFragmentDensityMapFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fragmentDensityMapNonSubsampledImages));
}
/** ## END VkPhysicalDeviceFragmentDensityMapFeaturesEXT ## **/

/** ## BEGIN VkDeviceMemoryOverallocationCreateInfoAMD ## **/

class _VkDeviceMemoryOverallocationCreateInfoAMD: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetoverallocationBehavior);
    static NAN_SETTER(SetoverallocationBehavior);
    

    // real instance
    VkDeviceMemoryOverallocationCreateInfoAMD instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceMemoryOverallocationCreateInfoAMD();
    ~_VkDeviceMemoryOverallocationCreateInfoAMD();

};

/*
#include "index.h"
#include "VkDeviceMemoryOverallocationCreateInfoAMD.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceMemoryOverallocationCreateInfoAMD::constructor;

_VkDeviceMemoryOverallocationCreateInfoAMD::_VkDeviceMemoryOverallocationCreateInfoAMD() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD;
  
}

_VkDeviceMemoryOverallocationCreateInfoAMD::~_VkDeviceMemoryOverallocationCreateInfoAMD() {
  //printf("VkDeviceMemoryOverallocationCreateInfoAMD deconstructed!!\n");
  
  
  
}

void _VkDeviceMemoryOverallocationCreateInfoAMD::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceMemoryOverallocationCreateInfoAMD::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceMemoryOverallocationCreateInfoAMD").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("overallocationBehavior").ToLocalChecked(), GetoverallocationBehavior, SetoverallocationBehavior, ctor);
  Nan::Set(target, Nan::New("VkDeviceMemoryOverallocationCreateInfoAMD").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceMemoryOverallocationCreateInfoAMD::flush() {
  _VkDeviceMemoryOverallocationCreateInfoAMD *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceMemoryOverallocationCreateInfoAMD::New) {
  if (info.IsConstructCall()) {
    _VkDeviceMemoryOverallocationCreateInfoAMD* self = new _VkDeviceMemoryOverallocationCreateInfoAMD();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("overallocationBehavior").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceMemoryOverallocationCreateInfoAMD constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceMemoryOverallocationCreateInfoAMD::GetsType) {
  _VkDeviceMemoryOverallocationCreateInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkDeviceMemoryOverallocationCreateInfoAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceMemoryOverallocationCreateInfoAMD::SetsType) {
  _VkDeviceMemoryOverallocationCreateInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkDeviceMemoryOverallocationCreateInfoAMD>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceMemoryOverallocationCreateInfoAMD.sType", "Number");
  
    return;
  }
}// overallocationBehavior
NAN_GETTER(_VkDeviceMemoryOverallocationCreateInfoAMD::GetoverallocationBehavior) {
  _VkDeviceMemoryOverallocationCreateInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkDeviceMemoryOverallocationCreateInfoAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.overallocationBehavior));
}NAN_SETTER(_VkDeviceMemoryOverallocationCreateInfoAMD::SetoverallocationBehavior) {
  _VkDeviceMemoryOverallocationCreateInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkDeviceMemoryOverallocationCreateInfoAMD>(info.This());
  if (value->IsNumber()) {
    self->instance.overallocationBehavior = static_cast<VkMemoryOverallocationBehaviorAMD>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceMemoryOverallocationCreateInfoAMD.overallocationBehavior", "Number");
  
    return;
  }
}
/** ## END VkDeviceMemoryOverallocationCreateInfoAMD ## **/

/** ## BEGIN VkImageStencilUsageCreateInfoEXT ## **/

class _VkImageStencilUsageCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetstencilUsage);
    static NAN_SETTER(SetstencilUsage);
    

    // real instance
    VkImageStencilUsageCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageStencilUsageCreateInfoEXT();
    ~_VkImageStencilUsageCreateInfoEXT();

};

/*
#include "index.h"
#include "VkImageStencilUsageCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageStencilUsageCreateInfoEXT::constructor;

_VkImageStencilUsageCreateInfoEXT::_VkImageStencilUsageCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT;
  
}

_VkImageStencilUsageCreateInfoEXT::~_VkImageStencilUsageCreateInfoEXT() {
  //printf("VkImageStencilUsageCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkImageStencilUsageCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageStencilUsageCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageStencilUsageCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("stencilUsage").ToLocalChecked(), GetstencilUsage, SetstencilUsage, ctor);
  Nan::Set(target, Nan::New("VkImageStencilUsageCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageStencilUsageCreateInfoEXT::flush() {
  _VkImageStencilUsageCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkImageStencilUsageCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkImageStencilUsageCreateInfoEXT* self = new _VkImageStencilUsageCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("stencilUsage").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageStencilUsageCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageStencilUsageCreateInfoEXT::GetsType) {
  _VkImageStencilUsageCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageStencilUsageCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageStencilUsageCreateInfoEXT::SetsType) {
  _VkImageStencilUsageCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageStencilUsageCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageStencilUsageCreateInfoEXT.sType", "Number");
  
    return;
  }
}// stencilUsage
NAN_GETTER(_VkImageStencilUsageCreateInfoEXT::GetstencilUsage) {
  _VkImageStencilUsageCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageStencilUsageCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stencilUsage));
}NAN_SETTER(_VkImageStencilUsageCreateInfoEXT::SetstencilUsage) {
  _VkImageStencilUsageCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageStencilUsageCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.stencilUsage = static_cast<VkImageUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageStencilUsageCreateInfoEXT.stencilUsage", "Number");
  
    return;
  }
}
/** ## END VkImageStencilUsageCreateInfoEXT ## **/

/** ## BEGIN VkImageDrmFormatModifierPropertiesEXT ## **/

class _VkImageDrmFormatModifierPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetdrmFormatModifier);

    // real instance
    VkImageDrmFormatModifierPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageDrmFormatModifierPropertiesEXT();
    ~_VkImageDrmFormatModifierPropertiesEXT();

};

/*
#include "index.h"
#include "VkImageDrmFormatModifierPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageDrmFormatModifierPropertiesEXT::constructor;

_VkImageDrmFormatModifierPropertiesEXT::_VkImageDrmFormatModifierPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT;
  
}

_VkImageDrmFormatModifierPropertiesEXT::~_VkImageDrmFormatModifierPropertiesEXT() {
  //printf("VkImageDrmFormatModifierPropertiesEXT deconstructed!!\n");
  
  
  
}

void _VkImageDrmFormatModifierPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageDrmFormatModifierPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageDrmFormatModifierPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifier").ToLocalChecked(), GetdrmFormatModifier, nullptr, ctor);
  Nan::Set(target, Nan::New("VkImageDrmFormatModifierPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageDrmFormatModifierPropertiesEXT::flush() {
  _VkImageDrmFormatModifierPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkImageDrmFormatModifierPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkImageDrmFormatModifierPropertiesEXT* self = new _VkImageDrmFormatModifierPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageDrmFormatModifierPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageDrmFormatModifierPropertiesEXT::GetsType) {
  _VkImageDrmFormatModifierPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// drmFormatModifier
NAN_GETTER(_VkImageDrmFormatModifierPropertiesEXT::GetdrmFormatModifier) {
  _VkImageDrmFormatModifierPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifier));
}
/** ## END VkImageDrmFormatModifierPropertiesEXT ## **/

/** ## BEGIN VkSubresourceLayout ## **/

class _VkSubresourceLayout: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getoffset);
    static NAN_GETTER(Getsize);
    static NAN_GETTER(GetrowPitch);
    static NAN_GETTER(GetarrayPitch);
    static NAN_GETTER(GetdepthPitch);

    // real instance
    VkSubresourceLayout instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubresourceLayout();
    ~_VkSubresourceLayout();

};

/*
#include "index.h"
#include "VkSubresourceLayout.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubresourceLayout::constructor;

_VkSubresourceLayout::_VkSubresourceLayout() {
  
  
}

_VkSubresourceLayout::~_VkSubresourceLayout() {
  //printf("VkSubresourceLayout deconstructed!!\n");
  
  
  
  
  
  
}

void _VkSubresourceLayout::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubresourceLayout::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubresourceLayout").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("rowPitch").ToLocalChecked(), GetrowPitch, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("arrayPitch").ToLocalChecked(), GetarrayPitch, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthPitch").ToLocalChecked(), GetdepthPitch, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSubresourceLayout").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubresourceLayout::flush() {
  _VkSubresourceLayout *self = this;
  
  return true;
}

NAN_METHOD(_VkSubresourceLayout::New) {
  if (info.IsConstructCall()) {
    _VkSubresourceLayout* self = new _VkSubresourceLayout();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubresourceLayout constructor cannot be invoked without 'new'");
  }
};

// offset
NAN_GETTER(_VkSubresourceLayout::Getoffset) {
  _VkSubresourceLayout *self = Nan::ObjectWrap::Unwrap<_VkSubresourceLayout>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}// size
NAN_GETTER(_VkSubresourceLayout::Getsize) {
  _VkSubresourceLayout *self = Nan::ObjectWrap::Unwrap<_VkSubresourceLayout>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}// rowPitch
NAN_GETTER(_VkSubresourceLayout::GetrowPitch) {
  _VkSubresourceLayout *self = Nan::ObjectWrap::Unwrap<_VkSubresourceLayout>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.rowPitch));
}// arrayPitch
NAN_GETTER(_VkSubresourceLayout::GetarrayPitch) {
  _VkSubresourceLayout *self = Nan::ObjectWrap::Unwrap<_VkSubresourceLayout>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.arrayPitch));
}// depthPitch
NAN_GETTER(_VkSubresourceLayout::GetdepthPitch) {
  _VkSubresourceLayout *self = Nan::ObjectWrap::Unwrap<_VkSubresourceLayout>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthPitch));
}
/** ## END VkSubresourceLayout ## **/

/** ## BEGIN VkImageDrmFormatModifierExplicitCreateInfoEXT ## **/

class _VkImageDrmFormatModifierExplicitCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdrmFormatModifier);
    static NAN_SETTER(SetdrmFormatModifier);
    
    static NAN_GETTER(GetdrmFormatModifierPlaneCount);
    static NAN_SETTER(SetdrmFormatModifierPlaneCount);
    
    std::vector<VkSubresourceLayout>* vpPlaneLayouts;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pPlaneLayouts;
    static NAN_GETTER(GetpPlaneLayouts);
    static NAN_SETTER(SetpPlaneLayouts);
    

    // real instance
    VkImageDrmFormatModifierExplicitCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageDrmFormatModifierExplicitCreateInfoEXT();
    ~_VkImageDrmFormatModifierExplicitCreateInfoEXT();

};

/*
#include "index.h"
#include "VkImageDrmFormatModifierExplicitCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageDrmFormatModifierExplicitCreateInfoEXT::constructor;

_VkImageDrmFormatModifierExplicitCreateInfoEXT::_VkImageDrmFormatModifierExplicitCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT;
  vpPlaneLayouts = new std::vector<VkSubresourceLayout>;
  
}

_VkImageDrmFormatModifierExplicitCreateInfoEXT::~_VkImageDrmFormatModifierExplicitCreateInfoEXT() {
  //printf("VkImageDrmFormatModifierExplicitCreateInfoEXT deconstructed!!\n");
  
  
  
  
  vpPlaneLayouts->clear();
  delete vpPlaneLayouts;
  
  pPlaneLayouts.Reset();
  
}

void _VkImageDrmFormatModifierExplicitCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageDrmFormatModifierExplicitCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageDrmFormatModifierExplicitCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifier").ToLocalChecked(), GetdrmFormatModifier, SetdrmFormatModifier, ctor);
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifierPlaneCount").ToLocalChecked(), GetdrmFormatModifierPlaneCount, SetdrmFormatModifierPlaneCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pPlaneLayouts").ToLocalChecked(), GetpPlaneLayouts, SetpPlaneLayouts, ctor);
  Nan::Set(target, Nan::New("VkImageDrmFormatModifierExplicitCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageDrmFormatModifierExplicitCreateInfoEXT::flush() {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = this;
  if (!(self->pPlaneLayouts.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pPlaneLayouts);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.drmFormatModifierPlaneCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'drmFormatModifierPlaneCount' for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts'");
      return false;
    }
    std::vector<VkSubresourceLayout>* data = self->vpPlaneLayouts;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSubresourceLayout::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts", "[object VkSubresourceLayout]");
  
        return false;
      }
      _VkSubresourceLayout* result = Nan::ObjectWrap::Unwrap<_VkSubresourceLayout>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pPlaneLayouts = data->data();
  }
  return true;
}

NAN_METHOD(_VkImageDrmFormatModifierExplicitCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkImageDrmFormatModifierExplicitCreateInfoEXT* self = new _VkImageDrmFormatModifierExplicitCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("drmFormatModifier").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("drmFormatModifierPlaneCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pPlaneLayouts").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageDrmFormatModifierExplicitCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageDrmFormatModifierExplicitCreateInfoEXT::GetsType) {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierExplicitCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageDrmFormatModifierExplicitCreateInfoEXT::SetsType) {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierExplicitCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.sType", "Number");
  
    return;
  }
}// drmFormatModifier
NAN_GETTER(_VkImageDrmFormatModifierExplicitCreateInfoEXT::GetdrmFormatModifier) {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierExplicitCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifier));
}NAN_SETTER(_VkImageDrmFormatModifierExplicitCreateInfoEXT::SetdrmFormatModifier) {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierExplicitCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.drmFormatModifier = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.drmFormatModifier", "Number");
  
    return;
  }
}// drmFormatModifierPlaneCount
NAN_GETTER(_VkImageDrmFormatModifierExplicitCreateInfoEXT::GetdrmFormatModifierPlaneCount) {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierExplicitCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifierPlaneCount));
}NAN_SETTER(_VkImageDrmFormatModifierExplicitCreateInfoEXT::SetdrmFormatModifierPlaneCount) {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierExplicitCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.drmFormatModifierPlaneCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.drmFormatModifierPlaneCount", "Number");
  
    return;
  }
}// pPlaneLayouts
NAN_GETTER(_VkImageDrmFormatModifierExplicitCreateInfoEXT::GetpPlaneLayouts) {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierExplicitCreateInfoEXT>(info.This());
  if (self->pPlaneLayouts.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pPlaneLayouts);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageDrmFormatModifierExplicitCreateInfoEXT::SetpPlaneLayouts) {
  _VkImageDrmFormatModifierExplicitCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierExplicitCreateInfoEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pPlaneLayouts.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pPlaneLayouts.Reset();
      self->instance.pPlaneLayouts = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts", "[object VkSubresourceLayout]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pPlaneLayouts = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts", "[object VkSubresourceLayout]");
  
    return;
  }
}
/** ## END VkImageDrmFormatModifierExplicitCreateInfoEXT ## **/

/** ## BEGIN VkImageDrmFormatModifierListCreateInfoEXT ## **/

class _VkImageDrmFormatModifierListCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdrmFormatModifierCount);
    static NAN_SETTER(SetdrmFormatModifierCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDrmFormatModifiers;
    static NAN_GETTER(GetpDrmFormatModifiers);
    static NAN_SETTER(SetpDrmFormatModifiers);
    

    // real instance
    VkImageDrmFormatModifierListCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageDrmFormatModifierListCreateInfoEXT();
    ~_VkImageDrmFormatModifierListCreateInfoEXT();

};

/*
#include "index.h"
#include "VkImageDrmFormatModifierListCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageDrmFormatModifierListCreateInfoEXT::constructor;

_VkImageDrmFormatModifierListCreateInfoEXT::_VkImageDrmFormatModifierListCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT;
  
}

_VkImageDrmFormatModifierListCreateInfoEXT::~_VkImageDrmFormatModifierListCreateInfoEXT() {
  //printf("VkImageDrmFormatModifierListCreateInfoEXT deconstructed!!\n");
  
  
  
  pDrmFormatModifiers.Reset();
  
}

void _VkImageDrmFormatModifierListCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageDrmFormatModifierListCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageDrmFormatModifierListCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifierCount").ToLocalChecked(), GetdrmFormatModifierCount, SetdrmFormatModifierCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDrmFormatModifiers").ToLocalChecked(), GetpDrmFormatModifiers, SetpDrmFormatModifiers, ctor);
  Nan::Set(target, Nan::New("VkImageDrmFormatModifierListCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageDrmFormatModifierListCreateInfoEXT::flush() {
  _VkImageDrmFormatModifierListCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkImageDrmFormatModifierListCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkImageDrmFormatModifierListCreateInfoEXT* self = new _VkImageDrmFormatModifierListCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("drmFormatModifierCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pDrmFormatModifiers").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageDrmFormatModifierListCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageDrmFormatModifierListCreateInfoEXT::GetsType) {
  _VkImageDrmFormatModifierListCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierListCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageDrmFormatModifierListCreateInfoEXT::SetsType) {
  _VkImageDrmFormatModifierListCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierListCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierListCreateInfoEXT.sType", "Number");
  
    return;
  }
}// drmFormatModifierCount
NAN_GETTER(_VkImageDrmFormatModifierListCreateInfoEXT::GetdrmFormatModifierCount) {
  _VkImageDrmFormatModifierListCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierListCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifierCount));
}NAN_SETTER(_VkImageDrmFormatModifierListCreateInfoEXT::SetdrmFormatModifierCount) {
  _VkImageDrmFormatModifierListCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierListCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.drmFormatModifierCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierListCreateInfoEXT.drmFormatModifierCount", "Number");
  
    return;
  }
}// pDrmFormatModifiers
NAN_GETTER(_VkImageDrmFormatModifierListCreateInfoEXT::GetpDrmFormatModifiers) {
  _VkImageDrmFormatModifierListCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierListCreateInfoEXT>(info.This());
  if (self->pDrmFormatModifiers.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDrmFormatModifiers);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageDrmFormatModifierListCreateInfoEXT::SetpDrmFormatModifiers) {
  _VkImageDrmFormatModifierListCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImageDrmFormatModifierListCreateInfoEXT>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsBigUint64Array()) {
        self->pDrmFormatModifiers.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierListCreateInfoEXT.pDrmFormatModifiers", "BigUint64Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDrmFormatModifiers.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageDrmFormatModifierListCreateInfoEXT.pDrmFormatModifiers", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDrmFormatModifiers = getTypedArrayData<uint64_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pDrmFormatModifiers = nullptr;
  }
}
/** ## END VkImageDrmFormatModifierListCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceImageDrmFormatModifierInfoEXT ## **/

class _VkPhysicalDeviceImageDrmFormatModifierInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdrmFormatModifier);
    static NAN_SETTER(SetdrmFormatModifier);
    
    static NAN_GETTER(GetsharingMode);
    static NAN_SETTER(SetsharingMode);
    
    static NAN_GETTER(GetqueueFamilyIndexCount);
    static NAN_SETTER(SetqueueFamilyIndexCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pQueueFamilyIndices;
    static NAN_GETTER(GetpQueueFamilyIndices);
    static NAN_SETTER(SetpQueueFamilyIndices);
    

    // real instance
    VkPhysicalDeviceImageDrmFormatModifierInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceImageDrmFormatModifierInfoEXT();
    ~_VkPhysicalDeviceImageDrmFormatModifierInfoEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceImageDrmFormatModifierInfoEXT::constructor;

_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::_VkPhysicalDeviceImageDrmFormatModifierInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT;
  
}

_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::~_VkPhysicalDeviceImageDrmFormatModifierInfoEXT() {
  //printf("VkPhysicalDeviceImageDrmFormatModifierInfoEXT deconstructed!!\n");
  
  
  
  
  
  pQueueFamilyIndices.Reset();
  
}

void _VkPhysicalDeviceImageDrmFormatModifierInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceImageDrmFormatModifierInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifier").ToLocalChecked(), GetdrmFormatModifier, SetdrmFormatModifier, ctor);
  SetPrototypeAccessor(proto, Nan::New("sharingMode").ToLocalChecked(), GetsharingMode, SetsharingMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueFamilyIndexCount").ToLocalChecked(), GetqueueFamilyIndexCount, SetqueueFamilyIndexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pQueueFamilyIndices").ToLocalChecked(), GetpQueueFamilyIndices, SetpQueueFamilyIndices, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceImageDrmFormatModifierInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceImageDrmFormatModifierInfoEXT::flush() {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceImageDrmFormatModifierInfoEXT* self = new _VkPhysicalDeviceImageDrmFormatModifierInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("drmFormatModifier").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("sharingMode").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("queueFamilyIndexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pQueueFamilyIndices").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceImageDrmFormatModifierInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::GetsType) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::SetsType) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sType", "Number");
  
    return;
  }
}// drmFormatModifier
NAN_GETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::GetdrmFormatModifier) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifier));
}NAN_SETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::SetdrmFormatModifier) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.drmFormatModifier = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.drmFormatModifier", "Number");
  
    return;
  }
}// sharingMode
NAN_GETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::GetsharingMode) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sharingMode));
}NAN_SETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::SetsharingMode) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sharingMode = static_cast<VkSharingMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sharingMode", "Number");
  
    return;
  }
}// queueFamilyIndexCount
NAN_GETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::GetqueueFamilyIndexCount) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueFamilyIndexCount));
}NAN_SETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::SetqueueFamilyIndexCount) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.queueFamilyIndexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.queueFamilyIndexCount", "Number");
  
    return;
  }
}// pQueueFamilyIndices
NAN_GETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::GetpQueueFamilyIndices) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  if (self->pQueueFamilyIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pQueueFamilyIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPhysicalDeviceImageDrmFormatModifierInfoEXT::SetpQueueFamilyIndices) {
  _VkPhysicalDeviceImageDrmFormatModifierInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pQueueFamilyIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.pQueueFamilyIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pQueueFamilyIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT.pQueueFamilyIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pQueueFamilyIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pQueueFamilyIndices = nullptr;
  }
}
/** ## END VkPhysicalDeviceImageDrmFormatModifierInfoEXT ## **/

/** ## BEGIN VkDrmFormatModifierPropertiesEXT ## **/

class _VkDrmFormatModifierPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetdrmFormatModifier);
    static NAN_GETTER(GetdrmFormatModifierPlaneCount);
    static NAN_GETTER(GetdrmFormatModifierTilingFeatures);

    // real instance
    VkDrmFormatModifierPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDrmFormatModifierPropertiesEXT();
    ~_VkDrmFormatModifierPropertiesEXT();

};

/*
#include "index.h"
#include "VkDrmFormatModifierPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDrmFormatModifierPropertiesEXT::constructor;

_VkDrmFormatModifierPropertiesEXT::_VkDrmFormatModifierPropertiesEXT() {
  
  
}

_VkDrmFormatModifierPropertiesEXT::~_VkDrmFormatModifierPropertiesEXT() {
  //printf("VkDrmFormatModifierPropertiesEXT deconstructed!!\n");
  
  
  
  
}

void _VkDrmFormatModifierPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDrmFormatModifierPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDrmFormatModifierPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifier").ToLocalChecked(), GetdrmFormatModifier, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifierPlaneCount").ToLocalChecked(), GetdrmFormatModifierPlaneCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifierTilingFeatures").ToLocalChecked(), GetdrmFormatModifierTilingFeatures, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDrmFormatModifierPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDrmFormatModifierPropertiesEXT::flush() {
  _VkDrmFormatModifierPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDrmFormatModifierPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkDrmFormatModifierPropertiesEXT* self = new _VkDrmFormatModifierPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDrmFormatModifierPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// drmFormatModifier
NAN_GETTER(_VkDrmFormatModifierPropertiesEXT::GetdrmFormatModifier) {
  _VkDrmFormatModifierPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkDrmFormatModifierPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifier));
}// drmFormatModifierPlaneCount
NAN_GETTER(_VkDrmFormatModifierPropertiesEXT::GetdrmFormatModifierPlaneCount) {
  _VkDrmFormatModifierPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkDrmFormatModifierPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifierPlaneCount));
}// drmFormatModifierTilingFeatures
NAN_GETTER(_VkDrmFormatModifierPropertiesEXT::GetdrmFormatModifierTilingFeatures) {
  _VkDrmFormatModifierPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkDrmFormatModifierPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifierTilingFeatures));
}
/** ## END VkDrmFormatModifierPropertiesEXT ## **/

/** ## BEGIN VkDrmFormatModifierPropertiesListEXT ## **/

class _VkDrmFormatModifierPropertiesListEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetdrmFormatModifierCount);
    std::vector<VkDrmFormatModifierPropertiesEXT>* vpDrmFormatModifierProperties;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDrmFormatModifierProperties;
    static NAN_GETTER(GetpDrmFormatModifierProperties);

    // real instance
    VkDrmFormatModifierPropertiesListEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDrmFormatModifierPropertiesListEXT();
    ~_VkDrmFormatModifierPropertiesListEXT();

};

/*
#include "index.h"
#include "VkDrmFormatModifierPropertiesListEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDrmFormatModifierPropertiesListEXT::constructor;

_VkDrmFormatModifierPropertiesListEXT::_VkDrmFormatModifierPropertiesListEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT;
  vpDrmFormatModifierProperties = new std::vector<VkDrmFormatModifierPropertiesEXT>;
  
}

_VkDrmFormatModifierPropertiesListEXT::~_VkDrmFormatModifierPropertiesListEXT() {
  //printf("VkDrmFormatModifierPropertiesListEXT deconstructed!!\n");
  
  
  
  vpDrmFormatModifierProperties->clear();
  delete vpDrmFormatModifierProperties;
  
  pDrmFormatModifierProperties.Reset();
  
}

void _VkDrmFormatModifierPropertiesListEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDrmFormatModifierPropertiesListEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDrmFormatModifierPropertiesListEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("drmFormatModifierCount").ToLocalChecked(), GetdrmFormatModifierCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDrmFormatModifierProperties").ToLocalChecked(), GetpDrmFormatModifierProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDrmFormatModifierPropertiesListEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDrmFormatModifierPropertiesListEXT::flush() {
  _VkDrmFormatModifierPropertiesListEXT *self = this;
  if (!(self->pDrmFormatModifierProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pDrmFormatModifierProperties);
    
  }
  return true;
}

NAN_METHOD(_VkDrmFormatModifierPropertiesListEXT::New) {
  if (info.IsConstructCall()) {
    _VkDrmFormatModifierPropertiesListEXT* self = new _VkDrmFormatModifierPropertiesListEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDrmFormatModifierPropertiesListEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDrmFormatModifierPropertiesListEXT::GetsType) {
  _VkDrmFormatModifierPropertiesListEXT *self = Nan::ObjectWrap::Unwrap<_VkDrmFormatModifierPropertiesListEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// drmFormatModifierCount
NAN_GETTER(_VkDrmFormatModifierPropertiesListEXT::GetdrmFormatModifierCount) {
  _VkDrmFormatModifierPropertiesListEXT *self = Nan::ObjectWrap::Unwrap<_VkDrmFormatModifierPropertiesListEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drmFormatModifierCount));
}// pDrmFormatModifierProperties
NAN_GETTER(_VkDrmFormatModifierPropertiesListEXT::GetpDrmFormatModifierProperties) {
  _VkDrmFormatModifierPropertiesListEXT *self = Nan::ObjectWrap::Unwrap<_VkDrmFormatModifierPropertiesListEXT>(info.This());
  if (self->pDrmFormatModifierProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDrmFormatModifierProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkDrmFormatModifierPropertiesListEXT ## **/

/** ## BEGIN VkPhysicalDeviceRayTracingPropertiesNV ## **/

class _VkPhysicalDeviceRayTracingPropertiesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetshaderGroupHandleSize);
    static NAN_GETTER(GetmaxRecursionDepth);
    static NAN_GETTER(GetmaxShaderGroupStride);
    static NAN_GETTER(GetshaderGroupBaseAlignment);
    static NAN_GETTER(GetmaxGeometryCount);
    static NAN_GETTER(GetmaxInstanceCount);
    static NAN_GETTER(GetmaxTriangleCount);
    static NAN_GETTER(GetmaxDescriptorSetAccelerationStructures);

    // real instance
    VkPhysicalDeviceRayTracingPropertiesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceRayTracingPropertiesNV();
    ~_VkPhysicalDeviceRayTracingPropertiesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceRayTracingPropertiesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceRayTracingPropertiesNV::constructor;

_VkPhysicalDeviceRayTracingPropertiesNV::_VkPhysicalDeviceRayTracingPropertiesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
  
}

_VkPhysicalDeviceRayTracingPropertiesNV::~_VkPhysicalDeviceRayTracingPropertiesNV() {
  //printf("VkPhysicalDeviceRayTracingPropertiesNV deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceRayTracingPropertiesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceRayTracingPropertiesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceRayTracingPropertiesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderGroupHandleSize").ToLocalChecked(), GetshaderGroupHandleSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxRecursionDepth").ToLocalChecked(), GetmaxRecursionDepth, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxShaderGroupStride").ToLocalChecked(), GetmaxShaderGroupStride, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderGroupBaseAlignment").ToLocalChecked(), GetshaderGroupBaseAlignment, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxGeometryCount").ToLocalChecked(), GetmaxGeometryCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxInstanceCount").ToLocalChecked(), GetmaxInstanceCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTriangleCount").ToLocalChecked(), GetmaxTriangleCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetAccelerationStructures").ToLocalChecked(), GetmaxDescriptorSetAccelerationStructures, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceRayTracingPropertiesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceRayTracingPropertiesNV::flush() {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceRayTracingPropertiesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceRayTracingPropertiesNV* self = new _VkPhysicalDeviceRayTracingPropertiesNV();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceRayTracingPropertiesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetsType) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// shaderGroupHandleSize
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetshaderGroupHandleSize) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderGroupHandleSize));
}// maxRecursionDepth
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetmaxRecursionDepth) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxRecursionDepth));
}// maxShaderGroupStride
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetmaxShaderGroupStride) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxShaderGroupStride));
}// shaderGroupBaseAlignment
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetshaderGroupBaseAlignment) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderGroupBaseAlignment));
}// maxGeometryCount
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetmaxGeometryCount) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxGeometryCount));
}// maxInstanceCount
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetmaxInstanceCount) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxInstanceCount));
}// maxTriangleCount
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetmaxTriangleCount) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTriangleCount));
}// maxDescriptorSetAccelerationStructures
NAN_GETTER(_VkPhysicalDeviceRayTracingPropertiesNV::GetmaxDescriptorSetAccelerationStructures) {
  _VkPhysicalDeviceRayTracingPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRayTracingPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetAccelerationStructures));
}
/** ## END VkPhysicalDeviceRayTracingPropertiesNV ## **/

/** ## BEGIN VkAccelerationStructureMemoryRequirementsInfoNV ## **/

class _VkAccelerationStructureMemoryRequirementsInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> accelerationStructure;
      static NAN_GETTER(GetaccelerationStructure);
    static NAN_SETTER(SetaccelerationStructure);
    

    // real instance
    VkAccelerationStructureMemoryRequirementsInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAccelerationStructureMemoryRequirementsInfoNV();
    ~_VkAccelerationStructureMemoryRequirementsInfoNV();

};

/*
#include "index.h"
#include "VkAccelerationStructureMemoryRequirementsInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAccelerationStructureMemoryRequirementsInfoNV::constructor;

_VkAccelerationStructureMemoryRequirementsInfoNV::_VkAccelerationStructureMemoryRequirementsInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV;
  
}

_VkAccelerationStructureMemoryRequirementsInfoNV::~_VkAccelerationStructureMemoryRequirementsInfoNV() {
  //printf("VkAccelerationStructureMemoryRequirementsInfoNV deconstructed!!\n");
  
  
  
  
}

void _VkAccelerationStructureMemoryRequirementsInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAccelerationStructureMemoryRequirementsInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAccelerationStructureMemoryRequirementsInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("accelerationStructure").ToLocalChecked(), GetaccelerationStructure, SetaccelerationStructure, ctor);
  Nan::Set(target, Nan::New("VkAccelerationStructureMemoryRequirementsInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAccelerationStructureMemoryRequirementsInfoNV::flush() {
  _VkAccelerationStructureMemoryRequirementsInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkAccelerationStructureMemoryRequirementsInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkAccelerationStructureMemoryRequirementsInfoNV* self = new _VkAccelerationStructureMemoryRequirementsInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("accelerationStructure").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAccelerationStructureMemoryRequirementsInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkAccelerationStructureMemoryRequirementsInfoNV::GetsType) {
  _VkAccelerationStructureMemoryRequirementsInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureMemoryRequirementsInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkAccelerationStructureMemoryRequirementsInfoNV::SetsType) {
  _VkAccelerationStructureMemoryRequirementsInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureMemoryRequirementsInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureMemoryRequirementsInfoNV.sType", "Number");
  
    return;
  }
}// type
NAN_GETTER(_VkAccelerationStructureMemoryRequirementsInfoNV::Gettype) {
  _VkAccelerationStructureMemoryRequirementsInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureMemoryRequirementsInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkAccelerationStructureMemoryRequirementsInfoNV::Settype) {
  _VkAccelerationStructureMemoryRequirementsInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureMemoryRequirementsInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkAccelerationStructureMemoryRequirementsTypeNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureMemoryRequirementsInfoNV.type", "Number");
  
    return;
  }
}// accelerationStructure
NAN_GETTER(_VkAccelerationStructureMemoryRequirementsInfoNV::GetaccelerationStructure) {
  _VkAccelerationStructureMemoryRequirementsInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureMemoryRequirementsInfoNV>(info.This());
  if (self->accelerationStructure.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->accelerationStructure);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkAccelerationStructureMemoryRequirementsInfoNV::SetaccelerationStructure) {
  _VkAccelerationStructureMemoryRequirementsInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureMemoryRequirementsInfoNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkAccelerationStructureNV::constructor)->HasInstance(obj)) {
      self->accelerationStructure.Reset<v8::Object>(value.As<v8::Object>());
      _VkAccelerationStructureNV* inst = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureNV>(obj);
      ;
      self->instance.accelerationStructure = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureMemoryRequirementsInfoNV.accelerationStructure", "[object VkAccelerationStructureNV]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->accelerationStructure.Reset();
    self->instance.accelerationStructure = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureMemoryRequirementsInfoNV.accelerationStructure", "[object VkAccelerationStructureNV]");
  
    return;
  }
}
/** ## END VkAccelerationStructureMemoryRequirementsInfoNV ## **/

/** ## BEGIN VkWriteDescriptorSetAccelerationStructureNV ## **/

class _VkWriteDescriptorSetAccelerationStructureNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetaccelerationStructureCount);
    static NAN_SETTER(SetaccelerationStructureCount);
    
    std::vector<VkAccelerationStructureNV>* vpAccelerationStructures;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAccelerationStructures;
    static NAN_GETTER(GetpAccelerationStructures);
    static NAN_SETTER(SetpAccelerationStructures);
    

    // real instance
    VkWriteDescriptorSetAccelerationStructureNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkWriteDescriptorSetAccelerationStructureNV();
    ~_VkWriteDescriptorSetAccelerationStructureNV();

};

/*
#include "index.h"
#include "VkWriteDescriptorSetAccelerationStructureNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkWriteDescriptorSetAccelerationStructureNV::constructor;

_VkWriteDescriptorSetAccelerationStructureNV::_VkWriteDescriptorSetAccelerationStructureNV() {
  instance.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV;
  vpAccelerationStructures = new std::vector<VkAccelerationStructureNV>;
  
}

_VkWriteDescriptorSetAccelerationStructureNV::~_VkWriteDescriptorSetAccelerationStructureNV() {
  //printf("VkWriteDescriptorSetAccelerationStructureNV deconstructed!!\n");
  
  
  
  vpAccelerationStructures->clear();
  delete vpAccelerationStructures;
  
  pAccelerationStructures.Reset();
  
}

void _VkWriteDescriptorSetAccelerationStructureNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkWriteDescriptorSetAccelerationStructureNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkWriteDescriptorSetAccelerationStructureNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("accelerationStructureCount").ToLocalChecked(), GetaccelerationStructureCount, SetaccelerationStructureCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAccelerationStructures").ToLocalChecked(), GetpAccelerationStructures, SetpAccelerationStructures, ctor);
  Nan::Set(target, Nan::New("VkWriteDescriptorSetAccelerationStructureNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkWriteDescriptorSetAccelerationStructureNV::flush() {
  _VkWriteDescriptorSetAccelerationStructureNV *self = this;
  if (!(self->pAccelerationStructures.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAccelerationStructures);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.accelerationStructureCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'accelerationStructureCount' for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures'");
      return false;
    }
    std::vector<VkAccelerationStructureNV>* data = self->vpAccelerationStructures;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAccelerationStructureNV::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures", "[object VkAccelerationStructureNV]");
  
        return false;
      }
      _VkAccelerationStructureNV* result = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureNV>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pAccelerationStructures = data->data();
  }
  return true;
}

NAN_METHOD(_VkWriteDescriptorSetAccelerationStructureNV::New) {
  if (info.IsConstructCall()) {
    _VkWriteDescriptorSetAccelerationStructureNV* self = new _VkWriteDescriptorSetAccelerationStructureNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("accelerationStructureCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pAccelerationStructures").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkWriteDescriptorSetAccelerationStructureNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkWriteDescriptorSetAccelerationStructureNV::GetsType) {
  _VkWriteDescriptorSetAccelerationStructureNV *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetAccelerationStructureNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkWriteDescriptorSetAccelerationStructureNV::SetsType) {
  _VkWriteDescriptorSetAccelerationStructureNV *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetAccelerationStructureNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSetAccelerationStructureNV.sType", "Number");
  
    return;
  }
}// accelerationStructureCount
NAN_GETTER(_VkWriteDescriptorSetAccelerationStructureNV::GetaccelerationStructureCount) {
  _VkWriteDescriptorSetAccelerationStructureNV *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetAccelerationStructureNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.accelerationStructureCount));
}NAN_SETTER(_VkWriteDescriptorSetAccelerationStructureNV::SetaccelerationStructureCount) {
  _VkWriteDescriptorSetAccelerationStructureNV *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetAccelerationStructureNV>(info.This());
  if (value->IsNumber()) {
    self->instance.accelerationStructureCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSetAccelerationStructureNV.accelerationStructureCount", "Number");
  
    return;
  }
}// pAccelerationStructures
NAN_GETTER(_VkWriteDescriptorSetAccelerationStructureNV::GetpAccelerationStructures) {
  _VkWriteDescriptorSetAccelerationStructureNV *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetAccelerationStructureNV>(info.This());
  if (self->pAccelerationStructures.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAccelerationStructures);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWriteDescriptorSetAccelerationStructureNV::SetpAccelerationStructures) {
  _VkWriteDescriptorSetAccelerationStructureNV *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetAccelerationStructureNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAccelerationStructures.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAccelerationStructures.Reset();
      self->instance.pAccelerationStructures = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures", "[object VkAccelerationStructureNV]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAccelerationStructures = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures", "[object VkAccelerationStructureNV]");
  
    return;
  }
}
/** ## END VkWriteDescriptorSetAccelerationStructureNV ## **/

/** ## BEGIN VkBindAccelerationStructureMemoryInfoNV ## **/

class _VkBindAccelerationStructureMemoryInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> accelerationStructure;
      static NAN_GETTER(GetaccelerationStructure);
    static NAN_SETTER(SetaccelerationStructure);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memory;
      static NAN_GETTER(Getmemory);
    static NAN_SETTER(Setmemory);
    
    static NAN_GETTER(GetmemoryOffset);
    static NAN_SETTER(SetmemoryOffset);
    
    static NAN_GETTER(GetdeviceIndexCount);
    static NAN_SETTER(SetdeviceIndexCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDeviceIndices;
    static NAN_GETTER(GetpDeviceIndices);
    static NAN_SETTER(SetpDeviceIndices);
    

    // real instance
    VkBindAccelerationStructureMemoryInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindAccelerationStructureMemoryInfoNV();
    ~_VkBindAccelerationStructureMemoryInfoNV();

};

/*
#include "index.h"
#include "VkBindAccelerationStructureMemoryInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindAccelerationStructureMemoryInfoNV::constructor;

_VkBindAccelerationStructureMemoryInfoNV::_VkBindAccelerationStructureMemoryInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV;
  
}

_VkBindAccelerationStructureMemoryInfoNV::~_VkBindAccelerationStructureMemoryInfoNV() {
  //printf("VkBindAccelerationStructureMemoryInfoNV deconstructed!!\n");
  
  
  
  
  
  
  pDeviceIndices.Reset();
  
}

void _VkBindAccelerationStructureMemoryInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindAccelerationStructureMemoryInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindAccelerationStructureMemoryInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("accelerationStructure").ToLocalChecked(), GetaccelerationStructure, SetaccelerationStructure, ctor);
  SetPrototypeAccessor(proto, Nan::New("memory").ToLocalChecked(), Getmemory, Setmemory, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryOffset").ToLocalChecked(), GetmemoryOffset, SetmemoryOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceIndexCount").ToLocalChecked(), GetdeviceIndexCount, SetdeviceIndexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDeviceIndices").ToLocalChecked(), GetpDeviceIndices, SetpDeviceIndices, ctor);
  Nan::Set(target, Nan::New("VkBindAccelerationStructureMemoryInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindAccelerationStructureMemoryInfoNV::flush() {
  _VkBindAccelerationStructureMemoryInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkBindAccelerationStructureMemoryInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkBindAccelerationStructureMemoryInfoNV* self = new _VkBindAccelerationStructureMemoryInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("accelerationStructure").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("memory").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("memoryOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("deviceIndexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pDeviceIndices").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindAccelerationStructureMemoryInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBindAccelerationStructureMemoryInfoNV::GetsType) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBindAccelerationStructureMemoryInfoNV::SetsType) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.sType", "Number");
  
    return;
  }
}// accelerationStructure
NAN_GETTER(_VkBindAccelerationStructureMemoryInfoNV::GetaccelerationStructure) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  if (self->accelerationStructure.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->accelerationStructure);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindAccelerationStructureMemoryInfoNV::SetaccelerationStructure) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkAccelerationStructureNV::constructor)->HasInstance(obj)) {
      self->accelerationStructure.Reset<v8::Object>(value.As<v8::Object>());
      _VkAccelerationStructureNV* inst = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureNV>(obj);
      ;
      self->instance.accelerationStructure = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.accelerationStructure", "[object VkAccelerationStructureNV]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->accelerationStructure.Reset();
    self->instance.accelerationStructure = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.accelerationStructure", "[object VkAccelerationStructureNV]");
  
    return;
  }
}// memory
NAN_GETTER(_VkBindAccelerationStructureMemoryInfoNV::Getmemory) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  if (self->memory.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memory);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindAccelerationStructureMemoryInfoNV::Setmemory) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj)) {
      self->memory.Reset<v8::Object>(value.As<v8::Object>());
      _VkDeviceMemory* inst = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      ;
      self->instance.memory = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->memory.Reset();
    self->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
NAN_GETTER(_VkBindAccelerationStructureMemoryInfoNV::GetmemoryOffset) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryOffset));
}NAN_SETTER(_VkBindAccelerationStructureMemoryInfoNV::SetmemoryOffset) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.memoryOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.memoryOffset", "Number");
  
    return;
  }
}// deviceIndexCount
NAN_GETTER(_VkBindAccelerationStructureMemoryInfoNV::GetdeviceIndexCount) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceIndexCount));
}NAN_SETTER(_VkBindAccelerationStructureMemoryInfoNV::SetdeviceIndexCount) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceIndexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.deviceIndexCount", "Number");
  
    return;
  }
}// pDeviceIndices
NAN_GETTER(_VkBindAccelerationStructureMemoryInfoNV::GetpDeviceIndices) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  if (self->pDeviceIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDeviceIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindAccelerationStructureMemoryInfoNV::SetpDeviceIndices) {
  _VkBindAccelerationStructureMemoryInfoNV *self = Nan::ObjectWrap::Unwrap<_VkBindAccelerationStructureMemoryInfoNV>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pDeviceIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.pDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDeviceIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindAccelerationStructureMemoryInfoNV.pDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDeviceIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pDeviceIndices = nullptr;
  }
}
/** ## END VkBindAccelerationStructureMemoryInfoNV ## **/

/** ## BEGIN VkGeometryAABBNV ## **/

class _VkGeometryAABBNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> aabbData;
      static NAN_GETTER(GetaabbData);
    static NAN_SETTER(SetaabbData);
    
    static NAN_GETTER(GetnumAABBs);
    static NAN_SETTER(SetnumAABBs);
    
    static NAN_GETTER(Getstride);
    static NAN_SETTER(Setstride);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    

    // real instance
    VkGeometryAABBNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkGeometryAABBNV();
    ~_VkGeometryAABBNV();

};

/*
#include "index.h"
#include "VkGeometryAABBNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkGeometryAABBNV::constructor;

_VkGeometryAABBNV::_VkGeometryAABBNV() {
  instance.sType = VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV;
  
}

_VkGeometryAABBNV::~_VkGeometryAABBNV() {
  //printf("VkGeometryAABBNV deconstructed!!\n");
  
  
  
  
  
  
}

void _VkGeometryAABBNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkGeometryAABBNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkGeometryAABBNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("aabbData").ToLocalChecked(), GetaabbData, SetaabbData, ctor);
  SetPrototypeAccessor(proto, Nan::New("numAABBs").ToLocalChecked(), GetnumAABBs, SetnumAABBs, ctor);
  SetPrototypeAccessor(proto, Nan::New("stride").ToLocalChecked(), Getstride, Setstride, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  Nan::Set(target, Nan::New("VkGeometryAABBNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkGeometryAABBNV::flush() {
  _VkGeometryAABBNV *self = this;
  
  return true;
}

NAN_METHOD(_VkGeometryAABBNV::New) {
  if (info.IsConstructCall()) {
    _VkGeometryAABBNV* self = new _VkGeometryAABBNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("aabbData").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("numAABBs").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("stride").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("offset").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkGeometryAABBNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkGeometryAABBNV::GetsType) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkGeometryAABBNV::SetsType) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryAABBNV.sType", "Number");
  
    return;
  }
}// aabbData
NAN_GETTER(_VkGeometryAABBNV::GetaabbData) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  if (self->aabbData.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->aabbData);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGeometryAABBNV::SetaabbData) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->aabbData.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.aabbData = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGeometryAABBNV.aabbData", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->aabbData.Reset();
    self->instance.aabbData = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryAABBNV.aabbData", "[object VkBuffer]");
  
    return;
  }
}// numAABBs
NAN_GETTER(_VkGeometryAABBNV::GetnumAABBs) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.numAABBs));
}NAN_SETTER(_VkGeometryAABBNV::SetnumAABBs) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  if (value->IsNumber()) {
    self->instance.numAABBs = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryAABBNV.numAABBs", "Number");
  
    return;
  }
}// stride
NAN_GETTER(_VkGeometryAABBNV::Getstride) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stride));
}NAN_SETTER(_VkGeometryAABBNV::Setstride) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  if (value->IsNumber()) {
    self->instance.stride = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryAABBNV.stride", "Number");
  
    return;
  }
}// offset
NAN_GETTER(_VkGeometryAABBNV::Getoffset) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkGeometryAABBNV::Setoffset) {
  _VkGeometryAABBNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryAABBNV.offset", "Number");
  
    return;
  }
}
/** ## END VkGeometryAABBNV ## **/

/** ## BEGIN VkGeometryTrianglesNV ## **/

class _VkGeometryTrianglesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> vertexData;
      static NAN_GETTER(GetvertexData);
    static NAN_SETTER(SetvertexData);
    
    static NAN_GETTER(GetvertexOffset);
    static NAN_SETTER(SetvertexOffset);
    
    static NAN_GETTER(GetvertexCount);
    static NAN_SETTER(SetvertexCount);
    
    static NAN_GETTER(GetvertexStride);
    static NAN_SETTER(SetvertexStride);
    
    static NAN_GETTER(GetvertexFormat);
    static NAN_SETTER(SetvertexFormat);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> indexData;
      static NAN_GETTER(GetindexData);
    static NAN_SETTER(SetindexData);
    
    static NAN_GETTER(GetindexOffset);
    static NAN_SETTER(SetindexOffset);
    
    static NAN_GETTER(GetindexCount);
    static NAN_SETTER(SetindexCount);
    
    static NAN_GETTER(GetindexType);
    static NAN_SETTER(SetindexType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> transformData;
      static NAN_GETTER(GettransformData);
    static NAN_SETTER(SettransformData);
    
    static NAN_GETTER(GettransformOffset);
    static NAN_SETTER(SettransformOffset);
    

    // real instance
    VkGeometryTrianglesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkGeometryTrianglesNV();
    ~_VkGeometryTrianglesNV();

};

/*
#include "index.h"
#include "VkGeometryTrianglesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkGeometryTrianglesNV::constructor;

_VkGeometryTrianglesNV::_VkGeometryTrianglesNV() {
  instance.sType = VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV;
  
}

_VkGeometryTrianglesNV::~_VkGeometryTrianglesNV() {
  //printf("VkGeometryTrianglesNV deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkGeometryTrianglesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkGeometryTrianglesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkGeometryTrianglesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexData").ToLocalChecked(), GetvertexData, SetvertexData, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexOffset").ToLocalChecked(), GetvertexOffset, SetvertexOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexCount").ToLocalChecked(), GetvertexCount, SetvertexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexStride").ToLocalChecked(), GetvertexStride, SetvertexStride, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexFormat").ToLocalChecked(), GetvertexFormat, SetvertexFormat, ctor);
  SetPrototypeAccessor(proto, Nan::New("indexData").ToLocalChecked(), GetindexData, SetindexData, ctor);
  SetPrototypeAccessor(proto, Nan::New("indexOffset").ToLocalChecked(), GetindexOffset, SetindexOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("indexCount").ToLocalChecked(), GetindexCount, SetindexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("indexType").ToLocalChecked(), GetindexType, SetindexType, ctor);
  SetPrototypeAccessor(proto, Nan::New("transformData").ToLocalChecked(), GettransformData, SettransformData, ctor);
  SetPrototypeAccessor(proto, Nan::New("transformOffset").ToLocalChecked(), GettransformOffset, SettransformOffset, ctor);
  Nan::Set(target, Nan::New("VkGeometryTrianglesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkGeometryTrianglesNV::flush() {
  _VkGeometryTrianglesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkGeometryTrianglesNV::New) {
  if (info.IsConstructCall()) {
    _VkGeometryTrianglesNV* self = new _VkGeometryTrianglesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("vertexData").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("vertexOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("vertexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("vertexStride").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("vertexFormat").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("indexData").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("indexOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("indexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("indexType").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("transformData").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("transformOffset").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkGeometryTrianglesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkGeometryTrianglesNV::GetsType) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkGeometryTrianglesNV::SetsType) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.sType", "Number");
  
    return;
  }
}// vertexData
NAN_GETTER(_VkGeometryTrianglesNV::GetvertexData) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (self->vertexData.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->vertexData);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGeometryTrianglesNV::SetvertexData) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->vertexData.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.vertexData = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.vertexData", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->vertexData.Reset();
    self->instance.vertexData = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.vertexData", "[object VkBuffer]");
  
    return;
  }
}// vertexOffset
NAN_GETTER(_VkGeometryTrianglesNV::GetvertexOffset) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexOffset));
}NAN_SETTER(_VkGeometryTrianglesNV::SetvertexOffset) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.vertexOffset", "Number");
  
    return;
  }
}// vertexCount
NAN_GETTER(_VkGeometryTrianglesNV::GetvertexCount) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexCount));
}NAN_SETTER(_VkGeometryTrianglesNV::SetvertexCount) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.vertexCount", "Number");
  
    return;
  }
}// vertexStride
NAN_GETTER(_VkGeometryTrianglesNV::GetvertexStride) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexStride));
}NAN_SETTER(_VkGeometryTrianglesNV::SetvertexStride) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexStride = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.vertexStride", "Number");
  
    return;
  }
}// vertexFormat
NAN_GETTER(_VkGeometryTrianglesNV::GetvertexFormat) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexFormat));
}NAN_SETTER(_VkGeometryTrianglesNV::SetvertexFormat) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexFormat = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.vertexFormat", "Number");
  
    return;
  }
}// indexData
NAN_GETTER(_VkGeometryTrianglesNV::GetindexData) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (self->indexData.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->indexData);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGeometryTrianglesNV::SetindexData) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->indexData.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.indexData = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.indexData", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->indexData.Reset();
    self->instance.indexData = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.indexData", "[object VkBuffer]");
  
    return;
  }
}// indexOffset
NAN_GETTER(_VkGeometryTrianglesNV::GetindexOffset) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.indexOffset));
}NAN_SETTER(_VkGeometryTrianglesNV::SetindexOffset) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.indexOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.indexOffset", "Number");
  
    return;
  }
}// indexCount
NAN_GETTER(_VkGeometryTrianglesNV::GetindexCount) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.indexCount));
}NAN_SETTER(_VkGeometryTrianglesNV::SetindexCount) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.indexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.indexCount", "Number");
  
    return;
  }
}// indexType
NAN_GETTER(_VkGeometryTrianglesNV::GetindexType) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.indexType));
}NAN_SETTER(_VkGeometryTrianglesNV::SetindexType) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.indexType = static_cast<VkIndexType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.indexType", "Number");
  
    return;
  }
}// transformData
NAN_GETTER(_VkGeometryTrianglesNV::GettransformData) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (self->transformData.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->transformData);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGeometryTrianglesNV::SettransformData) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->transformData.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.transformData = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.transformData", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->transformData.Reset();
    self->instance.transformData = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.transformData", "[object VkBuffer]");
  
    return;
  }
}// transformOffset
NAN_GETTER(_VkGeometryTrianglesNV::GettransformOffset) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.transformOffset));
}NAN_SETTER(_VkGeometryTrianglesNV::SettransformOffset) {
  _VkGeometryTrianglesNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.transformOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryTrianglesNV.transformOffset", "Number");
  
    return;
  }
}
/** ## END VkGeometryTrianglesNV ## **/

/** ## BEGIN VkGeometryDataNV ## **/

class _VkGeometryDataNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> triangles;
      static NAN_GETTER(Gettriangles);
    static NAN_SETTER(Settriangles);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> aabbs;
      static NAN_GETTER(Getaabbs);
    static NAN_SETTER(Setaabbs);
    

    // real instance
    VkGeometryDataNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkGeometryDataNV();
    ~_VkGeometryDataNV();

};

/*
#include "index.h"
#include "VkGeometryDataNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkGeometryDataNV::constructor;

_VkGeometryDataNV::_VkGeometryDataNV() {
  
  
}

_VkGeometryDataNV::~_VkGeometryDataNV() {
  //printf("VkGeometryDataNV deconstructed!!\n");
  
  
  
}

void _VkGeometryDataNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkGeometryDataNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkGeometryDataNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("triangles").ToLocalChecked(), Gettriangles, Settriangles, ctor);
  SetPrototypeAccessor(proto, Nan::New("aabbs").ToLocalChecked(), Getaabbs, Setaabbs, ctor);
  Nan::Set(target, Nan::New("VkGeometryDataNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkGeometryDataNV::flush() {
  _VkGeometryDataNV *self = this;
  if (!(self->triangles.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->triangles);
    
    _VkGeometryTrianglesNV* result = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.triangles = result->instance;
  }if (!(self->aabbs.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->aabbs);
    
    _VkGeometryAABBNV* result = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.aabbs = result->instance;
  }
  return true;
}

NAN_METHOD(_VkGeometryDataNV::New) {
  if (info.IsConstructCall()) {
    _VkGeometryDataNV* self = new _VkGeometryDataNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("triangles").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("aabbs").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkGeometryDataNV constructor cannot be invoked without 'new'");
  }
};

// triangles
NAN_GETTER(_VkGeometryDataNV::Gettriangles) {
  _VkGeometryDataNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryDataNV>(info.This());
  if (self->triangles.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->triangles);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGeometryDataNV::Settriangles) {
  _VkGeometryDataNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryDataNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkGeometryTrianglesNV::constructor)->HasInstance(obj)) {
      self->triangles.Reset<v8::Object>(value.As<v8::Object>());
      _VkGeometryTrianglesNV* inst = Nan::ObjectWrap::Unwrap<_VkGeometryTrianglesNV>(obj);
      inst->flush();
      self->instance.triangles = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGeometryDataNV.triangles", "[object VkGeometryTrianglesNV]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->triangles.Reset();
    memset(&self->instance.triangles, 0, sizeof(VkGeometryTrianglesNV));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryDataNV.triangles", "[object VkGeometryTrianglesNV]");
  
    return;
  }
}// aabbs
NAN_GETTER(_VkGeometryDataNV::Getaabbs) {
  _VkGeometryDataNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryDataNV>(info.This());
  if (self->aabbs.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->aabbs);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGeometryDataNV::Setaabbs) {
  _VkGeometryDataNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryDataNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkGeometryAABBNV::constructor)->HasInstance(obj)) {
      self->aabbs.Reset<v8::Object>(value.As<v8::Object>());
      _VkGeometryAABBNV* inst = Nan::ObjectWrap::Unwrap<_VkGeometryAABBNV>(obj);
      inst->flush();
      self->instance.aabbs = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGeometryDataNV.aabbs", "[object VkGeometryAABBNV]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->aabbs.Reset();
    memset(&self->instance.aabbs, 0, sizeof(VkGeometryAABBNV));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryDataNV.aabbs", "[object VkGeometryAABBNV]");
  
    return;
  }
}
/** ## END VkGeometryDataNV ## **/

/** ## BEGIN VkGeometryNV ## **/

class _VkGeometryNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetgeometryType);
    static NAN_SETTER(SetgeometryType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> geometry;
      static NAN_GETTER(Getgeometry);
    static NAN_SETTER(Setgeometry);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkGeometryNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkGeometryNV();
    ~_VkGeometryNV();

};

/*
#include "index.h"
#include "VkGeometryNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkGeometryNV::constructor;

_VkGeometryNV::_VkGeometryNV() {
  instance.sType = VK_STRUCTURE_TYPE_GEOMETRY_NV;
  
}

_VkGeometryNV::~_VkGeometryNV() {
  //printf("VkGeometryNV deconstructed!!\n");
  
  
  
  
  
}

void _VkGeometryNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkGeometryNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkGeometryNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("geometryType").ToLocalChecked(), GetgeometryType, SetgeometryType, ctor);
  SetPrototypeAccessor(proto, Nan::New("geometry").ToLocalChecked(), Getgeometry, Setgeometry, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkGeometryNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkGeometryNV::flush() {
  _VkGeometryNV *self = this;
  if (!(self->geometry.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->geometry);
    
    _VkGeometryDataNV* result = Nan::ObjectWrap::Unwrap<_VkGeometryDataNV>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.geometry = result->instance;
  }
  return true;
}

NAN_METHOD(_VkGeometryNV::New) {
  if (info.IsConstructCall()) {
    _VkGeometryNV* self = new _VkGeometryNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("geometryType").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("geometry").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkGeometryNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkGeometryNV::GetsType) {
  _VkGeometryNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkGeometryNV::SetsType) {
  _VkGeometryNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryNV.sType", "Number");
  
    return;
  }
}// geometryType
NAN_GETTER(_VkGeometryNV::GetgeometryType) {
  _VkGeometryNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.geometryType));
}NAN_SETTER(_VkGeometryNV::SetgeometryType) {
  _VkGeometryNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(info.This());
  if (value->IsNumber()) {
    self->instance.geometryType = static_cast<VkGeometryTypeNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryNV.geometryType", "Number");
  
    return;
  }
}// geometry
NAN_GETTER(_VkGeometryNV::Getgeometry) {
  _VkGeometryNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(info.This());
  if (self->geometry.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->geometry);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGeometryNV::Setgeometry) {
  _VkGeometryNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkGeometryDataNV::constructor)->HasInstance(obj)) {
      self->geometry.Reset<v8::Object>(value.As<v8::Object>());
      _VkGeometryDataNV* inst = Nan::ObjectWrap::Unwrap<_VkGeometryDataNV>(obj);
      inst->flush();
      self->instance.geometry = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGeometryNV.geometry", "[object VkGeometryDataNV]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->geometry.Reset();
    memset(&self->instance.geometry, 0, sizeof(VkGeometryDataNV));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryNV.geometry", "[object VkGeometryDataNV]");
  
    return;
  }
}// flags
NAN_GETTER(_VkGeometryNV::Getflags) {
  _VkGeometryNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkGeometryNV::Setflags) {
  _VkGeometryNV *self = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkGeometryFlagsNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGeometryNV.flags", "Number");
  
    return;
  }
}
/** ## END VkGeometryNV ## **/

/** ## BEGIN VkAccelerationStructureInfoNV ## **/

class _VkAccelerationStructureInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetinstanceCount);
    static NAN_SETTER(SetinstanceCount);
    
    static NAN_GETTER(GetgeometryCount);
    static NAN_SETTER(SetgeometryCount);
    
    std::vector<VkGeometryNV>* vpGeometries;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pGeometries;
    static NAN_GETTER(GetpGeometries);
    static NAN_SETTER(SetpGeometries);
    

    // real instance
    VkAccelerationStructureInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAccelerationStructureInfoNV();
    ~_VkAccelerationStructureInfoNV();

};

/*
#include "index.h"
#include "VkAccelerationStructureInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAccelerationStructureInfoNV::constructor;

_VkAccelerationStructureInfoNV::_VkAccelerationStructureInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV;
  vpGeometries = new std::vector<VkGeometryNV>;
  
}

_VkAccelerationStructureInfoNV::~_VkAccelerationStructureInfoNV() {
  //printf("VkAccelerationStructureInfoNV deconstructed!!\n");
  
  
  
  
  
  
  vpGeometries->clear();
  delete vpGeometries;
  
  pGeometries.Reset();
  
}

void _VkAccelerationStructureInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAccelerationStructureInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAccelerationStructureInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("instanceCount").ToLocalChecked(), GetinstanceCount, SetinstanceCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("geometryCount").ToLocalChecked(), GetgeometryCount, SetgeometryCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pGeometries").ToLocalChecked(), GetpGeometries, SetpGeometries, ctor);
  Nan::Set(target, Nan::New("VkAccelerationStructureInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAccelerationStructureInfoNV::flush() {
  _VkAccelerationStructureInfoNV *self = this;
  if (!(self->pGeometries.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pGeometries);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.geometryCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'geometryCount' for 'VkAccelerationStructureInfoNV.pGeometries'");
      return false;
    }
    std::vector<VkGeometryNV>* data = self->vpGeometries;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkGeometryNV::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureInfoNV.pGeometries", "[object VkGeometryNV]");
  
        return false;
      }
      _VkGeometryNV* result = Nan::ObjectWrap::Unwrap<_VkGeometryNV>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pGeometries = data->data();
  }
  return true;
}

NAN_METHOD(_VkAccelerationStructureInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkAccelerationStructureInfoNV* self = new _VkAccelerationStructureInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("instanceCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("geometryCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pGeometries").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAccelerationStructureInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkAccelerationStructureInfoNV::GetsType) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkAccelerationStructureInfoNV::SetsType) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureInfoNV.sType", "Number");
  
    return;
  }
}// type
NAN_GETTER(_VkAccelerationStructureInfoNV::Gettype) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkAccelerationStructureInfoNV::Settype) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkAccelerationStructureTypeNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureInfoNV.type", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkAccelerationStructureInfoNV::Getflags) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkAccelerationStructureInfoNV::Setflags) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkBuildAccelerationStructureFlagsNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureInfoNV.flags", "Number");
  
    return;
  }
}// instanceCount
NAN_GETTER(_VkAccelerationStructureInfoNV::GetinstanceCount) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.instanceCount));
}NAN_SETTER(_VkAccelerationStructureInfoNV::SetinstanceCount) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.instanceCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureInfoNV.instanceCount", "Number");
  
    return;
  }
}// geometryCount
NAN_GETTER(_VkAccelerationStructureInfoNV::GetgeometryCount) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.geometryCount));
}NAN_SETTER(_VkAccelerationStructureInfoNV::SetgeometryCount) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.geometryCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureInfoNV.geometryCount", "Number");
  
    return;
  }
}// pGeometries
NAN_GETTER(_VkAccelerationStructureInfoNV::GetpGeometries) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  if (self->pGeometries.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pGeometries);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkAccelerationStructureInfoNV::SetpGeometries) {
  _VkAccelerationStructureInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pGeometries.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pGeometries.Reset();
      self->instance.pGeometries = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureInfoNV.pGeometries", "[object VkGeometryNV]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pGeometries = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureInfoNV.pGeometries", "[object VkGeometryNV]");
  
    return;
  }
}
/** ## END VkAccelerationStructureInfoNV ## **/

/** ## BEGIN VkAccelerationStructureCreateInfoNV ## **/

class _VkAccelerationStructureCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetcompactedSize);
    static NAN_SETTER(SetcompactedSize);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> info;
      static NAN_GETTER(Getinfo);
    static NAN_SETTER(Setinfo);
    

    // real instance
    VkAccelerationStructureCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAccelerationStructureCreateInfoNV();
    ~_VkAccelerationStructureCreateInfoNV();

};

/*
#include "index.h"
#include "VkAccelerationStructureCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAccelerationStructureCreateInfoNV::constructor;

_VkAccelerationStructureCreateInfoNV::_VkAccelerationStructureCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV;
  
}

_VkAccelerationStructureCreateInfoNV::~_VkAccelerationStructureCreateInfoNV() {
  //printf("VkAccelerationStructureCreateInfoNV deconstructed!!\n");
  
  
  
  
}

void _VkAccelerationStructureCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAccelerationStructureCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAccelerationStructureCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("compactedSize").ToLocalChecked(), GetcompactedSize, SetcompactedSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("info").ToLocalChecked(), Getinfo, Setinfo, ctor);
  Nan::Set(target, Nan::New("VkAccelerationStructureCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAccelerationStructureCreateInfoNV::flush() {
  _VkAccelerationStructureCreateInfoNV *self = this;
  if (!(self->info.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->info);
    
    _VkAccelerationStructureInfoNV* result = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.info = result->instance;
  }
  return true;
}

NAN_METHOD(_VkAccelerationStructureCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkAccelerationStructureCreateInfoNV* self = new _VkAccelerationStructureCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("compactedSize").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("info").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAccelerationStructureCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkAccelerationStructureCreateInfoNV::GetsType) {
  _VkAccelerationStructureCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkAccelerationStructureCreateInfoNV::SetsType) {
  _VkAccelerationStructureCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureCreateInfoNV.sType", "Number");
  
    return;
  }
}// compactedSize
NAN_GETTER(_VkAccelerationStructureCreateInfoNV::GetcompactedSize) {
  _VkAccelerationStructureCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compactedSize));
}NAN_SETTER(_VkAccelerationStructureCreateInfoNV::SetcompactedSize) {
  _VkAccelerationStructureCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.compactedSize = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureCreateInfoNV.compactedSize", "Number");
  
    return;
  }
}// info
NAN_GETTER(_VkAccelerationStructureCreateInfoNV::Getinfo) {
  _VkAccelerationStructureCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureCreateInfoNV>(info.This());
  if (self->info.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->info);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkAccelerationStructureCreateInfoNV::Setinfo) {
  _VkAccelerationStructureCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureCreateInfoNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkAccelerationStructureInfoNV::constructor)->HasInstance(obj)) {
      self->info.Reset<v8::Object>(value.As<v8::Object>());
      _VkAccelerationStructureInfoNV* inst = Nan::ObjectWrap::Unwrap<_VkAccelerationStructureInfoNV>(obj);
      inst->flush();
      self->instance.info = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureCreateInfoNV.info", "[object VkAccelerationStructureInfoNV]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->info.Reset();
    memset(&self->instance.info, 0, sizeof(VkAccelerationStructureInfoNV));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAccelerationStructureCreateInfoNV.info", "[object VkAccelerationStructureInfoNV]");
  
    return;
  }
}
/** ## END VkAccelerationStructureCreateInfoNV ## **/

/** ## BEGIN VkRayTracingShaderGroupCreateInfoNV ## **/

class _VkRayTracingShaderGroupCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(GetgeneralShader);
    static NAN_SETTER(SetgeneralShader);
    
    static NAN_GETTER(GetclosestHitShader);
    static NAN_SETTER(SetclosestHitShader);
    
    static NAN_GETTER(GetanyHitShader);
    static NAN_SETTER(SetanyHitShader);
    
    static NAN_GETTER(GetintersectionShader);
    static NAN_SETTER(SetintersectionShader);
    

    // real instance
    VkRayTracingShaderGroupCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRayTracingShaderGroupCreateInfoNV();
    ~_VkRayTracingShaderGroupCreateInfoNV();

};

/*
#include "index.h"
#include "VkRayTracingShaderGroupCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRayTracingShaderGroupCreateInfoNV::constructor;

_VkRayTracingShaderGroupCreateInfoNV::_VkRayTracingShaderGroupCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV;
  
}

_VkRayTracingShaderGroupCreateInfoNV::~_VkRayTracingShaderGroupCreateInfoNV() {
  //printf("VkRayTracingShaderGroupCreateInfoNV deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkRayTracingShaderGroupCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRayTracingShaderGroupCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRayTracingShaderGroupCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("generalShader").ToLocalChecked(), GetgeneralShader, SetgeneralShader, ctor);
  SetPrototypeAccessor(proto, Nan::New("closestHitShader").ToLocalChecked(), GetclosestHitShader, SetclosestHitShader, ctor);
  SetPrototypeAccessor(proto, Nan::New("anyHitShader").ToLocalChecked(), GetanyHitShader, SetanyHitShader, ctor);
  SetPrototypeAccessor(proto, Nan::New("intersectionShader").ToLocalChecked(), GetintersectionShader, SetintersectionShader, ctor);
  Nan::Set(target, Nan::New("VkRayTracingShaderGroupCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRayTracingShaderGroupCreateInfoNV::flush() {
  _VkRayTracingShaderGroupCreateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkRayTracingShaderGroupCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkRayTracingShaderGroupCreateInfoNV* self = new _VkRayTracingShaderGroupCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("generalShader").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("closestHitShader").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("anyHitShader").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("intersectionShader").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRayTracingShaderGroupCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRayTracingShaderGroupCreateInfoNV::GetsType) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRayTracingShaderGroupCreateInfoNV::SetsType) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingShaderGroupCreateInfoNV.sType", "Number");
  
    return;
  }
}// type
NAN_GETTER(_VkRayTracingShaderGroupCreateInfoNV::Gettype) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkRayTracingShaderGroupCreateInfoNV::Settype) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkRayTracingShaderGroupTypeNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingShaderGroupCreateInfoNV.type", "Number");
  
    return;
  }
}// generalShader
NAN_GETTER(_VkRayTracingShaderGroupCreateInfoNV::GetgeneralShader) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.generalShader));
}NAN_SETTER(_VkRayTracingShaderGroupCreateInfoNV::SetgeneralShader) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.generalShader = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingShaderGroupCreateInfoNV.generalShader", "Number");
  
    return;
  }
}// closestHitShader
NAN_GETTER(_VkRayTracingShaderGroupCreateInfoNV::GetclosestHitShader) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.closestHitShader));
}NAN_SETTER(_VkRayTracingShaderGroupCreateInfoNV::SetclosestHitShader) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.closestHitShader = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingShaderGroupCreateInfoNV.closestHitShader", "Number");
  
    return;
  }
}// anyHitShader
NAN_GETTER(_VkRayTracingShaderGroupCreateInfoNV::GetanyHitShader) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.anyHitShader));
}NAN_SETTER(_VkRayTracingShaderGroupCreateInfoNV::SetanyHitShader) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.anyHitShader = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingShaderGroupCreateInfoNV.anyHitShader", "Number");
  
    return;
  }
}// intersectionShader
NAN_GETTER(_VkRayTracingShaderGroupCreateInfoNV::GetintersectionShader) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.intersectionShader));
}NAN_SETTER(_VkRayTracingShaderGroupCreateInfoNV::SetintersectionShader) {
  _VkRayTracingShaderGroupCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.intersectionShader = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingShaderGroupCreateInfoNV.intersectionShader", "Number");
  
    return;
  }
}
/** ## END VkRayTracingShaderGroupCreateInfoNV ## **/

/** ## BEGIN VkSpecializationMapEntry ## **/

class _VkSpecializationMapEntry: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetconstantID);
    static NAN_SETTER(SetconstantID);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
    static NAN_GETTER(Getsize);
    static NAN_SETTER(Setsize);
    

    // real instance
    VkSpecializationMapEntry instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSpecializationMapEntry();
    ~_VkSpecializationMapEntry();

};

/*
#include "index.h"
#include "VkSpecializationMapEntry.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSpecializationMapEntry::constructor;

_VkSpecializationMapEntry::_VkSpecializationMapEntry() {
  
  
}

_VkSpecializationMapEntry::~_VkSpecializationMapEntry() {
  //printf("VkSpecializationMapEntry deconstructed!!\n");
  
  
  
  
}

void _VkSpecializationMapEntry::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSpecializationMapEntry::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSpecializationMapEntry").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("constantID").ToLocalChecked(), GetconstantID, SetconstantID, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, Setsize, ctor);
  Nan::Set(target, Nan::New("VkSpecializationMapEntry").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSpecializationMapEntry::flush() {
  _VkSpecializationMapEntry *self = this;
  
  return true;
}

NAN_METHOD(_VkSpecializationMapEntry::New) {
  if (info.IsConstructCall()) {
    _VkSpecializationMapEntry* self = new _VkSpecializationMapEntry();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("constantID").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("size").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSpecializationMapEntry constructor cannot be invoked without 'new'");
  }
};

// constantID
NAN_GETTER(_VkSpecializationMapEntry::GetconstantID) {
  _VkSpecializationMapEntry *self = Nan::ObjectWrap::Unwrap<_VkSpecializationMapEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.constantID));
}NAN_SETTER(_VkSpecializationMapEntry::SetconstantID) {
  _VkSpecializationMapEntry *self = Nan::ObjectWrap::Unwrap<_VkSpecializationMapEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.constantID = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSpecializationMapEntry.constantID", "Number");
  
    return;
  }
}// offset
NAN_GETTER(_VkSpecializationMapEntry::Getoffset) {
  _VkSpecializationMapEntry *self = Nan::ObjectWrap::Unwrap<_VkSpecializationMapEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkSpecializationMapEntry::Setoffset) {
  _VkSpecializationMapEntry *self = Nan::ObjectWrap::Unwrap<_VkSpecializationMapEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSpecializationMapEntry.offset", "Number");
  
    return;
  }
}// size
NAN_GETTER(_VkSpecializationMapEntry::Getsize) {
  _VkSpecializationMapEntry *self = Nan::ObjectWrap::Unwrap<_VkSpecializationMapEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}NAN_SETTER(_VkSpecializationMapEntry::Setsize) {
  _VkSpecializationMapEntry *self = Nan::ObjectWrap::Unwrap<_VkSpecializationMapEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.size = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSpecializationMapEntry.size", "Number");
  
    return;
  }
}
/** ## END VkSpecializationMapEntry ## **/

/** ## BEGIN VkSpecializationInfo ## **/

class _VkSpecializationInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetmapEntryCount);
    static NAN_SETTER(SetmapEntryCount);
    
    std::vector<VkSpecializationMapEntry>* vpMapEntries;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pMapEntries;
    static NAN_GETTER(GetpMapEntries);
    static NAN_SETTER(SetpMapEntries);
    
    static NAN_GETTER(GetdataSize);
    static NAN_SETTER(SetdataSize);
    
    Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pData;
    static NAN_GETTER(GetpData);
    static NAN_SETTER(SetpData);
    

    // real instance
    VkSpecializationInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSpecializationInfo();
    ~_VkSpecializationInfo();

};

/*
#include "index.h"
#include "VkSpecializationInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSpecializationInfo::constructor;

_VkSpecializationInfo::_VkSpecializationInfo() {
  
  vpMapEntries = new std::vector<VkSpecializationMapEntry>;
  
}

_VkSpecializationInfo::~_VkSpecializationInfo() {
  //printf("VkSpecializationInfo deconstructed!!\n");
  
  
  vpMapEntries->clear();
  delete vpMapEntries;
  
  pMapEntries.Reset();
  
  
  pData.Reset();
  
}

void _VkSpecializationInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSpecializationInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSpecializationInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("mapEntryCount").ToLocalChecked(), GetmapEntryCount, SetmapEntryCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pMapEntries").ToLocalChecked(), GetpMapEntries, SetpMapEntries, ctor);
  SetPrototypeAccessor(proto, Nan::New("dataSize").ToLocalChecked(), GetdataSize, SetdataSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("pData").ToLocalChecked(), GetpData, SetpData, ctor);
  Nan::Set(target, Nan::New("VkSpecializationInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSpecializationInfo::flush() {
  _VkSpecializationInfo *self = this;
  if (!(self->pMapEntries.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pMapEntries);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.mapEntryCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'mapEntryCount' for 'VkSpecializationInfo.pMapEntries'");
      return false;
    }
    std::vector<VkSpecializationMapEntry>* data = self->vpMapEntries;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSpecializationMapEntry::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSpecializationInfo.pMapEntries", "[object VkSpecializationMapEntry]");
  
        return false;
      }
      _VkSpecializationMapEntry* result = Nan::ObjectWrap::Unwrap<_VkSpecializationMapEntry>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pMapEntries = data->data();
  }
  return true;
}

NAN_METHOD(_VkSpecializationInfo::New) {
  if (info.IsConstructCall()) {
    _VkSpecializationInfo* self = new _VkSpecializationInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("mapEntryCount").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("pMapEntries").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dataSize").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pData").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSpecializationInfo constructor cannot be invoked without 'new'");
  }
};

// mapEntryCount
NAN_GETTER(_VkSpecializationInfo::GetmapEntryCount) {
  _VkSpecializationInfo *self = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.mapEntryCount));
}NAN_SETTER(_VkSpecializationInfo::SetmapEntryCount) {
  _VkSpecializationInfo *self = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.mapEntryCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSpecializationInfo.mapEntryCount", "Number");
  
    return;
  }
}// pMapEntries
NAN_GETTER(_VkSpecializationInfo::GetpMapEntries) {
  _VkSpecializationInfo *self = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(info.This());
  if (self->pMapEntries.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pMapEntries);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSpecializationInfo::SetpMapEntries) {
  _VkSpecializationInfo *self = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pMapEntries.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pMapEntries.Reset();
      self->instance.pMapEntries = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSpecializationInfo.pMapEntries", "[object VkSpecializationMapEntry]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pMapEntries = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSpecializationInfo.pMapEntries", "[object VkSpecializationMapEntry]");
  
    return;
  }
}// dataSize
NAN_GETTER(_VkSpecializationInfo::GetdataSize) {
  _VkSpecializationInfo *self = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dataSize));
}NAN_SETTER(_VkSpecializationInfo::SetdataSize) {
  _VkSpecializationInfo *self = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.dataSize = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSpecializationInfo.dataSize", "Number");
  
    return;
  }
}// pData
NAN_GETTER(_VkSpecializationInfo::GetpData) {
  _VkSpecializationInfo *self = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(info.This());
}NAN_SETTER(_VkSpecializationInfo::SetpData) {
  _VkSpecializationInfo *self = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(info.This());
}
/** ## END VkSpecializationInfo ## **/

/** ## BEGIN VkPipelineShaderStageCreateInfo ## **/

class _VkPipelineShaderStageCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(Getstage);
    static NAN_SETTER(Setstage);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> module;
      static NAN_GETTER(Getmodule);
    static NAN_SETTER(Setmodule);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pName;
    static NAN_GETTER(GetpName);
    static NAN_SETTER(SetpName);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pSpecializationInfo;
      static NAN_GETTER(GetpSpecializationInfo);
    static NAN_SETTER(SetpSpecializationInfo);
    

    // real instance
    VkPipelineShaderStageCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineShaderStageCreateInfo();
    ~_VkPipelineShaderStageCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineShaderStageCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineShaderStageCreateInfo::constructor;

_VkPipelineShaderStageCreateInfo::_VkPipelineShaderStageCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  
}

_VkPipelineShaderStageCreateInfo::~_VkPipelineShaderStageCreateInfo() {
  //printf("VkPipelineShaderStageCreateInfo deconstructed!!\n");
  
  
  
  
  
  pName.Reset();
  
  pSpecializationInfo.Reset();
  
}

void _VkPipelineShaderStageCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineShaderStageCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineShaderStageCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("stage").ToLocalChecked(), Getstage, Setstage, ctor);
  SetPrototypeAccessor(proto, Nan::New("module").ToLocalChecked(), Getmodule, Setmodule, ctor);
  SetPrototypeAccessor(proto, Nan::New("pName").ToLocalChecked(), GetpName, SetpName, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSpecializationInfo").ToLocalChecked(), GetpSpecializationInfo, SetpSpecializationInfo, ctor);
  Nan::Set(target, Nan::New("VkPipelineShaderStageCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineShaderStageCreateInfo::flush() {
  _VkPipelineShaderStageCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineShaderStageCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineShaderStageCreateInfo* self = new _VkPipelineShaderStageCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("stage").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("module").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pName").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pSpecializationInfo").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineShaderStageCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineShaderStageCreateInfo::GetsType) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineShaderStageCreateInfo::SetsType) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineShaderStageCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineShaderStageCreateInfo::Getflags) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineShaderStageCreateInfo::Setflags) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineShaderStageCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineShaderStageCreateInfo.flags", "Number");
  
    return;
  }
}// stage
NAN_GETTER(_VkPipelineShaderStageCreateInfo::Getstage) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stage));
}NAN_SETTER(_VkPipelineShaderStageCreateInfo::Setstage) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.stage = static_cast<VkShaderStageFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineShaderStageCreateInfo.stage", "Number");
  
    return;
  }
}// module
NAN_GETTER(_VkPipelineShaderStageCreateInfo::Getmodule) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  if (self->module.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->module);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineShaderStageCreateInfo::Setmodule) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkShaderModule::constructor)->HasInstance(obj)) {
      self->module.Reset<v8::Object>(value.As<v8::Object>());
      _VkShaderModule* inst = Nan::ObjectWrap::Unwrap<_VkShaderModule>(obj);
      ;
      self->instance.module = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineShaderStageCreateInfo.module", "[object VkShaderModule]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->module.Reset();
    self->instance.module = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineShaderStageCreateInfo.module", "[object VkShaderModule]");
  
    return;
  }
}// pName
NAN_GETTER(_VkPipelineShaderStageCreateInfo::GetpName) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  if (self->pName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pName);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkPipelineShaderStageCreateInfo::SetpName) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pName = str;
    // free previous
    if (self->instance.pName) {
      delete[] self->instance.pName;
    }
    self->instance.pName = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pName = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineShaderStageCreateInfo.pName", "String");
  
    return;
  }
}// pSpecializationInfo
NAN_GETTER(_VkPipelineShaderStageCreateInfo::GetpSpecializationInfo) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  if (self->pSpecializationInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSpecializationInfo);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineShaderStageCreateInfo::SetpSpecializationInfo) {
  _VkPipelineShaderStageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSpecializationInfo::constructor)->HasInstance(obj)) {
      self->pSpecializationInfo.Reset<v8::Object>(value.As<v8::Object>());
      _VkSpecializationInfo* inst = Nan::ObjectWrap::Unwrap<_VkSpecializationInfo>(obj);
      inst->flush();
      self->instance.pSpecializationInfo = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineShaderStageCreateInfo.pSpecializationInfo", "[object VkSpecializationInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pSpecializationInfo.Reset();
    self->instance.pSpecializationInfo = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineShaderStageCreateInfo.pSpecializationInfo", "[object VkSpecializationInfo]");
  
    return;
  }
}
/** ## END VkPipelineShaderStageCreateInfo ## **/

/** ## BEGIN VkRayTracingPipelineCreateInfoNV ## **/

class _VkRayTracingPipelineCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetstageCount);
    static NAN_SETTER(SetstageCount);
    
    std::vector<VkPipelineShaderStageCreateInfo>* vpStages;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pStages;
    static NAN_GETTER(GetpStages);
    static NAN_SETTER(SetpStages);
    
    static NAN_GETTER(GetgroupCount);
    static NAN_SETTER(SetgroupCount);
    
    std::vector<VkRayTracingShaderGroupCreateInfoNV>* vpGroups;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pGroups;
    static NAN_GETTER(GetpGroups);
    static NAN_SETTER(SetpGroups);
    
    static NAN_GETTER(GetmaxRecursionDepth);
    static NAN_SETTER(SetmaxRecursionDepth);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> layout;
      static NAN_GETTER(Getlayout);
    static NAN_SETTER(Setlayout);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> basePipelineHandle;
      static NAN_GETTER(GetbasePipelineHandle);
    static NAN_SETTER(SetbasePipelineHandle);
    
    static NAN_GETTER(GetbasePipelineIndex);
    static NAN_SETTER(SetbasePipelineIndex);
    

    // real instance
    VkRayTracingPipelineCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRayTracingPipelineCreateInfoNV();
    ~_VkRayTracingPipelineCreateInfoNV();

};

/*
#include "index.h"
#include "VkRayTracingPipelineCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRayTracingPipelineCreateInfoNV::constructor;

_VkRayTracingPipelineCreateInfoNV::_VkRayTracingPipelineCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV;
  vpStages = new std::vector<VkPipelineShaderStageCreateInfo>;
  vpGroups = new std::vector<VkRayTracingShaderGroupCreateInfoNV>;
  
}

_VkRayTracingPipelineCreateInfoNV::~_VkRayTracingPipelineCreateInfoNV() {
  //printf("VkRayTracingPipelineCreateInfoNV deconstructed!!\n");
  
  
  
  
  vpStages->clear();
  delete vpStages;
  
  pStages.Reset();
  
  
  vpGroups->clear();
  delete vpGroups;
  
  pGroups.Reset();
  
  
  
  
  
}

void _VkRayTracingPipelineCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRayTracingPipelineCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRayTracingPipelineCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("stageCount").ToLocalChecked(), GetstageCount, SetstageCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pStages").ToLocalChecked(), GetpStages, SetpStages, ctor);
  SetPrototypeAccessor(proto, Nan::New("groupCount").ToLocalChecked(), GetgroupCount, SetgroupCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pGroups").ToLocalChecked(), GetpGroups, SetpGroups, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxRecursionDepth").ToLocalChecked(), GetmaxRecursionDepth, SetmaxRecursionDepth, ctor);
  SetPrototypeAccessor(proto, Nan::New("layout").ToLocalChecked(), Getlayout, Setlayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("basePipelineHandle").ToLocalChecked(), GetbasePipelineHandle, SetbasePipelineHandle, ctor);
  SetPrototypeAccessor(proto, Nan::New("basePipelineIndex").ToLocalChecked(), GetbasePipelineIndex, SetbasePipelineIndex, ctor);
  Nan::Set(target, Nan::New("VkRayTracingPipelineCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRayTracingPipelineCreateInfoNV::flush() {
  _VkRayTracingPipelineCreateInfoNV *self = this;
  if (!(self->pStages.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pStages);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.stageCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'stageCount' for 'VkRayTracingPipelineCreateInfoNV.pStages'");
      return false;
    }
    std::vector<VkPipelineShaderStageCreateInfo>* data = self->vpStages;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkPipelineShaderStageCreateInfo::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
        return false;
      }
      _VkPipelineShaderStageCreateInfo* result = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pStages = data->data();
  }if (!(self->pGroups.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pGroups);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.groupCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'groupCount' for 'VkRayTracingPipelineCreateInfoNV.pGroups'");
      return false;
    }
    std::vector<VkRayTracingShaderGroupCreateInfoNV>* data = self->vpGroups;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkRayTracingShaderGroupCreateInfoNV::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.pGroups", "[object VkRayTracingShaderGroupCreateInfoNV]");
  
        return false;
      }
      _VkRayTracingShaderGroupCreateInfoNV* result = Nan::ObjectWrap::Unwrap<_VkRayTracingShaderGroupCreateInfoNV>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pGroups = data->data();
  }
  return true;
}

NAN_METHOD(_VkRayTracingPipelineCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkRayTracingPipelineCreateInfoNV* self = new _VkRayTracingPipelineCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("stageCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pStages").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("groupCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pGroups").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("maxRecursionDepth").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("layout").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("basePipelineHandle").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("basePipelineIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRayTracingPipelineCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::GetsType) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::SetsType) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::Getflags) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::Setflags) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.flags", "Number");
  
    return;
  }
}// stageCount
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::GetstageCount) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stageCount));
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::SetstageCount) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.stageCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.stageCount", "Number");
  
    return;
  }
}// pStages
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::GetpStages) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (self->pStages.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pStages);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::SetpStages) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pStages.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pStages.Reset();
      self->instance.pStages = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pStages = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
    return;
  }
}// groupCount
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::GetgroupCount) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.groupCount));
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::SetgroupCount) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.groupCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.groupCount", "Number");
  
    return;
  }
}// pGroups
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::GetpGroups) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (self->pGroups.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pGroups);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::SetpGroups) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pGroups.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pGroups.Reset();
      self->instance.pGroups = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.pGroups", "[object VkRayTracingShaderGroupCreateInfoNV]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pGroups = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.pGroups", "[object VkRayTracingShaderGroupCreateInfoNV]");
  
    return;
  }
}// maxRecursionDepth
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::GetmaxRecursionDepth) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxRecursionDepth));
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::SetmaxRecursionDepth) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.maxRecursionDepth = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.maxRecursionDepth", "Number");
  
    return;
  }
}// layout
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::Getlayout) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (self->layout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->layout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::Setlayout) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineLayout::constructor)->HasInstance(obj)) {
      self->layout.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineLayout* inst = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(obj);
      ;
      self->instance.layout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.layout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->layout.Reset();
    self->instance.layout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.layout", "[object VkPipelineLayout]");
  
    return;
  }
}// basePipelineHandle
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::GetbasePipelineHandle) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (self->basePipelineHandle.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->basePipelineHandle);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::SetbasePipelineHandle) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipeline::constructor)->HasInstance(obj)) {
      self->basePipelineHandle.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipeline* inst = Nan::ObjectWrap::Unwrap<_VkPipeline>(obj);
      ;
      self->instance.basePipelineHandle = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.basePipelineHandle", "[object VkPipeline]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->basePipelineHandle.Reset();
    self->instance.basePipelineHandle = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.basePipelineHandle", "[object VkPipeline]");
  
    return;
  }
}// basePipelineIndex
NAN_GETTER(_VkRayTracingPipelineCreateInfoNV::GetbasePipelineIndex) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.basePipelineIndex));
}NAN_SETTER(_VkRayTracingPipelineCreateInfoNV::SetbasePipelineIndex) {
  _VkRayTracingPipelineCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkRayTracingPipelineCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.basePipelineIndex = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRayTracingPipelineCreateInfoNV.basePipelineIndex", "Number");
  
    return;
  }
}
/** ## END VkRayTracingPipelineCreateInfoNV ## **/

/** ## BEGIN VkDrawMeshTasksIndirectCommandNV ## **/

class _VkDrawMeshTasksIndirectCommandNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GettaskCount);
    static NAN_SETTER(SettaskCount);
    
    static NAN_GETTER(GetfirstTask);
    static NAN_SETTER(SetfirstTask);
    

    // real instance
    VkDrawMeshTasksIndirectCommandNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDrawMeshTasksIndirectCommandNV();
    ~_VkDrawMeshTasksIndirectCommandNV();

};

/*
#include "index.h"
#include "VkDrawMeshTasksIndirectCommandNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDrawMeshTasksIndirectCommandNV::constructor;

_VkDrawMeshTasksIndirectCommandNV::_VkDrawMeshTasksIndirectCommandNV() {
  
  
}

_VkDrawMeshTasksIndirectCommandNV::~_VkDrawMeshTasksIndirectCommandNV() {
  //printf("VkDrawMeshTasksIndirectCommandNV deconstructed!!\n");
  
  
  
}

void _VkDrawMeshTasksIndirectCommandNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDrawMeshTasksIndirectCommandNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDrawMeshTasksIndirectCommandNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("taskCount").ToLocalChecked(), GettaskCount, SettaskCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("firstTask").ToLocalChecked(), GetfirstTask, SetfirstTask, ctor);
  Nan::Set(target, Nan::New("VkDrawMeshTasksIndirectCommandNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDrawMeshTasksIndirectCommandNV::flush() {
  _VkDrawMeshTasksIndirectCommandNV *self = this;
  
  return true;
}

NAN_METHOD(_VkDrawMeshTasksIndirectCommandNV::New) {
  if (info.IsConstructCall()) {
    _VkDrawMeshTasksIndirectCommandNV* self = new _VkDrawMeshTasksIndirectCommandNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("taskCount").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("firstTask").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDrawMeshTasksIndirectCommandNV constructor cannot be invoked without 'new'");
  }
};

// taskCount
NAN_GETTER(_VkDrawMeshTasksIndirectCommandNV::GettaskCount) {
  _VkDrawMeshTasksIndirectCommandNV *self = Nan::ObjectWrap::Unwrap<_VkDrawMeshTasksIndirectCommandNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.taskCount));
}NAN_SETTER(_VkDrawMeshTasksIndirectCommandNV::SettaskCount) {
  _VkDrawMeshTasksIndirectCommandNV *self = Nan::ObjectWrap::Unwrap<_VkDrawMeshTasksIndirectCommandNV>(info.This());
  if (value->IsNumber()) {
    self->instance.taskCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawMeshTasksIndirectCommandNV.taskCount", "Number");
  
    return;
  }
}// firstTask
NAN_GETTER(_VkDrawMeshTasksIndirectCommandNV::GetfirstTask) {
  _VkDrawMeshTasksIndirectCommandNV *self = Nan::ObjectWrap::Unwrap<_VkDrawMeshTasksIndirectCommandNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.firstTask));
}NAN_SETTER(_VkDrawMeshTasksIndirectCommandNV::SetfirstTask) {
  _VkDrawMeshTasksIndirectCommandNV *self = Nan::ObjectWrap::Unwrap<_VkDrawMeshTasksIndirectCommandNV>(info.This());
  if (value->IsNumber()) {
    self->instance.firstTask = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawMeshTasksIndirectCommandNV.firstTask", "Number");
  
    return;
  }
}
/** ## END VkDrawMeshTasksIndirectCommandNV ## **/

/** ## BEGIN VkPhysicalDeviceMeshShaderPropertiesNV ## **/

class _VkPhysicalDeviceMeshShaderPropertiesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxDrawMeshTasksCount);
    static NAN_GETTER(GetmaxTaskWorkGroupInvocations);
    std::vector<uint32_t>* vmaxTaskWorkGroupSize;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> maxTaskWorkGroupSize;
    static NAN_GETTER(GetmaxTaskWorkGroupSize);
    static NAN_GETTER(GetmaxTaskTotalMemorySize);
    static NAN_GETTER(GetmaxTaskOutputCount);
    static NAN_GETTER(GetmaxMeshWorkGroupInvocations);
    std::vector<uint32_t>* vmaxMeshWorkGroupSize;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> maxMeshWorkGroupSize;
    static NAN_GETTER(GetmaxMeshWorkGroupSize);
    static NAN_GETTER(GetmaxMeshTotalMemorySize);
    static NAN_GETTER(GetmaxMeshOutputVertices);
    static NAN_GETTER(GetmaxMeshOutputPrimitives);
    static NAN_GETTER(GetmaxMeshMultiviewViewCount);
    static NAN_GETTER(GetmeshOutputPerVertexGranularity);
    static NAN_GETTER(GetmeshOutputPerPrimitiveGranularity);

    // real instance
    VkPhysicalDeviceMeshShaderPropertiesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMeshShaderPropertiesNV();
    ~_VkPhysicalDeviceMeshShaderPropertiesNV();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceMeshShaderPropertiesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMeshShaderPropertiesNV::constructor;

_VkPhysicalDeviceMeshShaderPropertiesNV::_VkPhysicalDeviceMeshShaderPropertiesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
  vmaxTaskWorkGroupSize = new std::vector<uint32_t>;
  vmaxMeshWorkGroupSize = new std::vector<uint32_t>;
  
}

_VkPhysicalDeviceMeshShaderPropertiesNV::~_VkPhysicalDeviceMeshShaderPropertiesNV() {
  //printf("VkPhysicalDeviceMeshShaderPropertiesNV deconstructed!!\n");
  
  
  
  
  vmaxTaskWorkGroupSize->clear();
  delete vmaxTaskWorkGroupSize;
  
  
  
  
  
  vmaxMeshWorkGroupSize->clear();
  delete vmaxMeshWorkGroupSize;
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceMeshShaderPropertiesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMeshShaderPropertiesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMeshShaderPropertiesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDrawMeshTasksCount").ToLocalChecked(), GetmaxDrawMeshTasksCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTaskWorkGroupInvocations").ToLocalChecked(), GetmaxTaskWorkGroupInvocations, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTaskWorkGroupSize").ToLocalChecked(), GetmaxTaskWorkGroupSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTaskTotalMemorySize").ToLocalChecked(), GetmaxTaskTotalMemorySize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTaskOutputCount").ToLocalChecked(), GetmaxTaskOutputCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMeshWorkGroupInvocations").ToLocalChecked(), GetmaxMeshWorkGroupInvocations, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMeshWorkGroupSize").ToLocalChecked(), GetmaxMeshWorkGroupSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMeshTotalMemorySize").ToLocalChecked(), GetmaxMeshTotalMemorySize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMeshOutputVertices").ToLocalChecked(), GetmaxMeshOutputVertices, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMeshOutputPrimitives").ToLocalChecked(), GetmaxMeshOutputPrimitives, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMeshMultiviewViewCount").ToLocalChecked(), GetmaxMeshMultiviewViewCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("meshOutputPerVertexGranularity").ToLocalChecked(), GetmeshOutputPerVertexGranularity, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("meshOutputPerPrimitiveGranularity").ToLocalChecked(), GetmeshOutputPerPrimitiveGranularity, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMeshShaderPropertiesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMeshShaderPropertiesNV::flush() {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = this;
  if (!(self->maxTaskWorkGroupSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxTaskWorkGroupSize);
    
  }if (!(self->maxMeshWorkGroupSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxMeshWorkGroupSize);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMeshShaderPropertiesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMeshShaderPropertiesNV* self = new _VkPhysicalDeviceMeshShaderPropertiesNV();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMeshShaderPropertiesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetsType) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxDrawMeshTasksCount
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxDrawMeshTasksCount) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDrawMeshTasksCount));
}// maxTaskWorkGroupInvocations
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxTaskWorkGroupInvocations) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTaskWorkGroupInvocations));
}// maxTaskWorkGroupSize
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxTaskWorkGroupSize) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  if (self->maxTaskWorkGroupSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->maxTaskWorkGroupSize));
  }
}// maxTaskTotalMemorySize
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxTaskTotalMemorySize) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTaskTotalMemorySize));
}// maxTaskOutputCount
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxTaskOutputCount) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTaskOutputCount));
}// maxMeshWorkGroupInvocations
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxMeshWorkGroupInvocations) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMeshWorkGroupInvocations));
}// maxMeshWorkGroupSize
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxMeshWorkGroupSize) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  if (self->maxMeshWorkGroupSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->maxMeshWorkGroupSize));
  }
}// maxMeshTotalMemorySize
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxMeshTotalMemorySize) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMeshTotalMemorySize));
}// maxMeshOutputVertices
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxMeshOutputVertices) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMeshOutputVertices));
}// maxMeshOutputPrimitives
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxMeshOutputPrimitives) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMeshOutputPrimitives));
}// maxMeshMultiviewViewCount
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmaxMeshMultiviewViewCount) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMeshMultiviewViewCount));
}// meshOutputPerVertexGranularity
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmeshOutputPerVertexGranularity) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.meshOutputPerVertexGranularity));
}// meshOutputPerPrimitiveGranularity
NAN_GETTER(_VkPhysicalDeviceMeshShaderPropertiesNV::GetmeshOutputPerPrimitiveGranularity) {
  _VkPhysicalDeviceMeshShaderPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.meshOutputPerPrimitiveGranularity));
}
/** ## END VkPhysicalDeviceMeshShaderPropertiesNV ## **/

/** ## BEGIN VkPhysicalDeviceMeshShaderFeaturesNV ## **/

class _VkPhysicalDeviceMeshShaderFeaturesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GettaskShader);
    static NAN_SETTER(SettaskShader);
    
    static NAN_GETTER(GetmeshShader);
    static NAN_SETTER(SetmeshShader);
    

    // real instance
    VkPhysicalDeviceMeshShaderFeaturesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMeshShaderFeaturesNV();
    ~_VkPhysicalDeviceMeshShaderFeaturesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMeshShaderFeaturesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMeshShaderFeaturesNV::constructor;

_VkPhysicalDeviceMeshShaderFeaturesNV::_VkPhysicalDeviceMeshShaderFeaturesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
  
}

_VkPhysicalDeviceMeshShaderFeaturesNV::~_VkPhysicalDeviceMeshShaderFeaturesNV() {
  //printf("VkPhysicalDeviceMeshShaderFeaturesNV deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceMeshShaderFeaturesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMeshShaderFeaturesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMeshShaderFeaturesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("taskShader").ToLocalChecked(), GettaskShader, SettaskShader, ctor);
  SetPrototypeAccessor(proto, Nan::New("meshShader").ToLocalChecked(), GetmeshShader, SetmeshShader, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMeshShaderFeaturesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMeshShaderFeaturesNV::flush() {
  _VkPhysicalDeviceMeshShaderFeaturesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMeshShaderFeaturesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMeshShaderFeaturesNV* self = new _VkPhysicalDeviceMeshShaderFeaturesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("taskShader").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("meshShader").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMeshShaderFeaturesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMeshShaderFeaturesNV::GetsType) {
  _VkPhysicalDeviceMeshShaderFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceMeshShaderFeaturesNV::SetsType) {
  _VkPhysicalDeviceMeshShaderFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderFeaturesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMeshShaderFeaturesNV.sType", "Number");
  
    return;
  }
}// taskShader
NAN_GETTER(_VkPhysicalDeviceMeshShaderFeaturesNV::GettaskShader) {
  _VkPhysicalDeviceMeshShaderFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.taskShader));
}NAN_SETTER(_VkPhysicalDeviceMeshShaderFeaturesNV::SettaskShader) {
  _VkPhysicalDeviceMeshShaderFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.taskShader = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMeshShaderFeaturesNV.taskShader", "Number");
  
    return;
  }
}// meshShader
NAN_GETTER(_VkPhysicalDeviceMeshShaderFeaturesNV::GetmeshShader) {
  _VkPhysicalDeviceMeshShaderFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.meshShader));
}NAN_SETTER(_VkPhysicalDeviceMeshShaderFeaturesNV::SetmeshShader) {
  _VkPhysicalDeviceMeshShaderFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMeshShaderFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.meshShader = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMeshShaderFeaturesNV.meshShader", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceMeshShaderFeaturesNV ## **/

/** ## BEGIN VkCoarseSampleLocationNV ## **/

class _VkCoarseSampleLocationNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetpixelX);
    static NAN_SETTER(SetpixelX);
    
    static NAN_GETTER(GetpixelY);
    static NAN_SETTER(SetpixelY);
    
    static NAN_GETTER(Getsample);
    static NAN_SETTER(Setsample);
    

    // real instance
    VkCoarseSampleLocationNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCoarseSampleLocationNV();
    ~_VkCoarseSampleLocationNV();

};

/*
#include "index.h"
#include "VkCoarseSampleLocationNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCoarseSampleLocationNV::constructor;

_VkCoarseSampleLocationNV::_VkCoarseSampleLocationNV() {
  
  
}

_VkCoarseSampleLocationNV::~_VkCoarseSampleLocationNV() {
  //printf("VkCoarseSampleLocationNV deconstructed!!\n");
  
  
  
  
}

void _VkCoarseSampleLocationNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCoarseSampleLocationNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCoarseSampleLocationNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("pixelX").ToLocalChecked(), GetpixelX, SetpixelX, ctor);
  SetPrototypeAccessor(proto, Nan::New("pixelY").ToLocalChecked(), GetpixelY, SetpixelY, ctor);
  SetPrototypeAccessor(proto, Nan::New("sample").ToLocalChecked(), Getsample, Setsample, ctor);
  Nan::Set(target, Nan::New("VkCoarseSampleLocationNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCoarseSampleLocationNV::flush() {
  _VkCoarseSampleLocationNV *self = this;
  
  return true;
}

NAN_METHOD(_VkCoarseSampleLocationNV::New) {
  if (info.IsConstructCall()) {
    _VkCoarseSampleLocationNV* self = new _VkCoarseSampleLocationNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("pixelX").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("pixelY").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("sample").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCoarseSampleLocationNV constructor cannot be invoked without 'new'");
  }
};

// pixelX
NAN_GETTER(_VkCoarseSampleLocationNV::GetpixelX) {
  _VkCoarseSampleLocationNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleLocationNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pixelX));
}NAN_SETTER(_VkCoarseSampleLocationNV::SetpixelX) {
  _VkCoarseSampleLocationNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleLocationNV>(info.This());
  if (value->IsNumber()) {
    self->instance.pixelX = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleLocationNV.pixelX", "Number");
  
    return;
  }
}// pixelY
NAN_GETTER(_VkCoarseSampleLocationNV::GetpixelY) {
  _VkCoarseSampleLocationNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleLocationNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pixelY));
}NAN_SETTER(_VkCoarseSampleLocationNV::SetpixelY) {
  _VkCoarseSampleLocationNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleLocationNV>(info.This());
  if (value->IsNumber()) {
    self->instance.pixelY = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleLocationNV.pixelY", "Number");
  
    return;
  }
}// sample
NAN_GETTER(_VkCoarseSampleLocationNV::Getsample) {
  _VkCoarseSampleLocationNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleLocationNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sample));
}NAN_SETTER(_VkCoarseSampleLocationNV::Setsample) {
  _VkCoarseSampleLocationNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleLocationNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sample = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleLocationNV.sample", "Number");
  
    return;
  }
}
/** ## END VkCoarseSampleLocationNV ## **/

/** ## BEGIN VkCoarseSampleOrderCustomNV ## **/

class _VkCoarseSampleOrderCustomNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetshadingRate);
    static NAN_SETTER(SetshadingRate);
    
    static NAN_GETTER(GetsampleCount);
    static NAN_SETTER(SetsampleCount);
    
    static NAN_GETTER(GetsampleLocationCount);
    static NAN_SETTER(SetsampleLocationCount);
    
    std::vector<VkCoarseSampleLocationNV>* vpSampleLocations;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSampleLocations;
    static NAN_GETTER(GetpSampleLocations);
    static NAN_SETTER(SetpSampleLocations);
    

    // real instance
    VkCoarseSampleOrderCustomNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCoarseSampleOrderCustomNV();
    ~_VkCoarseSampleOrderCustomNV();

};

/*
#include "index.h"
#include "VkCoarseSampleOrderCustomNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCoarseSampleOrderCustomNV::constructor;

_VkCoarseSampleOrderCustomNV::_VkCoarseSampleOrderCustomNV() {
  
  vpSampleLocations = new std::vector<VkCoarseSampleLocationNV>;
  
}

_VkCoarseSampleOrderCustomNV::~_VkCoarseSampleOrderCustomNV() {
  //printf("VkCoarseSampleOrderCustomNV deconstructed!!\n");
  
  
  
  
  vpSampleLocations->clear();
  delete vpSampleLocations;
  
  pSampleLocations.Reset();
  
}

void _VkCoarseSampleOrderCustomNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCoarseSampleOrderCustomNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCoarseSampleOrderCustomNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("shadingRate").ToLocalChecked(), GetshadingRate, SetshadingRate, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleCount").ToLocalChecked(), GetsampleCount, SetsampleCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationCount").ToLocalChecked(), GetsampleLocationCount, SetsampleLocationCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSampleLocations").ToLocalChecked(), GetpSampleLocations, SetpSampleLocations, ctor);
  Nan::Set(target, Nan::New("VkCoarseSampleOrderCustomNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCoarseSampleOrderCustomNV::flush() {
  _VkCoarseSampleOrderCustomNV *self = this;
  if (!(self->pSampleLocations.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSampleLocations);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.sampleLocationCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'sampleLocationCount' for 'VkCoarseSampleOrderCustomNV.pSampleLocations'");
      return false;
    }
    std::vector<VkCoarseSampleLocationNV>* data = self->vpSampleLocations;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkCoarseSampleLocationNV::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleOrderCustomNV.pSampleLocations", "[object VkCoarseSampleLocationNV]");
  
        return false;
      }
      _VkCoarseSampleLocationNV* result = Nan::ObjectWrap::Unwrap<_VkCoarseSampleLocationNV>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSampleLocations = data->data();
  }
  return true;
}

NAN_METHOD(_VkCoarseSampleOrderCustomNV::New) {
  if (info.IsConstructCall()) {
    _VkCoarseSampleOrderCustomNV* self = new _VkCoarseSampleOrderCustomNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("shadingRate").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("sampleCount").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("sampleLocationCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pSampleLocations").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCoarseSampleOrderCustomNV constructor cannot be invoked without 'new'");
  }
};

// shadingRate
NAN_GETTER(_VkCoarseSampleOrderCustomNV::GetshadingRate) {
  _VkCoarseSampleOrderCustomNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shadingRate));
}NAN_SETTER(_VkCoarseSampleOrderCustomNV::SetshadingRate) {
  _VkCoarseSampleOrderCustomNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(info.This());
  if (value->IsNumber()) {
    self->instance.shadingRate = static_cast<VkShadingRatePaletteEntryNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleOrderCustomNV.shadingRate", "Number");
  
    return;
  }
}// sampleCount
NAN_GETTER(_VkCoarseSampleOrderCustomNV::GetsampleCount) {
  _VkCoarseSampleOrderCustomNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleCount));
}NAN_SETTER(_VkCoarseSampleOrderCustomNV::SetsampleCount) {
  _VkCoarseSampleOrderCustomNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sampleCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleOrderCustomNV.sampleCount", "Number");
  
    return;
  }
}// sampleLocationCount
NAN_GETTER(_VkCoarseSampleOrderCustomNV::GetsampleLocationCount) {
  _VkCoarseSampleOrderCustomNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleLocationCount));
}NAN_SETTER(_VkCoarseSampleOrderCustomNV::SetsampleLocationCount) {
  _VkCoarseSampleOrderCustomNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sampleLocationCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleOrderCustomNV.sampleLocationCount", "Number");
  
    return;
  }
}// pSampleLocations
NAN_GETTER(_VkCoarseSampleOrderCustomNV::GetpSampleLocations) {
  _VkCoarseSampleOrderCustomNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(info.This());
  if (self->pSampleLocations.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSampleLocations);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCoarseSampleOrderCustomNV::SetpSampleLocations) {
  _VkCoarseSampleOrderCustomNV *self = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSampleLocations.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSampleLocations.Reset();
      self->instance.pSampleLocations = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleOrderCustomNV.pSampleLocations", "[object VkCoarseSampleLocationNV]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSampleLocations = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCoarseSampleOrderCustomNV.pSampleLocations", "[object VkCoarseSampleLocationNV]");
  
    return;
  }
}
/** ## END VkCoarseSampleOrderCustomNV ## **/

/** ## BEGIN VkPipelineViewportCoarseSampleOrderStateCreateInfoNV ## **/

class _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsampleOrderType);
    static NAN_SETTER(SetsampleOrderType);
    
    static NAN_GETTER(GetcustomSampleOrderCount);
    static NAN_SETTER(SetcustomSampleOrderCount);
    
    std::vector<VkCoarseSampleOrderCustomNV>* vpCustomSampleOrders;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pCustomSampleOrders;
    static NAN_GETTER(GetpCustomSampleOrders);
    static NAN_SETTER(SetpCustomSampleOrders);
    

    // real instance
    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
    ~_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV();

};

/*
#include "index.h"
#include "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::constructor;

_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV;
  vpCustomSampleOrders = new std::vector<VkCoarseSampleOrderCustomNV>;
  
}

_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::~_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV() {
  //printf("VkPipelineViewportCoarseSampleOrderStateCreateInfoNV deconstructed!!\n");
  
  
  
  
  vpCustomSampleOrders->clear();
  delete vpCustomSampleOrders;
  
  pCustomSampleOrders.Reset();
  
}

void _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineViewportCoarseSampleOrderStateCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleOrderType").ToLocalChecked(), GetsampleOrderType, SetsampleOrderType, ctor);
  SetPrototypeAccessor(proto, Nan::New("customSampleOrderCount").ToLocalChecked(), GetcustomSampleOrderCount, SetcustomSampleOrderCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pCustomSampleOrders").ToLocalChecked(), GetpCustomSampleOrders, SetpCustomSampleOrders, ctor);
  Nan::Set(target, Nan::New("VkPipelineViewportCoarseSampleOrderStateCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::flush() {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = this;
  if (!(self->pCustomSampleOrders.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pCustomSampleOrders);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.customSampleOrderCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'customSampleOrderCount' for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders'");
      return false;
    }
    std::vector<VkCoarseSampleOrderCustomNV>* data = self->vpCustomSampleOrders;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkCoarseSampleOrderCustomNV::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders", "[object VkCoarseSampleOrderCustomNV]");
  
        return false;
      }
      _VkCoarseSampleOrderCustomNV* result = Nan::ObjectWrap::Unwrap<_VkCoarseSampleOrderCustomNV>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pCustomSampleOrders = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* self = new _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("sampleOrderType").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("customSampleOrderCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pCustomSampleOrders").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineViewportCoarseSampleOrderStateCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::GetsType) {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::SetsType) {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// sampleOrderType
NAN_GETTER(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::GetsampleOrderType) {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleOrderType));
}NAN_SETTER(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::SetsampleOrderType) {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sampleOrderType = static_cast<VkCoarseSampleOrderTypeNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sampleOrderType", "Number");
  
    return;
  }
}// customSampleOrderCount
NAN_GETTER(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::GetcustomSampleOrderCount) {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.customSampleOrderCount));
}NAN_SETTER(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::SetcustomSampleOrderCount) {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.customSampleOrderCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.customSampleOrderCount", "Number");
  
    return;
  }
}// pCustomSampleOrders
NAN_GETTER(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::GetpCustomSampleOrders) {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(info.This());
  if (self->pCustomSampleOrders.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pCustomSampleOrders);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV::SetpCustomSampleOrders) {
  _VkPipelineViewportCoarseSampleOrderStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pCustomSampleOrders.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pCustomSampleOrders.Reset();
      self->instance.pCustomSampleOrders = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders", "[object VkCoarseSampleOrderCustomNV]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pCustomSampleOrders = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders", "[object VkCoarseSampleOrderCustomNV]");
  
    return;
  }
}
/** ## END VkPipelineViewportCoarseSampleOrderStateCreateInfoNV ## **/

/** ## BEGIN VkPhysicalDeviceShadingRateImagePropertiesNV ## **/

class _VkPhysicalDeviceShadingRateImagePropertiesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> shadingRateTexelSize;
      static NAN_GETTER(GetshadingRateTexelSize);
    static NAN_GETTER(GetshadingRatePaletteSize);
    static NAN_GETTER(GetshadingRateMaxCoarseSamples);

    // real instance
    VkPhysicalDeviceShadingRateImagePropertiesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceShadingRateImagePropertiesNV();
    ~_VkPhysicalDeviceShadingRateImagePropertiesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceShadingRateImagePropertiesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceShadingRateImagePropertiesNV::constructor;

_VkPhysicalDeviceShadingRateImagePropertiesNV::_VkPhysicalDeviceShadingRateImagePropertiesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
  
}

_VkPhysicalDeviceShadingRateImagePropertiesNV::~_VkPhysicalDeviceShadingRateImagePropertiesNV() {
  //printf("VkPhysicalDeviceShadingRateImagePropertiesNV deconstructed!!\n");
  
  
  
  
  
}

void _VkPhysicalDeviceShadingRateImagePropertiesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceShadingRateImagePropertiesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceShadingRateImagePropertiesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shadingRateTexelSize").ToLocalChecked(), GetshadingRateTexelSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shadingRatePaletteSize").ToLocalChecked(), GetshadingRatePaletteSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shadingRateMaxCoarseSamples").ToLocalChecked(), GetshadingRateMaxCoarseSamples, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceShadingRateImagePropertiesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceShadingRateImagePropertiesNV::flush() {
  _VkPhysicalDeviceShadingRateImagePropertiesNV *self = this;
  if (!(self->shadingRateTexelSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->shadingRateTexelSize);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceShadingRateImagePropertiesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceShadingRateImagePropertiesNV* self = new _VkPhysicalDeviceShadingRateImagePropertiesNV();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceShadingRateImagePropertiesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceShadingRateImagePropertiesNV::GetsType) {
  _VkPhysicalDeviceShadingRateImagePropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImagePropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// shadingRateTexelSize
NAN_GETTER(_VkPhysicalDeviceShadingRateImagePropertiesNV::GetshadingRateTexelSize) {
  _VkPhysicalDeviceShadingRateImagePropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImagePropertiesNV>(info.This());
  if (self->shadingRateTexelSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->shadingRateTexelSize);
    info.GetReturnValue().Set(obj);
  }
}// shadingRatePaletteSize
NAN_GETTER(_VkPhysicalDeviceShadingRateImagePropertiesNV::GetshadingRatePaletteSize) {
  _VkPhysicalDeviceShadingRateImagePropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImagePropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shadingRatePaletteSize));
}// shadingRateMaxCoarseSamples
NAN_GETTER(_VkPhysicalDeviceShadingRateImagePropertiesNV::GetshadingRateMaxCoarseSamples) {
  _VkPhysicalDeviceShadingRateImagePropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImagePropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shadingRateMaxCoarseSamples));
}
/** ## END VkPhysicalDeviceShadingRateImagePropertiesNV ## **/

/** ## BEGIN VkPhysicalDeviceShadingRateImageFeaturesNV ## **/

class _VkPhysicalDeviceShadingRateImageFeaturesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetshadingRateImage);
    static NAN_SETTER(SetshadingRateImage);
    
    static NAN_GETTER(GetshadingRateCoarseSampleOrder);
    static NAN_SETTER(SetshadingRateCoarseSampleOrder);
    

    // real instance
    VkPhysicalDeviceShadingRateImageFeaturesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceShadingRateImageFeaturesNV();
    ~_VkPhysicalDeviceShadingRateImageFeaturesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceShadingRateImageFeaturesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceShadingRateImageFeaturesNV::constructor;

_VkPhysicalDeviceShadingRateImageFeaturesNV::_VkPhysicalDeviceShadingRateImageFeaturesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
  
}

_VkPhysicalDeviceShadingRateImageFeaturesNV::~_VkPhysicalDeviceShadingRateImageFeaturesNV() {
  //printf("VkPhysicalDeviceShadingRateImageFeaturesNV deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceShadingRateImageFeaturesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceShadingRateImageFeaturesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceShadingRateImageFeaturesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("shadingRateImage").ToLocalChecked(), GetshadingRateImage, SetshadingRateImage, ctor);
  SetPrototypeAccessor(proto, Nan::New("shadingRateCoarseSampleOrder").ToLocalChecked(), GetshadingRateCoarseSampleOrder, SetshadingRateCoarseSampleOrder, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceShadingRateImageFeaturesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceShadingRateImageFeaturesNV::flush() {
  _VkPhysicalDeviceShadingRateImageFeaturesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceShadingRateImageFeaturesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceShadingRateImageFeaturesNV* self = new _VkPhysicalDeviceShadingRateImageFeaturesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("shadingRateImage").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("shadingRateCoarseSampleOrder").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceShadingRateImageFeaturesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceShadingRateImageFeaturesNV::GetsType) {
  _VkPhysicalDeviceShadingRateImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImageFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceShadingRateImageFeaturesNV::SetsType) {
  _VkPhysicalDeviceShadingRateImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImageFeaturesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShadingRateImageFeaturesNV.sType", "Number");
  
    return;
  }
}// shadingRateImage
NAN_GETTER(_VkPhysicalDeviceShadingRateImageFeaturesNV::GetshadingRateImage) {
  _VkPhysicalDeviceShadingRateImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImageFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shadingRateImage));
}NAN_SETTER(_VkPhysicalDeviceShadingRateImageFeaturesNV::SetshadingRateImage) {
  _VkPhysicalDeviceShadingRateImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImageFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shadingRateImage = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShadingRateImageFeaturesNV.shadingRateImage", "Number");
  
    return;
  }
}// shadingRateCoarseSampleOrder
NAN_GETTER(_VkPhysicalDeviceShadingRateImageFeaturesNV::GetshadingRateCoarseSampleOrder) {
  _VkPhysicalDeviceShadingRateImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImageFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shadingRateCoarseSampleOrder));
}NAN_SETTER(_VkPhysicalDeviceShadingRateImageFeaturesNV::SetshadingRateCoarseSampleOrder) {
  _VkPhysicalDeviceShadingRateImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShadingRateImageFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shadingRateCoarseSampleOrder = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShadingRateImageFeaturesNV.shadingRateCoarseSampleOrder", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceShadingRateImageFeaturesNV ## **/

/** ## BEGIN VkShadingRatePaletteNV ## **/

class _VkShadingRatePaletteNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetshadingRatePaletteEntryCount);
    static NAN_SETTER(SetshadingRatePaletteEntryCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pShadingRatePaletteEntries;
    static NAN_GETTER(GetpShadingRatePaletteEntries);
    static NAN_SETTER(SetpShadingRatePaletteEntries);
    

    // real instance
    VkShadingRatePaletteNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkShadingRatePaletteNV();
    ~_VkShadingRatePaletteNV();

};

/*
#include "index.h"
#include "VkShadingRatePaletteNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkShadingRatePaletteNV::constructor;

_VkShadingRatePaletteNV::_VkShadingRatePaletteNV() {
  
  
}

_VkShadingRatePaletteNV::~_VkShadingRatePaletteNV() {
  //printf("VkShadingRatePaletteNV deconstructed!!\n");
  
  
  pShadingRatePaletteEntries.Reset();
  
}

void _VkShadingRatePaletteNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkShadingRatePaletteNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkShadingRatePaletteNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("shadingRatePaletteEntryCount").ToLocalChecked(), GetshadingRatePaletteEntryCount, SetshadingRatePaletteEntryCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pShadingRatePaletteEntries").ToLocalChecked(), GetpShadingRatePaletteEntries, SetpShadingRatePaletteEntries, ctor);
  Nan::Set(target, Nan::New("VkShadingRatePaletteNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkShadingRatePaletteNV::flush() {
  _VkShadingRatePaletteNV *self = this;
  
  return true;
}

NAN_METHOD(_VkShadingRatePaletteNV::New) {
  if (info.IsConstructCall()) {
    _VkShadingRatePaletteNV* self = new _VkShadingRatePaletteNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("shadingRatePaletteEntryCount").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("pShadingRatePaletteEntries").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkShadingRatePaletteNV constructor cannot be invoked without 'new'");
  }
};

// shadingRatePaletteEntryCount
NAN_GETTER(_VkShadingRatePaletteNV::GetshadingRatePaletteEntryCount) {
  _VkShadingRatePaletteNV *self = Nan::ObjectWrap::Unwrap<_VkShadingRatePaletteNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shadingRatePaletteEntryCount));
}NAN_SETTER(_VkShadingRatePaletteNV::SetshadingRatePaletteEntryCount) {
  _VkShadingRatePaletteNV *self = Nan::ObjectWrap::Unwrap<_VkShadingRatePaletteNV>(info.This());
  if (value->IsNumber()) {
    self->instance.shadingRatePaletteEntryCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkShadingRatePaletteNV.shadingRatePaletteEntryCount", "Number");
  
    return;
  }
}// pShadingRatePaletteEntries
NAN_GETTER(_VkShadingRatePaletteNV::GetpShadingRatePaletteEntries) {
  _VkShadingRatePaletteNV *self = Nan::ObjectWrap::Unwrap<_VkShadingRatePaletteNV>(info.This());
  if (self->pShadingRatePaletteEntries.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pShadingRatePaletteEntries);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkShadingRatePaletteNV::SetpShadingRatePaletteEntries) {
  _VkShadingRatePaletteNV *self = Nan::ObjectWrap::Unwrap<_VkShadingRatePaletteNV>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pShadingRatePaletteEntries.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkShadingRatePaletteNV.pShadingRatePaletteEntries", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pShadingRatePaletteEntries.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkShadingRatePaletteNV.pShadingRatePaletteEntries", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pShadingRatePaletteEntries = reinterpret_cast<const VkShadingRatePaletteEntryNV *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pShadingRatePaletteEntries = nullptr;
  }
}
/** ## END VkShadingRatePaletteNV ## **/

/** ## BEGIN VkPipelineViewportShadingRateImageStateCreateInfoNV ## **/

class _VkPipelineViewportShadingRateImageStateCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetshadingRateImageEnable);
    static NAN_SETTER(SetshadingRateImageEnable);
    
    static NAN_GETTER(GetviewportCount);
    static NAN_SETTER(SetviewportCount);
    
    std::vector<VkShadingRatePaletteNV>* vpShadingRatePalettes;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pShadingRatePalettes;
    static NAN_GETTER(GetpShadingRatePalettes);
    static NAN_SETTER(SetpShadingRatePalettes);
    

    // real instance
    VkPipelineViewportShadingRateImageStateCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineViewportShadingRateImageStateCreateInfoNV();
    ~_VkPipelineViewportShadingRateImageStateCreateInfoNV();

};

/*
#include "index.h"
#include "VkPipelineViewportShadingRateImageStateCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineViewportShadingRateImageStateCreateInfoNV::constructor;

_VkPipelineViewportShadingRateImageStateCreateInfoNV::_VkPipelineViewportShadingRateImageStateCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV;
  vpShadingRatePalettes = new std::vector<VkShadingRatePaletteNV>;
  
}

_VkPipelineViewportShadingRateImageStateCreateInfoNV::~_VkPipelineViewportShadingRateImageStateCreateInfoNV() {
  //printf("VkPipelineViewportShadingRateImageStateCreateInfoNV deconstructed!!\n");
  
  
  
  
  vpShadingRatePalettes->clear();
  delete vpShadingRatePalettes;
  
  pShadingRatePalettes.Reset();
  
}

void _VkPipelineViewportShadingRateImageStateCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineViewportShadingRateImageStateCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineViewportShadingRateImageStateCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("shadingRateImageEnable").ToLocalChecked(), GetshadingRateImageEnable, SetshadingRateImageEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewportCount").ToLocalChecked(), GetviewportCount, SetviewportCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pShadingRatePalettes").ToLocalChecked(), GetpShadingRatePalettes, SetpShadingRatePalettes, ctor);
  Nan::Set(target, Nan::New("VkPipelineViewportShadingRateImageStateCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineViewportShadingRateImageStateCreateInfoNV::flush() {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = this;
  if (!(self->pShadingRatePalettes.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pShadingRatePalettes);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.viewportCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'viewportCount' for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes'");
      return false;
    }
    std::vector<VkShadingRatePaletteNV>* data = self->vpShadingRatePalettes;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkShadingRatePaletteNV::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes", "[object VkShadingRatePaletteNV]");
  
        return false;
      }
      _VkShadingRatePaletteNV* result = Nan::ObjectWrap::Unwrap<_VkShadingRatePaletteNV>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pShadingRatePalettes = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineViewportShadingRateImageStateCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkPipelineViewportShadingRateImageStateCreateInfoNV* self = new _VkPipelineViewportShadingRateImageStateCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("shadingRateImageEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("viewportCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pShadingRatePalettes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineViewportShadingRateImageStateCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineViewportShadingRateImageStateCreateInfoNV::GetsType) {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportShadingRateImageStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineViewportShadingRateImageStateCreateInfoNV::SetsType) {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportShadingRateImageStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportShadingRateImageStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// shadingRateImageEnable
NAN_GETTER(_VkPipelineViewportShadingRateImageStateCreateInfoNV::GetshadingRateImageEnable) {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportShadingRateImageStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shadingRateImageEnable));
}NAN_SETTER(_VkPipelineViewportShadingRateImageStateCreateInfoNV::SetshadingRateImageEnable) {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportShadingRateImageStateCreateInfoNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shadingRateImageEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportShadingRateImageStateCreateInfoNV.shadingRateImageEnable", "Number");
  
    return;
  }
}// viewportCount
NAN_GETTER(_VkPipelineViewportShadingRateImageStateCreateInfoNV::GetviewportCount) {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportShadingRateImageStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewportCount));
}NAN_SETTER(_VkPipelineViewportShadingRateImageStateCreateInfoNV::SetviewportCount) {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportShadingRateImageStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.viewportCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportShadingRateImageStateCreateInfoNV.viewportCount", "Number");
  
    return;
  }
}// pShadingRatePalettes
NAN_GETTER(_VkPipelineViewportShadingRateImageStateCreateInfoNV::GetpShadingRatePalettes) {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportShadingRateImageStateCreateInfoNV>(info.This());
  if (self->pShadingRatePalettes.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pShadingRatePalettes);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineViewportShadingRateImageStateCreateInfoNV::SetpShadingRatePalettes) {
  _VkPipelineViewportShadingRateImageStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportShadingRateImageStateCreateInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pShadingRatePalettes.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pShadingRatePalettes.Reset();
      self->instance.pShadingRatePalettes = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes", "[object VkShadingRatePaletteNV]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pShadingRatePalettes = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes", "[object VkShadingRatePaletteNV]");
  
    return;
  }
}
/** ## END VkPipelineViewportShadingRateImageStateCreateInfoNV ## **/

/** ## BEGIN VkPhysicalDeviceShaderImageFootprintFeaturesNV ## **/

class _VkPhysicalDeviceShaderImageFootprintFeaturesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetimageFootprint);
    static NAN_SETTER(SetimageFootprint);
    

    // real instance
    VkPhysicalDeviceShaderImageFootprintFeaturesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceShaderImageFootprintFeaturesNV();
    ~_VkPhysicalDeviceShaderImageFootprintFeaturesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceShaderImageFootprintFeaturesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceShaderImageFootprintFeaturesNV::constructor;

_VkPhysicalDeviceShaderImageFootprintFeaturesNV::_VkPhysicalDeviceShaderImageFootprintFeaturesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
  
}

_VkPhysicalDeviceShaderImageFootprintFeaturesNV::~_VkPhysicalDeviceShaderImageFootprintFeaturesNV() {
  //printf("VkPhysicalDeviceShaderImageFootprintFeaturesNV deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceShaderImageFootprintFeaturesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceShaderImageFootprintFeaturesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceShaderImageFootprintFeaturesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageFootprint").ToLocalChecked(), GetimageFootprint, SetimageFootprint, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceShaderImageFootprintFeaturesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceShaderImageFootprintFeaturesNV::flush() {
  _VkPhysicalDeviceShaderImageFootprintFeaturesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceShaderImageFootprintFeaturesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceShaderImageFootprintFeaturesNV* self = new _VkPhysicalDeviceShaderImageFootprintFeaturesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("imageFootprint").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceShaderImageFootprintFeaturesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceShaderImageFootprintFeaturesNV::GetsType) {
  _VkPhysicalDeviceShaderImageFootprintFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderImageFootprintFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceShaderImageFootprintFeaturesNV::SetsType) {
  _VkPhysicalDeviceShaderImageFootprintFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderImageFootprintFeaturesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShaderImageFootprintFeaturesNV.sType", "Number");
  
    return;
  }
}// imageFootprint
NAN_GETTER(_VkPhysicalDeviceShaderImageFootprintFeaturesNV::GetimageFootprint) {
  _VkPhysicalDeviceShaderImageFootprintFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderImageFootprintFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageFootprint));
}NAN_SETTER(_VkPhysicalDeviceShaderImageFootprintFeaturesNV::SetimageFootprint) {
  _VkPhysicalDeviceShaderImageFootprintFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderImageFootprintFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.imageFootprint = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShaderImageFootprintFeaturesNV.imageFootprint", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceShaderImageFootprintFeaturesNV ## **/

/** ## BEGIN VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV ## **/

class _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetfragmentShaderBarycentric);
    static NAN_SETTER(SetfragmentShaderBarycentric);
    

    // real instance
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV();
    ~_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::constructor;

_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV;
  
}

_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::~_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV() {
  //printf("VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fragmentShaderBarycentric").ToLocalChecked(), GetfragmentShaderBarycentric, SetfragmentShaderBarycentric, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::flush() {
  _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV* self = new _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("fragmentShaderBarycentric").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::GetsType) {
  _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::SetsType) {
  _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.sType", "Number");
  
    return;
  }
}// fragmentShaderBarycentric
NAN_GETTER(_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::GetfragmentShaderBarycentric) {
  _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fragmentShaderBarycentric));
}NAN_SETTER(_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV::SetfragmentShaderBarycentric) {
  _VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.fragmentShaderBarycentric = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.fragmentShaderBarycentric", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV ## **/

/** ## BEGIN VkPhysicalDeviceComputeShaderDerivativesFeaturesNV ## **/

class _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetcomputeDerivativeGroupQuads);
    static NAN_SETTER(SetcomputeDerivativeGroupQuads);
    
    static NAN_GETTER(GetcomputeDerivativeGroupLinear);
    static NAN_SETTER(SetcomputeDerivativeGroupLinear);
    

    // real instance
    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV();
    ~_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::constructor;

_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
  
}

_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::~_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV() {
  //printf("VkPhysicalDeviceComputeShaderDerivativesFeaturesNV deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceComputeShaderDerivativesFeaturesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("computeDerivativeGroupQuads").ToLocalChecked(), GetcomputeDerivativeGroupQuads, SetcomputeDerivativeGroupQuads, ctor);
  SetPrototypeAccessor(proto, Nan::New("computeDerivativeGroupLinear").ToLocalChecked(), GetcomputeDerivativeGroupLinear, SetcomputeDerivativeGroupLinear, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceComputeShaderDerivativesFeaturesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::flush() {
  _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* self = new _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("computeDerivativeGroupQuads").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("computeDerivativeGroupLinear").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceComputeShaderDerivativesFeaturesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::GetsType) {
  _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::SetsType) {
  _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.sType", "Number");
  
    return;
  }
}// computeDerivativeGroupQuads
NAN_GETTER(_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::GetcomputeDerivativeGroupQuads) {
  _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.computeDerivativeGroupQuads));
}NAN_SETTER(_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::SetcomputeDerivativeGroupQuads) {
  _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.computeDerivativeGroupQuads = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.computeDerivativeGroupQuads", "Number");
  
    return;
  }
}// computeDerivativeGroupLinear
NAN_GETTER(_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::GetcomputeDerivativeGroupLinear) {
  _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.computeDerivativeGroupLinear));
}NAN_SETTER(_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV::SetcomputeDerivativeGroupLinear) {
  _VkPhysicalDeviceComputeShaderDerivativesFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.computeDerivativeGroupLinear = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.computeDerivativeGroupLinear", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceComputeShaderDerivativesFeaturesNV ## **/

/** ## BEGIN VkPhysicalDeviceCornerSampledImageFeaturesNV ## **/

class _VkPhysicalDeviceCornerSampledImageFeaturesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetcornerSampledImage);
    static NAN_SETTER(SetcornerSampledImage);
    

    // real instance
    VkPhysicalDeviceCornerSampledImageFeaturesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceCornerSampledImageFeaturesNV();
    ~_VkPhysicalDeviceCornerSampledImageFeaturesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceCornerSampledImageFeaturesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceCornerSampledImageFeaturesNV::constructor;

_VkPhysicalDeviceCornerSampledImageFeaturesNV::_VkPhysicalDeviceCornerSampledImageFeaturesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
  
}

_VkPhysicalDeviceCornerSampledImageFeaturesNV::~_VkPhysicalDeviceCornerSampledImageFeaturesNV() {
  //printf("VkPhysicalDeviceCornerSampledImageFeaturesNV deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceCornerSampledImageFeaturesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceCornerSampledImageFeaturesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceCornerSampledImageFeaturesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("cornerSampledImage").ToLocalChecked(), GetcornerSampledImage, SetcornerSampledImage, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceCornerSampledImageFeaturesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceCornerSampledImageFeaturesNV::flush() {
  _VkPhysicalDeviceCornerSampledImageFeaturesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceCornerSampledImageFeaturesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceCornerSampledImageFeaturesNV* self = new _VkPhysicalDeviceCornerSampledImageFeaturesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("cornerSampledImage").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceCornerSampledImageFeaturesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceCornerSampledImageFeaturesNV::GetsType) {
  _VkPhysicalDeviceCornerSampledImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceCornerSampledImageFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceCornerSampledImageFeaturesNV::SetsType) {
  _VkPhysicalDeviceCornerSampledImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceCornerSampledImageFeaturesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceCornerSampledImageFeaturesNV.sType", "Number");
  
    return;
  }
}// cornerSampledImage
NAN_GETTER(_VkPhysicalDeviceCornerSampledImageFeaturesNV::GetcornerSampledImage) {
  _VkPhysicalDeviceCornerSampledImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceCornerSampledImageFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.cornerSampledImage));
}NAN_SETTER(_VkPhysicalDeviceCornerSampledImageFeaturesNV::SetcornerSampledImage) {
  _VkPhysicalDeviceCornerSampledImageFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceCornerSampledImageFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.cornerSampledImage = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceCornerSampledImageFeaturesNV.cornerSampledImage", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceCornerSampledImageFeaturesNV ## **/

/** ## BEGIN VkOffset2D ## **/

class _VkOffset2D: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getx);
    static NAN_SETTER(Setx);
    
    static NAN_GETTER(Gety);
    static NAN_SETTER(Sety);
    

    // real instance
    VkOffset2D instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkOffset2D();
    ~_VkOffset2D();

};

/*
#include "index.h"
#include "VkOffset2D.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkOffset2D::constructor;

_VkOffset2D::_VkOffset2D() {
  
  
}

_VkOffset2D::~_VkOffset2D() {
  //printf("VkOffset2D deconstructed!!\n");
  
  
  
}

void _VkOffset2D::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkOffset2D::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkOffset2D").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("x").ToLocalChecked(), Getx, Setx, ctor);
  SetPrototypeAccessor(proto, Nan::New("y").ToLocalChecked(), Gety, Sety, ctor);
  Nan::Set(target, Nan::New("VkOffset2D").ToLocalChecked(), ctor->GetFunction());
}

bool _VkOffset2D::flush() {
  _VkOffset2D *self = this;
  
  return true;
}

NAN_METHOD(_VkOffset2D::New) {
  if (info.IsConstructCall()) {
    _VkOffset2D* self = new _VkOffset2D();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("x").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("y").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkOffset2D constructor cannot be invoked without 'new'");
  }
};

// x
NAN_GETTER(_VkOffset2D::Getx) {
  _VkOffset2D *self = Nan::ObjectWrap::Unwrap<_VkOffset2D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.x));
}NAN_SETTER(_VkOffset2D::Setx) {
  _VkOffset2D *self = Nan::ObjectWrap::Unwrap<_VkOffset2D>(info.This());
  if (value->IsNumber()) {
    self->instance.x = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkOffset2D.x", "Number");
  
    return;
  }
}// y
NAN_GETTER(_VkOffset2D::Gety) {
  _VkOffset2D *self = Nan::ObjectWrap::Unwrap<_VkOffset2D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.y));
}NAN_SETTER(_VkOffset2D::Sety) {
  _VkOffset2D *self = Nan::ObjectWrap::Unwrap<_VkOffset2D>(info.This());
  if (value->IsNumber()) {
    self->instance.y = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkOffset2D.y", "Number");
  
    return;
  }
}
/** ## END VkOffset2D ## **/

/** ## BEGIN VkRect2D ## **/

class _VkRect2D: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> offset;
      static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> extent;
      static NAN_GETTER(Getextent);
    static NAN_SETTER(Setextent);
    

    // real instance
    VkRect2D instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRect2D();
    ~_VkRect2D();

};

/*
#include "index.h"
#include "VkRect2D.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRect2D::constructor;

_VkRect2D::_VkRect2D() {
  
  
}

_VkRect2D::~_VkRect2D() {
  //printf("VkRect2D deconstructed!!\n");
  
  
  
}

void _VkRect2D::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRect2D::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRect2D").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("extent").ToLocalChecked(), Getextent, Setextent, ctor);
  Nan::Set(target, Nan::New("VkRect2D").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRect2D::flush() {
  _VkRect2D *self = this;
  if (!(self->offset.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->offset);
    
    _VkOffset2D* result = Nan::ObjectWrap::Unwrap<_VkOffset2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.offset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->extent);
    
    _VkExtent2D* result = Nan::ObjectWrap::Unwrap<_VkExtent2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkRect2D::New) {
  if (info.IsConstructCall()) {
    _VkRect2D* self = new _VkRect2D();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("extent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRect2D constructor cannot be invoked without 'new'");
  }
};

// offset
NAN_GETTER(_VkRect2D::Getoffset) {
  _VkRect2D *self = Nan::ObjectWrap::Unwrap<_VkRect2D>(info.This());
  if (self->offset.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->offset);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRect2D::Setoffset) {
  _VkRect2D *self = Nan::ObjectWrap::Unwrap<_VkRect2D>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkOffset2D::constructor)->HasInstance(obj)) {
      self->offset.Reset<v8::Object>(value.As<v8::Object>());
      _VkOffset2D* inst = Nan::ObjectWrap::Unwrap<_VkOffset2D>(obj);
      inst->flush();
      self->instance.offset = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRect2D.offset", "[object VkOffset2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->offset.Reset();
    memset(&self->instance.offset, 0, sizeof(VkOffset2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRect2D.offset", "[object VkOffset2D]");
  
    return;
  }
}// extent
NAN_GETTER(_VkRect2D::Getextent) {
  _VkRect2D *self = Nan::ObjectWrap::Unwrap<_VkRect2D>(info.This());
  if (self->extent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->extent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRect2D::Setextent) {
  _VkRect2D *self = Nan::ObjectWrap::Unwrap<_VkRect2D>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent2D::constructor)->HasInstance(obj)) {
      self->extent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent2D* inst = Nan::ObjectWrap::Unwrap<_VkExtent2D>(obj);
      inst->flush();
      self->instance.extent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRect2D.extent", "[object VkExtent2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->extent.Reset();
    memset(&self->instance.extent, 0, sizeof(VkExtent2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRect2D.extent", "[object VkExtent2D]");
  
    return;
  }
}
/** ## END VkRect2D ## **/

/** ## BEGIN VkPipelineViewportExclusiveScissorStateCreateInfoNV ## **/

class _VkPipelineViewportExclusiveScissorStateCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetexclusiveScissorCount);
    static NAN_SETTER(SetexclusiveScissorCount);
    
    std::vector<VkRect2D>* vpExclusiveScissors;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pExclusiveScissors;
    static NAN_GETTER(GetpExclusiveScissors);
    static NAN_SETTER(SetpExclusiveScissors);
    

    // real instance
    VkPipelineViewportExclusiveScissorStateCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineViewportExclusiveScissorStateCreateInfoNV();
    ~_VkPipelineViewportExclusiveScissorStateCreateInfoNV();

};

/*
#include "index.h"
#include "VkPipelineViewportExclusiveScissorStateCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineViewportExclusiveScissorStateCreateInfoNV::constructor;

_VkPipelineViewportExclusiveScissorStateCreateInfoNV::_VkPipelineViewportExclusiveScissorStateCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV;
  vpExclusiveScissors = new std::vector<VkRect2D>;
  
}

_VkPipelineViewportExclusiveScissorStateCreateInfoNV::~_VkPipelineViewportExclusiveScissorStateCreateInfoNV() {
  //printf("VkPipelineViewportExclusiveScissorStateCreateInfoNV deconstructed!!\n");
  
  
  
  vpExclusiveScissors->clear();
  delete vpExclusiveScissors;
  
  pExclusiveScissors.Reset();
  
}

void _VkPipelineViewportExclusiveScissorStateCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineViewportExclusiveScissorStateCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineViewportExclusiveScissorStateCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("exclusiveScissorCount").ToLocalChecked(), GetexclusiveScissorCount, SetexclusiveScissorCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pExclusiveScissors").ToLocalChecked(), GetpExclusiveScissors, SetpExclusiveScissors, ctor);
  Nan::Set(target, Nan::New("VkPipelineViewportExclusiveScissorStateCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineViewportExclusiveScissorStateCreateInfoNV::flush() {
  _VkPipelineViewportExclusiveScissorStateCreateInfoNV *self = this;
  if (!(self->pExclusiveScissors.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pExclusiveScissors);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.exclusiveScissorCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'exclusiveScissorCount' for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors'");
      return false;
    }
    std::vector<VkRect2D>* data = self->vpExclusiveScissors;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkRect2D::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pExclusiveScissors = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineViewportExclusiveScissorStateCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkPipelineViewportExclusiveScissorStateCreateInfoNV* self = new _VkPipelineViewportExclusiveScissorStateCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("exclusiveScissorCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pExclusiveScissors").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineViewportExclusiveScissorStateCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineViewportExclusiveScissorStateCreateInfoNV::GetsType) {
  _VkPipelineViewportExclusiveScissorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineViewportExclusiveScissorStateCreateInfoNV::SetsType) {
  _VkPipelineViewportExclusiveScissorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportExclusiveScissorStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// exclusiveScissorCount
NAN_GETTER(_VkPipelineViewportExclusiveScissorStateCreateInfoNV::GetexclusiveScissorCount) {
  _VkPipelineViewportExclusiveScissorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.exclusiveScissorCount));
}NAN_SETTER(_VkPipelineViewportExclusiveScissorStateCreateInfoNV::SetexclusiveScissorCount) {
  _VkPipelineViewportExclusiveScissorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.exclusiveScissorCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportExclusiveScissorStateCreateInfoNV.exclusiveScissorCount", "Number");
  
    return;
  }
}// pExclusiveScissors
NAN_GETTER(_VkPipelineViewportExclusiveScissorStateCreateInfoNV::GetpExclusiveScissors) {
  _VkPipelineViewportExclusiveScissorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(info.This());
  if (self->pExclusiveScissors.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pExclusiveScissors);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineViewportExclusiveScissorStateCreateInfoNV::SetpExclusiveScissors) {
  _VkPipelineViewportExclusiveScissorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportExclusiveScissorStateCreateInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pExclusiveScissors.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pExclusiveScissors.Reset();
      self->instance.pExclusiveScissors = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pExclusiveScissors = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkPipelineViewportExclusiveScissorStateCreateInfoNV ## **/

/** ## BEGIN VkPhysicalDeviceExclusiveScissorFeaturesNV ## **/

class _VkPhysicalDeviceExclusiveScissorFeaturesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetexclusiveScissor);
    static NAN_SETTER(SetexclusiveScissor);
    

    // real instance
    VkPhysicalDeviceExclusiveScissorFeaturesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExclusiveScissorFeaturesNV();
    ~_VkPhysicalDeviceExclusiveScissorFeaturesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExclusiveScissorFeaturesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExclusiveScissorFeaturesNV::constructor;

_VkPhysicalDeviceExclusiveScissorFeaturesNV::_VkPhysicalDeviceExclusiveScissorFeaturesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
  
}

_VkPhysicalDeviceExclusiveScissorFeaturesNV::~_VkPhysicalDeviceExclusiveScissorFeaturesNV() {
  //printf("VkPhysicalDeviceExclusiveScissorFeaturesNV deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceExclusiveScissorFeaturesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExclusiveScissorFeaturesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExclusiveScissorFeaturesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("exclusiveScissor").ToLocalChecked(), GetexclusiveScissor, SetexclusiveScissor, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceExclusiveScissorFeaturesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExclusiveScissorFeaturesNV::flush() {
  _VkPhysicalDeviceExclusiveScissorFeaturesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExclusiveScissorFeaturesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExclusiveScissorFeaturesNV* self = new _VkPhysicalDeviceExclusiveScissorFeaturesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("exclusiveScissor").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExclusiveScissorFeaturesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceExclusiveScissorFeaturesNV::GetsType) {
  _VkPhysicalDeviceExclusiveScissorFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExclusiveScissorFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceExclusiveScissorFeaturesNV::SetsType) {
  _VkPhysicalDeviceExclusiveScissorFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExclusiveScissorFeaturesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExclusiveScissorFeaturesNV.sType", "Number");
  
    return;
  }
}// exclusiveScissor
NAN_GETTER(_VkPhysicalDeviceExclusiveScissorFeaturesNV::GetexclusiveScissor) {
  _VkPhysicalDeviceExclusiveScissorFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExclusiveScissorFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.exclusiveScissor));
}NAN_SETTER(_VkPhysicalDeviceExclusiveScissorFeaturesNV::SetexclusiveScissor) {
  _VkPhysicalDeviceExclusiveScissorFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExclusiveScissorFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.exclusiveScissor = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExclusiveScissorFeaturesNV.exclusiveScissor", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExclusiveScissorFeaturesNV ## **/

/** ## BEGIN VkPipelineRepresentativeFragmentTestStateCreateInfoNV ## **/

class _VkPipelineRepresentativeFragmentTestStateCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetrepresentativeFragmentTestEnable);
    static NAN_SETTER(SetrepresentativeFragmentTestEnable);
    

    // real instance
    VkPipelineRepresentativeFragmentTestStateCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineRepresentativeFragmentTestStateCreateInfoNV();
    ~_VkPipelineRepresentativeFragmentTestStateCreateInfoNV();

};

/*
#include "index.h"
#include "VkPipelineRepresentativeFragmentTestStateCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineRepresentativeFragmentTestStateCreateInfoNV::constructor;

_VkPipelineRepresentativeFragmentTestStateCreateInfoNV::_VkPipelineRepresentativeFragmentTestStateCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV;
  
}

_VkPipelineRepresentativeFragmentTestStateCreateInfoNV::~_VkPipelineRepresentativeFragmentTestStateCreateInfoNV() {
  //printf("VkPipelineRepresentativeFragmentTestStateCreateInfoNV deconstructed!!\n");
  
  
  
}

void _VkPipelineRepresentativeFragmentTestStateCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineRepresentativeFragmentTestStateCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineRepresentativeFragmentTestStateCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("representativeFragmentTestEnable").ToLocalChecked(), GetrepresentativeFragmentTestEnable, SetrepresentativeFragmentTestEnable, ctor);
  Nan::Set(target, Nan::New("VkPipelineRepresentativeFragmentTestStateCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineRepresentativeFragmentTestStateCreateInfoNV::flush() {
  _VkPipelineRepresentativeFragmentTestStateCreateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineRepresentativeFragmentTestStateCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkPipelineRepresentativeFragmentTestStateCreateInfoNV* self = new _VkPipelineRepresentativeFragmentTestStateCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("representativeFragmentTestEnable").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineRepresentativeFragmentTestStateCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineRepresentativeFragmentTestStateCreateInfoNV::GetsType) {
  _VkPipelineRepresentativeFragmentTestStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineRepresentativeFragmentTestStateCreateInfoNV::SetsType) {
  _VkPipelineRepresentativeFragmentTestStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRepresentativeFragmentTestStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// representativeFragmentTestEnable
NAN_GETTER(_VkPipelineRepresentativeFragmentTestStateCreateInfoNV::GetrepresentativeFragmentTestEnable) {
  _VkPipelineRepresentativeFragmentTestStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.representativeFragmentTestEnable));
}NAN_SETTER(_VkPipelineRepresentativeFragmentTestStateCreateInfoNV::SetrepresentativeFragmentTestEnable) {
  _VkPipelineRepresentativeFragmentTestStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.representativeFragmentTestEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRepresentativeFragmentTestStateCreateInfoNV.representativeFragmentTestEnable", "Number");
  
    return;
  }
}
/** ## END VkPipelineRepresentativeFragmentTestStateCreateInfoNV ## **/

/** ## BEGIN VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV ## **/

class _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetrepresentativeFragmentTest);
    static NAN_SETTER(SetrepresentativeFragmentTest);
    

    // real instance
    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
    ~_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();

};

/*
#include "index.h"
#include "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::constructor;

_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
  
}

_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::~_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV() {
  //printf("VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("representativeFragmentTest").ToLocalChecked(), GetrepresentativeFragmentTest, SetrepresentativeFragmentTest, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::flush() {
  _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* self = new _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("representativeFragmentTest").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::GetsType) {
  _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::SetsType) {
  _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.sType", "Number");
  
    return;
  }
}// representativeFragmentTest
NAN_GETTER(_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::GetrepresentativeFragmentTest) {
  _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.representativeFragmentTest));
}NAN_SETTER(_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV::SetrepresentativeFragmentTest) {
  _VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.representativeFragmentTest = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.representativeFragmentTest", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV ## **/

/** ## BEGIN VkPipelineRasterizationStateStreamCreateInfoEXT ## **/

class _VkPipelineRasterizationStateStreamCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetrasterizationStream);
    static NAN_SETTER(SetrasterizationStream);
    

    // real instance
    VkPipelineRasterizationStateStreamCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineRasterizationStateStreamCreateInfoEXT();
    ~_VkPipelineRasterizationStateStreamCreateInfoEXT();

};

/*
#include "index.h"
#include "VkPipelineRasterizationStateStreamCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineRasterizationStateStreamCreateInfoEXT::constructor;

_VkPipelineRasterizationStateStreamCreateInfoEXT::_VkPipelineRasterizationStateStreamCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT;
  
}

_VkPipelineRasterizationStateStreamCreateInfoEXT::~_VkPipelineRasterizationStateStreamCreateInfoEXT() {
  //printf("VkPipelineRasterizationStateStreamCreateInfoEXT deconstructed!!\n");
  
  
  
  
}

void _VkPipelineRasterizationStateStreamCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineRasterizationStateStreamCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineRasterizationStateStreamCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("rasterizationStream").ToLocalChecked(), GetrasterizationStream, SetrasterizationStream, ctor);
  Nan::Set(target, Nan::New("VkPipelineRasterizationStateStreamCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineRasterizationStateStreamCreateInfoEXT::flush() {
  _VkPipelineRasterizationStateStreamCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineRasterizationStateStreamCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkPipelineRasterizationStateStreamCreateInfoEXT* self = new _VkPipelineRasterizationStateStreamCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("rasterizationStream").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineRasterizationStateStreamCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineRasterizationStateStreamCreateInfoEXT::GetsType) {
  _VkPipelineRasterizationStateStreamCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateStreamCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineRasterizationStateStreamCreateInfoEXT::SetsType) {
  _VkPipelineRasterizationStateStreamCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateStreamCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateStreamCreateInfoEXT.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineRasterizationStateStreamCreateInfoEXT::Getflags) {
  _VkPipelineRasterizationStateStreamCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateStreamCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineRasterizationStateStreamCreateInfoEXT::Setflags) {
  _VkPipelineRasterizationStateStreamCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateStreamCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineRasterizationStateStreamCreateFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateStreamCreateInfoEXT.flags", "Number");
  
    return;
  }
}// rasterizationStream
NAN_GETTER(_VkPipelineRasterizationStateStreamCreateInfoEXT::GetrasterizationStream) {
  _VkPipelineRasterizationStateStreamCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateStreamCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.rasterizationStream));
}NAN_SETTER(_VkPipelineRasterizationStateStreamCreateInfoEXT::SetrasterizationStream) {
  _VkPipelineRasterizationStateStreamCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateStreamCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.rasterizationStream = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateStreamCreateInfoEXT.rasterizationStream", "Number");
  
    return;
  }
}
/** ## END VkPipelineRasterizationStateStreamCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceTransformFeedbackPropertiesEXT ## **/

class _VkPhysicalDeviceTransformFeedbackPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxTransformFeedbackStreams);
    static NAN_GETTER(GetmaxTransformFeedbackBuffers);
    static NAN_GETTER(GetmaxTransformFeedbackBufferSize);
    static NAN_GETTER(GetmaxTransformFeedbackStreamDataSize);
    static NAN_GETTER(GetmaxTransformFeedbackBufferDataSize);
    static NAN_GETTER(GetmaxTransformFeedbackBufferDataStride);
    static NAN_GETTER(GettransformFeedbackQueries);
    static NAN_GETTER(GettransformFeedbackStreamsLinesTriangles);
    static NAN_GETTER(GettransformFeedbackRasterizationStreamSelect);
    static NAN_GETTER(GettransformFeedbackDraw);

    // real instance
    VkPhysicalDeviceTransformFeedbackPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceTransformFeedbackPropertiesEXT();
    ~_VkPhysicalDeviceTransformFeedbackPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceTransformFeedbackPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceTransformFeedbackPropertiesEXT::constructor;

_VkPhysicalDeviceTransformFeedbackPropertiesEXT::_VkPhysicalDeviceTransformFeedbackPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceTransformFeedbackPropertiesEXT::~_VkPhysicalDeviceTransformFeedbackPropertiesEXT() {
  //printf("VkPhysicalDeviceTransformFeedbackPropertiesEXT deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceTransformFeedbackPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceTransformFeedbackPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTransformFeedbackStreams").ToLocalChecked(), GetmaxTransformFeedbackStreams, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTransformFeedbackBuffers").ToLocalChecked(), GetmaxTransformFeedbackBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTransformFeedbackBufferSize").ToLocalChecked(), GetmaxTransformFeedbackBufferSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTransformFeedbackStreamDataSize").ToLocalChecked(), GetmaxTransformFeedbackStreamDataSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTransformFeedbackBufferDataSize").ToLocalChecked(), GetmaxTransformFeedbackBufferDataSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTransformFeedbackBufferDataStride").ToLocalChecked(), GetmaxTransformFeedbackBufferDataStride, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("transformFeedbackQueries").ToLocalChecked(), GettransformFeedbackQueries, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("transformFeedbackStreamsLinesTriangles").ToLocalChecked(), GettransformFeedbackStreamsLinesTriangles, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("transformFeedbackRasterizationStreamSelect").ToLocalChecked(), GettransformFeedbackRasterizationStreamSelect, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("transformFeedbackDraw").ToLocalChecked(), GettransformFeedbackDraw, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceTransformFeedbackPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceTransformFeedbackPropertiesEXT::flush() {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceTransformFeedbackPropertiesEXT* self = new _VkPhysicalDeviceTransformFeedbackPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceTransformFeedbackPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GetsType) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxTransformFeedbackStreams
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GetmaxTransformFeedbackStreams) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTransformFeedbackStreams));
}// maxTransformFeedbackBuffers
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GetmaxTransformFeedbackBuffers) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTransformFeedbackBuffers));
}// maxTransformFeedbackBufferSize
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GetmaxTransformFeedbackBufferSize) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTransformFeedbackBufferSize));
}// maxTransformFeedbackStreamDataSize
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GetmaxTransformFeedbackStreamDataSize) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTransformFeedbackStreamDataSize));
}// maxTransformFeedbackBufferDataSize
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GetmaxTransformFeedbackBufferDataSize) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTransformFeedbackBufferDataSize));
}// maxTransformFeedbackBufferDataStride
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GetmaxTransformFeedbackBufferDataStride) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTransformFeedbackBufferDataStride));
}// transformFeedbackQueries
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GettransformFeedbackQueries) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.transformFeedbackQueries));
}// transformFeedbackStreamsLinesTriangles
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GettransformFeedbackStreamsLinesTriangles) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.transformFeedbackStreamsLinesTriangles));
}// transformFeedbackRasterizationStreamSelect
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GettransformFeedbackRasterizationStreamSelect) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.transformFeedbackRasterizationStreamSelect));
}// transformFeedbackDraw
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackPropertiesEXT::GettransformFeedbackDraw) {
  _VkPhysicalDeviceTransformFeedbackPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.transformFeedbackDraw));
}
/** ## END VkPhysicalDeviceTransformFeedbackPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceTransformFeedbackFeaturesEXT ## **/

class _VkPhysicalDeviceTransformFeedbackFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GettransformFeedback);
    static NAN_SETTER(SettransformFeedback);
    
    static NAN_GETTER(GetgeometryStreams);
    static NAN_SETTER(SetgeometryStreams);
    

    // real instance
    VkPhysicalDeviceTransformFeedbackFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceTransformFeedbackFeaturesEXT();
    ~_VkPhysicalDeviceTransformFeedbackFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceTransformFeedbackFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceTransformFeedbackFeaturesEXT::constructor;

_VkPhysicalDeviceTransformFeedbackFeaturesEXT::_VkPhysicalDeviceTransformFeedbackFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
  
}

_VkPhysicalDeviceTransformFeedbackFeaturesEXT::~_VkPhysicalDeviceTransformFeedbackFeaturesEXT() {
  //printf("VkPhysicalDeviceTransformFeedbackFeaturesEXT deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceTransformFeedbackFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceTransformFeedbackFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceTransformFeedbackFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("transformFeedback").ToLocalChecked(), GettransformFeedback, SettransformFeedback, ctor);
  SetPrototypeAccessor(proto, Nan::New("geometryStreams").ToLocalChecked(), GetgeometryStreams, SetgeometryStreams, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceTransformFeedbackFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceTransformFeedbackFeaturesEXT::flush() {
  _VkPhysicalDeviceTransformFeedbackFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceTransformFeedbackFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceTransformFeedbackFeaturesEXT* self = new _VkPhysicalDeviceTransformFeedbackFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("transformFeedback").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("geometryStreams").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceTransformFeedbackFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackFeaturesEXT::GetsType) {
  _VkPhysicalDeviceTransformFeedbackFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceTransformFeedbackFeaturesEXT::SetsType) {
  _VkPhysicalDeviceTransformFeedbackFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceTransformFeedbackFeaturesEXT.sType", "Number");
  
    return;
  }
}// transformFeedback
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackFeaturesEXT::GettransformFeedback) {
  _VkPhysicalDeviceTransformFeedbackFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.transformFeedback));
}NAN_SETTER(_VkPhysicalDeviceTransformFeedbackFeaturesEXT::SettransformFeedback) {
  _VkPhysicalDeviceTransformFeedbackFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.transformFeedback = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceTransformFeedbackFeaturesEXT.transformFeedback", "Number");
  
    return;
  }
}// geometryStreams
NAN_GETTER(_VkPhysicalDeviceTransformFeedbackFeaturesEXT::GetgeometryStreams) {
  _VkPhysicalDeviceTransformFeedbackFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.geometryStreams));
}NAN_SETTER(_VkPhysicalDeviceTransformFeedbackFeaturesEXT::SetgeometryStreams) {
  _VkPhysicalDeviceTransformFeedbackFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceTransformFeedbackFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.geometryStreams = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceTransformFeedbackFeaturesEXT.geometryStreams", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceTransformFeedbackFeaturesEXT ## **/

/** ## BEGIN VkPhysicalDeviceASTCDecodeFeaturesEXT ## **/

class _VkPhysicalDeviceASTCDecodeFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdecodeModeSharedExponent);
    static NAN_SETTER(SetdecodeModeSharedExponent);
    

    // real instance
    VkPhysicalDeviceASTCDecodeFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceASTCDecodeFeaturesEXT();
    ~_VkPhysicalDeviceASTCDecodeFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceASTCDecodeFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceASTCDecodeFeaturesEXT::constructor;

_VkPhysicalDeviceASTCDecodeFeaturesEXT::_VkPhysicalDeviceASTCDecodeFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
  
}

_VkPhysicalDeviceASTCDecodeFeaturesEXT::~_VkPhysicalDeviceASTCDecodeFeaturesEXT() {
  //printf("VkPhysicalDeviceASTCDecodeFeaturesEXT deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceASTCDecodeFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceASTCDecodeFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceASTCDecodeFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("decodeModeSharedExponent").ToLocalChecked(), GetdecodeModeSharedExponent, SetdecodeModeSharedExponent, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceASTCDecodeFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceASTCDecodeFeaturesEXT::flush() {
  _VkPhysicalDeviceASTCDecodeFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceASTCDecodeFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceASTCDecodeFeaturesEXT* self = new _VkPhysicalDeviceASTCDecodeFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("decodeModeSharedExponent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceASTCDecodeFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceASTCDecodeFeaturesEXT::GetsType) {
  _VkPhysicalDeviceASTCDecodeFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceASTCDecodeFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceASTCDecodeFeaturesEXT::SetsType) {
  _VkPhysicalDeviceASTCDecodeFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceASTCDecodeFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceASTCDecodeFeaturesEXT.sType", "Number");
  
    return;
  }
}// decodeModeSharedExponent
NAN_GETTER(_VkPhysicalDeviceASTCDecodeFeaturesEXT::GetdecodeModeSharedExponent) {
  _VkPhysicalDeviceASTCDecodeFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceASTCDecodeFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.decodeModeSharedExponent));
}NAN_SETTER(_VkPhysicalDeviceASTCDecodeFeaturesEXT::SetdecodeModeSharedExponent) {
  _VkPhysicalDeviceASTCDecodeFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceASTCDecodeFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.decodeModeSharedExponent = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceASTCDecodeFeaturesEXT.decodeModeSharedExponent", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceASTCDecodeFeaturesEXT ## **/

/** ## BEGIN VkImageViewASTCDecodeModeEXT ## **/

class _VkImageViewASTCDecodeModeEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdecodeMode);
    static NAN_SETTER(SetdecodeMode);
    

    // real instance
    VkImageViewASTCDecodeModeEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageViewASTCDecodeModeEXT();
    ~_VkImageViewASTCDecodeModeEXT();

};

/*
#include "index.h"
#include "VkImageViewASTCDecodeModeEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageViewASTCDecodeModeEXT::constructor;

_VkImageViewASTCDecodeModeEXT::_VkImageViewASTCDecodeModeEXT() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT;
  
}

_VkImageViewASTCDecodeModeEXT::~_VkImageViewASTCDecodeModeEXT() {
  //printf("VkImageViewASTCDecodeModeEXT deconstructed!!\n");
  
  
  
}

void _VkImageViewASTCDecodeModeEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageViewASTCDecodeModeEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageViewASTCDecodeModeEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("decodeMode").ToLocalChecked(), GetdecodeMode, SetdecodeMode, ctor);
  Nan::Set(target, Nan::New("VkImageViewASTCDecodeModeEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageViewASTCDecodeModeEXT::flush() {
  _VkImageViewASTCDecodeModeEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkImageViewASTCDecodeModeEXT::New) {
  if (info.IsConstructCall()) {
    _VkImageViewASTCDecodeModeEXT* self = new _VkImageViewASTCDecodeModeEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("decodeMode").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageViewASTCDecodeModeEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageViewASTCDecodeModeEXT::GetsType) {
  _VkImageViewASTCDecodeModeEXT *self = Nan::ObjectWrap::Unwrap<_VkImageViewASTCDecodeModeEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageViewASTCDecodeModeEXT::SetsType) {
  _VkImageViewASTCDecodeModeEXT *self = Nan::ObjectWrap::Unwrap<_VkImageViewASTCDecodeModeEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewASTCDecodeModeEXT.sType", "Number");
  
    return;
  }
}// decodeMode
NAN_GETTER(_VkImageViewASTCDecodeModeEXT::GetdecodeMode) {
  _VkImageViewASTCDecodeModeEXT *self = Nan::ObjectWrap::Unwrap<_VkImageViewASTCDecodeModeEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.decodeMode));
}NAN_SETTER(_VkImageViewASTCDecodeModeEXT::SetdecodeMode) {
  _VkImageViewASTCDecodeModeEXT *self = Nan::ObjectWrap::Unwrap<_VkImageViewASTCDecodeModeEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.decodeMode = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewASTCDecodeModeEXT.decodeMode", "Number");
  
    return;
  }
}
/** ## END VkImageViewASTCDecodeModeEXT ## **/

/** ## BEGIN VkAttachmentReference2KHR ## **/

class _VkAttachmentReference2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getattachment);
    static NAN_SETTER(Setattachment);
    
    static NAN_GETTER(Getlayout);
    static NAN_SETTER(Setlayout);
    
    static NAN_GETTER(GetaspectMask);
    static NAN_SETTER(SetaspectMask);
    

    // real instance
    VkAttachmentReference2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAttachmentReference2KHR();
    ~_VkAttachmentReference2KHR();

};

/*
#include "index.h"
#include "VkAttachmentReference2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAttachmentReference2KHR::constructor;

_VkAttachmentReference2KHR::_VkAttachmentReference2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR;
  
}

_VkAttachmentReference2KHR::~_VkAttachmentReference2KHR() {
  //printf("VkAttachmentReference2KHR deconstructed!!\n");
  
  
  
  
  
}

void _VkAttachmentReference2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAttachmentReference2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAttachmentReference2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("attachment").ToLocalChecked(), Getattachment, Setattachment, ctor);
  SetPrototypeAccessor(proto, Nan::New("layout").ToLocalChecked(), Getlayout, Setlayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("aspectMask").ToLocalChecked(), GetaspectMask, SetaspectMask, ctor);
  Nan::Set(target, Nan::New("VkAttachmentReference2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAttachmentReference2KHR::flush() {
  _VkAttachmentReference2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkAttachmentReference2KHR::New) {
  if (info.IsConstructCall()) {
    _VkAttachmentReference2KHR* self = new _VkAttachmentReference2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("attachment").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("layout").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("aspectMask").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAttachmentReference2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkAttachmentReference2KHR::GetsType) {
  _VkAttachmentReference2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkAttachmentReference2KHR::SetsType) {
  _VkAttachmentReference2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentReference2KHR.sType", "Number");
  
    return;
  }
}// attachment
NAN_GETTER(_VkAttachmentReference2KHR::Getattachment) {
  _VkAttachmentReference2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.attachment));
}NAN_SETTER(_VkAttachmentReference2KHR::Setattachment) {
  _VkAttachmentReference2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.attachment = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentReference2KHR.attachment", "Number");
  
    return;
  }
}// layout
NAN_GETTER(_VkAttachmentReference2KHR::Getlayout) {
  _VkAttachmentReference2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.layout));
}NAN_SETTER(_VkAttachmentReference2KHR::Setlayout) {
  _VkAttachmentReference2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.layout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentReference2KHR.layout", "Number");
  
    return;
  }
}// aspectMask
NAN_GETTER(_VkAttachmentReference2KHR::GetaspectMask) {
  _VkAttachmentReference2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.aspectMask));
}NAN_SETTER(_VkAttachmentReference2KHR::SetaspectMask) {
  _VkAttachmentReference2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.aspectMask = static_cast<VkImageAspectFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentReference2KHR.aspectMask", "Number");
  
    return;
  }
}
/** ## END VkAttachmentReference2KHR ## **/

/** ## BEGIN VkSubpassDescriptionDepthStencilResolveKHR ## **/

class _VkSubpassDescriptionDepthStencilResolveKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdepthResolveMode);
    static NAN_SETTER(SetdepthResolveMode);
    
    static NAN_GETTER(GetstencilResolveMode);
    static NAN_SETTER(SetstencilResolveMode);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pDepthStencilResolveAttachment;
      static NAN_GETTER(GetpDepthStencilResolveAttachment);
    static NAN_SETTER(SetpDepthStencilResolveAttachment);
    

    // real instance
    VkSubpassDescriptionDepthStencilResolveKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubpassDescriptionDepthStencilResolveKHR();
    ~_VkSubpassDescriptionDepthStencilResolveKHR();

};

/*
#include "index.h"
#include "VkSubpassDescriptionDepthStencilResolveKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubpassDescriptionDepthStencilResolveKHR::constructor;

_VkSubpassDescriptionDepthStencilResolveKHR::_VkSubpassDescriptionDepthStencilResolveKHR() {
  instance.sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR;
  
}

_VkSubpassDescriptionDepthStencilResolveKHR::~_VkSubpassDescriptionDepthStencilResolveKHR() {
  //printf("VkSubpassDescriptionDepthStencilResolveKHR deconstructed!!\n");
  
  
  
  
  pDepthStencilResolveAttachment.Reset();
  
}

void _VkSubpassDescriptionDepthStencilResolveKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubpassDescriptionDepthStencilResolveKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubpassDescriptionDepthStencilResolveKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthResolveMode").ToLocalChecked(), GetdepthResolveMode, SetdepthResolveMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("stencilResolveMode").ToLocalChecked(), GetstencilResolveMode, SetstencilResolveMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDepthStencilResolveAttachment").ToLocalChecked(), GetpDepthStencilResolveAttachment, SetpDepthStencilResolveAttachment, ctor);
  Nan::Set(target, Nan::New("VkSubpassDescriptionDepthStencilResolveKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubpassDescriptionDepthStencilResolveKHR::flush() {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSubpassDescriptionDepthStencilResolveKHR::New) {
  if (info.IsConstructCall()) {
    _VkSubpassDescriptionDepthStencilResolveKHR* self = new _VkSubpassDescriptionDepthStencilResolveKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("depthResolveMode").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("stencilResolveMode").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pDepthStencilResolveAttachment").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubpassDescriptionDepthStencilResolveKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSubpassDescriptionDepthStencilResolveKHR::GetsType) {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescriptionDepthStencilResolveKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSubpassDescriptionDepthStencilResolveKHR::SetsType) {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescriptionDepthStencilResolveKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescriptionDepthStencilResolveKHR.sType", "Number");
  
    return;
  }
}// depthResolveMode
NAN_GETTER(_VkSubpassDescriptionDepthStencilResolveKHR::GetdepthResolveMode) {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescriptionDepthStencilResolveKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthResolveMode));
}NAN_SETTER(_VkSubpassDescriptionDepthStencilResolveKHR::SetdepthResolveMode) {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescriptionDepthStencilResolveKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.depthResolveMode = static_cast<VkResolveModeFlagBitsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescriptionDepthStencilResolveKHR.depthResolveMode", "Number");
  
    return;
  }
}// stencilResolveMode
NAN_GETTER(_VkSubpassDescriptionDepthStencilResolveKHR::GetstencilResolveMode) {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescriptionDepthStencilResolveKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stencilResolveMode));
}NAN_SETTER(_VkSubpassDescriptionDepthStencilResolveKHR::SetstencilResolveMode) {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescriptionDepthStencilResolveKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.stencilResolveMode = static_cast<VkResolveModeFlagBitsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescriptionDepthStencilResolveKHR.stencilResolveMode", "Number");
  
    return;
  }
}// pDepthStencilResolveAttachment
NAN_GETTER(_VkSubpassDescriptionDepthStencilResolveKHR::GetpDepthStencilResolveAttachment) {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescriptionDepthStencilResolveKHR>(info.This());
  if (self->pDepthStencilResolveAttachment.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDepthStencilResolveAttachment);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescriptionDepthStencilResolveKHR::SetpDepthStencilResolveAttachment) {
  _VkSubpassDescriptionDepthStencilResolveKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescriptionDepthStencilResolveKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkAttachmentReference2KHR::constructor)->HasInstance(obj)) {
      self->pDepthStencilResolveAttachment.Reset<v8::Object>(value.As<v8::Object>());
      _VkAttachmentReference2KHR* inst = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(obj);
      inst->flush();
      self->instance.pDepthStencilResolveAttachment = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescriptionDepthStencilResolveKHR.pDepthStencilResolveAttachment", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pDepthStencilResolveAttachment.Reset();
    self->instance.pDepthStencilResolveAttachment = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescriptionDepthStencilResolveKHR.pDepthStencilResolveAttachment", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}
/** ## END VkSubpassDescriptionDepthStencilResolveKHR ## **/

/** ## BEGIN VkPhysicalDeviceDepthStencilResolvePropertiesKHR ## **/

class _VkPhysicalDeviceDepthStencilResolvePropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetsupportedDepthResolveModes);
    static NAN_GETTER(GetsupportedStencilResolveModes);
    static NAN_GETTER(GetindependentResolveNone);
    static NAN_GETTER(GetindependentResolve);

    // real instance
    VkPhysicalDeviceDepthStencilResolvePropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceDepthStencilResolvePropertiesKHR();
    ~_VkPhysicalDeviceDepthStencilResolvePropertiesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceDepthStencilResolvePropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceDepthStencilResolvePropertiesKHR::constructor;

_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::_VkPhysicalDeviceDepthStencilResolvePropertiesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR;
  
}

_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::~_VkPhysicalDeviceDepthStencilResolvePropertiesKHR() {
  //printf("VkPhysicalDeviceDepthStencilResolvePropertiesKHR deconstructed!!\n");
  
  
  
  
  
  
}

void _VkPhysicalDeviceDepthStencilResolvePropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceDepthStencilResolvePropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedDepthResolveModes").ToLocalChecked(), GetsupportedDepthResolveModes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedStencilResolveModes").ToLocalChecked(), GetsupportedStencilResolveModes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("independentResolveNone").ToLocalChecked(), GetindependentResolveNone, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("independentResolve").ToLocalChecked(), GetindependentResolve, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceDepthStencilResolvePropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceDepthStencilResolvePropertiesKHR::flush() {
  _VkPhysicalDeviceDepthStencilResolvePropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceDepthStencilResolvePropertiesKHR* self = new _VkPhysicalDeviceDepthStencilResolvePropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceDepthStencilResolvePropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::GetsType) {
  _VkPhysicalDeviceDepthStencilResolvePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDepthStencilResolvePropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// supportedDepthResolveModes
NAN_GETTER(_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::GetsupportedDepthResolveModes) {
  _VkPhysicalDeviceDepthStencilResolvePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDepthStencilResolvePropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedDepthResolveModes));
}// supportedStencilResolveModes
NAN_GETTER(_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::GetsupportedStencilResolveModes) {
  _VkPhysicalDeviceDepthStencilResolvePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDepthStencilResolvePropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedStencilResolveModes));
}// independentResolveNone
NAN_GETTER(_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::GetindependentResolveNone) {
  _VkPhysicalDeviceDepthStencilResolvePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDepthStencilResolvePropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.independentResolveNone));
}// independentResolve
NAN_GETTER(_VkPhysicalDeviceDepthStencilResolvePropertiesKHR::GetindependentResolve) {
  _VkPhysicalDeviceDepthStencilResolvePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDepthStencilResolvePropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.independentResolve));
}
/** ## END VkPhysicalDeviceDepthStencilResolvePropertiesKHR ## **/

/** ## BEGIN VkCheckpointDataNV ## **/

class _VkCheckpointDataNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(Getstage);

    // real instance
    VkCheckpointDataNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCheckpointDataNV();
    ~_VkCheckpointDataNV();

};

/*
#include "index.h"
#include "VkCheckpointDataNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCheckpointDataNV::constructor;

_VkCheckpointDataNV::_VkCheckpointDataNV() {
  instance.sType = VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV;
  
}

_VkCheckpointDataNV::~_VkCheckpointDataNV() {
  //printf("VkCheckpointDataNV deconstructed!!\n");
  
  
  
}

void _VkCheckpointDataNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCheckpointDataNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCheckpointDataNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("stage").ToLocalChecked(), Getstage, nullptr, ctor);
  Nan::Set(target, Nan::New("VkCheckpointDataNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCheckpointDataNV::flush() {
  _VkCheckpointDataNV *self = this;
  
  return true;
}

NAN_METHOD(_VkCheckpointDataNV::New) {
  if (info.IsConstructCall()) {
    _VkCheckpointDataNV* self = new _VkCheckpointDataNV();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCheckpointDataNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCheckpointDataNV::GetsType) {
  _VkCheckpointDataNV *self = Nan::ObjectWrap::Unwrap<_VkCheckpointDataNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// stage
NAN_GETTER(_VkCheckpointDataNV::Getstage) {
  _VkCheckpointDataNV *self = Nan::ObjectWrap::Unwrap<_VkCheckpointDataNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stage));
}
/** ## END VkCheckpointDataNV ## **/

/** ## BEGIN VkQueueFamilyCheckpointPropertiesNV ## **/

class _VkQueueFamilyCheckpointPropertiesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetcheckpointExecutionStageMask);

    // real instance
    VkQueueFamilyCheckpointPropertiesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkQueueFamilyCheckpointPropertiesNV();
    ~_VkQueueFamilyCheckpointPropertiesNV();

};

/*
#include "index.h"
#include "VkQueueFamilyCheckpointPropertiesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkQueueFamilyCheckpointPropertiesNV::constructor;

_VkQueueFamilyCheckpointPropertiesNV::_VkQueueFamilyCheckpointPropertiesNV() {
  instance.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV;
  
}

_VkQueueFamilyCheckpointPropertiesNV::~_VkQueueFamilyCheckpointPropertiesNV() {
  //printf("VkQueueFamilyCheckpointPropertiesNV deconstructed!!\n");
  
  
  
}

void _VkQueueFamilyCheckpointPropertiesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkQueueFamilyCheckpointPropertiesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkQueueFamilyCheckpointPropertiesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("checkpointExecutionStageMask").ToLocalChecked(), GetcheckpointExecutionStageMask, nullptr, ctor);
  Nan::Set(target, Nan::New("VkQueueFamilyCheckpointPropertiesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkQueueFamilyCheckpointPropertiesNV::flush() {
  _VkQueueFamilyCheckpointPropertiesNV *self = this;
  
  return true;
}

NAN_METHOD(_VkQueueFamilyCheckpointPropertiesNV::New) {
  if (info.IsConstructCall()) {
    _VkQueueFamilyCheckpointPropertiesNV* self = new _VkQueueFamilyCheckpointPropertiesNV();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkQueueFamilyCheckpointPropertiesNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkQueueFamilyCheckpointPropertiesNV::GetsType) {
  _VkQueueFamilyCheckpointPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkQueueFamilyCheckpointPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// checkpointExecutionStageMask
NAN_GETTER(_VkQueueFamilyCheckpointPropertiesNV::GetcheckpointExecutionStageMask) {
  _VkQueueFamilyCheckpointPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkQueueFamilyCheckpointPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.checkpointExecutionStageMask));
}
/** ## END VkQueueFamilyCheckpointPropertiesNV ## **/

/** ## BEGIN VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT ## **/

class _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetvertexAttributeInstanceRateDivisor);
    static NAN_SETTER(SetvertexAttributeInstanceRateDivisor);
    
    static NAN_GETTER(GetvertexAttributeInstanceRateZeroDivisor);
    static NAN_SETTER(SetvertexAttributeInstanceRateZeroDivisor);
    

    // real instance
    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
    ~_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::constructor;

_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT;
  
}

_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::~_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT() {
  //printf("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexAttributeInstanceRateDivisor").ToLocalChecked(), GetvertexAttributeInstanceRateDivisor, SetvertexAttributeInstanceRateDivisor, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexAttributeInstanceRateZeroDivisor").ToLocalChecked(), GetvertexAttributeInstanceRateZeroDivisor, SetvertexAttributeInstanceRateZeroDivisor, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::flush() {
  _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* self = new _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("vertexAttributeInstanceRateDivisor").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("vertexAttributeInstanceRateZeroDivisor").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::GetsType) {
  _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::SetsType) {
  _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.sType", "Number");
  
    return;
  }
}// vertexAttributeInstanceRateDivisor
NAN_GETTER(_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::GetvertexAttributeInstanceRateDivisor) {
  _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexAttributeInstanceRateDivisor));
}NAN_SETTER(_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::SetvertexAttributeInstanceRateDivisor) {
  _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.vertexAttributeInstanceRateDivisor = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.vertexAttributeInstanceRateDivisor", "Number");
  
    return;
  }
}// vertexAttributeInstanceRateZeroDivisor
NAN_GETTER(_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::GetvertexAttributeInstanceRateZeroDivisor) {
  _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexAttributeInstanceRateZeroDivisor));
}NAN_SETTER(_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT::SetvertexAttributeInstanceRateZeroDivisor) {
  _VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.vertexAttributeInstanceRateZeroDivisor = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.vertexAttributeInstanceRateZeroDivisor", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT ## **/

/** ## BEGIN VkPhysicalDeviceShaderAtomicInt64FeaturesKHR ## **/

class _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetshaderBufferInt64Atomics);
    static NAN_SETTER(SetshaderBufferInt64Atomics);
    
    static NAN_GETTER(GetshaderSharedInt64Atomics);
    static NAN_SETTER(SetshaderSharedInt64Atomics);
    

    // real instance
    VkPhysicalDeviceShaderAtomicInt64FeaturesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR();
    ~_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::constructor;

_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR;
  
}

_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::~_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR() {
  //printf("VkPhysicalDeviceShaderAtomicInt64FeaturesKHR deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceShaderAtomicInt64FeaturesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderBufferInt64Atomics").ToLocalChecked(), GetshaderBufferInt64Atomics, SetshaderBufferInt64Atomics, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderSharedInt64Atomics").ToLocalChecked(), GetshaderSharedInt64Atomics, SetshaderSharedInt64Atomics, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceShaderAtomicInt64FeaturesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::flush() {
  _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR* self = new _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("shaderBufferInt64Atomics").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("shaderSharedInt64Atomics").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceShaderAtomicInt64FeaturesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::GetsType) {
  _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::SetsType) {
  _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.sType", "Number");
  
    return;
  }
}// shaderBufferInt64Atomics
NAN_GETTER(_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::GetshaderBufferInt64Atomics) {
  _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderBufferInt64Atomics));
}NAN_SETTER(_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::SetshaderBufferInt64Atomics) {
  _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderBufferInt64Atomics = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.shaderBufferInt64Atomics", "Number");
  
    return;
  }
}// shaderSharedInt64Atomics
NAN_GETTER(_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::GetshaderSharedInt64Atomics) {
  _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderSharedInt64Atomics));
}NAN_SETTER(_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR::SetshaderSharedInt64Atomics) {
  _VkPhysicalDeviceShaderAtomicInt64FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderSharedInt64Atomics = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.shaderSharedInt64Atomics", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceShaderAtomicInt64FeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceVulkanMemoryModelFeaturesKHR ## **/

class _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetvulkanMemoryModel);
    static NAN_SETTER(SetvulkanMemoryModel);
    
    static NAN_GETTER(GetvulkanMemoryModelDeviceScope);
    static NAN_SETTER(SetvulkanMemoryModelDeviceScope);
    
    static NAN_GETTER(GetvulkanMemoryModelAvailabilityVisibilityChains);
    static NAN_SETTER(SetvulkanMemoryModelAvailabilityVisibilityChains);
    

    // real instance
    VkPhysicalDeviceVulkanMemoryModelFeaturesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR();
    ~_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::constructor;

_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR;
  
}

_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::~_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR() {
  //printf("VkPhysicalDeviceVulkanMemoryModelFeaturesKHR deconstructed!!\n");
  
  
  
  
  
}

void _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceVulkanMemoryModelFeaturesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("vulkanMemoryModel").ToLocalChecked(), GetvulkanMemoryModel, SetvulkanMemoryModel, ctor);
  SetPrototypeAccessor(proto, Nan::New("vulkanMemoryModelDeviceScope").ToLocalChecked(), GetvulkanMemoryModelDeviceScope, SetvulkanMemoryModelDeviceScope, ctor);
  SetPrototypeAccessor(proto, Nan::New("vulkanMemoryModelAvailabilityVisibilityChains").ToLocalChecked(), GetvulkanMemoryModelAvailabilityVisibilityChains, SetvulkanMemoryModelAvailabilityVisibilityChains, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceVulkanMemoryModelFeaturesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::flush() {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR* self = new _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("vulkanMemoryModel").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("vulkanMemoryModelDeviceScope").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("vulkanMemoryModelAvailabilityVisibilityChains").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceVulkanMemoryModelFeaturesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::GetsType) {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::SetsType) {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.sType", "Number");
  
    return;
  }
}// vulkanMemoryModel
NAN_GETTER(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::GetvulkanMemoryModel) {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vulkanMemoryModel));
}NAN_SETTER(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::SetvulkanMemoryModel) {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.vulkanMemoryModel = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.vulkanMemoryModel", "Number");
  
    return;
  }
}// vulkanMemoryModelDeviceScope
NAN_GETTER(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::GetvulkanMemoryModelDeviceScope) {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vulkanMemoryModelDeviceScope));
}NAN_SETTER(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::SetvulkanMemoryModelDeviceScope) {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.vulkanMemoryModelDeviceScope = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.vulkanMemoryModelDeviceScope", "Number");
  
    return;
  }
}// vulkanMemoryModelAvailabilityVisibilityChains
NAN_GETTER(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::GetvulkanMemoryModelAvailabilityVisibilityChains) {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vulkanMemoryModelAvailabilityVisibilityChains));
}NAN_SETTER(_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR::SetvulkanMemoryModelAvailabilityVisibilityChains) {
  _VkPhysicalDeviceVulkanMemoryModelFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.vulkanMemoryModelAvailabilityVisibilityChains = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.vulkanMemoryModelAvailabilityVisibilityChains", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceVulkanMemoryModelFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceConditionalRenderingFeaturesEXT ## **/

class _VkPhysicalDeviceConditionalRenderingFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetconditionalRendering);
    static NAN_SETTER(SetconditionalRendering);
    
    static NAN_GETTER(GetinheritedConditionalRendering);
    static NAN_SETTER(SetinheritedConditionalRendering);
    

    // real instance
    VkPhysicalDeviceConditionalRenderingFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceConditionalRenderingFeaturesEXT();
    ~_VkPhysicalDeviceConditionalRenderingFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceConditionalRenderingFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceConditionalRenderingFeaturesEXT::constructor;

_VkPhysicalDeviceConditionalRenderingFeaturesEXT::_VkPhysicalDeviceConditionalRenderingFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
  
}

_VkPhysicalDeviceConditionalRenderingFeaturesEXT::~_VkPhysicalDeviceConditionalRenderingFeaturesEXT() {
  //printf("VkPhysicalDeviceConditionalRenderingFeaturesEXT deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceConditionalRenderingFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceConditionalRenderingFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceConditionalRenderingFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("conditionalRendering").ToLocalChecked(), GetconditionalRendering, SetconditionalRendering, ctor);
  SetPrototypeAccessor(proto, Nan::New("inheritedConditionalRendering").ToLocalChecked(), GetinheritedConditionalRendering, SetinheritedConditionalRendering, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceConditionalRenderingFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceConditionalRenderingFeaturesEXT::flush() {
  _VkPhysicalDeviceConditionalRenderingFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceConditionalRenderingFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceConditionalRenderingFeaturesEXT* self = new _VkPhysicalDeviceConditionalRenderingFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("conditionalRendering").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("inheritedConditionalRendering").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceConditionalRenderingFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetsType) {
  _VkPhysicalDeviceConditionalRenderingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetsType) {
  _VkPhysicalDeviceConditionalRenderingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.sType", "Number");
  
    return;
  }
}// conditionalRendering
NAN_GETTER(_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetconditionalRendering) {
  _VkPhysicalDeviceConditionalRenderingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.conditionalRendering));
}NAN_SETTER(_VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetconditionalRendering) {
  _VkPhysicalDeviceConditionalRenderingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.conditionalRendering = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.conditionalRendering", "Number");
  
    return;
  }
}// inheritedConditionalRendering
NAN_GETTER(_VkPhysicalDeviceConditionalRenderingFeaturesEXT::GetinheritedConditionalRendering) {
  _VkPhysicalDeviceConditionalRenderingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.inheritedConditionalRendering));
}NAN_SETTER(_VkPhysicalDeviceConditionalRenderingFeaturesEXT::SetinheritedConditionalRendering) {
  _VkPhysicalDeviceConditionalRenderingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConditionalRenderingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.inheritedConditionalRendering = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceConditionalRenderingFeaturesEXT.inheritedConditionalRendering", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceConditionalRenderingFeaturesEXT ## **/

/** ## BEGIN VkPhysicalDevice8BitStorageFeaturesKHR ## **/

class _VkPhysicalDevice8BitStorageFeaturesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetstorageBuffer8BitAccess);
    static NAN_SETTER(SetstorageBuffer8BitAccess);
    
    static NAN_GETTER(GetuniformAndStorageBuffer8BitAccess);
    static NAN_SETTER(SetuniformAndStorageBuffer8BitAccess);
    
    static NAN_GETTER(GetstoragePushConstant8);
    static NAN_SETTER(SetstoragePushConstant8);
    

    // real instance
    VkPhysicalDevice8BitStorageFeaturesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDevice8BitStorageFeaturesKHR();
    ~_VkPhysicalDevice8BitStorageFeaturesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDevice8BitStorageFeaturesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDevice8BitStorageFeaturesKHR::constructor;

_VkPhysicalDevice8BitStorageFeaturesKHR::_VkPhysicalDevice8BitStorageFeaturesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR;
  
}

_VkPhysicalDevice8BitStorageFeaturesKHR::~_VkPhysicalDevice8BitStorageFeaturesKHR() {
  //printf("VkPhysicalDevice8BitStorageFeaturesKHR deconstructed!!\n");
  
  
  
  
  
}

void _VkPhysicalDevice8BitStorageFeaturesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDevice8BitStorageFeaturesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDevice8BitStorageFeaturesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("storageBuffer8BitAccess").ToLocalChecked(), GetstorageBuffer8BitAccess, SetstorageBuffer8BitAccess, ctor);
  SetPrototypeAccessor(proto, Nan::New("uniformAndStorageBuffer8BitAccess").ToLocalChecked(), GetuniformAndStorageBuffer8BitAccess, SetuniformAndStorageBuffer8BitAccess, ctor);
  SetPrototypeAccessor(proto, Nan::New("storagePushConstant8").ToLocalChecked(), GetstoragePushConstant8, SetstoragePushConstant8, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDevice8BitStorageFeaturesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDevice8BitStorageFeaturesKHR::flush() {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDevice8BitStorageFeaturesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDevice8BitStorageFeaturesKHR* self = new _VkPhysicalDevice8BitStorageFeaturesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("storageBuffer8BitAccess").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("uniformAndStorageBuffer8BitAccess").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("storagePushConstant8").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDevice8BitStorageFeaturesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDevice8BitStorageFeaturesKHR::GetsType) {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDevice8BitStorageFeaturesKHR::SetsType) {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.sType", "Number");
  
    return;
  }
}// storageBuffer8BitAccess
NAN_GETTER(_VkPhysicalDevice8BitStorageFeaturesKHR::GetstorageBuffer8BitAccess) {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.storageBuffer8BitAccess));
}NAN_SETTER(_VkPhysicalDevice8BitStorageFeaturesKHR::SetstorageBuffer8BitAccess) {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.storageBuffer8BitAccess = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.storageBuffer8BitAccess", "Number");
  
    return;
  }
}// uniformAndStorageBuffer8BitAccess
NAN_GETTER(_VkPhysicalDevice8BitStorageFeaturesKHR::GetuniformAndStorageBuffer8BitAccess) {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.uniformAndStorageBuffer8BitAccess));
}NAN_SETTER(_VkPhysicalDevice8BitStorageFeaturesKHR::SetuniformAndStorageBuffer8BitAccess) {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.uniformAndStorageBuffer8BitAccess = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.uniformAndStorageBuffer8BitAccess", "Number");
  
    return;
  }
}// storagePushConstant8
NAN_GETTER(_VkPhysicalDevice8BitStorageFeaturesKHR::GetstoragePushConstant8) {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.storagePushConstant8));
}NAN_SETTER(_VkPhysicalDevice8BitStorageFeaturesKHR::SetstoragePushConstant8) {
  _VkPhysicalDevice8BitStorageFeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice8BitStorageFeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.storagePushConstant8 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice8BitStorageFeaturesKHR.storagePushConstant8", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDevice8BitStorageFeaturesKHR ## **/

/** ## BEGIN VkCommandBufferInheritanceConditionalRenderingInfoEXT ## **/

class _VkCommandBufferInheritanceConditionalRenderingInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetconditionalRenderingEnable);
    static NAN_SETTER(SetconditionalRenderingEnable);
    

    // real instance
    VkCommandBufferInheritanceConditionalRenderingInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCommandBufferInheritanceConditionalRenderingInfoEXT();
    ~_VkCommandBufferInheritanceConditionalRenderingInfoEXT();

};

/*
#include "index.h"
#include "VkCommandBufferInheritanceConditionalRenderingInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCommandBufferInheritanceConditionalRenderingInfoEXT::constructor;

_VkCommandBufferInheritanceConditionalRenderingInfoEXT::_VkCommandBufferInheritanceConditionalRenderingInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT;
  
}

_VkCommandBufferInheritanceConditionalRenderingInfoEXT::~_VkCommandBufferInheritanceConditionalRenderingInfoEXT() {
  //printf("VkCommandBufferInheritanceConditionalRenderingInfoEXT deconstructed!!\n");
  
  
  
}

void _VkCommandBufferInheritanceConditionalRenderingInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCommandBufferInheritanceConditionalRenderingInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCommandBufferInheritanceConditionalRenderingInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("conditionalRenderingEnable").ToLocalChecked(), GetconditionalRenderingEnable, SetconditionalRenderingEnable, ctor);
  Nan::Set(target, Nan::New("VkCommandBufferInheritanceConditionalRenderingInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCommandBufferInheritanceConditionalRenderingInfoEXT::flush() {
  _VkCommandBufferInheritanceConditionalRenderingInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkCommandBufferInheritanceConditionalRenderingInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkCommandBufferInheritanceConditionalRenderingInfoEXT* self = new _VkCommandBufferInheritanceConditionalRenderingInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("conditionalRenderingEnable").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCommandBufferInheritanceConditionalRenderingInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetsType) {
  _VkCommandBufferInheritanceConditionalRenderingInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCommandBufferInheritanceConditionalRenderingInfoEXT::SetsType) {
  _VkCommandBufferInheritanceConditionalRenderingInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceConditionalRenderingInfoEXT.sType", "Number");
  
    return;
  }
}// conditionalRenderingEnable
NAN_GETTER(_VkCommandBufferInheritanceConditionalRenderingInfoEXT::GetconditionalRenderingEnable) {
  _VkCommandBufferInheritanceConditionalRenderingInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.conditionalRenderingEnable));
}NAN_SETTER(_VkCommandBufferInheritanceConditionalRenderingInfoEXT::SetconditionalRenderingEnable) {
  _VkCommandBufferInheritanceConditionalRenderingInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceConditionalRenderingInfoEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.conditionalRenderingEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceConditionalRenderingInfoEXT.conditionalRenderingEnable", "Number");
  
    return;
  }
}
/** ## END VkCommandBufferInheritanceConditionalRenderingInfoEXT ## **/

/** ## BEGIN VkPhysicalDevicePCIBusInfoPropertiesEXT ## **/

class _VkPhysicalDevicePCIBusInfoPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetpciDomain);
    static NAN_GETTER(GetpciBus);
    static NAN_GETTER(GetpciDevice);
    static NAN_GETTER(GetpciFunction);

    // real instance
    VkPhysicalDevicePCIBusInfoPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDevicePCIBusInfoPropertiesEXT();
    ~_VkPhysicalDevicePCIBusInfoPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDevicePCIBusInfoPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDevicePCIBusInfoPropertiesEXT::constructor;

_VkPhysicalDevicePCIBusInfoPropertiesEXT::_VkPhysicalDevicePCIBusInfoPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
  
}

_VkPhysicalDevicePCIBusInfoPropertiesEXT::~_VkPhysicalDevicePCIBusInfoPropertiesEXT() {
  //printf("VkPhysicalDevicePCIBusInfoPropertiesEXT deconstructed!!\n");
  
  
  
  
  
  
}

void _VkPhysicalDevicePCIBusInfoPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDevicePCIBusInfoPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDevicePCIBusInfoPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pciDomain").ToLocalChecked(), GetpciDomain, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pciBus").ToLocalChecked(), GetpciBus, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pciDevice").ToLocalChecked(), GetpciDevice, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pciFunction").ToLocalChecked(), GetpciFunction, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDevicePCIBusInfoPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDevicePCIBusInfoPropertiesEXT::flush() {
  _VkPhysicalDevicePCIBusInfoPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDevicePCIBusInfoPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDevicePCIBusInfoPropertiesEXT* self = new _VkPhysicalDevicePCIBusInfoPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDevicePCIBusInfoPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDevicePCIBusInfoPropertiesEXT::GetsType) {
  _VkPhysicalDevicePCIBusInfoPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePCIBusInfoPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// pciDomain
NAN_GETTER(_VkPhysicalDevicePCIBusInfoPropertiesEXT::GetpciDomain) {
  _VkPhysicalDevicePCIBusInfoPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePCIBusInfoPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pciDomain));
}// pciBus
NAN_GETTER(_VkPhysicalDevicePCIBusInfoPropertiesEXT::GetpciBus) {
  _VkPhysicalDevicePCIBusInfoPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePCIBusInfoPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pciBus));
}// pciDevice
NAN_GETTER(_VkPhysicalDevicePCIBusInfoPropertiesEXT::GetpciDevice) {
  _VkPhysicalDevicePCIBusInfoPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePCIBusInfoPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pciDevice));
}// pciFunction
NAN_GETTER(_VkPhysicalDevicePCIBusInfoPropertiesEXT::GetpciFunction) {
  _VkPhysicalDevicePCIBusInfoPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePCIBusInfoPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pciFunction));
}
/** ## END VkPhysicalDevicePCIBusInfoPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT ## **/

class _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxVertexAttribDivisor);

    // real instance
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
    ~_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::constructor;

_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::~_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT() {
  //printf("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxVertexAttribDivisor").ToLocalChecked(), GetmaxVertexAttribDivisor, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::flush() {
  _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* self = new _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetsType) {
  _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxVertexAttribDivisor
NAN_GETTER(_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::GetmaxVertexAttribDivisor) {
  _VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxVertexAttribDivisor));
}
/** ## END VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT ## **/

/** ## BEGIN VkVertexInputBindingDivisorDescriptionEXT ## **/

class _VkVertexInputBindingDivisorDescriptionEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getbinding);
    static NAN_SETTER(Setbinding);
    
    static NAN_GETTER(Getdivisor);
    static NAN_SETTER(Setdivisor);
    

    // real instance
    VkVertexInputBindingDivisorDescriptionEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkVertexInputBindingDivisorDescriptionEXT();
    ~_VkVertexInputBindingDivisorDescriptionEXT();

};

/*
#include "index.h"
#include "VkVertexInputBindingDivisorDescriptionEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkVertexInputBindingDivisorDescriptionEXT::constructor;

_VkVertexInputBindingDivisorDescriptionEXT::_VkVertexInputBindingDivisorDescriptionEXT() {
  
  
}

_VkVertexInputBindingDivisorDescriptionEXT::~_VkVertexInputBindingDivisorDescriptionEXT() {
  //printf("VkVertexInputBindingDivisorDescriptionEXT deconstructed!!\n");
  
  
  
}

void _VkVertexInputBindingDivisorDescriptionEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkVertexInputBindingDivisorDescriptionEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkVertexInputBindingDivisorDescriptionEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("binding").ToLocalChecked(), Getbinding, Setbinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("divisor").ToLocalChecked(), Getdivisor, Setdivisor, ctor);
  Nan::Set(target, Nan::New("VkVertexInputBindingDivisorDescriptionEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkVertexInputBindingDivisorDescriptionEXT::flush() {
  _VkVertexInputBindingDivisorDescriptionEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkVertexInputBindingDivisorDescriptionEXT::New) {
  if (info.IsConstructCall()) {
    _VkVertexInputBindingDivisorDescriptionEXT* self = new _VkVertexInputBindingDivisorDescriptionEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("binding").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("divisor").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkVertexInputBindingDivisorDescriptionEXT constructor cannot be invoked without 'new'");
  }
};

// binding
NAN_GETTER(_VkVertexInputBindingDivisorDescriptionEXT::Getbinding) {
  _VkVertexInputBindingDivisorDescriptionEXT *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDivisorDescriptionEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.binding));
}NAN_SETTER(_VkVertexInputBindingDivisorDescriptionEXT::Setbinding) {
  _VkVertexInputBindingDivisorDescriptionEXT *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDivisorDescriptionEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.binding = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputBindingDivisorDescriptionEXT.binding", "Number");
  
    return;
  }
}// divisor
NAN_GETTER(_VkVertexInputBindingDivisorDescriptionEXT::Getdivisor) {
  _VkVertexInputBindingDivisorDescriptionEXT *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDivisorDescriptionEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.divisor));
}NAN_SETTER(_VkVertexInputBindingDivisorDescriptionEXT::Setdivisor) {
  _VkVertexInputBindingDivisorDescriptionEXT *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDivisorDescriptionEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.divisor = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputBindingDivisorDescriptionEXT.divisor", "Number");
  
    return;
  }
}
/** ## END VkVertexInputBindingDivisorDescriptionEXT ## **/

/** ## BEGIN VkPipelineVertexInputDivisorStateCreateInfoEXT ## **/

class _VkPipelineVertexInputDivisorStateCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetvertexBindingDivisorCount);
    static NAN_SETTER(SetvertexBindingDivisorCount);
    
    std::vector<VkVertexInputBindingDivisorDescriptionEXT>* vpVertexBindingDivisors;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pVertexBindingDivisors;
    static NAN_GETTER(GetpVertexBindingDivisors);
    static NAN_SETTER(SetpVertexBindingDivisors);
    

    // real instance
    VkPipelineVertexInputDivisorStateCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineVertexInputDivisorStateCreateInfoEXT();
    ~_VkPipelineVertexInputDivisorStateCreateInfoEXT();

};

/*
#include "index.h"
#include "VkPipelineVertexInputDivisorStateCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineVertexInputDivisorStateCreateInfoEXT::constructor;

_VkPipelineVertexInputDivisorStateCreateInfoEXT::_VkPipelineVertexInputDivisorStateCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT;
  vpVertexBindingDivisors = new std::vector<VkVertexInputBindingDivisorDescriptionEXT>;
  
}

_VkPipelineVertexInputDivisorStateCreateInfoEXT::~_VkPipelineVertexInputDivisorStateCreateInfoEXT() {
  //printf("VkPipelineVertexInputDivisorStateCreateInfoEXT deconstructed!!\n");
  
  
  
  vpVertexBindingDivisors->clear();
  delete vpVertexBindingDivisors;
  
  pVertexBindingDivisors.Reset();
  
}

void _VkPipelineVertexInputDivisorStateCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineVertexInputDivisorStateCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineVertexInputDivisorStateCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexBindingDivisorCount").ToLocalChecked(), GetvertexBindingDivisorCount, SetvertexBindingDivisorCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pVertexBindingDivisors").ToLocalChecked(), GetpVertexBindingDivisors, SetpVertexBindingDivisors, ctor);
  Nan::Set(target, Nan::New("VkPipelineVertexInputDivisorStateCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineVertexInputDivisorStateCreateInfoEXT::flush() {
  _VkPipelineVertexInputDivisorStateCreateInfoEXT *self = this;
  if (!(self->pVertexBindingDivisors.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pVertexBindingDivisors);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.vertexBindingDivisorCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'vertexBindingDivisorCount' for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors'");
      return false;
    }
    std::vector<VkVertexInputBindingDivisorDescriptionEXT>* data = self->vpVertexBindingDivisors;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkVertexInputBindingDivisorDescriptionEXT::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors", "[object VkVertexInputBindingDivisorDescriptionEXT]");
  
        return false;
      }
      _VkVertexInputBindingDivisorDescriptionEXT* result = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDivisorDescriptionEXT>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pVertexBindingDivisors = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineVertexInputDivisorStateCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkPipelineVertexInputDivisorStateCreateInfoEXT* self = new _VkPipelineVertexInputDivisorStateCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("vertexBindingDivisorCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pVertexBindingDivisors").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineVertexInputDivisorStateCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetsType) {
  _VkPipelineVertexInputDivisorStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputDivisorStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineVertexInputDivisorStateCreateInfoEXT::SetsType) {
  _VkPipelineVertexInputDivisorStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputDivisorStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// vertexBindingDivisorCount
NAN_GETTER(_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetvertexBindingDivisorCount) {
  _VkPipelineVertexInputDivisorStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputDivisorStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexBindingDivisorCount));
}NAN_SETTER(_VkPipelineVertexInputDivisorStateCreateInfoEXT::SetvertexBindingDivisorCount) {
  _VkPipelineVertexInputDivisorStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputDivisorStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexBindingDivisorCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.vertexBindingDivisorCount", "Number");
  
    return;
  }
}// pVertexBindingDivisors
NAN_GETTER(_VkPipelineVertexInputDivisorStateCreateInfoEXT::GetpVertexBindingDivisors) {
  _VkPipelineVertexInputDivisorStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputDivisorStateCreateInfoEXT>(info.This());
  if (self->pVertexBindingDivisors.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pVertexBindingDivisors);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineVertexInputDivisorStateCreateInfoEXT::SetpVertexBindingDivisors) {
  _VkPipelineVertexInputDivisorStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputDivisorStateCreateInfoEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pVertexBindingDivisors.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pVertexBindingDivisors.Reset();
      self->instance.pVertexBindingDivisors = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors", "[object VkVertexInputBindingDivisorDescriptionEXT]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pVertexBindingDivisors = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors", "[object VkVertexInputBindingDivisorDescriptionEXT]");
  
    return;
  }
}
/** ## END VkPipelineVertexInputDivisorStateCreateInfoEXT ## **/

/** ## BEGIN VkSubpassEndInfoKHR ## **/

class _VkSubpassEndInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    

    // real instance
    VkSubpassEndInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubpassEndInfoKHR();
    ~_VkSubpassEndInfoKHR();

};

/*
#include "index.h"
#include "VkSubpassEndInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubpassEndInfoKHR::constructor;

_VkSubpassEndInfoKHR::_VkSubpassEndInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR;
  
}

_VkSubpassEndInfoKHR::~_VkSubpassEndInfoKHR() {
  //printf("VkSubpassEndInfoKHR deconstructed!!\n");
  
  
}

void _VkSubpassEndInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubpassEndInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubpassEndInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  Nan::Set(target, Nan::New("VkSubpassEndInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubpassEndInfoKHR::flush() {
  _VkSubpassEndInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSubpassEndInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkSubpassEndInfoKHR* self = new _VkSubpassEndInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubpassEndInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSubpassEndInfoKHR::GetsType) {
  _VkSubpassEndInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassEndInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSubpassEndInfoKHR::SetsType) {
  _VkSubpassEndInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassEndInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassEndInfoKHR.sType", "Number");
  
    return;
  }
}
/** ## END VkSubpassEndInfoKHR ## **/

/** ## BEGIN VkSubpassBeginInfoKHR ## **/

class _VkSubpassBeginInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getcontents);
    static NAN_SETTER(Setcontents);
    

    // real instance
    VkSubpassBeginInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubpassBeginInfoKHR();
    ~_VkSubpassBeginInfoKHR();

};

/*
#include "index.h"
#include "VkSubpassBeginInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubpassBeginInfoKHR::constructor;

_VkSubpassBeginInfoKHR::_VkSubpassBeginInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR;
  
}

_VkSubpassBeginInfoKHR::~_VkSubpassBeginInfoKHR() {
  //printf("VkSubpassBeginInfoKHR deconstructed!!\n");
  
  
  
}

void _VkSubpassBeginInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubpassBeginInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubpassBeginInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("contents").ToLocalChecked(), Getcontents, Setcontents, ctor);
  Nan::Set(target, Nan::New("VkSubpassBeginInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubpassBeginInfoKHR::flush() {
  _VkSubpassBeginInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSubpassBeginInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkSubpassBeginInfoKHR* self = new _VkSubpassBeginInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("contents").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubpassBeginInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSubpassBeginInfoKHR::GetsType) {
  _VkSubpassBeginInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassBeginInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSubpassBeginInfoKHR::SetsType) {
  _VkSubpassBeginInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassBeginInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassBeginInfoKHR.sType", "Number");
  
    return;
  }
}// contents
NAN_GETTER(_VkSubpassBeginInfoKHR::Getcontents) {
  _VkSubpassBeginInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassBeginInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.contents));
}NAN_SETTER(_VkSubpassBeginInfoKHR::Setcontents) {
  _VkSubpassBeginInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassBeginInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.contents = static_cast<VkSubpassContents>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassBeginInfoKHR.contents", "Number");
  
    return;
  }
}
/** ## END VkSubpassBeginInfoKHR ## **/

/** ## BEGIN VkSubpassDependency2KHR ## **/

class _VkSubpassDependency2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsrcSubpass);
    static NAN_SETTER(SetsrcSubpass);
    
    static NAN_GETTER(GetdstSubpass);
    static NAN_SETTER(SetdstSubpass);
    
    static NAN_GETTER(GetsrcStageMask);
    static NAN_SETTER(SetsrcStageMask);
    
    static NAN_GETTER(GetdstStageMask);
    static NAN_SETTER(SetdstStageMask);
    
    static NAN_GETTER(GetsrcAccessMask);
    static NAN_SETTER(SetsrcAccessMask);
    
    static NAN_GETTER(GetdstAccessMask);
    static NAN_SETTER(SetdstAccessMask);
    
    static NAN_GETTER(GetdependencyFlags);
    static NAN_SETTER(SetdependencyFlags);
    
    static NAN_GETTER(GetviewOffset);
    static NAN_SETTER(SetviewOffset);
    

    // real instance
    VkSubpassDependency2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubpassDependency2KHR();
    ~_VkSubpassDependency2KHR();

};

/*
#include "index.h"
#include "VkSubpassDependency2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubpassDependency2KHR::constructor;

_VkSubpassDependency2KHR::_VkSubpassDependency2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR;
  
}

_VkSubpassDependency2KHR::~_VkSubpassDependency2KHR() {
  //printf("VkSubpassDependency2KHR deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
}

void _VkSubpassDependency2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubpassDependency2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubpassDependency2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcSubpass").ToLocalChecked(), GetsrcSubpass, SetsrcSubpass, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstSubpass").ToLocalChecked(), GetdstSubpass, SetdstSubpass, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcStageMask").ToLocalChecked(), GetsrcStageMask, SetsrcStageMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstStageMask").ToLocalChecked(), GetdstStageMask, SetdstStageMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcAccessMask").ToLocalChecked(), GetsrcAccessMask, SetsrcAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstAccessMask").ToLocalChecked(), GetdstAccessMask, SetdstAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dependencyFlags").ToLocalChecked(), GetdependencyFlags, SetdependencyFlags, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewOffset").ToLocalChecked(), GetviewOffset, SetviewOffset, ctor);
  Nan::Set(target, Nan::New("VkSubpassDependency2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubpassDependency2KHR::flush() {
  _VkSubpassDependency2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSubpassDependency2KHR::New) {
  if (info.IsConstructCall()) {
    _VkSubpassDependency2KHR* self = new _VkSubpassDependency2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("srcSubpass").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstSubpass").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("srcStageMask").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("dstStageMask").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("srcAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("dstAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("dependencyFlags").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("viewOffset").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubpassDependency2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSubpassDependency2KHR::GetsType) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSubpassDependency2KHR::SetsType) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.sType", "Number");
  
    return;
  }
}// srcSubpass
NAN_GETTER(_VkSubpassDependency2KHR::GetsrcSubpass) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcSubpass));
}NAN_SETTER(_VkSubpassDependency2KHR::SetsrcSubpass) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.srcSubpass = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.srcSubpass", "Number");
  
    return;
  }
}// dstSubpass
NAN_GETTER(_VkSubpassDependency2KHR::GetdstSubpass) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstSubpass));
}NAN_SETTER(_VkSubpassDependency2KHR::SetdstSubpass) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.dstSubpass = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.dstSubpass", "Number");
  
    return;
  }
}// srcStageMask
NAN_GETTER(_VkSubpassDependency2KHR::GetsrcStageMask) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcStageMask));
}NAN_SETTER(_VkSubpassDependency2KHR::SetsrcStageMask) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.srcStageMask = static_cast<VkPipelineStageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.srcStageMask", "Number");
  
    return;
  }
}// dstStageMask
NAN_GETTER(_VkSubpassDependency2KHR::GetdstStageMask) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstStageMask));
}NAN_SETTER(_VkSubpassDependency2KHR::SetdstStageMask) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.dstStageMask = static_cast<VkPipelineStageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.dstStageMask", "Number");
  
    return;
  }
}// srcAccessMask
NAN_GETTER(_VkSubpassDependency2KHR::GetsrcAccessMask) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcAccessMask));
}NAN_SETTER(_VkSubpassDependency2KHR::SetsrcAccessMask) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.srcAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
NAN_GETTER(_VkSubpassDependency2KHR::GetdstAccessMask) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstAccessMask));
}NAN_SETTER(_VkSubpassDependency2KHR::SetdstAccessMask) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.dstAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.dstAccessMask", "Number");
  
    return;
  }
}// dependencyFlags
NAN_GETTER(_VkSubpassDependency2KHR::GetdependencyFlags) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dependencyFlags));
}NAN_SETTER(_VkSubpassDependency2KHR::SetdependencyFlags) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.dependencyFlags = static_cast<VkDependencyFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.dependencyFlags", "Number");
  
    return;
  }
}// viewOffset
NAN_GETTER(_VkSubpassDependency2KHR::GetviewOffset) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewOffset));
}NAN_SETTER(_VkSubpassDependency2KHR::SetviewOffset) {
  _VkSubpassDependency2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.viewOffset = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency2KHR.viewOffset", "Number");
  
    return;
  }
}
/** ## END VkSubpassDependency2KHR ## **/

/** ## BEGIN VkSubpassDescription2KHR ## **/

class _VkSubpassDescription2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetpipelineBindPoint);
    static NAN_SETTER(SetpipelineBindPoint);
    
    static NAN_GETTER(GetviewMask);
    static NAN_SETTER(SetviewMask);
    
    static NAN_GETTER(GetinputAttachmentCount);
    static NAN_SETTER(SetinputAttachmentCount);
    
    std::vector<VkAttachmentReference2KHR>* vpInputAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pInputAttachments;
    static NAN_GETTER(GetpInputAttachments);
    static NAN_SETTER(SetpInputAttachments);
    
    static NAN_GETTER(GetcolorAttachmentCount);
    static NAN_SETTER(SetcolorAttachmentCount);
    
    std::vector<VkAttachmentReference2KHR>* vpColorAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pColorAttachments;
    static NAN_GETTER(GetpColorAttachments);
    static NAN_SETTER(SetpColorAttachments);
    
    std::vector<VkAttachmentReference2KHR>* vpResolveAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pResolveAttachments;
    static NAN_GETTER(GetpResolveAttachments);
    static NAN_SETTER(SetpResolveAttachments);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pDepthStencilAttachment;
      static NAN_GETTER(GetpDepthStencilAttachment);
    static NAN_SETTER(SetpDepthStencilAttachment);
    
    static NAN_GETTER(GetpreserveAttachmentCount);
    static NAN_SETTER(SetpreserveAttachmentCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pPreserveAttachments;
    static NAN_GETTER(GetpPreserveAttachments);
    static NAN_SETTER(SetpPreserveAttachments);
    

    // real instance
    VkSubpassDescription2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubpassDescription2KHR();
    ~_VkSubpassDescription2KHR();

};

/*
#include "index.h"
#include "VkSubpassDescription2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubpassDescription2KHR::constructor;

_VkSubpassDescription2KHR::_VkSubpassDescription2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR;
  vpInputAttachments = new std::vector<VkAttachmentReference2KHR>;
  vpColorAttachments = new std::vector<VkAttachmentReference2KHR>;
  vpResolveAttachments = new std::vector<VkAttachmentReference2KHR>;
  
}

_VkSubpassDescription2KHR::~_VkSubpassDescription2KHR() {
  //printf("VkSubpassDescription2KHR deconstructed!!\n");
  
  
  
  
  
  
  vpInputAttachments->clear();
  delete vpInputAttachments;
  
  pInputAttachments.Reset();
  
  
  vpColorAttachments->clear();
  delete vpColorAttachments;
  
  pColorAttachments.Reset();
  
  vpResolveAttachments->clear();
  delete vpResolveAttachments;
  
  pResolveAttachments.Reset();
  
  pDepthStencilAttachment.Reset();
  
  
  pPreserveAttachments.Reset();
  
}

void _VkSubpassDescription2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubpassDescription2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubpassDescription2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineBindPoint").ToLocalChecked(), GetpipelineBindPoint, SetpipelineBindPoint, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewMask").ToLocalChecked(), GetviewMask, SetviewMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("inputAttachmentCount").ToLocalChecked(), GetinputAttachmentCount, SetinputAttachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pInputAttachments").ToLocalChecked(), GetpInputAttachments, SetpInputAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("colorAttachmentCount").ToLocalChecked(), GetcolorAttachmentCount, SetcolorAttachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pColorAttachments").ToLocalChecked(), GetpColorAttachments, SetpColorAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("pResolveAttachments").ToLocalChecked(), GetpResolveAttachments, SetpResolveAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDepthStencilAttachment").ToLocalChecked(), GetpDepthStencilAttachment, SetpDepthStencilAttachment, ctor);
  SetPrototypeAccessor(proto, Nan::New("preserveAttachmentCount").ToLocalChecked(), GetpreserveAttachmentCount, SetpreserveAttachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pPreserveAttachments").ToLocalChecked(), GetpPreserveAttachments, SetpPreserveAttachments, ctor);
  Nan::Set(target, Nan::New("VkSubpassDescription2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubpassDescription2KHR::flush() {
  _VkSubpassDescription2KHR *self = this;
  if (!(self->pInputAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pInputAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.inputAttachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'inputAttachmentCount' for 'VkSubpassDescription2KHR.pInputAttachments'");
      return false;
    }
    std::vector<VkAttachmentReference2KHR>* data = self->vpInputAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentReference2KHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pInputAttachments", "[object VkAttachmentReference2KHR]");
  
        return false;
      }
      _VkAttachmentReference2KHR* result = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pInputAttachments = data->data();
  }if (!(self->pColorAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pColorAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.colorAttachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pColorAttachments'");
      return false;
    }
    std::vector<VkAttachmentReference2KHR>* data = self->vpColorAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentReference2KHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pColorAttachments", "[object VkAttachmentReference2KHR]");
  
        return false;
      }
      _VkAttachmentReference2KHR* result = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pColorAttachments = data->data();
  }if (!(self->pResolveAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pResolveAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.colorAttachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pResolveAttachments'");
      return false;
    }
    std::vector<VkAttachmentReference2KHR>* data = self->vpResolveAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentReference2KHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pResolveAttachments", "[object VkAttachmentReference2KHR]");
  
        return false;
      }
      _VkAttachmentReference2KHR* result = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pResolveAttachments = data->data();
  }
  return true;
}

NAN_METHOD(_VkSubpassDescription2KHR::New) {
  if (info.IsConstructCall()) {
    _VkSubpassDescription2KHR* self = new _VkSubpassDescription2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pipelineBindPoint").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("viewMask").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("inputAttachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pInputAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("colorAttachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pColorAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("pResolveAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("pDepthStencilAttachment").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("preserveAttachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("pPreserveAttachments").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubpassDescription2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSubpassDescription2KHR::GetsType) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSubpassDescription2KHR::SetsType) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkSubpassDescription2KHR::Getflags) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkSubpassDescription2KHR::Setflags) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSubpassDescriptionFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.flags", "Number");
  
    return;
  }
}// pipelineBindPoint
NAN_GETTER(_VkSubpassDescription2KHR::GetpipelineBindPoint) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pipelineBindPoint));
}NAN_SETTER(_VkSubpassDescription2KHR::SetpipelineBindPoint) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pipelineBindPoint", "Number");
  
    return;
  }
}// viewMask
NAN_GETTER(_VkSubpassDescription2KHR::GetviewMask) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewMask));
}NAN_SETTER(_VkSubpassDescription2KHR::SetviewMask) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.viewMask = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.viewMask", "Number");
  
    return;
  }
}// inputAttachmentCount
NAN_GETTER(_VkSubpassDescription2KHR::GetinputAttachmentCount) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.inputAttachmentCount));
}NAN_SETTER(_VkSubpassDescription2KHR::SetinputAttachmentCount) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.inputAttachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.inputAttachmentCount", "Number");
  
    return;
  }
}// pInputAttachments
NAN_GETTER(_VkSubpassDescription2KHR::GetpInputAttachments) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (self->pInputAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pInputAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription2KHR::SetpInputAttachments) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pInputAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pInputAttachments.Reset();
      self->instance.pInputAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pInputAttachments", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pInputAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pInputAttachments", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}// colorAttachmentCount
NAN_GETTER(_VkSubpassDescription2KHR::GetcolorAttachmentCount) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.colorAttachmentCount));
}NAN_SETTER(_VkSubpassDescription2KHR::SetcolorAttachmentCount) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.colorAttachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.colorAttachmentCount", "Number");
  
    return;
  }
}// pColorAttachments
NAN_GETTER(_VkSubpassDescription2KHR::GetpColorAttachments) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (self->pColorAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pColorAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription2KHR::SetpColorAttachments) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pColorAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pColorAttachments.Reset();
      self->instance.pColorAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pColorAttachments", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pColorAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pColorAttachments", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}// pResolveAttachments
NAN_GETTER(_VkSubpassDescription2KHR::GetpResolveAttachments) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (self->pResolveAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pResolveAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription2KHR::SetpResolveAttachments) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pResolveAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pResolveAttachments.Reset();
      self->instance.pResolveAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pResolveAttachments", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pResolveAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pResolveAttachments", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}// pDepthStencilAttachment
NAN_GETTER(_VkSubpassDescription2KHR::GetpDepthStencilAttachment) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (self->pDepthStencilAttachment.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDepthStencilAttachment);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription2KHR::SetpDepthStencilAttachment) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkAttachmentReference2KHR::constructor)->HasInstance(obj)) {
      self->pDepthStencilAttachment.Reset<v8::Object>(value.As<v8::Object>());
      _VkAttachmentReference2KHR* inst = Nan::ObjectWrap::Unwrap<_VkAttachmentReference2KHR>(obj);
      inst->flush();
      self->instance.pDepthStencilAttachment = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pDepthStencilAttachment", "[object VkAttachmentReference2KHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pDepthStencilAttachment.Reset();
    self->instance.pDepthStencilAttachment = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pDepthStencilAttachment", "[object VkAttachmentReference2KHR]");
  
    return;
  }
}// preserveAttachmentCount
NAN_GETTER(_VkSubpassDescription2KHR::GetpreserveAttachmentCount) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.preserveAttachmentCount));
}NAN_SETTER(_VkSubpassDescription2KHR::SetpreserveAttachmentCount) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.preserveAttachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.preserveAttachmentCount", "Number");
  
    return;
  }
}// pPreserveAttachments
NAN_GETTER(_VkSubpassDescription2KHR::GetpPreserveAttachments) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  if (self->pPreserveAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pPreserveAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription2KHR::SetpPreserveAttachments) {
  _VkSubpassDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pPreserveAttachments.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pPreserveAttachments", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pPreserveAttachments.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription2KHR.pPreserveAttachments", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pPreserveAttachments = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pPreserveAttachments = nullptr;
  }
}
/** ## END VkSubpassDescription2KHR ## **/

/** ## BEGIN VkAttachmentDescription2KHR ## **/

class _VkAttachmentDescription2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
    static NAN_GETTER(Getsamples);
    static NAN_SETTER(Setsamples);
    
    static NAN_GETTER(GetloadOp);
    static NAN_SETTER(SetloadOp);
    
    static NAN_GETTER(GetstoreOp);
    static NAN_SETTER(SetstoreOp);
    
    static NAN_GETTER(GetstencilLoadOp);
    static NAN_SETTER(SetstencilLoadOp);
    
    static NAN_GETTER(GetstencilStoreOp);
    static NAN_SETTER(SetstencilStoreOp);
    
    static NAN_GETTER(GetinitialLayout);
    static NAN_SETTER(SetinitialLayout);
    
    static NAN_GETTER(GetfinalLayout);
    static NAN_SETTER(SetfinalLayout);
    

    // real instance
    VkAttachmentDescription2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAttachmentDescription2KHR();
    ~_VkAttachmentDescription2KHR();

};

/*
#include "index.h"
#include "VkAttachmentDescription2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAttachmentDescription2KHR::constructor;

_VkAttachmentDescription2KHR::_VkAttachmentDescription2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR;
  
}

_VkAttachmentDescription2KHR::~_VkAttachmentDescription2KHR() {
  //printf("VkAttachmentDescription2KHR deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
}

void _VkAttachmentDescription2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAttachmentDescription2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAttachmentDescription2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("samples").ToLocalChecked(), Getsamples, Setsamples, ctor);
  SetPrototypeAccessor(proto, Nan::New("loadOp").ToLocalChecked(), GetloadOp, SetloadOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("storeOp").ToLocalChecked(), GetstoreOp, SetstoreOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("stencilLoadOp").ToLocalChecked(), GetstencilLoadOp, SetstencilLoadOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("stencilStoreOp").ToLocalChecked(), GetstencilStoreOp, SetstencilStoreOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("initialLayout").ToLocalChecked(), GetinitialLayout, SetinitialLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("finalLayout").ToLocalChecked(), GetfinalLayout, SetfinalLayout, ctor);
  Nan::Set(target, Nan::New("VkAttachmentDescription2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAttachmentDescription2KHR::flush() {
  _VkAttachmentDescription2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkAttachmentDescription2KHR::New) {
  if (info.IsConstructCall()) {
    _VkAttachmentDescription2KHR* self = new _VkAttachmentDescription2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("samples").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("loadOp").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("storeOp").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("stencilLoadOp").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("stencilStoreOp").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("initialLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("finalLayout").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAttachmentDescription2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkAttachmentDescription2KHR::GetsType) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkAttachmentDescription2KHR::SetsType) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkAttachmentDescription2KHR::Getflags) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkAttachmentDescription2KHR::Setflags) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkAttachmentDescriptionFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.flags", "Number");
  
    return;
  }
}// format
NAN_GETTER(_VkAttachmentDescription2KHR::Getformat) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkAttachmentDescription2KHR::Setformat) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.format", "Number");
  
    return;
  }
}// samples
NAN_GETTER(_VkAttachmentDescription2KHR::Getsamples) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.samples));
}NAN_SETTER(_VkAttachmentDescription2KHR::Setsamples) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.samples = static_cast<VkSampleCountFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.samples", "Number");
  
    return;
  }
}// loadOp
NAN_GETTER(_VkAttachmentDescription2KHR::GetloadOp) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.loadOp));
}NAN_SETTER(_VkAttachmentDescription2KHR::SetloadOp) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.loadOp = static_cast<VkAttachmentLoadOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.loadOp", "Number");
  
    return;
  }
}// storeOp
NAN_GETTER(_VkAttachmentDescription2KHR::GetstoreOp) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.storeOp));
}NAN_SETTER(_VkAttachmentDescription2KHR::SetstoreOp) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.storeOp = static_cast<VkAttachmentStoreOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.storeOp", "Number");
  
    return;
  }
}// stencilLoadOp
NAN_GETTER(_VkAttachmentDescription2KHR::GetstencilLoadOp) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stencilLoadOp));
}NAN_SETTER(_VkAttachmentDescription2KHR::SetstencilLoadOp) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.stencilLoadOp = static_cast<VkAttachmentLoadOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.stencilLoadOp", "Number");
  
    return;
  }
}// stencilStoreOp
NAN_GETTER(_VkAttachmentDescription2KHR::GetstencilStoreOp) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stencilStoreOp));
}NAN_SETTER(_VkAttachmentDescription2KHR::SetstencilStoreOp) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.stencilStoreOp = static_cast<VkAttachmentStoreOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.stencilStoreOp", "Number");
  
    return;
  }
}// initialLayout
NAN_GETTER(_VkAttachmentDescription2KHR::GetinitialLayout) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.initialLayout));
}NAN_SETTER(_VkAttachmentDescription2KHR::SetinitialLayout) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.initialLayout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.initialLayout", "Number");
  
    return;
  }
}// finalLayout
NAN_GETTER(_VkAttachmentDescription2KHR::GetfinalLayout) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.finalLayout));
}NAN_SETTER(_VkAttachmentDescription2KHR::SetfinalLayout) {
  _VkAttachmentDescription2KHR *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.finalLayout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription2KHR.finalLayout", "Number");
  
    return;
  }
}
/** ## END VkAttachmentDescription2KHR ## **/

/** ## BEGIN VkRenderPassCreateInfo2KHR ## **/

class _VkRenderPassCreateInfo2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetattachmentCount);
    static NAN_SETTER(SetattachmentCount);
    
    std::vector<VkAttachmentDescription2KHR>* vpAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAttachments;
    static NAN_GETTER(GetpAttachments);
    static NAN_SETTER(SetpAttachments);
    
    static NAN_GETTER(GetsubpassCount);
    static NAN_SETTER(SetsubpassCount);
    
    std::vector<VkSubpassDescription2KHR>* vpSubpasses;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSubpasses;
    static NAN_GETTER(GetpSubpasses);
    static NAN_SETTER(SetpSubpasses);
    
    static NAN_GETTER(GetdependencyCount);
    static NAN_SETTER(SetdependencyCount);
    
    std::vector<VkSubpassDependency2KHR>* vpDependencies;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDependencies;
    static NAN_GETTER(GetpDependencies);
    static NAN_SETTER(SetpDependencies);
    
    static NAN_GETTER(GetcorrelatedViewMaskCount);
    static NAN_SETTER(SetcorrelatedViewMaskCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pCorrelatedViewMasks;
    static NAN_GETTER(GetpCorrelatedViewMasks);
    static NAN_SETTER(SetpCorrelatedViewMasks);
    

    // real instance
    VkRenderPassCreateInfo2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassCreateInfo2KHR();
    ~_VkRenderPassCreateInfo2KHR();

};

/*
#include "index.h"
#include "VkRenderPassCreateInfo2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassCreateInfo2KHR::constructor;

_VkRenderPassCreateInfo2KHR::_VkRenderPassCreateInfo2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR;
  vpAttachments = new std::vector<VkAttachmentDescription2KHR>;
  vpSubpasses = new std::vector<VkSubpassDescription2KHR>;
  vpDependencies = new std::vector<VkSubpassDependency2KHR>;
  
}

_VkRenderPassCreateInfo2KHR::~_VkRenderPassCreateInfo2KHR() {
  //printf("VkRenderPassCreateInfo2KHR deconstructed!!\n");
  
  
  
  
  vpAttachments->clear();
  delete vpAttachments;
  
  pAttachments.Reset();
  
  
  vpSubpasses->clear();
  delete vpSubpasses;
  
  pSubpasses.Reset();
  
  
  vpDependencies->clear();
  delete vpDependencies;
  
  pDependencies.Reset();
  
  
  pCorrelatedViewMasks.Reset();
  
}

void _VkRenderPassCreateInfo2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassCreateInfo2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassCreateInfo2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("attachmentCount").ToLocalChecked(), GetattachmentCount, SetattachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAttachments").ToLocalChecked(), GetpAttachments, SetpAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("subpassCount").ToLocalChecked(), GetsubpassCount, SetsubpassCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSubpasses").ToLocalChecked(), GetpSubpasses, SetpSubpasses, ctor);
  SetPrototypeAccessor(proto, Nan::New("dependencyCount").ToLocalChecked(), GetdependencyCount, SetdependencyCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDependencies").ToLocalChecked(), GetpDependencies, SetpDependencies, ctor);
  SetPrototypeAccessor(proto, Nan::New("correlatedViewMaskCount").ToLocalChecked(), GetcorrelatedViewMaskCount, SetcorrelatedViewMaskCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pCorrelatedViewMasks").ToLocalChecked(), GetpCorrelatedViewMasks, SetpCorrelatedViewMasks, ctor);
  Nan::Set(target, Nan::New("VkRenderPassCreateInfo2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassCreateInfo2KHR::flush() {
  _VkRenderPassCreateInfo2KHR *self = this;
  if (!(self->pAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.attachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'attachmentCount' for 'VkRenderPassCreateInfo2KHR.pAttachments'");
      return false;
    }
    std::vector<VkAttachmentDescription2KHR>* data = self->vpAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentDescription2KHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pAttachments", "[object VkAttachmentDescription2KHR]");
  
        return false;
      }
      _VkAttachmentDescription2KHR* result = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription2KHR>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAttachments = data->data();
  }if (!(self->pSubpasses.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSubpasses);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.subpassCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'subpassCount' for 'VkRenderPassCreateInfo2KHR.pSubpasses'");
      return false;
    }
    std::vector<VkSubpassDescription2KHR>* data = self->vpSubpasses;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSubpassDescription2KHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pSubpasses", "[object VkSubpassDescription2KHR]");
  
        return false;
      }
      _VkSubpassDescription2KHR* result = Nan::ObjectWrap::Unwrap<_VkSubpassDescription2KHR>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSubpasses = data->data();
  }if (!(self->pDependencies.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pDependencies);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.dependencyCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'dependencyCount' for 'VkRenderPassCreateInfo2KHR.pDependencies'");
      return false;
    }
    std::vector<VkSubpassDependency2KHR>* data = self->vpDependencies;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSubpassDependency2KHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pDependencies", "[object VkSubpassDependency2KHR]");
  
        return false;
      }
      _VkSubpassDependency2KHR* result = Nan::ObjectWrap::Unwrap<_VkSubpassDependency2KHR>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDependencies = data->data();
  }
  return true;
}

NAN_METHOD(_VkRenderPassCreateInfo2KHR::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassCreateInfo2KHR* self = new _VkRenderPassCreateInfo2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("attachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("subpassCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pSubpasses").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("dependencyCount").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pDependencies").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("correlatedViewMaskCount").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("pCorrelatedViewMasks").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassCreateInfo2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetsType) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetsType) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkRenderPassCreateInfo2KHR::Getflags) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::Setflags) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkRenderPassCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.flags", "Number");
  
    return;
  }
}// attachmentCount
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetattachmentCount) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.attachmentCount));
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetattachmentCount) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.attachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.attachmentCount", "Number");
  
    return;
  }
}// pAttachments
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetpAttachments) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (self->pAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetpAttachments) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAttachments.Reset();
      self->instance.pAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pAttachments", "[object VkAttachmentDescription2KHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pAttachments", "[object VkAttachmentDescription2KHR]");
  
    return;
  }
}// subpassCount
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetsubpassCount) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subpassCount));
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetsubpassCount) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.subpassCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.subpassCount", "Number");
  
    return;
  }
}// pSubpasses
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetpSubpasses) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (self->pSubpasses.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSubpasses);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetpSubpasses) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSubpasses.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSubpasses.Reset();
      self->instance.pSubpasses = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pSubpasses", "[object VkSubpassDescription2KHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSubpasses = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pSubpasses", "[object VkSubpassDescription2KHR]");
  
    return;
  }
}// dependencyCount
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetdependencyCount) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dependencyCount));
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetdependencyCount) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.dependencyCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.dependencyCount", "Number");
  
    return;
  }
}// pDependencies
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetpDependencies) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (self->pDependencies.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDependencies);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetpDependencies) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pDependencies.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pDependencies.Reset();
      self->instance.pDependencies = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pDependencies", "[object VkSubpassDependency2KHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pDependencies = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pDependencies", "[object VkSubpassDependency2KHR]");
  
    return;
  }
}// correlatedViewMaskCount
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetcorrelatedViewMaskCount) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.correlatedViewMaskCount));
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetcorrelatedViewMaskCount) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.correlatedViewMaskCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.correlatedViewMaskCount", "Number");
  
    return;
  }
}// pCorrelatedViewMasks
NAN_GETTER(_VkRenderPassCreateInfo2KHR::GetpCorrelatedViewMasks) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  if (self->pCorrelatedViewMasks.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pCorrelatedViewMasks);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassCreateInfo2KHR::SetpCorrelatedViewMasks) {
  _VkRenderPassCreateInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo2KHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pCorrelatedViewMasks.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pCorrelatedViewMasks", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pCorrelatedViewMasks.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo2KHR.pCorrelatedViewMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pCorrelatedViewMasks = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pCorrelatedViewMasks = nullptr;
  }
}
/** ## END VkRenderPassCreateInfo2KHR ## **/

/** ## BEGIN VkDescriptorSetVariableDescriptorCountLayoutSupportEXT ## **/

class _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxVariableDescriptorCount);

    // real instance
    VkDescriptorSetVariableDescriptorCountLayoutSupportEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT();
    ~_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT();

};

/*
#include "index.h"
#include "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::constructor;

_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT;
  
}

_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::~_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT() {
  //printf("VkDescriptorSetVariableDescriptorCountLayoutSupportEXT deconstructed!!\n");
  
  
  
}

void _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetVariableDescriptorCountLayoutSupportEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxVariableDescriptorCount").ToLocalChecked(), GetmaxVariableDescriptorCount, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDescriptorSetVariableDescriptorCountLayoutSupportEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::flush() {
  _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT* self = new _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorSetVariableDescriptorCountLayoutSupportEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetsType) {
  _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxVariableDescriptorCount
NAN_GETTER(_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT::GetmaxVariableDescriptorCount) {
  _VkDescriptorSetVariableDescriptorCountLayoutSupportEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxVariableDescriptorCount));
}
/** ## END VkDescriptorSetVariableDescriptorCountLayoutSupportEXT ## **/

/** ## BEGIN VkDescriptorSetVariableDescriptorCountAllocateInfoEXT ## **/

class _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdescriptorSetCount);
    static NAN_SETTER(SetdescriptorSetCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDescriptorCounts;
    static NAN_GETTER(GetpDescriptorCounts);
    static NAN_SETTER(SetpDescriptorCounts);
    

    // real instance
    VkDescriptorSetVariableDescriptorCountAllocateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT();
    ~_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT();

};

/*
#include "index.h"
#include "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::constructor;

_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT;
  
}

_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::~_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT() {
  //printf("VkDescriptorSetVariableDescriptorCountAllocateInfoEXT deconstructed!!\n");
  
  
  
  pDescriptorCounts.Reset();
  
}

void _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetVariableDescriptorCountAllocateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorSetCount").ToLocalChecked(), GetdescriptorSetCount, SetdescriptorSetCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDescriptorCounts").ToLocalChecked(), GetpDescriptorCounts, SetpDescriptorCounts, ctor);
  Nan::Set(target, Nan::New("VkDescriptorSetVariableDescriptorCountAllocateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::flush() {
  _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT* self = new _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("descriptorSetCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pDescriptorCounts").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorSetVariableDescriptorCountAllocateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetsType) {
  _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetsType) {
  _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.sType", "Number");
  
    return;
  }
}// descriptorSetCount
NAN_GETTER(_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetdescriptorSetCount) {
  _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorSetCount));
}NAN_SETTER(_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetdescriptorSetCount) {
  _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorSetCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.descriptorSetCount", "Number");
  
    return;
  }
}// pDescriptorCounts
NAN_GETTER(_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::GetpDescriptorCounts) {
  _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>(info.This());
  if (self->pDescriptorCounts.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDescriptorCounts);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT::SetpDescriptorCounts) {
  _VkDescriptorSetVariableDescriptorCountAllocateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pDescriptorCounts.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pDescriptorCounts", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDescriptorCounts.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pDescriptorCounts", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDescriptorCounts = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pDescriptorCounts = nullptr;
  }
}
/** ## END VkDescriptorSetVariableDescriptorCountAllocateInfoEXT ## **/

/** ## BEGIN VkDescriptorSetLayoutBindingFlagsCreateInfoEXT ## **/

class _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetbindingCount);
    static NAN_SETTER(SetbindingCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pBindingFlags;
    static NAN_GETTER(GetpBindingFlags);
    static NAN_SETTER(SetpBindingFlags);
    

    // real instance
    VkDescriptorSetLayoutBindingFlagsCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT();
    ~_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT();

};

/*
#include "index.h"
#include "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::constructor;

_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT;
  
}

_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::~_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT() {
  //printf("VkDescriptorSetLayoutBindingFlagsCreateInfoEXT deconstructed!!\n");
  
  
  
  pBindingFlags.Reset();
  
}

void _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetLayoutBindingFlagsCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("bindingCount").ToLocalChecked(), GetbindingCount, SetbindingCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pBindingFlags").ToLocalChecked(), GetpBindingFlags, SetpBindingFlags, ctor);
  Nan::Set(target, Nan::New("VkDescriptorSetLayoutBindingFlagsCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::flush() {
  _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT* self = new _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("bindingCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pBindingFlags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorSetLayoutBindingFlagsCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetsType) {
  _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetsType) {
  _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.sType", "Number");
  
    return;
  }
}// bindingCount
NAN_GETTER(_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetbindingCount) {
  _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bindingCount));
}NAN_SETTER(_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetbindingCount) {
  _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.bindingCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.bindingCount", "Number");
  
    return;
  }
}// pBindingFlags
NAN_GETTER(_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::GetpBindingFlags) {
  _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>(info.This());
  if (self->pBindingFlags.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pBindingFlags);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT::SetpBindingFlags) {
  _VkDescriptorSetLayoutBindingFlagsCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pBindingFlags.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pBindingFlags", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pBindingFlags.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pBindingFlags", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pBindingFlags = reinterpret_cast<const VkDescriptorBindingFlagsEXT *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pBindingFlags = nullptr;
  }
}
/** ## END VkDescriptorSetLayoutBindingFlagsCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceDescriptorIndexingPropertiesEXT ## **/

class _VkPhysicalDeviceDescriptorIndexingPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxUpdateAfterBindDescriptorsInAllPools);
    static NAN_GETTER(GetshaderUniformBufferArrayNonUniformIndexingNative);
    static NAN_GETTER(GetshaderSampledImageArrayNonUniformIndexingNative);
    static NAN_GETTER(GetshaderStorageBufferArrayNonUniformIndexingNative);
    static NAN_GETTER(GetshaderStorageImageArrayNonUniformIndexingNative);
    static NAN_GETTER(GetshaderInputAttachmentArrayNonUniformIndexingNative);
    static NAN_GETTER(GetrobustBufferAccessUpdateAfterBind);
    static NAN_GETTER(GetquadDivergentImplicitLod);
    static NAN_GETTER(GetmaxPerStageDescriptorUpdateAfterBindSamplers);
    static NAN_GETTER(GetmaxPerStageDescriptorUpdateAfterBindUniformBuffers);
    static NAN_GETTER(GetmaxPerStageDescriptorUpdateAfterBindStorageBuffers);
    static NAN_GETTER(GetmaxPerStageDescriptorUpdateAfterBindSampledImages);
    static NAN_GETTER(GetmaxPerStageDescriptorUpdateAfterBindStorageImages);
    static NAN_GETTER(GetmaxPerStageDescriptorUpdateAfterBindInputAttachments);
    static NAN_GETTER(GetmaxPerStageUpdateAfterBindResources);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindSamplers);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindUniformBuffers);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindStorageBuffers);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindSampledImages);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindStorageImages);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindInputAttachments);

    // real instance
    VkPhysicalDeviceDescriptorIndexingPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceDescriptorIndexingPropertiesEXT();
    ~_VkPhysicalDeviceDescriptorIndexingPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceDescriptorIndexingPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::constructor;

_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::_VkPhysicalDeviceDescriptorIndexingPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::~_VkPhysicalDeviceDescriptorIndexingPropertiesEXT() {
  //printf("VkPhysicalDeviceDescriptorIndexingPropertiesEXT deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceDescriptorIndexingPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxUpdateAfterBindDescriptorsInAllPools").ToLocalChecked(), GetmaxUpdateAfterBindDescriptorsInAllPools, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderUniformBufferArrayNonUniformIndexingNative").ToLocalChecked(), GetshaderUniformBufferArrayNonUniformIndexingNative, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderSampledImageArrayNonUniformIndexingNative").ToLocalChecked(), GetshaderSampledImageArrayNonUniformIndexingNative, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageBufferArrayNonUniformIndexingNative").ToLocalChecked(), GetshaderStorageBufferArrayNonUniformIndexingNative, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageImageArrayNonUniformIndexingNative").ToLocalChecked(), GetshaderStorageImageArrayNonUniformIndexingNative, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderInputAttachmentArrayNonUniformIndexingNative").ToLocalChecked(), GetshaderInputAttachmentArrayNonUniformIndexingNative, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("robustBufferAccessUpdateAfterBind").ToLocalChecked(), GetrobustBufferAccessUpdateAfterBind, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("quadDivergentImplicitLod").ToLocalChecked(), GetquadDivergentImplicitLod, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorUpdateAfterBindSamplers").ToLocalChecked(), GetmaxPerStageDescriptorUpdateAfterBindSamplers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorUpdateAfterBindUniformBuffers").ToLocalChecked(), GetmaxPerStageDescriptorUpdateAfterBindUniformBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorUpdateAfterBindStorageBuffers").ToLocalChecked(), GetmaxPerStageDescriptorUpdateAfterBindStorageBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorUpdateAfterBindSampledImages").ToLocalChecked(), GetmaxPerStageDescriptorUpdateAfterBindSampledImages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorUpdateAfterBindStorageImages").ToLocalChecked(), GetmaxPerStageDescriptorUpdateAfterBindStorageImages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorUpdateAfterBindInputAttachments").ToLocalChecked(), GetmaxPerStageDescriptorUpdateAfterBindInputAttachments, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageUpdateAfterBindResources").ToLocalChecked(), GetmaxPerStageUpdateAfterBindResources, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindSamplers").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindSamplers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindUniformBuffers").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindUniformBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindUniformBuffersDynamic").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindStorageBuffers").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindStorageBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindStorageBuffersDynamic").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindSampledImages").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindSampledImages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindStorageImages").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindStorageImages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindInputAttachments").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindInputAttachments, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceDescriptorIndexingPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceDescriptorIndexingPropertiesEXT::flush() {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceDescriptorIndexingPropertiesEXT* self = new _VkPhysicalDeviceDescriptorIndexingPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceDescriptorIndexingPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetsType) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxUpdateAfterBindDescriptorsInAllPools
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxUpdateAfterBindDescriptorsInAllPools) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxUpdateAfterBindDescriptorsInAllPools));
}// shaderUniformBufferArrayNonUniformIndexingNative
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderUniformBufferArrayNonUniformIndexingNative) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderUniformBufferArrayNonUniformIndexingNative));
}// shaderSampledImageArrayNonUniformIndexingNative
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderSampledImageArrayNonUniformIndexingNative) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderSampledImageArrayNonUniformIndexingNative));
}// shaderStorageBufferArrayNonUniformIndexingNative
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderStorageBufferArrayNonUniformIndexingNative) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageBufferArrayNonUniformIndexingNative));
}// shaderStorageImageArrayNonUniformIndexingNative
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderStorageImageArrayNonUniformIndexingNative) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageImageArrayNonUniformIndexingNative));
}// shaderInputAttachmentArrayNonUniformIndexingNative
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetshaderInputAttachmentArrayNonUniformIndexingNative) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderInputAttachmentArrayNonUniformIndexingNative));
}// robustBufferAccessUpdateAfterBind
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetrobustBufferAccessUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.robustBufferAccessUpdateAfterBind));
}// quadDivergentImplicitLod
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetquadDivergentImplicitLod) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.quadDivergentImplicitLod));
}// maxPerStageDescriptorUpdateAfterBindSamplers
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindSamplers) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorUpdateAfterBindSamplers));
}// maxPerStageDescriptorUpdateAfterBindUniformBuffers
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindUniformBuffers) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorUpdateAfterBindUniformBuffers));
}// maxPerStageDescriptorUpdateAfterBindStorageBuffers
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindStorageBuffers) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorUpdateAfterBindStorageBuffers));
}// maxPerStageDescriptorUpdateAfterBindSampledImages
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindSampledImages) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorUpdateAfterBindSampledImages));
}// maxPerStageDescriptorUpdateAfterBindStorageImages
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindStorageImages) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorUpdateAfterBindStorageImages));
}// maxPerStageDescriptorUpdateAfterBindInputAttachments
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindInputAttachments) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorUpdateAfterBindInputAttachments));
}// maxPerStageUpdateAfterBindResources
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxPerStageUpdateAfterBindResources) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageUpdateAfterBindResources));
}// maxDescriptorSetUpdateAfterBindSamplers
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindSamplers) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindSamplers));
}// maxDescriptorSetUpdateAfterBindUniformBuffers
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindUniformBuffers) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindUniformBuffers));
}// maxDescriptorSetUpdateAfterBindUniformBuffersDynamic
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindUniformBuffersDynamic) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic));
}// maxDescriptorSetUpdateAfterBindStorageBuffers
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageBuffers) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindStorageBuffers));
}// maxDescriptorSetUpdateAfterBindStorageBuffersDynamic
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageBuffersDynamic) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic));
}// maxDescriptorSetUpdateAfterBindSampledImages
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindSampledImages) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindSampledImages));
}// maxDescriptorSetUpdateAfterBindStorageImages
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindStorageImages) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindStorageImages));
}// maxDescriptorSetUpdateAfterBindInputAttachments
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindInputAttachments) {
  _VkPhysicalDeviceDescriptorIndexingPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindInputAttachments));
}
/** ## END VkPhysicalDeviceDescriptorIndexingPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceDescriptorIndexingFeaturesEXT ## **/

class _VkPhysicalDeviceDescriptorIndexingFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetshaderInputAttachmentArrayDynamicIndexing);
    static NAN_SETTER(SetshaderInputAttachmentArrayDynamicIndexing);
    
    static NAN_GETTER(GetshaderUniformTexelBufferArrayDynamicIndexing);
    static NAN_SETTER(SetshaderUniformTexelBufferArrayDynamicIndexing);
    
    static NAN_GETTER(GetshaderStorageTexelBufferArrayDynamicIndexing);
    static NAN_SETTER(SetshaderStorageTexelBufferArrayDynamicIndexing);
    
    static NAN_GETTER(GetshaderUniformBufferArrayNonUniformIndexing);
    static NAN_SETTER(SetshaderUniformBufferArrayNonUniformIndexing);
    
    static NAN_GETTER(GetshaderSampledImageArrayNonUniformIndexing);
    static NAN_SETTER(SetshaderSampledImageArrayNonUniformIndexing);
    
    static NAN_GETTER(GetshaderStorageBufferArrayNonUniformIndexing);
    static NAN_SETTER(SetshaderStorageBufferArrayNonUniformIndexing);
    
    static NAN_GETTER(GetshaderStorageImageArrayNonUniformIndexing);
    static NAN_SETTER(SetshaderStorageImageArrayNonUniformIndexing);
    
    static NAN_GETTER(GetshaderInputAttachmentArrayNonUniformIndexing);
    static NAN_SETTER(SetshaderInputAttachmentArrayNonUniformIndexing);
    
    static NAN_GETTER(GetshaderUniformTexelBufferArrayNonUniformIndexing);
    static NAN_SETTER(SetshaderUniformTexelBufferArrayNonUniformIndexing);
    
    static NAN_GETTER(GetshaderStorageTexelBufferArrayNonUniformIndexing);
    static NAN_SETTER(SetshaderStorageTexelBufferArrayNonUniformIndexing);
    
    static NAN_GETTER(GetdescriptorBindingUniformBufferUpdateAfterBind);
    static NAN_SETTER(SetdescriptorBindingUniformBufferUpdateAfterBind);
    
    static NAN_GETTER(GetdescriptorBindingSampledImageUpdateAfterBind);
    static NAN_SETTER(SetdescriptorBindingSampledImageUpdateAfterBind);
    
    static NAN_GETTER(GetdescriptorBindingStorageImageUpdateAfterBind);
    static NAN_SETTER(SetdescriptorBindingStorageImageUpdateAfterBind);
    
    static NAN_GETTER(GetdescriptorBindingStorageBufferUpdateAfterBind);
    static NAN_SETTER(SetdescriptorBindingStorageBufferUpdateAfterBind);
    
    static NAN_GETTER(GetdescriptorBindingUniformTexelBufferUpdateAfterBind);
    static NAN_SETTER(SetdescriptorBindingUniformTexelBufferUpdateAfterBind);
    
    static NAN_GETTER(GetdescriptorBindingStorageTexelBufferUpdateAfterBind);
    static NAN_SETTER(SetdescriptorBindingStorageTexelBufferUpdateAfterBind);
    
    static NAN_GETTER(GetdescriptorBindingUpdateUnusedWhilePending);
    static NAN_SETTER(SetdescriptorBindingUpdateUnusedWhilePending);
    
    static NAN_GETTER(GetdescriptorBindingPartiallyBound);
    static NAN_SETTER(SetdescriptorBindingPartiallyBound);
    
    static NAN_GETTER(GetdescriptorBindingVariableDescriptorCount);
    static NAN_SETTER(SetdescriptorBindingVariableDescriptorCount);
    
    static NAN_GETTER(GetruntimeDescriptorArray);
    static NAN_SETTER(SetruntimeDescriptorArray);
    

    // real instance
    VkPhysicalDeviceDescriptorIndexingFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceDescriptorIndexingFeaturesEXT();
    ~_VkPhysicalDeviceDescriptorIndexingFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::constructor;

_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::_VkPhysicalDeviceDescriptorIndexingFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT;
  
}

_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::~_VkPhysicalDeviceDescriptorIndexingFeaturesEXT() {
  //printf("VkPhysicalDeviceDescriptorIndexingFeaturesEXT deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceDescriptorIndexingFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderInputAttachmentArrayDynamicIndexing").ToLocalChecked(), GetshaderInputAttachmentArrayDynamicIndexing, SetshaderInputAttachmentArrayDynamicIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderUniformTexelBufferArrayDynamicIndexing").ToLocalChecked(), GetshaderUniformTexelBufferArrayDynamicIndexing, SetshaderUniformTexelBufferArrayDynamicIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageTexelBufferArrayDynamicIndexing").ToLocalChecked(), GetshaderStorageTexelBufferArrayDynamicIndexing, SetshaderStorageTexelBufferArrayDynamicIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderUniformBufferArrayNonUniformIndexing").ToLocalChecked(), GetshaderUniformBufferArrayNonUniformIndexing, SetshaderUniformBufferArrayNonUniformIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderSampledImageArrayNonUniformIndexing").ToLocalChecked(), GetshaderSampledImageArrayNonUniformIndexing, SetshaderSampledImageArrayNonUniformIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageBufferArrayNonUniformIndexing").ToLocalChecked(), GetshaderStorageBufferArrayNonUniformIndexing, SetshaderStorageBufferArrayNonUniformIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageImageArrayNonUniformIndexing").ToLocalChecked(), GetshaderStorageImageArrayNonUniformIndexing, SetshaderStorageImageArrayNonUniformIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderInputAttachmentArrayNonUniformIndexing").ToLocalChecked(), GetshaderInputAttachmentArrayNonUniformIndexing, SetshaderInputAttachmentArrayNonUniformIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderUniformTexelBufferArrayNonUniformIndexing").ToLocalChecked(), GetshaderUniformTexelBufferArrayNonUniformIndexing, SetshaderUniformTexelBufferArrayNonUniformIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageTexelBufferArrayNonUniformIndexing").ToLocalChecked(), GetshaderStorageTexelBufferArrayNonUniformIndexing, SetshaderStorageTexelBufferArrayNonUniformIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingUniformBufferUpdateAfterBind").ToLocalChecked(), GetdescriptorBindingUniformBufferUpdateAfterBind, SetdescriptorBindingUniformBufferUpdateAfterBind, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingSampledImageUpdateAfterBind").ToLocalChecked(), GetdescriptorBindingSampledImageUpdateAfterBind, SetdescriptorBindingSampledImageUpdateAfterBind, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingStorageImageUpdateAfterBind").ToLocalChecked(), GetdescriptorBindingStorageImageUpdateAfterBind, SetdescriptorBindingStorageImageUpdateAfterBind, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingStorageBufferUpdateAfterBind").ToLocalChecked(), GetdescriptorBindingStorageBufferUpdateAfterBind, SetdescriptorBindingStorageBufferUpdateAfterBind, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingUniformTexelBufferUpdateAfterBind").ToLocalChecked(), GetdescriptorBindingUniformTexelBufferUpdateAfterBind, SetdescriptorBindingUniformTexelBufferUpdateAfterBind, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingStorageTexelBufferUpdateAfterBind").ToLocalChecked(), GetdescriptorBindingStorageTexelBufferUpdateAfterBind, SetdescriptorBindingStorageTexelBufferUpdateAfterBind, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingUpdateUnusedWhilePending").ToLocalChecked(), GetdescriptorBindingUpdateUnusedWhilePending, SetdescriptorBindingUpdateUnusedWhilePending, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingPartiallyBound").ToLocalChecked(), GetdescriptorBindingPartiallyBound, SetdescriptorBindingPartiallyBound, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingVariableDescriptorCount").ToLocalChecked(), GetdescriptorBindingVariableDescriptorCount, SetdescriptorBindingVariableDescriptorCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("runtimeDescriptorArray").ToLocalChecked(), GetruntimeDescriptorArray, SetruntimeDescriptorArray, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceDescriptorIndexingFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceDescriptorIndexingFeaturesEXT::flush() {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceDescriptorIndexingFeaturesEXT* self = new _VkPhysicalDeviceDescriptorIndexingFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("shaderInputAttachmentArrayDynamicIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("shaderUniformTexelBufferArrayDynamicIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("shaderStorageTexelBufferArrayDynamicIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("shaderUniformBufferArrayNonUniformIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("shaderSampledImageArrayNonUniformIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("shaderStorageBufferArrayNonUniformIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("shaderStorageImageArrayNonUniformIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("shaderInputAttachmentArrayNonUniformIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("shaderUniformTexelBufferArrayNonUniformIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("shaderStorageTexelBufferArrayNonUniformIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("descriptorBindingUniformBufferUpdateAfterBind").ToLocalChecked();
      v8::Local<v8::String> sAccess13 = Nan::New("descriptorBindingSampledImageUpdateAfterBind").ToLocalChecked();
      v8::Local<v8::String> sAccess14 = Nan::New("descriptorBindingStorageImageUpdateAfterBind").ToLocalChecked();
      v8::Local<v8::String> sAccess15 = Nan::New("descriptorBindingStorageBufferUpdateAfterBind").ToLocalChecked();
      v8::Local<v8::String> sAccess16 = Nan::New("descriptorBindingUniformTexelBufferUpdateAfterBind").ToLocalChecked();
      v8::Local<v8::String> sAccess17 = Nan::New("descriptorBindingStorageTexelBufferUpdateAfterBind").ToLocalChecked();
      v8::Local<v8::String> sAccess18 = Nan::New("descriptorBindingUpdateUnusedWhilePending").ToLocalChecked();
      v8::Local<v8::String> sAccess19 = Nan::New("descriptorBindingPartiallyBound").ToLocalChecked();
      v8::Local<v8::String> sAccess20 = Nan::New("descriptorBindingVariableDescriptorCount").ToLocalChecked();
      v8::Local<v8::String> sAccess21 = Nan::New("runtimeDescriptorArray").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      if (obj->Has(sAccess13)) info.This()->Set(sAccess13, obj->Get(sAccess13));
      if (obj->Has(sAccess14)) info.This()->Set(sAccess14, obj->Get(sAccess14));
      if (obj->Has(sAccess15)) info.This()->Set(sAccess15, obj->Get(sAccess15));
      if (obj->Has(sAccess16)) info.This()->Set(sAccess16, obj->Get(sAccess16));
      if (obj->Has(sAccess17)) info.This()->Set(sAccess17, obj->Get(sAccess17));
      if (obj->Has(sAccess18)) info.This()->Set(sAccess18, obj->Get(sAccess18));
      if (obj->Has(sAccess19)) info.This()->Set(sAccess19, obj->Get(sAccess19));
      if (obj->Has(sAccess20)) info.This()->Set(sAccess20, obj->Get(sAccess20));
      if (obj->Has(sAccess21)) info.This()->Set(sAccess21, obj->Get(sAccess21));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceDescriptorIndexingFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetsType) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetsType) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.sType", "Number");
  
    return;
  }
}// shaderInputAttachmentArrayDynamicIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderInputAttachmentArrayDynamicIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderInputAttachmentArrayDynamicIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderInputAttachmentArrayDynamicIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderInputAttachmentArrayDynamicIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderInputAttachmentArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderUniformTexelBufferArrayDynamicIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformTexelBufferArrayDynamicIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderUniformTexelBufferArrayDynamicIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformTexelBufferArrayDynamicIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderUniformTexelBufferArrayDynamicIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderUniformTexelBufferArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderStorageTexelBufferArrayDynamicIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageTexelBufferArrayDynamicIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageTexelBufferArrayDynamicIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageTexelBufferArrayDynamicIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageTexelBufferArrayDynamicIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderStorageTexelBufferArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderUniformBufferArrayNonUniformIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformBufferArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderUniformBufferArrayNonUniformIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformBufferArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderUniformBufferArrayNonUniformIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderUniformBufferArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderSampledImageArrayNonUniformIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderSampledImageArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderSampledImageArrayNonUniformIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderSampledImageArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderSampledImageArrayNonUniformIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderSampledImageArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderStorageBufferArrayNonUniformIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageBufferArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageBufferArrayNonUniformIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageBufferArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageBufferArrayNonUniformIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderStorageBufferArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderStorageImageArrayNonUniformIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageImageArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageImageArrayNonUniformIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageImageArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageImageArrayNonUniformIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderStorageImageArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderInputAttachmentArrayNonUniformIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderInputAttachmentArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderInputAttachmentArrayNonUniformIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderInputAttachmentArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderInputAttachmentArrayNonUniformIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderInputAttachmentArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderUniformTexelBufferArrayNonUniformIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderUniformTexelBufferArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderUniformTexelBufferArrayNonUniformIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderUniformTexelBufferArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderUniformTexelBufferArrayNonUniformIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderUniformTexelBufferArrayNonUniformIndexing", "Number");
  
    return;
  }
}// shaderStorageTexelBufferArrayNonUniformIndexing
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetshaderStorageTexelBufferArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageTexelBufferArrayNonUniformIndexing));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetshaderStorageTexelBufferArrayNonUniformIndexing) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageTexelBufferArrayNonUniformIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.shaderStorageTexelBufferArrayNonUniformIndexing", "Number");
  
    return;
  }
}// descriptorBindingUniformBufferUpdateAfterBind
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUniformBufferUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingUniformBufferUpdateAfterBind));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUniformBufferUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingUniformBufferUpdateAfterBind = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingUniformBufferUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingSampledImageUpdateAfterBind
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingSampledImageUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingSampledImageUpdateAfterBind));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingSampledImageUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingSampledImageUpdateAfterBind = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingSampledImageUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingStorageImageUpdateAfterBind
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageImageUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingStorageImageUpdateAfterBind));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageImageUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingStorageImageUpdateAfterBind = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingStorageImageUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingStorageBufferUpdateAfterBind
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageBufferUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingStorageBufferUpdateAfterBind));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageBufferUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingStorageBufferUpdateAfterBind = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingStorageBufferUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingUniformTexelBufferUpdateAfterBind
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUniformTexelBufferUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingUniformTexelBufferUpdateAfterBind));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUniformTexelBufferUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingUniformTexelBufferUpdateAfterBind = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingUniformTexelBufferUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingStorageTexelBufferUpdateAfterBind
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingStorageTexelBufferUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingStorageTexelBufferUpdateAfterBind));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingStorageTexelBufferUpdateAfterBind) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingStorageTexelBufferUpdateAfterBind = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingStorageTexelBufferUpdateAfterBind", "Number");
  
    return;
  }
}// descriptorBindingUpdateUnusedWhilePending
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingUpdateUnusedWhilePending) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingUpdateUnusedWhilePending));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingUpdateUnusedWhilePending) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingUpdateUnusedWhilePending = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingUpdateUnusedWhilePending", "Number");
  
    return;
  }
}// descriptorBindingPartiallyBound
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingPartiallyBound) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingPartiallyBound));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingPartiallyBound) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingPartiallyBound = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingPartiallyBound", "Number");
  
    return;
  }
}// descriptorBindingVariableDescriptorCount
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetdescriptorBindingVariableDescriptorCount) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingVariableDescriptorCount));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetdescriptorBindingVariableDescriptorCount) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingVariableDescriptorCount = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.descriptorBindingVariableDescriptorCount", "Number");
  
    return;
  }
}// runtimeDescriptorArray
NAN_GETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::GetruntimeDescriptorArray) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.runtimeDescriptorArray));
}NAN_SETTER(_VkPhysicalDeviceDescriptorIndexingFeaturesEXT::SetruntimeDescriptorArray) {
  _VkPhysicalDeviceDescriptorIndexingFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.runtimeDescriptorArray = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT.runtimeDescriptorArray", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceDescriptorIndexingFeaturesEXT ## **/

/** ## BEGIN VkPipelineRasterizationConservativeStateCreateInfoEXT ## **/

class _VkPipelineRasterizationConservativeStateCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetconservativeRasterizationMode);
    static NAN_SETTER(SetconservativeRasterizationMode);
    
    static NAN_GETTER(GetextraPrimitiveOverestimationSize);
    static NAN_SETTER(SetextraPrimitiveOverestimationSize);
    

    // real instance
    VkPipelineRasterizationConservativeStateCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineRasterizationConservativeStateCreateInfoEXT();
    ~_VkPipelineRasterizationConservativeStateCreateInfoEXT();

};

/*
#include "index.h"
#include "VkPipelineRasterizationConservativeStateCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineRasterizationConservativeStateCreateInfoEXT::constructor;

_VkPipelineRasterizationConservativeStateCreateInfoEXT::_VkPipelineRasterizationConservativeStateCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT;
  
}

_VkPipelineRasterizationConservativeStateCreateInfoEXT::~_VkPipelineRasterizationConservativeStateCreateInfoEXT() {
  //printf("VkPipelineRasterizationConservativeStateCreateInfoEXT deconstructed!!\n");
  
  
  
  
  
}

void _VkPipelineRasterizationConservativeStateCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineRasterizationConservativeStateCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineRasterizationConservativeStateCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("conservativeRasterizationMode").ToLocalChecked(), GetconservativeRasterizationMode, SetconservativeRasterizationMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("extraPrimitiveOverestimationSize").ToLocalChecked(), GetextraPrimitiveOverestimationSize, SetextraPrimitiveOverestimationSize, ctor);
  Nan::Set(target, Nan::New("VkPipelineRasterizationConservativeStateCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineRasterizationConservativeStateCreateInfoEXT::flush() {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineRasterizationConservativeStateCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkPipelineRasterizationConservativeStateCreateInfoEXT* self = new _VkPipelineRasterizationConservativeStateCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("conservativeRasterizationMode").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("extraPrimitiveOverestimationSize").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineRasterizationConservativeStateCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetsType) {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineRasterizationConservativeStateCreateInfoEXT::SetsType) {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineRasterizationConservativeStateCreateInfoEXT::Getflags) {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineRasterizationConservativeStateCreateInfoEXT::Setflags) {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineRasterizationConservativeStateCreateFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.flags", "Number");
  
    return;
  }
}// conservativeRasterizationMode
NAN_GETTER(_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetconservativeRasterizationMode) {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.conservativeRasterizationMode));
}NAN_SETTER(_VkPipelineRasterizationConservativeStateCreateInfoEXT::SetconservativeRasterizationMode) {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.conservativeRasterizationMode = static_cast<VkConservativeRasterizationModeEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.conservativeRasterizationMode", "Number");
  
    return;
  }
}// extraPrimitiveOverestimationSize
NAN_GETTER(_VkPipelineRasterizationConservativeStateCreateInfoEXT::GetextraPrimitiveOverestimationSize) {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.extraPrimitiveOverestimationSize));
}NAN_SETTER(_VkPipelineRasterizationConservativeStateCreateInfoEXT::SetextraPrimitiveOverestimationSize) {
  _VkPipelineRasterizationConservativeStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationConservativeStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.extraPrimitiveOverestimationSize = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationConservativeStateCreateInfoEXT.extraPrimitiveOverestimationSize", "Number");
  
    return;
  }
}
/** ## END VkPipelineRasterizationConservativeStateCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceShaderCorePropertiesAMD ## **/

class _VkPhysicalDeviceShaderCorePropertiesAMD: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetshaderEngineCount);
    static NAN_GETTER(GetshaderArraysPerEngineCount);
    static NAN_GETTER(GetcomputeUnitsPerShaderArray);
    static NAN_GETTER(GetsimdPerComputeUnit);
    static NAN_GETTER(GetwavefrontsPerSimd);
    static NAN_GETTER(GetwavefrontSize);
    static NAN_GETTER(GetsgprsPerSimd);
    static NAN_GETTER(GetminSgprAllocation);
    static NAN_GETTER(GetmaxSgprAllocation);
    static NAN_GETTER(GetsgprAllocationGranularity);
    static NAN_GETTER(GetvgprsPerSimd);
    static NAN_GETTER(GetminVgprAllocation);
    static NAN_GETTER(GetmaxVgprAllocation);
    static NAN_GETTER(GetvgprAllocationGranularity);

    // real instance
    VkPhysicalDeviceShaderCorePropertiesAMD instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceShaderCorePropertiesAMD();
    ~_VkPhysicalDeviceShaderCorePropertiesAMD();

};

/*
#include "index.h"
#include "VkPhysicalDeviceShaderCorePropertiesAMD.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceShaderCorePropertiesAMD::constructor;

_VkPhysicalDeviceShaderCorePropertiesAMD::_VkPhysicalDeviceShaderCorePropertiesAMD() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
  
}

_VkPhysicalDeviceShaderCorePropertiesAMD::~_VkPhysicalDeviceShaderCorePropertiesAMD() {
  //printf("VkPhysicalDeviceShaderCorePropertiesAMD deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceShaderCorePropertiesAMD::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceShaderCorePropertiesAMD::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceShaderCorePropertiesAMD").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderEngineCount").ToLocalChecked(), GetshaderEngineCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderArraysPerEngineCount").ToLocalChecked(), GetshaderArraysPerEngineCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("computeUnitsPerShaderArray").ToLocalChecked(), GetcomputeUnitsPerShaderArray, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("simdPerComputeUnit").ToLocalChecked(), GetsimdPerComputeUnit, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("wavefrontsPerSimd").ToLocalChecked(), GetwavefrontsPerSimd, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("wavefrontSize").ToLocalChecked(), GetwavefrontSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sgprsPerSimd").ToLocalChecked(), GetsgprsPerSimd, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minSgprAllocation").ToLocalChecked(), GetminSgprAllocation, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSgprAllocation").ToLocalChecked(), GetmaxSgprAllocation, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sgprAllocationGranularity").ToLocalChecked(), GetsgprAllocationGranularity, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("vgprsPerSimd").ToLocalChecked(), GetvgprsPerSimd, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minVgprAllocation").ToLocalChecked(), GetminVgprAllocation, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxVgprAllocation").ToLocalChecked(), GetmaxVgprAllocation, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("vgprAllocationGranularity").ToLocalChecked(), GetvgprAllocationGranularity, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceShaderCorePropertiesAMD").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceShaderCorePropertiesAMD::flush() {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceShaderCorePropertiesAMD::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceShaderCorePropertiesAMD* self = new _VkPhysicalDeviceShaderCorePropertiesAMD();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceShaderCorePropertiesAMD constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetsType) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// shaderEngineCount
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetshaderEngineCount) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderEngineCount));
}// shaderArraysPerEngineCount
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetshaderArraysPerEngineCount) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderArraysPerEngineCount));
}// computeUnitsPerShaderArray
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetcomputeUnitsPerShaderArray) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.computeUnitsPerShaderArray));
}// simdPerComputeUnit
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetsimdPerComputeUnit) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.simdPerComputeUnit));
}// wavefrontsPerSimd
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetwavefrontsPerSimd) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.wavefrontsPerSimd));
}// wavefrontSize
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetwavefrontSize) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.wavefrontSize));
}// sgprsPerSimd
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetsgprsPerSimd) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sgprsPerSimd));
}// minSgprAllocation
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetminSgprAllocation) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minSgprAllocation));
}// maxSgprAllocation
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetmaxSgprAllocation) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSgprAllocation));
}// sgprAllocationGranularity
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetsgprAllocationGranularity) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sgprAllocationGranularity));
}// vgprsPerSimd
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetvgprsPerSimd) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vgprsPerSimd));
}// minVgprAllocation
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetminVgprAllocation) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minVgprAllocation));
}// maxVgprAllocation
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetmaxVgprAllocation) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxVgprAllocation));
}// vgprAllocationGranularity
NAN_GETTER(_VkPhysicalDeviceShaderCorePropertiesAMD::GetvgprAllocationGranularity) {
  _VkPhysicalDeviceShaderCorePropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderCorePropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vgprAllocationGranularity));
}
/** ## END VkPhysicalDeviceShaderCorePropertiesAMD ## **/

/** ## BEGIN VkCalibratedTimestampInfoEXT ## **/

class _VkCalibratedTimestampInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GettimeDomain);
    static NAN_SETTER(SettimeDomain);
    

    // real instance
    VkCalibratedTimestampInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCalibratedTimestampInfoEXT();
    ~_VkCalibratedTimestampInfoEXT();

};

/*
#include "index.h"
#include "VkCalibratedTimestampInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCalibratedTimestampInfoEXT::constructor;

_VkCalibratedTimestampInfoEXT::_VkCalibratedTimestampInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT;
  
}

_VkCalibratedTimestampInfoEXT::~_VkCalibratedTimestampInfoEXT() {
  //printf("VkCalibratedTimestampInfoEXT deconstructed!!\n");
  
  
  
}

void _VkCalibratedTimestampInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCalibratedTimestampInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCalibratedTimestampInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("timeDomain").ToLocalChecked(), GettimeDomain, SettimeDomain, ctor);
  Nan::Set(target, Nan::New("VkCalibratedTimestampInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCalibratedTimestampInfoEXT::flush() {
  _VkCalibratedTimestampInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkCalibratedTimestampInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkCalibratedTimestampInfoEXT* self = new _VkCalibratedTimestampInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("timeDomain").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCalibratedTimestampInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCalibratedTimestampInfoEXT::GetsType) {
  _VkCalibratedTimestampInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkCalibratedTimestampInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCalibratedTimestampInfoEXT::SetsType) {
  _VkCalibratedTimestampInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkCalibratedTimestampInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCalibratedTimestampInfoEXT.sType", "Number");
  
    return;
  }
}// timeDomain
NAN_GETTER(_VkCalibratedTimestampInfoEXT::GettimeDomain) {
  _VkCalibratedTimestampInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkCalibratedTimestampInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.timeDomain));
}NAN_SETTER(_VkCalibratedTimestampInfoEXT::SettimeDomain) {
  _VkCalibratedTimestampInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkCalibratedTimestampInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.timeDomain = static_cast<VkTimeDomainEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCalibratedTimestampInfoEXT.timeDomain", "Number");
  
    return;
  }
}
/** ## END VkCalibratedTimestampInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceConservativeRasterizationPropertiesEXT ## **/

class _VkPhysicalDeviceConservativeRasterizationPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetprimitiveOverestimationSize);
    static NAN_GETTER(GetmaxExtraPrimitiveOverestimationSize);
    static NAN_GETTER(GetextraPrimitiveOverestimationSizeGranularity);
    static NAN_GETTER(GetprimitiveUnderestimation);
    static NAN_GETTER(GetconservativePointAndLineRasterization);
    static NAN_GETTER(GetdegenerateTrianglesRasterized);
    static NAN_GETTER(GetdegenerateLinesRasterized);
    static NAN_GETTER(GetfullyCoveredFragmentShaderInputVariable);
    static NAN_GETTER(GetconservativeRasterizationPostDepthCoverage);

    // real instance
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceConservativeRasterizationPropertiesEXT();
    ~_VkPhysicalDeviceConservativeRasterizationPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceConservativeRasterizationPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::constructor;

_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::_VkPhysicalDeviceConservativeRasterizationPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::~_VkPhysicalDeviceConservativeRasterizationPropertiesEXT() {
  //printf("VkPhysicalDeviceConservativeRasterizationPropertiesEXT deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceConservativeRasterizationPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("primitiveOverestimationSize").ToLocalChecked(), GetprimitiveOverestimationSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxExtraPrimitiveOverestimationSize").ToLocalChecked(), GetmaxExtraPrimitiveOverestimationSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("extraPrimitiveOverestimationSizeGranularity").ToLocalChecked(), GetextraPrimitiveOverestimationSizeGranularity, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("primitiveUnderestimation").ToLocalChecked(), GetprimitiveUnderestimation, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("conservativePointAndLineRasterization").ToLocalChecked(), GetconservativePointAndLineRasterization, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("degenerateTrianglesRasterized").ToLocalChecked(), GetdegenerateTrianglesRasterized, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("degenerateLinesRasterized").ToLocalChecked(), GetdegenerateLinesRasterized, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("fullyCoveredFragmentShaderInputVariable").ToLocalChecked(), GetfullyCoveredFragmentShaderInputVariable, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("conservativeRasterizationPostDepthCoverage").ToLocalChecked(), GetconservativeRasterizationPostDepthCoverage, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceConservativeRasterizationPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceConservativeRasterizationPropertiesEXT::flush() {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceConservativeRasterizationPropertiesEXT* self = new _VkPhysicalDeviceConservativeRasterizationPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceConservativeRasterizationPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetsType) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// primitiveOverestimationSize
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetprimitiveOverestimationSize) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.primitiveOverestimationSize));
}// maxExtraPrimitiveOverestimationSize
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetmaxExtraPrimitiveOverestimationSize) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxExtraPrimitiveOverestimationSize));
}// extraPrimitiveOverestimationSizeGranularity
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetextraPrimitiveOverestimationSizeGranularity) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.extraPrimitiveOverestimationSizeGranularity));
}// primitiveUnderestimation
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetprimitiveUnderestimation) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.primitiveUnderestimation));
}// conservativePointAndLineRasterization
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetconservativePointAndLineRasterization) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.conservativePointAndLineRasterization));
}// degenerateTrianglesRasterized
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetdegenerateTrianglesRasterized) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.degenerateTrianglesRasterized));
}// degenerateLinesRasterized
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetdegenerateLinesRasterized) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.degenerateLinesRasterized));
}// fullyCoveredFragmentShaderInputVariable
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetfullyCoveredFragmentShaderInputVariable) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fullyCoveredFragmentShaderInputVariable));
}// conservativeRasterizationPostDepthCoverage
NAN_GETTER(_VkPhysicalDeviceConservativeRasterizationPropertiesEXT::GetconservativeRasterizationPostDepthCoverage) {
  _VkPhysicalDeviceConservativeRasterizationPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.conservativeRasterizationPostDepthCoverage));
}
/** ## END VkPhysicalDeviceConservativeRasterizationPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceExternalMemoryHostPropertiesEXT ## **/

class _VkPhysicalDeviceExternalMemoryHostPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetminImportedHostPointerAlignment);

    // real instance
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalMemoryHostPropertiesEXT();
    ~_VkPhysicalDeviceExternalMemoryHostPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalMemoryHostPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::constructor;

_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::_VkPhysicalDeviceExternalMemoryHostPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::~_VkPhysicalDeviceExternalMemoryHostPropertiesEXT() {
  //printf("VkPhysicalDeviceExternalMemoryHostPropertiesEXT deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalMemoryHostPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minImportedHostPointerAlignment").ToLocalChecked(), GetminImportedHostPointerAlignment, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalMemoryHostPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalMemoryHostPropertiesEXT::flush() {
  _VkPhysicalDeviceExternalMemoryHostPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalMemoryHostPropertiesEXT* self = new _VkPhysicalDeviceExternalMemoryHostPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalMemoryHostPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetsType) {
  _VkPhysicalDeviceExternalMemoryHostPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// minImportedHostPointerAlignment
NAN_GETTER(_VkPhysicalDeviceExternalMemoryHostPropertiesEXT::GetminImportedHostPointerAlignment) {
  _VkPhysicalDeviceExternalMemoryHostPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minImportedHostPointerAlignment));
}
/** ## END VkPhysicalDeviceExternalMemoryHostPropertiesEXT ## **/

/** ## BEGIN VkMemoryHostPointerPropertiesEXT ## **/

class _VkMemoryHostPointerPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmemoryTypeBits);

    // real instance
    VkMemoryHostPointerPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryHostPointerPropertiesEXT();
    ~_VkMemoryHostPointerPropertiesEXT();

};

/*
#include "index.h"
#include "VkMemoryHostPointerPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryHostPointerPropertiesEXT::constructor;

_VkMemoryHostPointerPropertiesEXT::_VkMemoryHostPointerPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT;
  
}

_VkMemoryHostPointerPropertiesEXT::~_VkMemoryHostPointerPropertiesEXT() {
  //printf("VkMemoryHostPointerPropertiesEXT deconstructed!!\n");
  
  
  
}

void _VkMemoryHostPointerPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryHostPointerPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryHostPointerPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryTypeBits").ToLocalChecked(), GetmemoryTypeBits, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMemoryHostPointerPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryHostPointerPropertiesEXT::flush() {
  _VkMemoryHostPointerPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryHostPointerPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkMemoryHostPointerPropertiesEXT* self = new _VkMemoryHostPointerPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryHostPointerPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryHostPointerPropertiesEXT::GetsType) {
  _VkMemoryHostPointerPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkMemoryHostPointerPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// memoryTypeBits
NAN_GETTER(_VkMemoryHostPointerPropertiesEXT::GetmemoryTypeBits) {
  _VkMemoryHostPointerPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkMemoryHostPointerPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryTypeBits));
}
/** ## END VkMemoryHostPointerPropertiesEXT ## **/

/** ## BEGIN VkImportMemoryHostPointerInfoEXT ## **/

class _VkImportMemoryHostPointerInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkImportMemoryHostPointerInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImportMemoryHostPointerInfoEXT();
    ~_VkImportMemoryHostPointerInfoEXT();

};

/*
#include "index.h"
#include "VkImportMemoryHostPointerInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImportMemoryHostPointerInfoEXT::constructor;

_VkImportMemoryHostPointerInfoEXT::_VkImportMemoryHostPointerInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
  
}

_VkImportMemoryHostPointerInfoEXT::~_VkImportMemoryHostPointerInfoEXT() {
  //printf("VkImportMemoryHostPointerInfoEXT deconstructed!!\n");
  
  
  
}

void _VkImportMemoryHostPointerInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImportMemoryHostPointerInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImportMemoryHostPointerInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkImportMemoryHostPointerInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImportMemoryHostPointerInfoEXT::flush() {
  _VkImportMemoryHostPointerInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkImportMemoryHostPointerInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkImportMemoryHostPointerInfoEXT* self = new _VkImportMemoryHostPointerInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImportMemoryHostPointerInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImportMemoryHostPointerInfoEXT::GetsType) {
  _VkImportMemoryHostPointerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryHostPointerInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImportMemoryHostPointerInfoEXT::SetsType) {
  _VkImportMemoryHostPointerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryHostPointerInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryHostPointerInfoEXT.sType", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkImportMemoryHostPointerInfoEXT::GethandleType) {
  _VkImportMemoryHostPointerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryHostPointerInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkImportMemoryHostPointerInfoEXT::SethandleType) {
  _VkImportMemoryHostPointerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryHostPointerInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryHostPointerInfoEXT.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportMemoryHostPointerInfoEXT ## **/

/** ## BEGIN VkDebugUtilsObjectNameInfoEXT ## **/

class _VkDebugUtilsObjectNameInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetobjectType);
    static NAN_SETTER(SetobjectType);
    
    static NAN_GETTER(GetobjectHandle);
    static NAN_SETTER(SetobjectHandle);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pObjectName;
    static NAN_GETTER(GetpObjectName);
    static NAN_SETTER(SetpObjectName);
    

    // real instance
    VkDebugUtilsObjectNameInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugUtilsObjectNameInfoEXT();
    ~_VkDebugUtilsObjectNameInfoEXT();

};

/*
#include "index.h"
#include "VkDebugUtilsObjectNameInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugUtilsObjectNameInfoEXT::constructor;

_VkDebugUtilsObjectNameInfoEXT::_VkDebugUtilsObjectNameInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT;
  
}

_VkDebugUtilsObjectNameInfoEXT::~_VkDebugUtilsObjectNameInfoEXT() {
  //printf("VkDebugUtilsObjectNameInfoEXT deconstructed!!\n");
  
  
  
  
  pObjectName.Reset();
  
}

void _VkDebugUtilsObjectNameInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugUtilsObjectNameInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugUtilsObjectNameInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectType").ToLocalChecked(), GetobjectType, SetobjectType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectHandle").ToLocalChecked(), GetobjectHandle, SetobjectHandle, ctor);
  SetPrototypeAccessor(proto, Nan::New("pObjectName").ToLocalChecked(), GetpObjectName, SetpObjectName, ctor);
  Nan::Set(target, Nan::New("VkDebugUtilsObjectNameInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugUtilsObjectNameInfoEXT::flush() {
  _VkDebugUtilsObjectNameInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDebugUtilsObjectNameInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugUtilsObjectNameInfoEXT* self = new _VkDebugUtilsObjectNameInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("objectType").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("objectHandle").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pObjectName").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugUtilsObjectNameInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugUtilsObjectNameInfoEXT::GetsType) {
  _VkDebugUtilsObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugUtilsObjectNameInfoEXT::SetsType) {
  _VkDebugUtilsObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectNameInfoEXT.sType", "Number");
  
    return;
  }
}// objectType
NAN_GETTER(_VkDebugUtilsObjectNameInfoEXT::GetobjectType) {
  _VkDebugUtilsObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.objectType));
}NAN_SETTER(_VkDebugUtilsObjectNameInfoEXT::SetobjectType) {
  _VkDebugUtilsObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.objectType = static_cast<VkObjectType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectNameInfoEXT.objectType", "Number");
  
    return;
  }
}// objectHandle
NAN_GETTER(_VkDebugUtilsObjectNameInfoEXT::GetobjectHandle) {
  _VkDebugUtilsObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.objectHandle));
}NAN_SETTER(_VkDebugUtilsObjectNameInfoEXT::SetobjectHandle) {
  _VkDebugUtilsObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.objectHandle = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectNameInfoEXT.objectHandle", "Number");
  
    return;
  }
}// pObjectName
NAN_GETTER(_VkDebugUtilsObjectNameInfoEXT::GetpObjectName) {
  _VkDebugUtilsObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(info.This());
  if (self->pObjectName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pObjectName);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkDebugUtilsObjectNameInfoEXT::SetpObjectName) {
  _VkDebugUtilsObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pObjectName = str;
    // free previous
    if (self->instance.pObjectName) {
      delete[] self->instance.pObjectName;
    }
    self->instance.pObjectName = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pObjectName = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectNameInfoEXT.pObjectName", "String");
  
    return;
  }
}
/** ## END VkDebugUtilsObjectNameInfoEXT ## **/

/** ## BEGIN VkDebugUtilsLabelEXT ## **/

class _VkDebugUtilsLabelEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pLabelName;
    static NAN_GETTER(GetpLabelName);
    static NAN_SETTER(SetpLabelName);
    
    std::vector<float>* vcolor;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> color;
    static NAN_GETTER(Getcolor);
    static NAN_SETTER(Setcolor);
    

    // real instance
    VkDebugUtilsLabelEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugUtilsLabelEXT();
    ~_VkDebugUtilsLabelEXT();

};

/*
#include <string.h>
#include "index.h"
#include "VkDebugUtilsLabelEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugUtilsLabelEXT::constructor;

_VkDebugUtilsLabelEXT::_VkDebugUtilsLabelEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT;
  vcolor = new std::vector<float>;
  
}

_VkDebugUtilsLabelEXT::~_VkDebugUtilsLabelEXT() {
  //printf("VkDebugUtilsLabelEXT deconstructed!!\n");
  
  
  pLabelName.Reset();
  
  vcolor->clear();
  delete vcolor;
  
  
}

void _VkDebugUtilsLabelEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugUtilsLabelEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugUtilsLabelEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("pLabelName").ToLocalChecked(), GetpLabelName, SetpLabelName, ctor);
  SetPrototypeAccessor(proto, Nan::New("color").ToLocalChecked(), Getcolor, Setcolor, ctor);
  Nan::Set(target, Nan::New("VkDebugUtilsLabelEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugUtilsLabelEXT::flush() {
  _VkDebugUtilsLabelEXT *self = this;
  if (!(self->color.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->color);
    
    if (value->IsArray()) {
      // validate length
      if (v8::Local<v8::Array>::Cast(value)->Length() != 4) {
        Nan::ThrowRangeError("Invalid array length, expected array length of '4' for 'VkDebugUtilsLabelEXT.color'");
        return false;
      }
      std::vector<float> array = createArrayOfV8Numbers<float>(value);
      memcpy(self->instance.color, array.data(), sizeof(float) * 4);
    } else if (value->IsNull()) {
      memset(&self->instance.color, 0, sizeof(float));
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsLabelEXT.color", "Array");
  
      return false;
    }
  }
  return true;
}

NAN_METHOD(_VkDebugUtilsLabelEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugUtilsLabelEXT* self = new _VkDebugUtilsLabelEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pLabelName").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("color").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugUtilsLabelEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugUtilsLabelEXT::GetsType) {
  _VkDebugUtilsLabelEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsLabelEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugUtilsLabelEXT::SetsType) {
  _VkDebugUtilsLabelEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsLabelEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsLabelEXT.sType", "Number");
  
    return;
  }
}// pLabelName
NAN_GETTER(_VkDebugUtilsLabelEXT::GetpLabelName) {
  _VkDebugUtilsLabelEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsLabelEXT>(info.This());
  if (self->pLabelName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pLabelName);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkDebugUtilsLabelEXT::SetpLabelName) {
  _VkDebugUtilsLabelEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsLabelEXT>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pLabelName = str;
    // free previous
    if (self->instance.pLabelName) {
      delete[] self->instance.pLabelName;
    }
    self->instance.pLabelName = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pLabelName = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsLabelEXT.pLabelName", "String");
  
    return;
  }
}// color
NAN_GETTER(_VkDebugUtilsLabelEXT::Getcolor) {
  _VkDebugUtilsLabelEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsLabelEXT>(info.This());
  if (self->color.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->color));
  }
}NAN_SETTER(_VkDebugUtilsLabelEXT::Setcolor) {
  _VkDebugUtilsLabelEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsLabelEXT>(info.This());
  // js
  if (value->IsArray()) {
    self->color.Reset<v8::Array>(value.As<v8::Array>());
  } else if (value->IsNull()) {
    self->color.Reset();
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsLabelEXT.color", "Array");
  
    return;
  }
}
/** ## END VkDebugUtilsLabelEXT ## **/

/** ## BEGIN VkDebugUtilsMessengerCallbackDataEXT ## **/

class _VkDebugUtilsMessengerCallbackDataEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pMessageIdName;
    static NAN_GETTER(GetpMessageIdName);
    static NAN_SETTER(SetpMessageIdName);
    
    static NAN_GETTER(GetmessageIdNumber);
    static NAN_SETTER(SetmessageIdNumber);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pMessage;
    static NAN_GETTER(GetpMessage);
    static NAN_SETTER(SetpMessage);
    
    static NAN_GETTER(GetqueueLabelCount);
    static NAN_SETTER(SetqueueLabelCount);
    
    std::vector<VkDebugUtilsLabelEXT>* vpQueueLabels;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pQueueLabels;
    static NAN_GETTER(GetpQueueLabels);
    static NAN_SETTER(SetpQueueLabels);
    
    static NAN_GETTER(GetcmdBufLabelCount);
    static NAN_SETTER(SetcmdBufLabelCount);
    
    std::vector<VkDebugUtilsLabelEXT>* vpCmdBufLabels;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pCmdBufLabels;
    static NAN_GETTER(GetpCmdBufLabels);
    static NAN_SETTER(SetpCmdBufLabels);
    
    static NAN_GETTER(GetobjectCount);
    static NAN_SETTER(SetobjectCount);
    
    std::vector<VkDebugUtilsObjectNameInfoEXT>* vpObjects;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pObjects;
    static NAN_GETTER(GetpObjects);
    static NAN_SETTER(SetpObjects);
    

    // real instance
    VkDebugUtilsMessengerCallbackDataEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugUtilsMessengerCallbackDataEXT();
    ~_VkDebugUtilsMessengerCallbackDataEXT();

};

/*
#include "index.h"
#include "VkDebugUtilsMessengerCallbackDataEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugUtilsMessengerCallbackDataEXT::constructor;

_VkDebugUtilsMessengerCallbackDataEXT::_VkDebugUtilsMessengerCallbackDataEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
  vpQueueLabels = new std::vector<VkDebugUtilsLabelEXT>;
  vpCmdBufLabels = new std::vector<VkDebugUtilsLabelEXT>;
  vpObjects = new std::vector<VkDebugUtilsObjectNameInfoEXT>;
  
}

_VkDebugUtilsMessengerCallbackDataEXT::~_VkDebugUtilsMessengerCallbackDataEXT() {
  //printf("VkDebugUtilsMessengerCallbackDataEXT deconstructed!!\n");
  
  
  
  pMessageIdName.Reset();
  
  
  pMessage.Reset();
  
  
  vpQueueLabels->clear();
  delete vpQueueLabels;
  
  pQueueLabels.Reset();
  
  
  vpCmdBufLabels->clear();
  delete vpCmdBufLabels;
  
  pCmdBufLabels.Reset();
  
  
  vpObjects->clear();
  delete vpObjects;
  
  pObjects.Reset();
  
}

void _VkDebugUtilsMessengerCallbackDataEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugUtilsMessengerCallbackDataEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugUtilsMessengerCallbackDataEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pMessageIdName").ToLocalChecked(), GetpMessageIdName, SetpMessageIdName, ctor);
  SetPrototypeAccessor(proto, Nan::New("messageIdNumber").ToLocalChecked(), GetmessageIdNumber, SetmessageIdNumber, ctor);
  SetPrototypeAccessor(proto, Nan::New("pMessage").ToLocalChecked(), GetpMessage, SetpMessage, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueLabelCount").ToLocalChecked(), GetqueueLabelCount, SetqueueLabelCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pQueueLabels").ToLocalChecked(), GetpQueueLabels, SetpQueueLabels, ctor);
  SetPrototypeAccessor(proto, Nan::New("cmdBufLabelCount").ToLocalChecked(), GetcmdBufLabelCount, SetcmdBufLabelCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pCmdBufLabels").ToLocalChecked(), GetpCmdBufLabels, SetpCmdBufLabels, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectCount").ToLocalChecked(), GetobjectCount, SetobjectCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pObjects").ToLocalChecked(), GetpObjects, SetpObjects, ctor);
  Nan::Set(target, Nan::New("VkDebugUtilsMessengerCallbackDataEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugUtilsMessengerCallbackDataEXT::flush() {
  _VkDebugUtilsMessengerCallbackDataEXT *self = this;
  if (!(self->pQueueLabels.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pQueueLabels);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.queueLabelCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'queueLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels'");
      return false;
    }
    std::vector<VkDebugUtilsLabelEXT>* data = self->vpQueueLabels;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDebugUtilsLabelEXT::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels", "[object VkDebugUtilsLabelEXT]");
  
        return false;
      }
      _VkDebugUtilsLabelEXT* result = Nan::ObjectWrap::Unwrap<_VkDebugUtilsLabelEXT>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pQueueLabels = data->data();
  }if (!(self->pCmdBufLabels.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pCmdBufLabels);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.cmdBufLabelCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'cmdBufLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels'");
      return false;
    }
    std::vector<VkDebugUtilsLabelEXT>* data = self->vpCmdBufLabels;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDebugUtilsLabelEXT::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels", "[object VkDebugUtilsLabelEXT]");
  
        return false;
      }
      _VkDebugUtilsLabelEXT* result = Nan::ObjectWrap::Unwrap<_VkDebugUtilsLabelEXT>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pCmdBufLabels = data->data();
  }if (!(self->pObjects.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pObjects);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.objectCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'objectCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects'");
      return false;
    }
    std::vector<VkDebugUtilsObjectNameInfoEXT>* data = self->vpObjects;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDebugUtilsObjectNameInfoEXT::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pObjects", "[object VkDebugUtilsObjectNameInfoEXT]");
  
        return false;
      }
      _VkDebugUtilsObjectNameInfoEXT* result = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectNameInfoEXT>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pObjects = data->data();
  }
  return true;
}

NAN_METHOD(_VkDebugUtilsMessengerCallbackDataEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugUtilsMessengerCallbackDataEXT* self = new _VkDebugUtilsMessengerCallbackDataEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pMessageIdName").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("messageIdNumber").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pMessage").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("queueLabelCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pQueueLabels").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("cmdBufLabelCount").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("pCmdBufLabels").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("objectCount").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("pObjects").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugUtilsMessengerCallbackDataEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetsType) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetsType) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::Getflags) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::Setflags) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDebugUtilsMessengerCallbackDataFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.flags", "Number");
  
    return;
  }
}// pMessageIdName
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetpMessageIdName) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (self->pMessageIdName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pMessageIdName);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetpMessageIdName) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pMessageIdName = str;
    // free previous
    if (self->instance.pMessageIdName) {
      delete[] self->instance.pMessageIdName;
    }
    self->instance.pMessageIdName = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pMessageIdName = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pMessageIdName", "String");
  
    return;
  }
}// messageIdNumber
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetmessageIdNumber) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.messageIdNumber));
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetmessageIdNumber) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.messageIdNumber = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.messageIdNumber", "Number");
  
    return;
  }
}// pMessage
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetpMessage) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (self->pMessage.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pMessage);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetpMessage) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pMessage = str;
    // free previous
    if (self->instance.pMessage) {
      delete[] self->instance.pMessage;
    }
    self->instance.pMessage = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pMessage = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pMessage", "String");
  
    return;
  }
}// queueLabelCount
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetqueueLabelCount) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueLabelCount));
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetqueueLabelCount) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.queueLabelCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.queueLabelCount", "Number");
  
    return;
  }
}// pQueueLabels
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetpQueueLabels) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (self->pQueueLabels.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pQueueLabels);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetpQueueLabels) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pQueueLabels.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pQueueLabels.Reset();
      self->instance.pQueueLabels = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels", "[object VkDebugUtilsLabelEXT]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pQueueLabels = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels", "[object VkDebugUtilsLabelEXT]");
  
    return;
  }
}// cmdBufLabelCount
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetcmdBufLabelCount) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.cmdBufLabelCount));
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetcmdBufLabelCount) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.cmdBufLabelCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.cmdBufLabelCount", "Number");
  
    return;
  }
}// pCmdBufLabels
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetpCmdBufLabels) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (self->pCmdBufLabels.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pCmdBufLabels);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetpCmdBufLabels) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pCmdBufLabels.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pCmdBufLabels.Reset();
      self->instance.pCmdBufLabels = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels", "[object VkDebugUtilsLabelEXT]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pCmdBufLabels = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels", "[object VkDebugUtilsLabelEXT]");
  
    return;
  }
}// objectCount
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetobjectCount) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.objectCount));
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetobjectCount) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.objectCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.objectCount", "Number");
  
    return;
  }
}// pObjects
NAN_GETTER(_VkDebugUtilsMessengerCallbackDataEXT::GetpObjects) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  if (self->pObjects.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pObjects);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDebugUtilsMessengerCallbackDataEXT::SetpObjects) {
  _VkDebugUtilsMessengerCallbackDataEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCallbackDataEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pObjects.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pObjects.Reset();
      self->instance.pObjects = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pObjects", "[object VkDebugUtilsObjectNameInfoEXT]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pObjects = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCallbackDataEXT.pObjects", "[object VkDebugUtilsObjectNameInfoEXT]");
  
    return;
  }
}
/** ## END VkDebugUtilsMessengerCallbackDataEXT ## **/

/** ## BEGIN VkDebugUtilsMessengerCreateInfoEXT ## **/

class _VkDebugUtilsMessengerCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetmessageSeverity);
    static NAN_SETTER(SetmessageSeverity);
    
    static NAN_GETTER(GetmessageType);
    static NAN_SETTER(SetmessageType);
    

    // real instance
    VkDebugUtilsMessengerCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugUtilsMessengerCreateInfoEXT();
    ~_VkDebugUtilsMessengerCreateInfoEXT();

};

/*
#include "index.h"
#include "VkDebugUtilsMessengerCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugUtilsMessengerCreateInfoEXT::constructor;

_VkDebugUtilsMessengerCreateInfoEXT::_VkDebugUtilsMessengerCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
  
}

_VkDebugUtilsMessengerCreateInfoEXT::~_VkDebugUtilsMessengerCreateInfoEXT() {
  //printf("VkDebugUtilsMessengerCreateInfoEXT deconstructed!!\n");
  
  
  
  
  
}

void _VkDebugUtilsMessengerCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugUtilsMessengerCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugUtilsMessengerCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("messageSeverity").ToLocalChecked(), GetmessageSeverity, SetmessageSeverity, ctor);
  SetPrototypeAccessor(proto, Nan::New("messageType").ToLocalChecked(), GetmessageType, SetmessageType, ctor);
  Nan::Set(target, Nan::New("VkDebugUtilsMessengerCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugUtilsMessengerCreateInfoEXT::flush() {
  _VkDebugUtilsMessengerCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDebugUtilsMessengerCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugUtilsMessengerCreateInfoEXT* self = new _VkDebugUtilsMessengerCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("messageSeverity").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("messageType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugUtilsMessengerCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugUtilsMessengerCreateInfoEXT::GetsType) {
  _VkDebugUtilsMessengerCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugUtilsMessengerCreateInfoEXT::SetsType) {
  _VkDebugUtilsMessengerCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDebugUtilsMessengerCreateInfoEXT::Getflags) {
  _VkDebugUtilsMessengerCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDebugUtilsMessengerCreateInfoEXT::Setflags) {
  _VkDebugUtilsMessengerCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDebugUtilsMessengerCreateFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.flags", "Number");
  
    return;
  }
}// messageSeverity
NAN_GETTER(_VkDebugUtilsMessengerCreateInfoEXT::GetmessageSeverity) {
  _VkDebugUtilsMessengerCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.messageSeverity));
}NAN_SETTER(_VkDebugUtilsMessengerCreateInfoEXT::SetmessageSeverity) {
  _VkDebugUtilsMessengerCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.messageSeverity = static_cast<VkDebugUtilsMessageSeverityFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.messageSeverity", "Number");
  
    return;
  }
}// messageType
NAN_GETTER(_VkDebugUtilsMessengerCreateInfoEXT::GetmessageType) {
  _VkDebugUtilsMessengerCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.messageType));
}NAN_SETTER(_VkDebugUtilsMessengerCreateInfoEXT::SetmessageType) {
  _VkDebugUtilsMessengerCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsMessengerCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.messageType = static_cast<VkDebugUtilsMessageTypeFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsMessengerCreateInfoEXT.messageType", "Number");
  
    return;
  }
}
/** ## END VkDebugUtilsMessengerCreateInfoEXT ## **/

/** ## BEGIN VkDebugUtilsObjectTagInfoEXT ## **/

class _VkDebugUtilsObjectTagInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetobjectType);
    static NAN_SETTER(SetobjectType);
    
    static NAN_GETTER(GetobjectHandle);
    static NAN_SETTER(SetobjectHandle);
    
    static NAN_GETTER(GettagName);
    static NAN_SETTER(SettagName);
    
    static NAN_GETTER(GettagSize);
    static NAN_SETTER(SettagSize);
    
    Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pTag;
    static NAN_GETTER(GetpTag);
    static NAN_SETTER(SetpTag);
    

    // real instance
    VkDebugUtilsObjectTagInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugUtilsObjectTagInfoEXT();
    ~_VkDebugUtilsObjectTagInfoEXT();

};

/*
#include "index.h"
#include "VkDebugUtilsObjectTagInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugUtilsObjectTagInfoEXT::constructor;

_VkDebugUtilsObjectTagInfoEXT::_VkDebugUtilsObjectTagInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT;
  
}

_VkDebugUtilsObjectTagInfoEXT::~_VkDebugUtilsObjectTagInfoEXT() {
  //printf("VkDebugUtilsObjectTagInfoEXT deconstructed!!\n");
  
  
  
  
  
  
  pTag.Reset();
  
}

void _VkDebugUtilsObjectTagInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugUtilsObjectTagInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugUtilsObjectTagInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectType").ToLocalChecked(), GetobjectType, SetobjectType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectHandle").ToLocalChecked(), GetobjectHandle, SetobjectHandle, ctor);
  SetPrototypeAccessor(proto, Nan::New("tagName").ToLocalChecked(), GettagName, SettagName, ctor);
  SetPrototypeAccessor(proto, Nan::New("tagSize").ToLocalChecked(), GettagSize, SettagSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("pTag").ToLocalChecked(), GetpTag, SetpTag, ctor);
  Nan::Set(target, Nan::New("VkDebugUtilsObjectTagInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugUtilsObjectTagInfoEXT::flush() {
  _VkDebugUtilsObjectTagInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDebugUtilsObjectTagInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugUtilsObjectTagInfoEXT* self = new _VkDebugUtilsObjectTagInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("objectType").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("objectHandle").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("tagName").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("tagSize").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pTag").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugUtilsObjectTagInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugUtilsObjectTagInfoEXT::GetsType) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugUtilsObjectTagInfoEXT::SetsType) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectTagInfoEXT.sType", "Number");
  
    return;
  }
}// objectType
NAN_GETTER(_VkDebugUtilsObjectTagInfoEXT::GetobjectType) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.objectType));
}NAN_SETTER(_VkDebugUtilsObjectTagInfoEXT::SetobjectType) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.objectType = static_cast<VkObjectType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectTagInfoEXT.objectType", "Number");
  
    return;
  }
}// objectHandle
NAN_GETTER(_VkDebugUtilsObjectTagInfoEXT::GetobjectHandle) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.objectHandle));
}NAN_SETTER(_VkDebugUtilsObjectTagInfoEXT::SetobjectHandle) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.objectHandle = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectTagInfoEXT.objectHandle", "Number");
  
    return;
  }
}// tagName
NAN_GETTER(_VkDebugUtilsObjectTagInfoEXT::GettagName) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tagName));
}NAN_SETTER(_VkDebugUtilsObjectTagInfoEXT::SettagName) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.tagName = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectTagInfoEXT.tagName", "Number");
  
    return;
  }
}// tagSize
NAN_GETTER(_VkDebugUtilsObjectTagInfoEXT::GettagSize) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tagSize));
}NAN_SETTER(_VkDebugUtilsObjectTagInfoEXT::SettagSize) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.tagSize = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugUtilsObjectTagInfoEXT.tagSize", "Number");
  
    return;
  }
}// pTag
NAN_GETTER(_VkDebugUtilsObjectTagInfoEXT::GetpTag) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
}NAN_SETTER(_VkDebugUtilsObjectTagInfoEXT::SetpTag) {
  _VkDebugUtilsObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugUtilsObjectTagInfoEXT>(info.This());
}
/** ## END VkDebugUtilsObjectTagInfoEXT ## **/

/** ## BEGIN VkDeviceQueueGlobalPriorityCreateInfoEXT ## **/

class _VkDeviceQueueGlobalPriorityCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetglobalPriority);
    static NAN_SETTER(SetglobalPriority);
    

    // real instance
    VkDeviceQueueGlobalPriorityCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceQueueGlobalPriorityCreateInfoEXT();
    ~_VkDeviceQueueGlobalPriorityCreateInfoEXT();

};

/*
#include "index.h"
#include "VkDeviceQueueGlobalPriorityCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceQueueGlobalPriorityCreateInfoEXT::constructor;

_VkDeviceQueueGlobalPriorityCreateInfoEXT::_VkDeviceQueueGlobalPriorityCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT;
  
}

_VkDeviceQueueGlobalPriorityCreateInfoEXT::~_VkDeviceQueueGlobalPriorityCreateInfoEXT() {
  //printf("VkDeviceQueueGlobalPriorityCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkDeviceQueueGlobalPriorityCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceQueueGlobalPriorityCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceQueueGlobalPriorityCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("globalPriority").ToLocalChecked(), GetglobalPriority, SetglobalPriority, ctor);
  Nan::Set(target, Nan::New("VkDeviceQueueGlobalPriorityCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceQueueGlobalPriorityCreateInfoEXT::flush() {
  _VkDeviceQueueGlobalPriorityCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceQueueGlobalPriorityCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDeviceQueueGlobalPriorityCreateInfoEXT* self = new _VkDeviceQueueGlobalPriorityCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("globalPriority").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceQueueGlobalPriorityCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceQueueGlobalPriorityCreateInfoEXT::GetsType) {
  _VkDeviceQueueGlobalPriorityCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueGlobalPriorityCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceQueueGlobalPriorityCreateInfoEXT::SetsType) {
  _VkDeviceQueueGlobalPriorityCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueGlobalPriorityCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueGlobalPriorityCreateInfoEXT.sType", "Number");
  
    return;
  }
}// globalPriority
NAN_GETTER(_VkDeviceQueueGlobalPriorityCreateInfoEXT::GetglobalPriority) {
  _VkDeviceQueueGlobalPriorityCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueGlobalPriorityCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.globalPriority));
}NAN_SETTER(_VkDeviceQueueGlobalPriorityCreateInfoEXT::SetglobalPriority) {
  _VkDeviceQueueGlobalPriorityCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueGlobalPriorityCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.globalPriority = static_cast<VkQueueGlobalPriorityEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueGlobalPriorityCreateInfoEXT.globalPriority", "Number");
  
    return;
  }
}
/** ## END VkDeviceQueueGlobalPriorityCreateInfoEXT ## **/

/** ## BEGIN VkShaderResourceUsageAMD ## **/

class _VkShaderResourceUsageAMD: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetnumUsedVgprs);
    static NAN_GETTER(GetnumUsedSgprs);
    static NAN_GETTER(GetldsSizePerLocalWorkGroup);
    static NAN_GETTER(GetldsUsageSizeInBytes);
    static NAN_GETTER(GetscratchMemUsageInBytes);

    // real instance
    VkShaderResourceUsageAMD instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkShaderResourceUsageAMD();
    ~_VkShaderResourceUsageAMD();

};

/*
#include "index.h"
#include "VkShaderResourceUsageAMD.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkShaderResourceUsageAMD::constructor;

_VkShaderResourceUsageAMD::_VkShaderResourceUsageAMD() {
  
  
}

_VkShaderResourceUsageAMD::~_VkShaderResourceUsageAMD() {
  //printf("VkShaderResourceUsageAMD deconstructed!!\n");
  
  
  
  
  
  
}

void _VkShaderResourceUsageAMD::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkShaderResourceUsageAMD::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkShaderResourceUsageAMD").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("numUsedVgprs").ToLocalChecked(), GetnumUsedVgprs, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("numUsedSgprs").ToLocalChecked(), GetnumUsedSgprs, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("ldsSizePerLocalWorkGroup").ToLocalChecked(), GetldsSizePerLocalWorkGroup, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("ldsUsageSizeInBytes").ToLocalChecked(), GetldsUsageSizeInBytes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("scratchMemUsageInBytes").ToLocalChecked(), GetscratchMemUsageInBytes, nullptr, ctor);
  Nan::Set(target, Nan::New("VkShaderResourceUsageAMD").ToLocalChecked(), ctor->GetFunction());
}

bool _VkShaderResourceUsageAMD::flush() {
  _VkShaderResourceUsageAMD *self = this;
  
  return true;
}

NAN_METHOD(_VkShaderResourceUsageAMD::New) {
  if (info.IsConstructCall()) {
    _VkShaderResourceUsageAMD* self = new _VkShaderResourceUsageAMD();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkShaderResourceUsageAMD constructor cannot be invoked without 'new'");
  }
};

// numUsedVgprs
NAN_GETTER(_VkShaderResourceUsageAMD::GetnumUsedVgprs) {
  _VkShaderResourceUsageAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderResourceUsageAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.numUsedVgprs));
}// numUsedSgprs
NAN_GETTER(_VkShaderResourceUsageAMD::GetnumUsedSgprs) {
  _VkShaderResourceUsageAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderResourceUsageAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.numUsedSgprs));
}// ldsSizePerLocalWorkGroup
NAN_GETTER(_VkShaderResourceUsageAMD::GetldsSizePerLocalWorkGroup) {
  _VkShaderResourceUsageAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderResourceUsageAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.ldsSizePerLocalWorkGroup));
}// ldsUsageSizeInBytes
NAN_GETTER(_VkShaderResourceUsageAMD::GetldsUsageSizeInBytes) {
  _VkShaderResourceUsageAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderResourceUsageAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.ldsUsageSizeInBytes));
}// scratchMemUsageInBytes
NAN_GETTER(_VkShaderResourceUsageAMD::GetscratchMemUsageInBytes) {
  _VkShaderResourceUsageAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderResourceUsageAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.scratchMemUsageInBytes));
}
/** ## END VkShaderResourceUsageAMD ## **/

/** ## BEGIN VkShaderStatisticsInfoAMD ## **/

class _VkShaderStatisticsInfoAMD: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetshaderStageMask);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> resourceUsage;
      static NAN_GETTER(GetresourceUsage);
    static NAN_GETTER(GetnumPhysicalVgprs);
    static NAN_GETTER(GetnumPhysicalSgprs);
    static NAN_GETTER(GetnumAvailableVgprs);
    static NAN_GETTER(GetnumAvailableSgprs);
    std::vector<uint32_t>* vcomputeWorkGroupSize;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> computeWorkGroupSize;
    static NAN_GETTER(GetcomputeWorkGroupSize);

    // real instance
    VkShaderStatisticsInfoAMD instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkShaderStatisticsInfoAMD();
    ~_VkShaderStatisticsInfoAMD();

};

/*
#include <string.h>
#include "index.h"
#include "VkShaderStatisticsInfoAMD.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkShaderStatisticsInfoAMD::constructor;

_VkShaderStatisticsInfoAMD::_VkShaderStatisticsInfoAMD() {
  
  vcomputeWorkGroupSize = new std::vector<uint32_t>;
  
}

_VkShaderStatisticsInfoAMD::~_VkShaderStatisticsInfoAMD() {
  //printf("VkShaderStatisticsInfoAMD deconstructed!!\n");
  
  
  
  
  
  
  
  vcomputeWorkGroupSize->clear();
  delete vcomputeWorkGroupSize;
  
  
}

void _VkShaderStatisticsInfoAMD::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkShaderStatisticsInfoAMD::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkShaderStatisticsInfoAMD").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("shaderStageMask").ToLocalChecked(), GetshaderStageMask, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("resourceUsage").ToLocalChecked(), GetresourceUsage, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("numPhysicalVgprs").ToLocalChecked(), GetnumPhysicalVgprs, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("numPhysicalSgprs").ToLocalChecked(), GetnumPhysicalSgprs, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("numAvailableVgprs").ToLocalChecked(), GetnumAvailableVgprs, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("numAvailableSgprs").ToLocalChecked(), GetnumAvailableSgprs, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("computeWorkGroupSize").ToLocalChecked(), GetcomputeWorkGroupSize, nullptr, ctor);
  Nan::Set(target, Nan::New("VkShaderStatisticsInfoAMD").ToLocalChecked(), ctor->GetFunction());
}

bool _VkShaderStatisticsInfoAMD::flush() {
  _VkShaderStatisticsInfoAMD *self = this;
  if (!(self->resourceUsage.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->resourceUsage);
    
  }if (!(self->computeWorkGroupSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->computeWorkGroupSize);
    
  }
  return true;
}

NAN_METHOD(_VkShaderStatisticsInfoAMD::New) {
  if (info.IsConstructCall()) {
    _VkShaderStatisticsInfoAMD* self = new _VkShaderStatisticsInfoAMD();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkShaderStatisticsInfoAMD constructor cannot be invoked without 'new'");
  }
};

// shaderStageMask
NAN_GETTER(_VkShaderStatisticsInfoAMD::GetshaderStageMask) {
  _VkShaderStatisticsInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderStatisticsInfoAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStageMask));
}// resourceUsage
NAN_GETTER(_VkShaderStatisticsInfoAMD::GetresourceUsage) {
  _VkShaderStatisticsInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderStatisticsInfoAMD>(info.This());
  if (self->resourceUsage.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->resourceUsage);
    info.GetReturnValue().Set(obj);
  }
}// numPhysicalVgprs
NAN_GETTER(_VkShaderStatisticsInfoAMD::GetnumPhysicalVgprs) {
  _VkShaderStatisticsInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderStatisticsInfoAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.numPhysicalVgprs));
}// numPhysicalSgprs
NAN_GETTER(_VkShaderStatisticsInfoAMD::GetnumPhysicalSgprs) {
  _VkShaderStatisticsInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderStatisticsInfoAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.numPhysicalSgprs));
}// numAvailableVgprs
NAN_GETTER(_VkShaderStatisticsInfoAMD::GetnumAvailableVgprs) {
  _VkShaderStatisticsInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderStatisticsInfoAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.numAvailableVgprs));
}// numAvailableSgprs
NAN_GETTER(_VkShaderStatisticsInfoAMD::GetnumAvailableSgprs) {
  _VkShaderStatisticsInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderStatisticsInfoAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.numAvailableSgprs));
}// computeWorkGroupSize
NAN_GETTER(_VkShaderStatisticsInfoAMD::GetcomputeWorkGroupSize) {
  _VkShaderStatisticsInfoAMD *self = Nan::ObjectWrap::Unwrap<_VkShaderStatisticsInfoAMD>(info.This());
  if (self->computeWorkGroupSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->computeWorkGroupSize));
  }
}
/** ## END VkShaderStatisticsInfoAMD ## **/

/** ## BEGIN VkPhysicalDeviceFloatControlsPropertiesKHR ## **/

class _VkPhysicalDeviceFloatControlsPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetseparateDenormSettings);
    static NAN_GETTER(GetseparateRoundingModeSettings);
    static NAN_GETTER(GetshaderSignedZeroInfNanPreserveFloat16);
    static NAN_GETTER(GetshaderSignedZeroInfNanPreserveFloat32);
    static NAN_GETTER(GetshaderSignedZeroInfNanPreserveFloat64);
    static NAN_GETTER(GetshaderDenormPreserveFloat16);
    static NAN_GETTER(GetshaderDenormPreserveFloat32);
    static NAN_GETTER(GetshaderDenormPreserveFloat64);
    static NAN_GETTER(GetshaderDenormFlushToZeroFloat16);
    static NAN_GETTER(GetshaderDenormFlushToZeroFloat32);
    static NAN_GETTER(GetshaderDenormFlushToZeroFloat64);
    static NAN_GETTER(GetshaderRoundingModeRTEFloat16);
    static NAN_GETTER(GetshaderRoundingModeRTEFloat32);
    static NAN_GETTER(GetshaderRoundingModeRTEFloat64);
    static NAN_GETTER(GetshaderRoundingModeRTZFloat16);
    static NAN_GETTER(GetshaderRoundingModeRTZFloat32);
    static NAN_GETTER(GetshaderRoundingModeRTZFloat64);

    // real instance
    VkPhysicalDeviceFloatControlsPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceFloatControlsPropertiesKHR();
    ~_VkPhysicalDeviceFloatControlsPropertiesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceFloatControlsPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceFloatControlsPropertiesKHR::constructor;

_VkPhysicalDeviceFloatControlsPropertiesKHR::_VkPhysicalDeviceFloatControlsPropertiesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR;
  
}

_VkPhysicalDeviceFloatControlsPropertiesKHR::~_VkPhysicalDeviceFloatControlsPropertiesKHR() {
  //printf("VkPhysicalDeviceFloatControlsPropertiesKHR deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceFloatControlsPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceFloatControlsPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceFloatControlsPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("separateDenormSettings").ToLocalChecked(), GetseparateDenormSettings, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("separateRoundingModeSettings").ToLocalChecked(), GetseparateRoundingModeSettings, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderSignedZeroInfNanPreserveFloat16").ToLocalChecked(), GetshaderSignedZeroInfNanPreserveFloat16, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderSignedZeroInfNanPreserveFloat32").ToLocalChecked(), GetshaderSignedZeroInfNanPreserveFloat32, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderSignedZeroInfNanPreserveFloat64").ToLocalChecked(), GetshaderSignedZeroInfNanPreserveFloat64, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderDenormPreserveFloat16").ToLocalChecked(), GetshaderDenormPreserveFloat16, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderDenormPreserveFloat32").ToLocalChecked(), GetshaderDenormPreserveFloat32, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderDenormPreserveFloat64").ToLocalChecked(), GetshaderDenormPreserveFloat64, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderDenormFlushToZeroFloat16").ToLocalChecked(), GetshaderDenormFlushToZeroFloat16, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderDenormFlushToZeroFloat32").ToLocalChecked(), GetshaderDenormFlushToZeroFloat32, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderDenormFlushToZeroFloat64").ToLocalChecked(), GetshaderDenormFlushToZeroFloat64, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderRoundingModeRTEFloat16").ToLocalChecked(), GetshaderRoundingModeRTEFloat16, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderRoundingModeRTEFloat32").ToLocalChecked(), GetshaderRoundingModeRTEFloat32, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderRoundingModeRTEFloat64").ToLocalChecked(), GetshaderRoundingModeRTEFloat64, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderRoundingModeRTZFloat16").ToLocalChecked(), GetshaderRoundingModeRTZFloat16, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderRoundingModeRTZFloat32").ToLocalChecked(), GetshaderRoundingModeRTZFloat32, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderRoundingModeRTZFloat64").ToLocalChecked(), GetshaderRoundingModeRTZFloat64, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceFloatControlsPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceFloatControlsPropertiesKHR::flush() {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceFloatControlsPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceFloatControlsPropertiesKHR* self = new _VkPhysicalDeviceFloatControlsPropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceFloatControlsPropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetsType) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// separateDenormSettings
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetseparateDenormSettings) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.separateDenormSettings));
}// separateRoundingModeSettings
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetseparateRoundingModeSettings) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.separateRoundingModeSettings));
}// shaderSignedZeroInfNanPreserveFloat16
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderSignedZeroInfNanPreserveFloat16) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderSignedZeroInfNanPreserveFloat16));
}// shaderSignedZeroInfNanPreserveFloat32
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderSignedZeroInfNanPreserveFloat32) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderSignedZeroInfNanPreserveFloat32));
}// shaderSignedZeroInfNanPreserveFloat64
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderSignedZeroInfNanPreserveFloat64) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderSignedZeroInfNanPreserveFloat64));
}// shaderDenormPreserveFloat16
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderDenormPreserveFloat16) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderDenormPreserveFloat16));
}// shaderDenormPreserveFloat32
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderDenormPreserveFloat32) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderDenormPreserveFloat32));
}// shaderDenormPreserveFloat64
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderDenormPreserveFloat64) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderDenormPreserveFloat64));
}// shaderDenormFlushToZeroFloat16
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderDenormFlushToZeroFloat16) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderDenormFlushToZeroFloat16));
}// shaderDenormFlushToZeroFloat32
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderDenormFlushToZeroFloat32) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderDenormFlushToZeroFloat32));
}// shaderDenormFlushToZeroFloat64
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderDenormFlushToZeroFloat64) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderDenormFlushToZeroFloat64));
}// shaderRoundingModeRTEFloat16
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderRoundingModeRTEFloat16) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderRoundingModeRTEFloat16));
}// shaderRoundingModeRTEFloat32
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderRoundingModeRTEFloat32) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderRoundingModeRTEFloat32));
}// shaderRoundingModeRTEFloat64
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderRoundingModeRTEFloat64) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderRoundingModeRTEFloat64));
}// shaderRoundingModeRTZFloat16
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderRoundingModeRTZFloat16) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderRoundingModeRTZFloat16));
}// shaderRoundingModeRTZFloat32
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderRoundingModeRTZFloat32) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderRoundingModeRTZFloat32));
}// shaderRoundingModeRTZFloat64
NAN_GETTER(_VkPhysicalDeviceFloatControlsPropertiesKHR::GetshaderRoundingModeRTZFloat64) {
  _VkPhysicalDeviceFloatControlsPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloatControlsPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderRoundingModeRTZFloat64));
}
/** ## END VkPhysicalDeviceFloatControlsPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceFloat16Int8FeaturesKHR ## **/

class _VkPhysicalDeviceFloat16Int8FeaturesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetshaderFloat16);
    static NAN_SETTER(SetshaderFloat16);
    
    static NAN_GETTER(GetshaderInt8);
    static NAN_SETTER(SetshaderInt8);
    

    // real instance
    VkPhysicalDeviceFloat16Int8FeaturesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceFloat16Int8FeaturesKHR();
    ~_VkPhysicalDeviceFloat16Int8FeaturesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceFloat16Int8FeaturesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceFloat16Int8FeaturesKHR::constructor;

_VkPhysicalDeviceFloat16Int8FeaturesKHR::_VkPhysicalDeviceFloat16Int8FeaturesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR;
  
}

_VkPhysicalDeviceFloat16Int8FeaturesKHR::~_VkPhysicalDeviceFloat16Int8FeaturesKHR() {
  //printf("VkPhysicalDeviceFloat16Int8FeaturesKHR deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceFloat16Int8FeaturesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceFloat16Int8FeaturesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceFloat16Int8FeaturesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderFloat16").ToLocalChecked(), GetshaderFloat16, SetshaderFloat16, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderInt8").ToLocalChecked(), GetshaderInt8, SetshaderInt8, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceFloat16Int8FeaturesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceFloat16Int8FeaturesKHR::flush() {
  _VkPhysicalDeviceFloat16Int8FeaturesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceFloat16Int8FeaturesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceFloat16Int8FeaturesKHR* self = new _VkPhysicalDeviceFloat16Int8FeaturesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("shaderFloat16").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("shaderInt8").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceFloat16Int8FeaturesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceFloat16Int8FeaturesKHR::GetsType) {
  _VkPhysicalDeviceFloat16Int8FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloat16Int8FeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceFloat16Int8FeaturesKHR::SetsType) {
  _VkPhysicalDeviceFloat16Int8FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloat16Int8FeaturesKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFloat16Int8FeaturesKHR.sType", "Number");
  
    return;
  }
}// shaderFloat16
NAN_GETTER(_VkPhysicalDeviceFloat16Int8FeaturesKHR::GetshaderFloat16) {
  _VkPhysicalDeviceFloat16Int8FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloat16Int8FeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderFloat16));
}NAN_SETTER(_VkPhysicalDeviceFloat16Int8FeaturesKHR::SetshaderFloat16) {
  _VkPhysicalDeviceFloat16Int8FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloat16Int8FeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderFloat16 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFloat16Int8FeaturesKHR.shaderFloat16", "Number");
  
    return;
  }
}// shaderInt8
NAN_GETTER(_VkPhysicalDeviceFloat16Int8FeaturesKHR::GetshaderInt8) {
  _VkPhysicalDeviceFloat16Int8FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloat16Int8FeaturesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderInt8));
}NAN_SETTER(_VkPhysicalDeviceFloat16Int8FeaturesKHR::SetshaderInt8) {
  _VkPhysicalDeviceFloat16Int8FeaturesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFloat16Int8FeaturesKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderInt8 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFloat16Int8FeaturesKHR.shaderInt8", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceFloat16Int8FeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceShaderDrawParameterFeatures ## **/

class _VkPhysicalDeviceShaderDrawParameterFeatures: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetshaderDrawParameters);
    static NAN_SETTER(SetshaderDrawParameters);
    

    // real instance
    VkPhysicalDeviceShaderDrawParameterFeatures instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceShaderDrawParameterFeatures();
    ~_VkPhysicalDeviceShaderDrawParameterFeatures();

};

/*
#include "index.h"
#include "VkPhysicalDeviceShaderDrawParameterFeatures.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceShaderDrawParameterFeatures::constructor;

_VkPhysicalDeviceShaderDrawParameterFeatures::_VkPhysicalDeviceShaderDrawParameterFeatures() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES;
  
}

_VkPhysicalDeviceShaderDrawParameterFeatures::~_VkPhysicalDeviceShaderDrawParameterFeatures() {
  //printf("VkPhysicalDeviceShaderDrawParameterFeatures deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceShaderDrawParameterFeatures::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceShaderDrawParameterFeatures::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceShaderDrawParameterFeatures").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderDrawParameters").ToLocalChecked(), GetshaderDrawParameters, SetshaderDrawParameters, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceShaderDrawParameterFeatures").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceShaderDrawParameterFeatures::flush() {
  _VkPhysicalDeviceShaderDrawParameterFeatures *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceShaderDrawParameterFeatures::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceShaderDrawParameterFeatures* self = new _VkPhysicalDeviceShaderDrawParameterFeatures();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("shaderDrawParameters").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceShaderDrawParameterFeatures constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceShaderDrawParameterFeatures::GetsType) {
  _VkPhysicalDeviceShaderDrawParameterFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderDrawParameterFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceShaderDrawParameterFeatures::SetsType) {
  _VkPhysicalDeviceShaderDrawParameterFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderDrawParameterFeatures>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShaderDrawParameterFeatures.sType", "Number");
  
    return;
  }
}// shaderDrawParameters
NAN_GETTER(_VkPhysicalDeviceShaderDrawParameterFeatures::GetshaderDrawParameters) {
  _VkPhysicalDeviceShaderDrawParameterFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderDrawParameterFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderDrawParameters));
}NAN_SETTER(_VkPhysicalDeviceShaderDrawParameterFeatures::SetshaderDrawParameters) {
  _VkPhysicalDeviceShaderDrawParameterFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceShaderDrawParameterFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderDrawParameters = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceShaderDrawParameterFeatures.shaderDrawParameters", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceShaderDrawParameterFeatures ## **/

/** ## BEGIN VkDescriptorSetLayoutSupportKHR ## **/

class _VkDescriptorSetLayoutSupportKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkDescriptorSetLayoutSupportKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorSetLayoutSupportKHR();
    ~_VkDescriptorSetLayoutSupportKHR();

};

/*
#include "index.h"
#include "VkDescriptorSetLayoutSupportKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetLayoutSupportKHR::constructor;

_VkDescriptorSetLayoutSupportKHR::_VkDescriptorSetLayoutSupportKHR() {
  
  
}

_VkDescriptorSetLayoutSupportKHR::~_VkDescriptorSetLayoutSupportKHR() {
  //printf("VkDescriptorSetLayoutSupportKHR deconstructed!!\n");
  
}

void _VkDescriptorSetLayoutSupportKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetLayoutSupportKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetLayoutSupportKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkDescriptorSetLayoutSupportKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorSetLayoutSupportKHR::flush() {
  _VkDescriptorSetLayoutSupportKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorSetLayoutSupportKHR::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorSetLayoutSupportKHR* self = new _VkDescriptorSetLayoutSupportKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorSetLayoutSupportKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkDescriptorSetLayoutSupportKHR ## **/

/** ## BEGIN VkDescriptorSetLayoutSupport ## **/

class _VkDescriptorSetLayoutSupport: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(Getsupported);

    // real instance
    VkDescriptorSetLayoutSupport instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorSetLayoutSupport();
    ~_VkDescriptorSetLayoutSupport();

};

/*
#include "index.h"
#include "VkDescriptorSetLayoutSupport.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetLayoutSupport::constructor;

_VkDescriptorSetLayoutSupport::_VkDescriptorSetLayoutSupport() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT;
  
}

_VkDescriptorSetLayoutSupport::~_VkDescriptorSetLayoutSupport() {
  //printf("VkDescriptorSetLayoutSupport deconstructed!!\n");
  
  
  
}

void _VkDescriptorSetLayoutSupport::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetLayoutSupport::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetLayoutSupport").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supported").ToLocalChecked(), Getsupported, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDescriptorSetLayoutSupport").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorSetLayoutSupport::flush() {
  _VkDescriptorSetLayoutSupport *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorSetLayoutSupport::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorSetLayoutSupport* self = new _VkDescriptorSetLayoutSupport();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorSetLayoutSupport constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorSetLayoutSupport::GetsType) {
  _VkDescriptorSetLayoutSupport *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutSupport>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// supported
NAN_GETTER(_VkDescriptorSetLayoutSupport::Getsupported) {
  _VkDescriptorSetLayoutSupport *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutSupport>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supported));
}
/** ## END VkDescriptorSetLayoutSupport ## **/

/** ## BEGIN VkPhysicalDeviceMaintenance3PropertiesKHR ## **/

class _VkPhysicalDeviceMaintenance3PropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceMaintenance3PropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMaintenance3PropertiesKHR();
    ~_VkPhysicalDeviceMaintenance3PropertiesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMaintenance3PropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMaintenance3PropertiesKHR::constructor;

_VkPhysicalDeviceMaintenance3PropertiesKHR::_VkPhysicalDeviceMaintenance3PropertiesKHR() {
  
  
}

_VkPhysicalDeviceMaintenance3PropertiesKHR::~_VkPhysicalDeviceMaintenance3PropertiesKHR() {
  //printf("VkPhysicalDeviceMaintenance3PropertiesKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceMaintenance3PropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMaintenance3PropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMaintenance3PropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceMaintenance3PropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMaintenance3PropertiesKHR::flush() {
  _VkPhysicalDeviceMaintenance3PropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMaintenance3PropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMaintenance3PropertiesKHR* self = new _VkPhysicalDeviceMaintenance3PropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMaintenance3PropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceMaintenance3PropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceMaintenance3Properties ## **/

class _VkPhysicalDeviceMaintenance3Properties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxPerSetDescriptors);
    static NAN_GETTER(GetmaxMemoryAllocationSize);

    // real instance
    VkPhysicalDeviceMaintenance3Properties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMaintenance3Properties();
    ~_VkPhysicalDeviceMaintenance3Properties();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMaintenance3Properties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMaintenance3Properties::constructor;

_VkPhysicalDeviceMaintenance3Properties::_VkPhysicalDeviceMaintenance3Properties() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
  
}

_VkPhysicalDeviceMaintenance3Properties::~_VkPhysicalDeviceMaintenance3Properties() {
  //printf("VkPhysicalDeviceMaintenance3Properties deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceMaintenance3Properties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMaintenance3Properties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMaintenance3Properties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerSetDescriptors").ToLocalChecked(), GetmaxPerSetDescriptors, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMemoryAllocationSize").ToLocalChecked(), GetmaxMemoryAllocationSize, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMaintenance3Properties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMaintenance3Properties::flush() {
  _VkPhysicalDeviceMaintenance3Properties *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMaintenance3Properties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMaintenance3Properties* self = new _VkPhysicalDeviceMaintenance3Properties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMaintenance3Properties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMaintenance3Properties::GetsType) {
  _VkPhysicalDeviceMaintenance3Properties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMaintenance3Properties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxPerSetDescriptors
NAN_GETTER(_VkPhysicalDeviceMaintenance3Properties::GetmaxPerSetDescriptors) {
  _VkPhysicalDeviceMaintenance3Properties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMaintenance3Properties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerSetDescriptors));
}// maxMemoryAllocationSize
NAN_GETTER(_VkPhysicalDeviceMaintenance3Properties::GetmaxMemoryAllocationSize) {
  _VkPhysicalDeviceMaintenance3Properties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMaintenance3Properties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMemoryAllocationSize));
}
/** ## END VkPhysicalDeviceMaintenance3Properties ## **/

/** ## BEGIN VkShaderModuleValidationCacheCreateInfoEXT ## **/

class _VkShaderModuleValidationCacheCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> validationCache;
      static NAN_GETTER(GetvalidationCache);
    static NAN_SETTER(SetvalidationCache);
    

    // real instance
    VkShaderModuleValidationCacheCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkShaderModuleValidationCacheCreateInfoEXT();
    ~_VkShaderModuleValidationCacheCreateInfoEXT();

};

/*
#include "index.h"
#include "VkShaderModuleValidationCacheCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkShaderModuleValidationCacheCreateInfoEXT::constructor;

_VkShaderModuleValidationCacheCreateInfoEXT::_VkShaderModuleValidationCacheCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT;
  
}

_VkShaderModuleValidationCacheCreateInfoEXT::~_VkShaderModuleValidationCacheCreateInfoEXT() {
  //printf("VkShaderModuleValidationCacheCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkShaderModuleValidationCacheCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkShaderModuleValidationCacheCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkShaderModuleValidationCacheCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("validationCache").ToLocalChecked(), GetvalidationCache, SetvalidationCache, ctor);
  Nan::Set(target, Nan::New("VkShaderModuleValidationCacheCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkShaderModuleValidationCacheCreateInfoEXT::flush() {
  _VkShaderModuleValidationCacheCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkShaderModuleValidationCacheCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkShaderModuleValidationCacheCreateInfoEXT* self = new _VkShaderModuleValidationCacheCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("validationCache").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkShaderModuleValidationCacheCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkShaderModuleValidationCacheCreateInfoEXT::GetsType) {
  _VkShaderModuleValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleValidationCacheCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkShaderModuleValidationCacheCreateInfoEXT::SetsType) {
  _VkShaderModuleValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleValidationCacheCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkShaderModuleValidationCacheCreateInfoEXT.sType", "Number");
  
    return;
  }
}// validationCache
NAN_GETTER(_VkShaderModuleValidationCacheCreateInfoEXT::GetvalidationCache) {
  _VkShaderModuleValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleValidationCacheCreateInfoEXT>(info.This());
  if (self->validationCache.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->validationCache);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkShaderModuleValidationCacheCreateInfoEXT::SetvalidationCache) {
  _VkShaderModuleValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleValidationCacheCreateInfoEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkValidationCacheEXT::constructor)->HasInstance(obj)) {
      self->validationCache.Reset<v8::Object>(value.As<v8::Object>());
      _VkValidationCacheEXT* inst = Nan::ObjectWrap::Unwrap<_VkValidationCacheEXT>(obj);
      ;
      self->instance.validationCache = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkShaderModuleValidationCacheCreateInfoEXT.validationCache", "[object VkValidationCacheEXT]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->validationCache.Reset();
    self->instance.validationCache = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkShaderModuleValidationCacheCreateInfoEXT.validationCache", "[object VkValidationCacheEXT]");
  
    return;
  }
}
/** ## END VkShaderModuleValidationCacheCreateInfoEXT ## **/

/** ## BEGIN VkValidationCacheCreateInfoEXT ## **/

class _VkValidationCacheCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetinitialDataSize);
    static NAN_SETTER(SetinitialDataSize);
    
    Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pInitialData;
    static NAN_GETTER(GetpInitialData);
    static NAN_SETTER(SetpInitialData);
    

    // real instance
    VkValidationCacheCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkValidationCacheCreateInfoEXT();
    ~_VkValidationCacheCreateInfoEXT();

};

/*
#include "index.h"
#include "VkValidationCacheCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkValidationCacheCreateInfoEXT::constructor;

_VkValidationCacheCreateInfoEXT::_VkValidationCacheCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT;
  
}

_VkValidationCacheCreateInfoEXT::~_VkValidationCacheCreateInfoEXT() {
  //printf("VkValidationCacheCreateInfoEXT deconstructed!!\n");
  
  
  
  
  pInitialData.Reset();
  
}

void _VkValidationCacheCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkValidationCacheCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkValidationCacheCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("initialDataSize").ToLocalChecked(), GetinitialDataSize, SetinitialDataSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("pInitialData").ToLocalChecked(), GetpInitialData, SetpInitialData, ctor);
  Nan::Set(target, Nan::New("VkValidationCacheCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkValidationCacheCreateInfoEXT::flush() {
  _VkValidationCacheCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkValidationCacheCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkValidationCacheCreateInfoEXT* self = new _VkValidationCacheCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("initialDataSize").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pInitialData").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkValidationCacheCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkValidationCacheCreateInfoEXT::GetsType) {
  _VkValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationCacheCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkValidationCacheCreateInfoEXT::SetsType) {
  _VkValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationCacheCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkValidationCacheCreateInfoEXT.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkValidationCacheCreateInfoEXT::Getflags) {
  _VkValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationCacheCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkValidationCacheCreateInfoEXT::Setflags) {
  _VkValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationCacheCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkValidationCacheCreateFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkValidationCacheCreateInfoEXT.flags", "Number");
  
    return;
  }
}// initialDataSize
NAN_GETTER(_VkValidationCacheCreateInfoEXT::GetinitialDataSize) {
  _VkValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationCacheCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.initialDataSize));
}NAN_SETTER(_VkValidationCacheCreateInfoEXT::SetinitialDataSize) {
  _VkValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationCacheCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.initialDataSize = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkValidationCacheCreateInfoEXT.initialDataSize", "Number");
  
    return;
  }
}// pInitialData
NAN_GETTER(_VkValidationCacheCreateInfoEXT::GetpInitialData) {
  _VkValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationCacheCreateInfoEXT>(info.This());
}NAN_SETTER(_VkValidationCacheCreateInfoEXT::SetpInitialData) {
  _VkValidationCacheCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationCacheCreateInfoEXT>(info.This());
}
/** ## END VkValidationCacheCreateInfoEXT ## **/

/** ## BEGIN VkImageFormatListCreateInfoKHR ## **/

class _VkImageFormatListCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetviewFormatCount);
    static NAN_SETTER(SetviewFormatCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pViewFormats;
    static NAN_GETTER(GetpViewFormats);
    static NAN_SETTER(SetpViewFormats);
    

    // real instance
    VkImageFormatListCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageFormatListCreateInfoKHR();
    ~_VkImageFormatListCreateInfoKHR();

};

/*
#include "index.h"
#include "VkImageFormatListCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageFormatListCreateInfoKHR::constructor;

_VkImageFormatListCreateInfoKHR::_VkImageFormatListCreateInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR;
  
}

_VkImageFormatListCreateInfoKHR::~_VkImageFormatListCreateInfoKHR() {
  //printf("VkImageFormatListCreateInfoKHR deconstructed!!\n");
  
  
  
  pViewFormats.Reset();
  
}

void _VkImageFormatListCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageFormatListCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageFormatListCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewFormatCount").ToLocalChecked(), GetviewFormatCount, SetviewFormatCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pViewFormats").ToLocalChecked(), GetpViewFormats, SetpViewFormats, ctor);
  Nan::Set(target, Nan::New("VkImageFormatListCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageFormatListCreateInfoKHR::flush() {
  _VkImageFormatListCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImageFormatListCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImageFormatListCreateInfoKHR* self = new _VkImageFormatListCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("viewFormatCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pViewFormats").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageFormatListCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageFormatListCreateInfoKHR::GetsType) {
  _VkImageFormatListCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageFormatListCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageFormatListCreateInfoKHR::SetsType) {
  _VkImageFormatListCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageFormatListCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageFormatListCreateInfoKHR.sType", "Number");
  
    return;
  }
}// viewFormatCount
NAN_GETTER(_VkImageFormatListCreateInfoKHR::GetviewFormatCount) {
  _VkImageFormatListCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageFormatListCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewFormatCount));
}NAN_SETTER(_VkImageFormatListCreateInfoKHR::SetviewFormatCount) {
  _VkImageFormatListCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageFormatListCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.viewFormatCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageFormatListCreateInfoKHR.viewFormatCount", "Number");
  
    return;
  }
}// pViewFormats
NAN_GETTER(_VkImageFormatListCreateInfoKHR::GetpViewFormats) {
  _VkImageFormatListCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageFormatListCreateInfoKHR>(info.This());
  if (self->pViewFormats.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pViewFormats);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageFormatListCreateInfoKHR::SetpViewFormats) {
  _VkImageFormatListCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageFormatListCreateInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pViewFormats.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkImageFormatListCreateInfoKHR.pViewFormats", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pViewFormats.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageFormatListCreateInfoKHR.pViewFormats", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pViewFormats = reinterpret_cast<const VkFormat *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pViewFormats = nullptr;
  }
}
/** ## END VkImageFormatListCreateInfoKHR ## **/

/** ## BEGIN VkPipelineCoverageModulationStateCreateInfoNV ## **/

class _VkPipelineCoverageModulationStateCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetcoverageModulationMode);
    static NAN_SETTER(SetcoverageModulationMode);
    
    static NAN_GETTER(GetcoverageModulationTableEnable);
    static NAN_SETTER(SetcoverageModulationTableEnable);
    
    static NAN_GETTER(GetcoverageModulationTableCount);
    static NAN_SETTER(SetcoverageModulationTableCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pCoverageModulationTable;
    static NAN_GETTER(GetpCoverageModulationTable);
    static NAN_SETTER(SetpCoverageModulationTable);
    

    // real instance
    VkPipelineCoverageModulationStateCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineCoverageModulationStateCreateInfoNV();
    ~_VkPipelineCoverageModulationStateCreateInfoNV();

};

/*
#include "index.h"
#include "VkPipelineCoverageModulationStateCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineCoverageModulationStateCreateInfoNV::constructor;

_VkPipelineCoverageModulationStateCreateInfoNV::_VkPipelineCoverageModulationStateCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV;
  
}

_VkPipelineCoverageModulationStateCreateInfoNV::~_VkPipelineCoverageModulationStateCreateInfoNV() {
  //printf("VkPipelineCoverageModulationStateCreateInfoNV deconstructed!!\n");
  
  
  
  
  
  
  pCoverageModulationTable.Reset();
  
}

void _VkPipelineCoverageModulationStateCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineCoverageModulationStateCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineCoverageModulationStateCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("coverageModulationMode").ToLocalChecked(), GetcoverageModulationMode, SetcoverageModulationMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("coverageModulationTableEnable").ToLocalChecked(), GetcoverageModulationTableEnable, SetcoverageModulationTableEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("coverageModulationTableCount").ToLocalChecked(), GetcoverageModulationTableCount, SetcoverageModulationTableCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pCoverageModulationTable").ToLocalChecked(), GetpCoverageModulationTable, SetpCoverageModulationTable, ctor);
  Nan::Set(target, Nan::New("VkPipelineCoverageModulationStateCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineCoverageModulationStateCreateInfoNV::flush() {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineCoverageModulationStateCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkPipelineCoverageModulationStateCreateInfoNV* self = new _VkPipelineCoverageModulationStateCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("coverageModulationMode").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("coverageModulationTableEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("coverageModulationTableCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pCoverageModulationTable").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineCoverageModulationStateCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineCoverageModulationStateCreateInfoNV::GetsType) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineCoverageModulationStateCreateInfoNV::SetsType) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineCoverageModulationStateCreateInfoNV::Getflags) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineCoverageModulationStateCreateInfoNV::Setflags) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineCoverageModulationStateCreateFlagsNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.flags", "Number");
  
    return;
  }
}// coverageModulationMode
NAN_GETTER(_VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationMode) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.coverageModulationMode));
}NAN_SETTER(_VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationMode) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.coverageModulationMode = static_cast<VkCoverageModulationModeNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationMode", "Number");
  
    return;
  }
}// coverageModulationTableEnable
NAN_GETTER(_VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationTableEnable) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.coverageModulationTableEnable));
}NAN_SETTER(_VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationTableEnable) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.coverageModulationTableEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableEnable", "Number");
  
    return;
  }
}// coverageModulationTableCount
NAN_GETTER(_VkPipelineCoverageModulationStateCreateInfoNV::GetcoverageModulationTableCount) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.coverageModulationTableCount));
}NAN_SETTER(_VkPipelineCoverageModulationStateCreateInfoNV::SetcoverageModulationTableCount) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.coverageModulationTableCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableCount", "Number");
  
    return;
  }
}// pCoverageModulationTable
NAN_GETTER(_VkPipelineCoverageModulationStateCreateInfoNV::GetpCoverageModulationTable) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  if (self->pCoverageModulationTable.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pCoverageModulationTable);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineCoverageModulationStateCreateInfoNV::SetpCoverageModulationTable) {
  _VkPipelineCoverageModulationStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageModulationStateCreateInfoNV>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsFloat32Array()) {
        self->pCoverageModulationTable.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable", "Float32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pCoverageModulationTable.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable", "Float32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pCoverageModulationTable = getTypedArrayData<float>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pCoverageModulationTable = nullptr;
  }
}
/** ## END VkPipelineCoverageModulationStateCreateInfoNV ## **/

/** ## BEGIN VkDescriptorPoolInlineUniformBlockCreateInfoEXT ## **/

class _VkDescriptorPoolInlineUniformBlockCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetmaxInlineUniformBlockBindings);
    static NAN_SETTER(SetmaxInlineUniformBlockBindings);
    

    // real instance
    VkDescriptorPoolInlineUniformBlockCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorPoolInlineUniformBlockCreateInfoEXT();
    ~_VkDescriptorPoolInlineUniformBlockCreateInfoEXT();

};

/*
#include "index.h"
#include "VkDescriptorPoolInlineUniformBlockCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorPoolInlineUniformBlockCreateInfoEXT::constructor;

_VkDescriptorPoolInlineUniformBlockCreateInfoEXT::_VkDescriptorPoolInlineUniformBlockCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT;
  
}

_VkDescriptorPoolInlineUniformBlockCreateInfoEXT::~_VkDescriptorPoolInlineUniformBlockCreateInfoEXT() {
  //printf("VkDescriptorPoolInlineUniformBlockCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkDescriptorPoolInlineUniformBlockCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorPoolInlineUniformBlockCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorPoolInlineUniformBlockCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxInlineUniformBlockBindings").ToLocalChecked(), GetmaxInlineUniformBlockBindings, SetmaxInlineUniformBlockBindings, ctor);
  Nan::Set(target, Nan::New("VkDescriptorPoolInlineUniformBlockCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorPoolInlineUniformBlockCreateInfoEXT::flush() {
  _VkDescriptorPoolInlineUniformBlockCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorPoolInlineUniformBlockCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorPoolInlineUniformBlockCreateInfoEXT* self = new _VkDescriptorPoolInlineUniformBlockCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("maxInlineUniformBlockBindings").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorPoolInlineUniformBlockCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorPoolInlineUniformBlockCreateInfoEXT::GetsType) {
  _VkDescriptorPoolInlineUniformBlockCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDescriptorPoolInlineUniformBlockCreateInfoEXT::SetsType) {
  _VkDescriptorPoolInlineUniformBlockCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolInlineUniformBlockCreateInfoEXT.sType", "Number");
  
    return;
  }
}// maxInlineUniformBlockBindings
NAN_GETTER(_VkDescriptorPoolInlineUniformBlockCreateInfoEXT::GetmaxInlineUniformBlockBindings) {
  _VkDescriptorPoolInlineUniformBlockCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxInlineUniformBlockBindings));
}NAN_SETTER(_VkDescriptorPoolInlineUniformBlockCreateInfoEXT::SetmaxInlineUniformBlockBindings) {
  _VkDescriptorPoolInlineUniformBlockCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.maxInlineUniformBlockBindings = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolInlineUniformBlockCreateInfoEXT.maxInlineUniformBlockBindings", "Number");
  
    return;
  }
}
/** ## END VkDescriptorPoolInlineUniformBlockCreateInfoEXT ## **/

/** ## BEGIN VkWriteDescriptorSetInlineUniformBlockEXT ## **/

class _VkWriteDescriptorSetInlineUniformBlockEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdataSize);
    static NAN_SETTER(SetdataSize);
    
    Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pData;
    static NAN_GETTER(GetpData);
    static NAN_SETTER(SetpData);
    

    // real instance
    VkWriteDescriptorSetInlineUniformBlockEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkWriteDescriptorSetInlineUniformBlockEXT();
    ~_VkWriteDescriptorSetInlineUniformBlockEXT();

};

/*
#include "index.h"
#include "VkWriteDescriptorSetInlineUniformBlockEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkWriteDescriptorSetInlineUniformBlockEXT::constructor;

_VkWriteDescriptorSetInlineUniformBlockEXT::_VkWriteDescriptorSetInlineUniformBlockEXT() {
  instance.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT;
  
}

_VkWriteDescriptorSetInlineUniformBlockEXT::~_VkWriteDescriptorSetInlineUniformBlockEXT() {
  //printf("VkWriteDescriptorSetInlineUniformBlockEXT deconstructed!!\n");
  
  
  
  pData.Reset();
  
}

void _VkWriteDescriptorSetInlineUniformBlockEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkWriteDescriptorSetInlineUniformBlockEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkWriteDescriptorSetInlineUniformBlockEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("dataSize").ToLocalChecked(), GetdataSize, SetdataSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("pData").ToLocalChecked(), GetpData, SetpData, ctor);
  Nan::Set(target, Nan::New("VkWriteDescriptorSetInlineUniformBlockEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkWriteDescriptorSetInlineUniformBlockEXT::flush() {
  _VkWriteDescriptorSetInlineUniformBlockEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkWriteDescriptorSetInlineUniformBlockEXT::New) {
  if (info.IsConstructCall()) {
    _VkWriteDescriptorSetInlineUniformBlockEXT* self = new _VkWriteDescriptorSetInlineUniformBlockEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dataSize").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pData").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkWriteDescriptorSetInlineUniformBlockEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkWriteDescriptorSetInlineUniformBlockEXT::GetsType) {
  _VkWriteDescriptorSetInlineUniformBlockEXT *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetInlineUniformBlockEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkWriteDescriptorSetInlineUniformBlockEXT::SetsType) {
  _VkWriteDescriptorSetInlineUniformBlockEXT *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetInlineUniformBlockEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSetInlineUniformBlockEXT.sType", "Number");
  
    return;
  }
}// dataSize
NAN_GETTER(_VkWriteDescriptorSetInlineUniformBlockEXT::GetdataSize) {
  _VkWriteDescriptorSetInlineUniformBlockEXT *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetInlineUniformBlockEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dataSize));
}NAN_SETTER(_VkWriteDescriptorSetInlineUniformBlockEXT::SetdataSize) {
  _VkWriteDescriptorSetInlineUniformBlockEXT *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetInlineUniformBlockEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.dataSize = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSetInlineUniformBlockEXT.dataSize", "Number");
  
    return;
  }
}// pData
NAN_GETTER(_VkWriteDescriptorSetInlineUniformBlockEXT::GetpData) {
  _VkWriteDescriptorSetInlineUniformBlockEXT *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetInlineUniformBlockEXT>(info.This());
}NAN_SETTER(_VkWriteDescriptorSetInlineUniformBlockEXT::SetpData) {
  _VkWriteDescriptorSetInlineUniformBlockEXT *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSetInlineUniformBlockEXT>(info.This());
}
/** ## END VkWriteDescriptorSetInlineUniformBlockEXT ## **/

/** ## BEGIN VkPhysicalDeviceInlineUniformBlockPropertiesEXT ## **/

class _VkPhysicalDeviceInlineUniformBlockPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxInlineUniformBlockSize);
    static NAN_GETTER(GetmaxPerStageDescriptorInlineUniformBlocks);
    static NAN_GETTER(GetmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks);
    static NAN_GETTER(GetmaxDescriptorSetInlineUniformBlocks);
    static NAN_GETTER(GetmaxDescriptorSetUpdateAfterBindInlineUniformBlocks);

    // real instance
    VkPhysicalDeviceInlineUniformBlockPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceInlineUniformBlockPropertiesEXT();
    ~_VkPhysicalDeviceInlineUniformBlockPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceInlineUniformBlockPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceInlineUniformBlockPropertiesEXT::constructor;

_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::_VkPhysicalDeviceInlineUniformBlockPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::~_VkPhysicalDeviceInlineUniformBlockPropertiesEXT() {
  //printf("VkPhysicalDeviceInlineUniformBlockPropertiesEXT deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceInlineUniformBlockPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceInlineUniformBlockPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxInlineUniformBlockSize").ToLocalChecked(), GetmaxInlineUniformBlockSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorInlineUniformBlocks").ToLocalChecked(), GetmaxPerStageDescriptorInlineUniformBlocks, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks").ToLocalChecked(), GetmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetInlineUniformBlocks").ToLocalChecked(), GetmaxDescriptorSetInlineUniformBlocks, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUpdateAfterBindInlineUniformBlocks").ToLocalChecked(), GetmaxDescriptorSetUpdateAfterBindInlineUniformBlocks, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceInlineUniformBlockPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceInlineUniformBlockPropertiesEXT::flush() {
  _VkPhysicalDeviceInlineUniformBlockPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceInlineUniformBlockPropertiesEXT* self = new _VkPhysicalDeviceInlineUniformBlockPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceInlineUniformBlockPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::GetsType) {
  _VkPhysicalDeviceInlineUniformBlockPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxInlineUniformBlockSize
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::GetmaxInlineUniformBlockSize) {
  _VkPhysicalDeviceInlineUniformBlockPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxInlineUniformBlockSize));
}// maxPerStageDescriptorInlineUniformBlocks
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::GetmaxPerStageDescriptorInlineUniformBlocks) {
  _VkPhysicalDeviceInlineUniformBlockPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorInlineUniformBlocks));
}// maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::GetmaxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) {
  _VkPhysicalDeviceInlineUniformBlockPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks));
}// maxDescriptorSetInlineUniformBlocks
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::GetmaxDescriptorSetInlineUniformBlocks) {
  _VkPhysicalDeviceInlineUniformBlockPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetInlineUniformBlocks));
}// maxDescriptorSetUpdateAfterBindInlineUniformBlocks
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockPropertiesEXT::GetmaxDescriptorSetUpdateAfterBindInlineUniformBlocks) {
  _VkPhysicalDeviceInlineUniformBlockPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUpdateAfterBindInlineUniformBlocks));
}
/** ## END VkPhysicalDeviceInlineUniformBlockPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceInlineUniformBlockFeaturesEXT ## **/

class _VkPhysicalDeviceInlineUniformBlockFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetinlineUniformBlock);
    static NAN_SETTER(SetinlineUniformBlock);
    
    static NAN_GETTER(GetdescriptorBindingInlineUniformBlockUpdateAfterBind);
    static NAN_SETTER(SetdescriptorBindingInlineUniformBlockUpdateAfterBind);
    

    // real instance
    VkPhysicalDeviceInlineUniformBlockFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceInlineUniformBlockFeaturesEXT();
    ~_VkPhysicalDeviceInlineUniformBlockFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceInlineUniformBlockFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceInlineUniformBlockFeaturesEXT::constructor;

_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::_VkPhysicalDeviceInlineUniformBlockFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT;
  
}

_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::~_VkPhysicalDeviceInlineUniformBlockFeaturesEXT() {
  //printf("VkPhysicalDeviceInlineUniformBlockFeaturesEXT deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceInlineUniformBlockFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceInlineUniformBlockFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("inlineUniformBlock").ToLocalChecked(), GetinlineUniformBlock, SetinlineUniformBlock, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorBindingInlineUniformBlockUpdateAfterBind").ToLocalChecked(), GetdescriptorBindingInlineUniformBlockUpdateAfterBind, SetdescriptorBindingInlineUniformBlockUpdateAfterBind, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceInlineUniformBlockFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceInlineUniformBlockFeaturesEXT::flush() {
  _VkPhysicalDeviceInlineUniformBlockFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceInlineUniformBlockFeaturesEXT* self = new _VkPhysicalDeviceInlineUniformBlockFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("inlineUniformBlock").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("descriptorBindingInlineUniformBlockUpdateAfterBind").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceInlineUniformBlockFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::GetsType) {
  _VkPhysicalDeviceInlineUniformBlockFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::SetsType) {
  _VkPhysicalDeviceInlineUniformBlockFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceInlineUniformBlockFeaturesEXT.sType", "Number");
  
    return;
  }
}// inlineUniformBlock
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::GetinlineUniformBlock) {
  _VkPhysicalDeviceInlineUniformBlockFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.inlineUniformBlock));
}NAN_SETTER(_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::SetinlineUniformBlock) {
  _VkPhysicalDeviceInlineUniformBlockFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.inlineUniformBlock = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceInlineUniformBlockFeaturesEXT.inlineUniformBlock", "Number");
  
    return;
  }
}// descriptorBindingInlineUniformBlockUpdateAfterBind
NAN_GETTER(_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::GetdescriptorBindingInlineUniformBlockUpdateAfterBind) {
  _VkPhysicalDeviceInlineUniformBlockFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorBindingInlineUniformBlockUpdateAfterBind));
}NAN_SETTER(_VkPhysicalDeviceInlineUniformBlockFeaturesEXT::SetdescriptorBindingInlineUniformBlockUpdateAfterBind) {
  _VkPhysicalDeviceInlineUniformBlockFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.descriptorBindingInlineUniformBlockUpdateAfterBind = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceInlineUniformBlockFeaturesEXT.descriptorBindingInlineUniformBlockUpdateAfterBind", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceInlineUniformBlockFeaturesEXT ## **/

/** ## BEGIN VkPipelineColorBlendAdvancedStateCreateInfoEXT ## **/

class _VkPipelineColorBlendAdvancedStateCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsrcPremultiplied);
    static NAN_SETTER(SetsrcPremultiplied);
    
    static NAN_GETTER(GetdstPremultiplied);
    static NAN_SETTER(SetdstPremultiplied);
    
    static NAN_GETTER(GetblendOverlap);
    static NAN_SETTER(SetblendOverlap);
    

    // real instance
    VkPipelineColorBlendAdvancedStateCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineColorBlendAdvancedStateCreateInfoEXT();
    ~_VkPipelineColorBlendAdvancedStateCreateInfoEXT();

};

/*
#include "index.h"
#include "VkPipelineColorBlendAdvancedStateCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineColorBlendAdvancedStateCreateInfoEXT::constructor;

_VkPipelineColorBlendAdvancedStateCreateInfoEXT::_VkPipelineColorBlendAdvancedStateCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT;
  
}

_VkPipelineColorBlendAdvancedStateCreateInfoEXT::~_VkPipelineColorBlendAdvancedStateCreateInfoEXT() {
  //printf("VkPipelineColorBlendAdvancedStateCreateInfoEXT deconstructed!!\n");
  
  
  
  
  
}

void _VkPipelineColorBlendAdvancedStateCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineColorBlendAdvancedStateCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcPremultiplied").ToLocalChecked(), GetsrcPremultiplied, SetsrcPremultiplied, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstPremultiplied").ToLocalChecked(), GetdstPremultiplied, SetdstPremultiplied, ctor);
  SetPrototypeAccessor(proto, Nan::New("blendOverlap").ToLocalChecked(), GetblendOverlap, SetblendOverlap, ctor);
  Nan::Set(target, Nan::New("VkPipelineColorBlendAdvancedStateCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineColorBlendAdvancedStateCreateInfoEXT::flush() {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkPipelineColorBlendAdvancedStateCreateInfoEXT* self = new _VkPipelineColorBlendAdvancedStateCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("srcPremultiplied").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstPremultiplied").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("blendOverlap").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineColorBlendAdvancedStateCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetsType) {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetsType) {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// srcPremultiplied
NAN_GETTER(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetsrcPremultiplied) {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcPremultiplied));
}NAN_SETTER(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetsrcPremultiplied) {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.srcPremultiplied = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.srcPremultiplied", "Number");
  
    return;
  }
}// dstPremultiplied
NAN_GETTER(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetdstPremultiplied) {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstPremultiplied));
}NAN_SETTER(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetdstPremultiplied) {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.dstPremultiplied = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.dstPremultiplied", "Number");
  
    return;
  }
}// blendOverlap
NAN_GETTER(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::GetblendOverlap) {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.blendOverlap));
}NAN_SETTER(_VkPipelineColorBlendAdvancedStateCreateInfoEXT::SetblendOverlap) {
  _VkPipelineColorBlendAdvancedStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAdvancedStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.blendOverlap = static_cast<VkBlendOverlapEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAdvancedStateCreateInfoEXT.blendOverlap", "Number");
  
    return;
  }
}
/** ## END VkPipelineColorBlendAdvancedStateCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ## **/

class _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetadvancedBlendMaxColorAttachments);
    static NAN_GETTER(GetadvancedBlendIndependentBlend);
    static NAN_GETTER(GetadvancedBlendNonPremultipliedSrcColor);
    static NAN_GETTER(GetadvancedBlendNonPremultipliedDstColor);
    static NAN_GETTER(GetadvancedBlendCorrelatedOverlap);
    static NAN_GETTER(GetadvancedBlendAllOperations);

    // real instance
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
    ~_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::constructor;

_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::~_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT() {
  //printf("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT deconstructed!!\n");
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("advancedBlendMaxColorAttachments").ToLocalChecked(), GetadvancedBlendMaxColorAttachments, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("advancedBlendIndependentBlend").ToLocalChecked(), GetadvancedBlendIndependentBlend, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("advancedBlendNonPremultipliedSrcColor").ToLocalChecked(), GetadvancedBlendNonPremultipliedSrcColor, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("advancedBlendNonPremultipliedDstColor").ToLocalChecked(), GetadvancedBlendNonPremultipliedDstColor, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("advancedBlendCorrelatedOverlap").ToLocalChecked(), GetadvancedBlendCorrelatedOverlap, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("advancedBlendAllOperations").ToLocalChecked(), GetadvancedBlendAllOperations, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::flush() {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* self = new _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetsType) {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// advancedBlendMaxColorAttachments
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendMaxColorAttachments) {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.advancedBlendMaxColorAttachments));
}// advancedBlendIndependentBlend
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendIndependentBlend) {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.advancedBlendIndependentBlend));
}// advancedBlendNonPremultipliedSrcColor
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendNonPremultipliedSrcColor) {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.advancedBlendNonPremultipliedSrcColor));
}// advancedBlendNonPremultipliedDstColor
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendNonPremultipliedDstColor) {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.advancedBlendNonPremultipliedDstColor));
}// advancedBlendCorrelatedOverlap
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendCorrelatedOverlap) {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.advancedBlendCorrelatedOverlap));
}// advancedBlendAllOperations
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::GetadvancedBlendAllOperations) {
  _VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.advancedBlendAllOperations));
}
/** ## END VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ## **/

class _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetadvancedBlendCoherentOperations);
    static NAN_SETTER(SetadvancedBlendCoherentOperations);
    

    // real instance
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
    ~_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::constructor;

_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
  
}

_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::~_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT() {
  //printf("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("advancedBlendCoherentOperations").ToLocalChecked(), GetadvancedBlendCoherentOperations, SetadvancedBlendCoherentOperations, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::flush() {
  _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* self = new _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("advancedBlendCoherentOperations").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetsType) {
  _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::SetsType) {
  _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.sType", "Number");
  
    return;
  }
}// advancedBlendCoherentOperations
NAN_GETTER(_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::GetadvancedBlendCoherentOperations) {
  _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.advancedBlendCoherentOperations));
}NAN_SETTER(_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT::SetadvancedBlendCoherentOperations) {
  _VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.advancedBlendCoherentOperations = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.advancedBlendCoherentOperations", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ## **/

/** ## BEGIN VkSamplerReductionModeCreateInfoEXT ## **/

class _VkSamplerReductionModeCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetreductionMode);
    static NAN_SETTER(SetreductionMode);
    

    // real instance
    VkSamplerReductionModeCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSamplerReductionModeCreateInfoEXT();
    ~_VkSamplerReductionModeCreateInfoEXT();

};

/*
#include "index.h"
#include "VkSamplerReductionModeCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSamplerReductionModeCreateInfoEXT::constructor;

_VkSamplerReductionModeCreateInfoEXT::_VkSamplerReductionModeCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT;
  
}

_VkSamplerReductionModeCreateInfoEXT::~_VkSamplerReductionModeCreateInfoEXT() {
  //printf("VkSamplerReductionModeCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkSamplerReductionModeCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerReductionModeCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerReductionModeCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("reductionMode").ToLocalChecked(), GetreductionMode, SetreductionMode, ctor);
  Nan::Set(target, Nan::New("VkSamplerReductionModeCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSamplerReductionModeCreateInfoEXT::flush() {
  _VkSamplerReductionModeCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkSamplerReductionModeCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkSamplerReductionModeCreateInfoEXT* self = new _VkSamplerReductionModeCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("reductionMode").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSamplerReductionModeCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSamplerReductionModeCreateInfoEXT::GetsType) {
  _VkSamplerReductionModeCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSamplerReductionModeCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSamplerReductionModeCreateInfoEXT::SetsType) {
  _VkSamplerReductionModeCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSamplerReductionModeCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerReductionModeCreateInfoEXT.sType", "Number");
  
    return;
  }
}// reductionMode
NAN_GETTER(_VkSamplerReductionModeCreateInfoEXT::GetreductionMode) {
  _VkSamplerReductionModeCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSamplerReductionModeCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.reductionMode));
}NAN_SETTER(_VkSamplerReductionModeCreateInfoEXT::SetreductionMode) {
  _VkSamplerReductionModeCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSamplerReductionModeCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.reductionMode = static_cast<VkSamplerReductionModeEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerReductionModeCreateInfoEXT.reductionMode", "Number");
  
    return;
  }
}
/** ## END VkSamplerReductionModeCreateInfoEXT ## **/

/** ## BEGIN VkMultisamplePropertiesEXT ## **/

class _VkMultisamplePropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxSampleLocationGridSize;
      static NAN_GETTER(GetmaxSampleLocationGridSize);

    // real instance
    VkMultisamplePropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMultisamplePropertiesEXT();
    ~_VkMultisamplePropertiesEXT();

};

/*
#include "index.h"
#include "VkMultisamplePropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMultisamplePropertiesEXT::constructor;

_VkMultisamplePropertiesEXT::_VkMultisamplePropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT;
  
}

_VkMultisamplePropertiesEXT::~_VkMultisamplePropertiesEXT() {
  //printf("VkMultisamplePropertiesEXT deconstructed!!\n");
  
  
  
}

void _VkMultisamplePropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMultisamplePropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMultisamplePropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSampleLocationGridSize").ToLocalChecked(), GetmaxSampleLocationGridSize, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMultisamplePropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMultisamplePropertiesEXT::flush() {
  _VkMultisamplePropertiesEXT *self = this;
  if (!(self->maxSampleLocationGridSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxSampleLocationGridSize);
    
  }
  return true;
}

NAN_METHOD(_VkMultisamplePropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkMultisamplePropertiesEXT* self = new _VkMultisamplePropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMultisamplePropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMultisamplePropertiesEXT::GetsType) {
  _VkMultisamplePropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkMultisamplePropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxSampleLocationGridSize
NAN_GETTER(_VkMultisamplePropertiesEXT::GetmaxSampleLocationGridSize) {
  _VkMultisamplePropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkMultisamplePropertiesEXT>(info.This());
  if (self->maxSampleLocationGridSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxSampleLocationGridSize);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkMultisamplePropertiesEXT ## **/

/** ## BEGIN VkPhysicalDeviceSampleLocationsPropertiesEXT ## **/

class _VkPhysicalDeviceSampleLocationsPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetsampleLocationSampleCounts);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxSampleLocationGridSize;
      static NAN_GETTER(GetmaxSampleLocationGridSize);
    std::vector<float>* vsampleLocationCoordinateRange;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> sampleLocationCoordinateRange;
    static NAN_GETTER(GetsampleLocationCoordinateRange);
    static NAN_GETTER(GetsampleLocationSubPixelBits);
    static NAN_GETTER(GetvariableSampleLocations);

    // real instance
    VkPhysicalDeviceSampleLocationsPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSampleLocationsPropertiesEXT();
    ~_VkPhysicalDeviceSampleLocationsPropertiesEXT();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceSampleLocationsPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSampleLocationsPropertiesEXT::constructor;

_VkPhysicalDeviceSampleLocationsPropertiesEXT::_VkPhysicalDeviceSampleLocationsPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
  vsampleLocationCoordinateRange = new std::vector<float>;
  
}

_VkPhysicalDeviceSampleLocationsPropertiesEXT::~_VkPhysicalDeviceSampleLocationsPropertiesEXT() {
  //printf("VkPhysicalDeviceSampleLocationsPropertiesEXT deconstructed!!\n");
  
  
  
  
  vsampleLocationCoordinateRange->clear();
  delete vsampleLocationCoordinateRange;
  
  
  
  
}

void _VkPhysicalDeviceSampleLocationsPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSampleLocationsPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSampleLocationsPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationSampleCounts").ToLocalChecked(), GetsampleLocationSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSampleLocationGridSize").ToLocalChecked(), GetmaxSampleLocationGridSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationCoordinateRange").ToLocalChecked(), GetsampleLocationCoordinateRange, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationSubPixelBits").ToLocalChecked(), GetsampleLocationSubPixelBits, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("variableSampleLocations").ToLocalChecked(), GetvariableSampleLocations, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceSampleLocationsPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSampleLocationsPropertiesEXT::flush() {
  _VkPhysicalDeviceSampleLocationsPropertiesEXT *self = this;
  if (!(self->maxSampleLocationGridSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxSampleLocationGridSize);
    
  }if (!(self->sampleLocationCoordinateRange.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->sampleLocationCoordinateRange);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSampleLocationsPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSampleLocationsPropertiesEXT* self = new _VkPhysicalDeviceSampleLocationsPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSampleLocationsPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsType) {
  _VkPhysicalDeviceSampleLocationsPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSampleLocationsPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// sampleLocationSampleCounts
NAN_GETTER(_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationSampleCounts) {
  _VkPhysicalDeviceSampleLocationsPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSampleLocationsPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleLocationSampleCounts));
}// maxSampleLocationGridSize
NAN_GETTER(_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetmaxSampleLocationGridSize) {
  _VkPhysicalDeviceSampleLocationsPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSampleLocationsPropertiesEXT>(info.This());
  if (self->maxSampleLocationGridSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxSampleLocationGridSize);
    info.GetReturnValue().Set(obj);
  }
}// sampleLocationCoordinateRange
NAN_GETTER(_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationCoordinateRange) {
  _VkPhysicalDeviceSampleLocationsPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSampleLocationsPropertiesEXT>(info.This());
  if (self->sampleLocationCoordinateRange.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->sampleLocationCoordinateRange));
  }
}// sampleLocationSubPixelBits
NAN_GETTER(_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetsampleLocationSubPixelBits) {
  _VkPhysicalDeviceSampleLocationsPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSampleLocationsPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleLocationSubPixelBits));
}// variableSampleLocations
NAN_GETTER(_VkPhysicalDeviceSampleLocationsPropertiesEXT::GetvariableSampleLocations) {
  _VkPhysicalDeviceSampleLocationsPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSampleLocationsPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.variableSampleLocations));
}
/** ## END VkPhysicalDeviceSampleLocationsPropertiesEXT ## **/

/** ## BEGIN VkSampleLocationEXT ## **/

class _VkSampleLocationEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getx);
    static NAN_SETTER(Setx);
    
    static NAN_GETTER(Gety);
    static NAN_SETTER(Sety);
    

    // real instance
    VkSampleLocationEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSampleLocationEXT();
    ~_VkSampleLocationEXT();

};

/*
#include "index.h"
#include "VkSampleLocationEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSampleLocationEXT::constructor;

_VkSampleLocationEXT::_VkSampleLocationEXT() {
  
  
}

_VkSampleLocationEXT::~_VkSampleLocationEXT() {
  //printf("VkSampleLocationEXT deconstructed!!\n");
  
  
  
}

void _VkSampleLocationEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSampleLocationEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSampleLocationEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("x").ToLocalChecked(), Getx, Setx, ctor);
  SetPrototypeAccessor(proto, Nan::New("y").ToLocalChecked(), Gety, Sety, ctor);
  Nan::Set(target, Nan::New("VkSampleLocationEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSampleLocationEXT::flush() {
  _VkSampleLocationEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkSampleLocationEXT::New) {
  if (info.IsConstructCall()) {
    _VkSampleLocationEXT* self = new _VkSampleLocationEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("x").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("y").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSampleLocationEXT constructor cannot be invoked without 'new'");
  }
};

// x
NAN_GETTER(_VkSampleLocationEXT::Getx) {
  _VkSampleLocationEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.x));
}NAN_SETTER(_VkSampleLocationEXT::Setx) {
  _VkSampleLocationEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.x = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSampleLocationEXT.x", "Number");
  
    return;
  }
}// y
NAN_GETTER(_VkSampleLocationEXT::Gety) {
  _VkSampleLocationEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.y));
}NAN_SETTER(_VkSampleLocationEXT::Sety) {
  _VkSampleLocationEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.y = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSampleLocationEXT.y", "Number");
  
    return;
  }
}
/** ## END VkSampleLocationEXT ## **/

/** ## BEGIN VkSampleLocationsInfoEXT ## **/

class _VkSampleLocationsInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsampleLocationsPerPixel);
    static NAN_SETTER(SetsampleLocationsPerPixel);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> sampleLocationGridSize;
      static NAN_GETTER(GetsampleLocationGridSize);
    static NAN_SETTER(SetsampleLocationGridSize);
    
    static NAN_GETTER(GetsampleLocationsCount);
    static NAN_SETTER(SetsampleLocationsCount);
    
    std::vector<VkSampleLocationEXT>* vpSampleLocations;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSampleLocations;
    static NAN_GETTER(GetpSampleLocations);
    static NAN_SETTER(SetpSampleLocations);
    

    // real instance
    VkSampleLocationsInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSampleLocationsInfoEXT();
    ~_VkSampleLocationsInfoEXT();

};

/*
#include "index.h"
#include "VkSampleLocationsInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSampleLocationsInfoEXT::constructor;

_VkSampleLocationsInfoEXT::_VkSampleLocationsInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT;
  vpSampleLocations = new std::vector<VkSampleLocationEXT>;
  
}

_VkSampleLocationsInfoEXT::~_VkSampleLocationsInfoEXT() {
  //printf("VkSampleLocationsInfoEXT deconstructed!!\n");
  
  
  
  
  
  vpSampleLocations->clear();
  delete vpSampleLocations;
  
  pSampleLocations.Reset();
  
}

void _VkSampleLocationsInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSampleLocationsInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSampleLocationsInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationsPerPixel").ToLocalChecked(), GetsampleLocationsPerPixel, SetsampleLocationsPerPixel, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationGridSize").ToLocalChecked(), GetsampleLocationGridSize, SetsampleLocationGridSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationsCount").ToLocalChecked(), GetsampleLocationsCount, SetsampleLocationsCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSampleLocations").ToLocalChecked(), GetpSampleLocations, SetpSampleLocations, ctor);
  Nan::Set(target, Nan::New("VkSampleLocationsInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSampleLocationsInfoEXT::flush() {
  _VkSampleLocationsInfoEXT *self = this;
  if (!(self->sampleLocationGridSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->sampleLocationGridSize);
    
    _VkExtent2D* result = Nan::ObjectWrap::Unwrap<_VkExtent2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.sampleLocationGridSize = result->instance;
  }if (!(self->pSampleLocations.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSampleLocations);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.sampleLocationsCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'sampleLocationsCount' for 'VkSampleLocationsInfoEXT.pSampleLocations'");
      return false;
    }
    std::vector<VkSampleLocationEXT>* data = self->vpSampleLocations;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSampleLocationEXT::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSampleLocationsInfoEXT.pSampleLocations", "[object VkSampleLocationEXT]");
  
        return false;
      }
      _VkSampleLocationEXT* result = Nan::ObjectWrap::Unwrap<_VkSampleLocationEXT>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSampleLocations = data->data();
  }
  return true;
}

NAN_METHOD(_VkSampleLocationsInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkSampleLocationsInfoEXT* self = new _VkSampleLocationsInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("sampleLocationsPerPixel").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("sampleLocationGridSize").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("sampleLocationsCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pSampleLocations").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSampleLocationsInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSampleLocationsInfoEXT::GetsType) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSampleLocationsInfoEXT::SetsType) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSampleLocationsInfoEXT.sType", "Number");
  
    return;
  }
}// sampleLocationsPerPixel
NAN_GETTER(_VkSampleLocationsInfoEXT::GetsampleLocationsPerPixel) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleLocationsPerPixel));
}NAN_SETTER(_VkSampleLocationsInfoEXT::SetsampleLocationsPerPixel) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sampleLocationsPerPixel = static_cast<VkSampleCountFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSampleLocationsInfoEXT.sampleLocationsPerPixel", "Number");
  
    return;
  }
}// sampleLocationGridSize
NAN_GETTER(_VkSampleLocationsInfoEXT::GetsampleLocationGridSize) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  if (self->sampleLocationGridSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->sampleLocationGridSize);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSampleLocationsInfoEXT::SetsampleLocationGridSize) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent2D::constructor)->HasInstance(obj)) {
      self->sampleLocationGridSize.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent2D* inst = Nan::ObjectWrap::Unwrap<_VkExtent2D>(obj);
      inst->flush();
      self->instance.sampleLocationGridSize = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSampleLocationsInfoEXT.sampleLocationGridSize", "[object VkExtent2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->sampleLocationGridSize.Reset();
    memset(&self->instance.sampleLocationGridSize, 0, sizeof(VkExtent2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSampleLocationsInfoEXT.sampleLocationGridSize", "[object VkExtent2D]");
  
    return;
  }
}// sampleLocationsCount
NAN_GETTER(_VkSampleLocationsInfoEXT::GetsampleLocationsCount) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleLocationsCount));
}NAN_SETTER(_VkSampleLocationsInfoEXT::SetsampleLocationsCount) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sampleLocationsCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSampleLocationsInfoEXT.sampleLocationsCount", "Number");
  
    return;
  }
}// pSampleLocations
NAN_GETTER(_VkSampleLocationsInfoEXT::GetpSampleLocations) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  if (self->pSampleLocations.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSampleLocations);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSampleLocationsInfoEXT::SetpSampleLocations) {
  _VkSampleLocationsInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSampleLocations.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSampleLocations.Reset();
      self->instance.pSampleLocations = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSampleLocationsInfoEXT.pSampleLocations", "[object VkSampleLocationEXT]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSampleLocations = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSampleLocationsInfoEXT.pSampleLocations", "[object VkSampleLocationEXT]");
  
    return;
  }
}
/** ## END VkSampleLocationsInfoEXT ## **/

/** ## BEGIN VkPipelineSampleLocationsStateCreateInfoEXT ## **/

class _VkPipelineSampleLocationsStateCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsampleLocationsEnable);
    static NAN_SETTER(SetsampleLocationsEnable);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> sampleLocationsInfo;
      static NAN_GETTER(GetsampleLocationsInfo);
    static NAN_SETTER(SetsampleLocationsInfo);
    

    // real instance
    VkPipelineSampleLocationsStateCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineSampleLocationsStateCreateInfoEXT();
    ~_VkPipelineSampleLocationsStateCreateInfoEXT();

};

/*
#include "index.h"
#include "VkPipelineSampleLocationsStateCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineSampleLocationsStateCreateInfoEXT::constructor;

_VkPipelineSampleLocationsStateCreateInfoEXT::_VkPipelineSampleLocationsStateCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT;
  
}

_VkPipelineSampleLocationsStateCreateInfoEXT::~_VkPipelineSampleLocationsStateCreateInfoEXT() {
  //printf("VkPipelineSampleLocationsStateCreateInfoEXT deconstructed!!\n");
  
  
  
  
}

void _VkPipelineSampleLocationsStateCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineSampleLocationsStateCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineSampleLocationsStateCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationsEnable").ToLocalChecked(), GetsampleLocationsEnable, SetsampleLocationsEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationsInfo").ToLocalChecked(), GetsampleLocationsInfo, SetsampleLocationsInfo, ctor);
  Nan::Set(target, Nan::New("VkPipelineSampleLocationsStateCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineSampleLocationsStateCreateInfoEXT::flush() {
  _VkPipelineSampleLocationsStateCreateInfoEXT *self = this;
  if (!(self->sampleLocationsInfo.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->sampleLocationsInfo);
    
    _VkSampleLocationsInfoEXT* result = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.sampleLocationsInfo = result->instance;
  }
  return true;
}

NAN_METHOD(_VkPipelineSampleLocationsStateCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkPipelineSampleLocationsStateCreateInfoEXT* self = new _VkPipelineSampleLocationsStateCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("sampleLocationsEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("sampleLocationsInfo").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineSampleLocationsStateCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineSampleLocationsStateCreateInfoEXT::GetsType) {
  _VkPipelineSampleLocationsStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineSampleLocationsStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineSampleLocationsStateCreateInfoEXT::SetsType) {
  _VkPipelineSampleLocationsStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineSampleLocationsStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// sampleLocationsEnable
NAN_GETTER(_VkPipelineSampleLocationsStateCreateInfoEXT::GetsampleLocationsEnable) {
  _VkPipelineSampleLocationsStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineSampleLocationsStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleLocationsEnable));
}NAN_SETTER(_VkPipelineSampleLocationsStateCreateInfoEXT::SetsampleLocationsEnable) {
  _VkPipelineSampleLocationsStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineSampleLocationsStateCreateInfoEXT>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sampleLocationsEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsEnable", "Number");
  
    return;
  }
}// sampleLocationsInfo
NAN_GETTER(_VkPipelineSampleLocationsStateCreateInfoEXT::GetsampleLocationsInfo) {
  _VkPipelineSampleLocationsStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineSampleLocationsStateCreateInfoEXT>(info.This());
  if (self->sampleLocationsInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->sampleLocationsInfo);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineSampleLocationsStateCreateInfoEXT::SetsampleLocationsInfo) {
  _VkPipelineSampleLocationsStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineSampleLocationsStateCreateInfoEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSampleLocationsInfoEXT::constructor)->HasInstance(obj)) {
      self->sampleLocationsInfo.Reset<v8::Object>(value.As<v8::Object>());
      _VkSampleLocationsInfoEXT* inst = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(obj);
      inst->flush();
      self->instance.sampleLocationsInfo = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->sampleLocationsInfo.Reset();
    memset(&self->instance.sampleLocationsInfo, 0, sizeof(VkSampleLocationsInfoEXT));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
    return;
  }
}
/** ## END VkPipelineSampleLocationsStateCreateInfoEXT ## **/

/** ## BEGIN VkSubpassSampleLocationsEXT ## **/

class _VkSubpassSampleLocationsEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsubpassIndex);
    static NAN_SETTER(SetsubpassIndex);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> sampleLocationsInfo;
      static NAN_GETTER(GetsampleLocationsInfo);
    static NAN_SETTER(SetsampleLocationsInfo);
    

    // real instance
    VkSubpassSampleLocationsEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubpassSampleLocationsEXT();
    ~_VkSubpassSampleLocationsEXT();

};

/*
#include "index.h"
#include "VkSubpassSampleLocationsEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubpassSampleLocationsEXT::constructor;

_VkSubpassSampleLocationsEXT::_VkSubpassSampleLocationsEXT() {
  
  
}

_VkSubpassSampleLocationsEXT::~_VkSubpassSampleLocationsEXT() {
  //printf("VkSubpassSampleLocationsEXT deconstructed!!\n");
  
  
  
}

void _VkSubpassSampleLocationsEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubpassSampleLocationsEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubpassSampleLocationsEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("subpassIndex").ToLocalChecked(), GetsubpassIndex, SetsubpassIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationsInfo").ToLocalChecked(), GetsampleLocationsInfo, SetsampleLocationsInfo, ctor);
  Nan::Set(target, Nan::New("VkSubpassSampleLocationsEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubpassSampleLocationsEXT::flush() {
  _VkSubpassSampleLocationsEXT *self = this;
  if (!(self->sampleLocationsInfo.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->sampleLocationsInfo);
    
    _VkSampleLocationsInfoEXT* result = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.sampleLocationsInfo = result->instance;
  }
  return true;
}

NAN_METHOD(_VkSubpassSampleLocationsEXT::New) {
  if (info.IsConstructCall()) {
    _VkSubpassSampleLocationsEXT* self = new _VkSubpassSampleLocationsEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("subpassIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("sampleLocationsInfo").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubpassSampleLocationsEXT constructor cannot be invoked without 'new'");
  }
};

// subpassIndex
NAN_GETTER(_VkSubpassSampleLocationsEXT::GetsubpassIndex) {
  _VkSubpassSampleLocationsEXT *self = Nan::ObjectWrap::Unwrap<_VkSubpassSampleLocationsEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subpassIndex));
}NAN_SETTER(_VkSubpassSampleLocationsEXT::SetsubpassIndex) {
  _VkSubpassSampleLocationsEXT *self = Nan::ObjectWrap::Unwrap<_VkSubpassSampleLocationsEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.subpassIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassSampleLocationsEXT.subpassIndex", "Number");
  
    return;
  }
}// sampleLocationsInfo
NAN_GETTER(_VkSubpassSampleLocationsEXT::GetsampleLocationsInfo) {
  _VkSubpassSampleLocationsEXT *self = Nan::ObjectWrap::Unwrap<_VkSubpassSampleLocationsEXT>(info.This());
  if (self->sampleLocationsInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->sampleLocationsInfo);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassSampleLocationsEXT::SetsampleLocationsInfo) {
  _VkSubpassSampleLocationsEXT *self = Nan::ObjectWrap::Unwrap<_VkSubpassSampleLocationsEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSampleLocationsInfoEXT::constructor)->HasInstance(obj)) {
      self->sampleLocationsInfo.Reset<v8::Object>(value.As<v8::Object>());
      _VkSampleLocationsInfoEXT* inst = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(obj);
      inst->flush();
      self->instance.sampleLocationsInfo = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassSampleLocationsEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->sampleLocationsInfo.Reset();
    memset(&self->instance.sampleLocationsInfo, 0, sizeof(VkSampleLocationsInfoEXT));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassSampleLocationsEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
    return;
  }
}
/** ## END VkSubpassSampleLocationsEXT ## **/

/** ## BEGIN VkAttachmentSampleLocationsEXT ## **/

class _VkAttachmentSampleLocationsEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetattachmentIndex);
    static NAN_SETTER(SetattachmentIndex);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> sampleLocationsInfo;
      static NAN_GETTER(GetsampleLocationsInfo);
    static NAN_SETTER(SetsampleLocationsInfo);
    

    // real instance
    VkAttachmentSampleLocationsEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAttachmentSampleLocationsEXT();
    ~_VkAttachmentSampleLocationsEXT();

};

/*
#include "index.h"
#include "VkAttachmentSampleLocationsEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAttachmentSampleLocationsEXT::constructor;

_VkAttachmentSampleLocationsEXT::_VkAttachmentSampleLocationsEXT() {
  
  
}

_VkAttachmentSampleLocationsEXT::~_VkAttachmentSampleLocationsEXT() {
  //printf("VkAttachmentSampleLocationsEXT deconstructed!!\n");
  
  
  
}

void _VkAttachmentSampleLocationsEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAttachmentSampleLocationsEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAttachmentSampleLocationsEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("attachmentIndex").ToLocalChecked(), GetattachmentIndex, SetattachmentIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleLocationsInfo").ToLocalChecked(), GetsampleLocationsInfo, SetsampleLocationsInfo, ctor);
  Nan::Set(target, Nan::New("VkAttachmentSampleLocationsEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAttachmentSampleLocationsEXT::flush() {
  _VkAttachmentSampleLocationsEXT *self = this;
  if (!(self->sampleLocationsInfo.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->sampleLocationsInfo);
    
    _VkSampleLocationsInfoEXT* result = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.sampleLocationsInfo = result->instance;
  }
  return true;
}

NAN_METHOD(_VkAttachmentSampleLocationsEXT::New) {
  if (info.IsConstructCall()) {
    _VkAttachmentSampleLocationsEXT* self = new _VkAttachmentSampleLocationsEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("attachmentIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("sampleLocationsInfo").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAttachmentSampleLocationsEXT constructor cannot be invoked without 'new'");
  }
};

// attachmentIndex
NAN_GETTER(_VkAttachmentSampleLocationsEXT::GetattachmentIndex) {
  _VkAttachmentSampleLocationsEXT *self = Nan::ObjectWrap::Unwrap<_VkAttachmentSampleLocationsEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.attachmentIndex));
}NAN_SETTER(_VkAttachmentSampleLocationsEXT::SetattachmentIndex) {
  _VkAttachmentSampleLocationsEXT *self = Nan::ObjectWrap::Unwrap<_VkAttachmentSampleLocationsEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.attachmentIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentSampleLocationsEXT.attachmentIndex", "Number");
  
    return;
  }
}// sampleLocationsInfo
NAN_GETTER(_VkAttachmentSampleLocationsEXT::GetsampleLocationsInfo) {
  _VkAttachmentSampleLocationsEXT *self = Nan::ObjectWrap::Unwrap<_VkAttachmentSampleLocationsEXT>(info.This());
  if (self->sampleLocationsInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->sampleLocationsInfo);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkAttachmentSampleLocationsEXT::SetsampleLocationsInfo) {
  _VkAttachmentSampleLocationsEXT *self = Nan::ObjectWrap::Unwrap<_VkAttachmentSampleLocationsEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSampleLocationsInfoEXT::constructor)->HasInstance(obj)) {
      self->sampleLocationsInfo.Reset<v8::Object>(value.As<v8::Object>());
      _VkSampleLocationsInfoEXT* inst = Nan::ObjectWrap::Unwrap<_VkSampleLocationsInfoEXT>(obj);
      inst->flush();
      self->instance.sampleLocationsInfo = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkAttachmentSampleLocationsEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->sampleLocationsInfo.Reset();
    memset(&self->instance.sampleLocationsInfo, 0, sizeof(VkSampleLocationsInfoEXT));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentSampleLocationsEXT.sampleLocationsInfo", "[object VkSampleLocationsInfoEXT]");
  
    return;
  }
}
/** ## END VkAttachmentSampleLocationsEXT ## **/

/** ## BEGIN VkRenderPassSampleLocationsBeginInfoEXT ## **/

class _VkRenderPassSampleLocationsBeginInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetattachmentInitialSampleLocationsCount);
    static NAN_SETTER(SetattachmentInitialSampleLocationsCount);
    
    std::vector<VkAttachmentSampleLocationsEXT>* vpAttachmentInitialSampleLocations;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAttachmentInitialSampleLocations;
    static NAN_GETTER(GetpAttachmentInitialSampleLocations);
    static NAN_SETTER(SetpAttachmentInitialSampleLocations);
    
    static NAN_GETTER(GetpostSubpassSampleLocationsCount);
    static NAN_SETTER(SetpostSubpassSampleLocationsCount);
    
    std::vector<VkSubpassSampleLocationsEXT>* vpPostSubpassSampleLocations;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pPostSubpassSampleLocations;
    static NAN_GETTER(GetpPostSubpassSampleLocations);
    static NAN_SETTER(SetpPostSubpassSampleLocations);
    

    // real instance
    VkRenderPassSampleLocationsBeginInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassSampleLocationsBeginInfoEXT();
    ~_VkRenderPassSampleLocationsBeginInfoEXT();

};

/*
#include "index.h"
#include "VkRenderPassSampleLocationsBeginInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassSampleLocationsBeginInfoEXT::constructor;

_VkRenderPassSampleLocationsBeginInfoEXT::_VkRenderPassSampleLocationsBeginInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT;
  vpAttachmentInitialSampleLocations = new std::vector<VkAttachmentSampleLocationsEXT>;
  vpPostSubpassSampleLocations = new std::vector<VkSubpassSampleLocationsEXT>;
  
}

_VkRenderPassSampleLocationsBeginInfoEXT::~_VkRenderPassSampleLocationsBeginInfoEXT() {
  //printf("VkRenderPassSampleLocationsBeginInfoEXT deconstructed!!\n");
  
  
  
  vpAttachmentInitialSampleLocations->clear();
  delete vpAttachmentInitialSampleLocations;
  
  pAttachmentInitialSampleLocations.Reset();
  
  
  vpPostSubpassSampleLocations->clear();
  delete vpPostSubpassSampleLocations;
  
  pPostSubpassSampleLocations.Reset();
  
}

void _VkRenderPassSampleLocationsBeginInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassSampleLocationsBeginInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassSampleLocationsBeginInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("attachmentInitialSampleLocationsCount").ToLocalChecked(), GetattachmentInitialSampleLocationsCount, SetattachmentInitialSampleLocationsCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAttachmentInitialSampleLocations").ToLocalChecked(), GetpAttachmentInitialSampleLocations, SetpAttachmentInitialSampleLocations, ctor);
  SetPrototypeAccessor(proto, Nan::New("postSubpassSampleLocationsCount").ToLocalChecked(), GetpostSubpassSampleLocationsCount, SetpostSubpassSampleLocationsCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pPostSubpassSampleLocations").ToLocalChecked(), GetpPostSubpassSampleLocations, SetpPostSubpassSampleLocations, ctor);
  Nan::Set(target, Nan::New("VkRenderPassSampleLocationsBeginInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassSampleLocationsBeginInfoEXT::flush() {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = this;
  if (!(self->pAttachmentInitialSampleLocations.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAttachmentInitialSampleLocations);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.attachmentInitialSampleLocationsCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'attachmentInitialSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations'");
      return false;
    }
    std::vector<VkAttachmentSampleLocationsEXT>* data = self->vpAttachmentInitialSampleLocations;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentSampleLocationsEXT::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations", "[object VkAttachmentSampleLocationsEXT]");
  
        return false;
      }
      _VkAttachmentSampleLocationsEXT* result = Nan::ObjectWrap::Unwrap<_VkAttachmentSampleLocationsEXT>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAttachmentInitialSampleLocations = data->data();
  }if (!(self->pPostSubpassSampleLocations.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pPostSubpassSampleLocations);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.postSubpassSampleLocationsCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'postSubpassSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations'");
      return false;
    }
    std::vector<VkSubpassSampleLocationsEXT>* data = self->vpPostSubpassSampleLocations;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSubpassSampleLocationsEXT::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations", "[object VkSubpassSampleLocationsEXT]");
  
        return false;
      }
      _VkSubpassSampleLocationsEXT* result = Nan::ObjectWrap::Unwrap<_VkSubpassSampleLocationsEXT>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pPostSubpassSampleLocations = data->data();
  }
  return true;
}

NAN_METHOD(_VkRenderPassSampleLocationsBeginInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassSampleLocationsBeginInfoEXT* self = new _VkRenderPassSampleLocationsBeginInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("attachmentInitialSampleLocationsCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pAttachmentInitialSampleLocations").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("postSubpassSampleLocationsCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pPostSubpassSampleLocations").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassSampleLocationsBeginInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRenderPassSampleLocationsBeginInfoEXT::GetsType) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRenderPassSampleLocationsBeginInfoEXT::SetsType) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.sType", "Number");
  
    return;
  }
}// attachmentInitialSampleLocationsCount
NAN_GETTER(_VkRenderPassSampleLocationsBeginInfoEXT::GetattachmentInitialSampleLocationsCount) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.attachmentInitialSampleLocationsCount));
}NAN_SETTER(_VkRenderPassSampleLocationsBeginInfoEXT::SetattachmentInitialSampleLocationsCount) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.attachmentInitialSampleLocationsCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.attachmentInitialSampleLocationsCount", "Number");
  
    return;
  }
}// pAttachmentInitialSampleLocations
NAN_GETTER(_VkRenderPassSampleLocationsBeginInfoEXT::GetpAttachmentInitialSampleLocations) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  if (self->pAttachmentInitialSampleLocations.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAttachmentInitialSampleLocations);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassSampleLocationsBeginInfoEXT::SetpAttachmentInitialSampleLocations) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAttachmentInitialSampleLocations.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAttachmentInitialSampleLocations.Reset();
      self->instance.pAttachmentInitialSampleLocations = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations", "[object VkAttachmentSampleLocationsEXT]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAttachmentInitialSampleLocations = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations", "[object VkAttachmentSampleLocationsEXT]");
  
    return;
  }
}// postSubpassSampleLocationsCount
NAN_GETTER(_VkRenderPassSampleLocationsBeginInfoEXT::GetpostSubpassSampleLocationsCount) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.postSubpassSampleLocationsCount));
}NAN_SETTER(_VkRenderPassSampleLocationsBeginInfoEXT::SetpostSubpassSampleLocationsCount) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.postSubpassSampleLocationsCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.postSubpassSampleLocationsCount", "Number");
  
    return;
  }
}// pPostSubpassSampleLocations
NAN_GETTER(_VkRenderPassSampleLocationsBeginInfoEXT::GetpPostSubpassSampleLocations) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  if (self->pPostSubpassSampleLocations.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pPostSubpassSampleLocations);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassSampleLocationsBeginInfoEXT::SetpPostSubpassSampleLocations) {
  _VkRenderPassSampleLocationsBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkRenderPassSampleLocationsBeginInfoEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pPostSubpassSampleLocations.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pPostSubpassSampleLocations.Reset();
      self->instance.pPostSubpassSampleLocations = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations", "[object VkSubpassSampleLocationsEXT]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pPostSubpassSampleLocations = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations", "[object VkSubpassSampleLocationsEXT]");
  
    return;
  }
}
/** ## END VkRenderPassSampleLocationsBeginInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ## **/

class _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetfilterMinmaxSingleComponentFormats);
    static NAN_GETTER(GetfilterMinmaxImageComponentMapping);

    // real instance
    VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT();
    ~_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::constructor;

_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::~_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT() {
  //printf("VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("filterMinmaxSingleComponentFormats").ToLocalChecked(), GetfilterMinmaxSingleComponentFormats, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("filterMinmaxImageComponentMapping").ToLocalChecked(), GetfilterMinmaxImageComponentMapping, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::flush() {
  _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT* self = new _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetsType) {
  _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// filterMinmaxSingleComponentFormats
NAN_GETTER(_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetfilterMinmaxSingleComponentFormats) {
  _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.filterMinmaxSingleComponentFormats));
}// filterMinmaxImageComponentMapping
NAN_GETTER(_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT::GetfilterMinmaxImageComponentMapping) {
  _VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.filterMinmaxImageComponentMapping));
}
/** ## END VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ## **/

/** ## BEGIN VkPipelineCoverageToColorStateCreateInfoNV ## **/

class _VkPipelineCoverageToColorStateCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetcoverageToColorEnable);
    static NAN_SETTER(SetcoverageToColorEnable);
    
    static NAN_GETTER(GetcoverageToColorLocation);
    static NAN_SETTER(SetcoverageToColorLocation);
    

    // real instance
    VkPipelineCoverageToColorStateCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineCoverageToColorStateCreateInfoNV();
    ~_VkPipelineCoverageToColorStateCreateInfoNV();

};

/*
#include "index.h"
#include "VkPipelineCoverageToColorStateCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineCoverageToColorStateCreateInfoNV::constructor;

_VkPipelineCoverageToColorStateCreateInfoNV::_VkPipelineCoverageToColorStateCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV;
  
}

_VkPipelineCoverageToColorStateCreateInfoNV::~_VkPipelineCoverageToColorStateCreateInfoNV() {
  //printf("VkPipelineCoverageToColorStateCreateInfoNV deconstructed!!\n");
  
  
  
  
  
}

void _VkPipelineCoverageToColorStateCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineCoverageToColorStateCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineCoverageToColorStateCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("coverageToColorEnable").ToLocalChecked(), GetcoverageToColorEnable, SetcoverageToColorEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("coverageToColorLocation").ToLocalChecked(), GetcoverageToColorLocation, SetcoverageToColorLocation, ctor);
  Nan::Set(target, Nan::New("VkPipelineCoverageToColorStateCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineCoverageToColorStateCreateInfoNV::flush() {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineCoverageToColorStateCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkPipelineCoverageToColorStateCreateInfoNV* self = new _VkPipelineCoverageToColorStateCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("coverageToColorEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("coverageToColorLocation").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineCoverageToColorStateCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineCoverageToColorStateCreateInfoNV::GetsType) {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineCoverageToColorStateCreateInfoNV::SetsType) {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineCoverageToColorStateCreateInfoNV::Getflags) {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineCoverageToColorStateCreateInfoNV::Setflags) {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineCoverageToColorStateCreateFlagsNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.flags", "Number");
  
    return;
  }
}// coverageToColorEnable
NAN_GETTER(_VkPipelineCoverageToColorStateCreateInfoNV::GetcoverageToColorEnable) {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.coverageToColorEnable));
}NAN_SETTER(_VkPipelineCoverageToColorStateCreateInfoNV::SetcoverageToColorEnable) {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.coverageToColorEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorEnable", "Number");
  
    return;
  }
}// coverageToColorLocation
NAN_GETTER(_VkPipelineCoverageToColorStateCreateInfoNV::GetcoverageToColorLocation) {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.coverageToColorLocation));
}NAN_SETTER(_VkPipelineCoverageToColorStateCreateInfoNV::SetcoverageToColorLocation) {
  _VkPipelineCoverageToColorStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineCoverageToColorStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.coverageToColorLocation = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorLocation", "Number");
  
    return;
  }
}
/** ## END VkPipelineCoverageToColorStateCreateInfoNV ## **/

/** ## BEGIN VkDeviceQueueInfo2 ## **/

class _VkDeviceQueueInfo2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetqueueFamilyIndex);
    static NAN_SETTER(SetqueueFamilyIndex);
    
    static NAN_GETTER(GetqueueIndex);
    static NAN_SETTER(SetqueueIndex);
    

    // real instance
    VkDeviceQueueInfo2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceQueueInfo2();
    ~_VkDeviceQueueInfo2();

};

/*
#include "index.h"
#include "VkDeviceQueueInfo2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceQueueInfo2::constructor;

_VkDeviceQueueInfo2::_VkDeviceQueueInfo2() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
  
}

_VkDeviceQueueInfo2::~_VkDeviceQueueInfo2() {
  //printf("VkDeviceQueueInfo2 deconstructed!!\n");
  
  
  
  
  
}

void _VkDeviceQueueInfo2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceQueueInfo2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceQueueInfo2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueFamilyIndex").ToLocalChecked(), GetqueueFamilyIndex, SetqueueFamilyIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueIndex").ToLocalChecked(), GetqueueIndex, SetqueueIndex, ctor);
  Nan::Set(target, Nan::New("VkDeviceQueueInfo2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceQueueInfo2::flush() {
  _VkDeviceQueueInfo2 *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceQueueInfo2::New) {
  if (info.IsConstructCall()) {
    _VkDeviceQueueInfo2* self = new _VkDeviceQueueInfo2();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("queueFamilyIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("queueIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceQueueInfo2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceQueueInfo2::GetsType) {
  _VkDeviceQueueInfo2 *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceQueueInfo2::SetsType) {
  _VkDeviceQueueInfo2 *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueInfo2.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDeviceQueueInfo2::Getflags) {
  _VkDeviceQueueInfo2 *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDeviceQueueInfo2::Setflags) {
  _VkDeviceQueueInfo2 *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDeviceQueueCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueInfo2.flags", "Number");
  
    return;
  }
}// queueFamilyIndex
NAN_GETTER(_VkDeviceQueueInfo2::GetqueueFamilyIndex) {
  _VkDeviceQueueInfo2 *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueFamilyIndex));
}NAN_SETTER(_VkDeviceQueueInfo2::SetqueueFamilyIndex) {
  _VkDeviceQueueInfo2 *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.queueFamilyIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueInfo2.queueFamilyIndex", "Number");
  
    return;
  }
}// queueIndex
NAN_GETTER(_VkDeviceQueueInfo2::GetqueueIndex) {
  _VkDeviceQueueInfo2 *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueIndex));
}NAN_SETTER(_VkDeviceQueueInfo2::SetqueueIndex) {
  _VkDeviceQueueInfo2 *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.queueIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueInfo2.queueIndex", "Number");
  
    return;
  }
}
/** ## END VkDeviceQueueInfo2 ## **/

/** ## BEGIN VkPhysicalDeviceProtectedMemoryProperties ## **/

class _VkPhysicalDeviceProtectedMemoryProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetprotectedNoFault);

    // real instance
    VkPhysicalDeviceProtectedMemoryProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceProtectedMemoryProperties();
    ~_VkPhysicalDeviceProtectedMemoryProperties();

};

/*
#include "index.h"
#include "VkPhysicalDeviceProtectedMemoryProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceProtectedMemoryProperties::constructor;

_VkPhysicalDeviceProtectedMemoryProperties::_VkPhysicalDeviceProtectedMemoryProperties() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
  
}

_VkPhysicalDeviceProtectedMemoryProperties::~_VkPhysicalDeviceProtectedMemoryProperties() {
  //printf("VkPhysicalDeviceProtectedMemoryProperties deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceProtectedMemoryProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceProtectedMemoryProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceProtectedMemoryProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("protectedNoFault").ToLocalChecked(), GetprotectedNoFault, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceProtectedMemoryProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceProtectedMemoryProperties::flush() {
  _VkPhysicalDeviceProtectedMemoryProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceProtectedMemoryProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceProtectedMemoryProperties* self = new _VkPhysicalDeviceProtectedMemoryProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceProtectedMemoryProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceProtectedMemoryProperties::GetsType) {
  _VkPhysicalDeviceProtectedMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProtectedMemoryProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// protectedNoFault
NAN_GETTER(_VkPhysicalDeviceProtectedMemoryProperties::GetprotectedNoFault) {
  _VkPhysicalDeviceProtectedMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProtectedMemoryProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.protectedNoFault));
}
/** ## END VkPhysicalDeviceProtectedMemoryProperties ## **/

/** ## BEGIN VkPhysicalDeviceProtectedMemoryFeatures ## **/

class _VkPhysicalDeviceProtectedMemoryFeatures: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetprotectedMemory);
    static NAN_SETTER(SetprotectedMemory);
    

    // real instance
    VkPhysicalDeviceProtectedMemoryFeatures instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceProtectedMemoryFeatures();
    ~_VkPhysicalDeviceProtectedMemoryFeatures();

};

/*
#include "index.h"
#include "VkPhysicalDeviceProtectedMemoryFeatures.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceProtectedMemoryFeatures::constructor;

_VkPhysicalDeviceProtectedMemoryFeatures::_VkPhysicalDeviceProtectedMemoryFeatures() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
  
}

_VkPhysicalDeviceProtectedMemoryFeatures::~_VkPhysicalDeviceProtectedMemoryFeatures() {
  //printf("VkPhysicalDeviceProtectedMemoryFeatures deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceProtectedMemoryFeatures::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceProtectedMemoryFeatures::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceProtectedMemoryFeatures").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("protectedMemory").ToLocalChecked(), GetprotectedMemory, SetprotectedMemory, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceProtectedMemoryFeatures").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceProtectedMemoryFeatures::flush() {
  _VkPhysicalDeviceProtectedMemoryFeatures *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceProtectedMemoryFeatures::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceProtectedMemoryFeatures* self = new _VkPhysicalDeviceProtectedMemoryFeatures();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("protectedMemory").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceProtectedMemoryFeatures constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceProtectedMemoryFeatures::GetsType) {
  _VkPhysicalDeviceProtectedMemoryFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProtectedMemoryFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceProtectedMemoryFeatures::SetsType) {
  _VkPhysicalDeviceProtectedMemoryFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProtectedMemoryFeatures>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceProtectedMemoryFeatures.sType", "Number");
  
    return;
  }
}// protectedMemory
NAN_GETTER(_VkPhysicalDeviceProtectedMemoryFeatures::GetprotectedMemory) {
  _VkPhysicalDeviceProtectedMemoryFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProtectedMemoryFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.protectedMemory));
}NAN_SETTER(_VkPhysicalDeviceProtectedMemoryFeatures::SetprotectedMemory) {
  _VkPhysicalDeviceProtectedMemoryFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProtectedMemoryFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.protectedMemory = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceProtectedMemoryFeatures.protectedMemory", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceProtectedMemoryFeatures ## **/

/** ## BEGIN VkProtectedSubmitInfo ## **/

class _VkProtectedSubmitInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetprotectedSubmit);
    static NAN_SETTER(SetprotectedSubmit);
    

    // real instance
    VkProtectedSubmitInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkProtectedSubmitInfo();
    ~_VkProtectedSubmitInfo();

};

/*
#include "index.h"
#include "VkProtectedSubmitInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkProtectedSubmitInfo::constructor;

_VkProtectedSubmitInfo::_VkProtectedSubmitInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
  
}

_VkProtectedSubmitInfo::~_VkProtectedSubmitInfo() {
  //printf("VkProtectedSubmitInfo deconstructed!!\n");
  
  
  
}

void _VkProtectedSubmitInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkProtectedSubmitInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkProtectedSubmitInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("protectedSubmit").ToLocalChecked(), GetprotectedSubmit, SetprotectedSubmit, ctor);
  Nan::Set(target, Nan::New("VkProtectedSubmitInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkProtectedSubmitInfo::flush() {
  _VkProtectedSubmitInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkProtectedSubmitInfo::New) {
  if (info.IsConstructCall()) {
    _VkProtectedSubmitInfo* self = new _VkProtectedSubmitInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("protectedSubmit").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkProtectedSubmitInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkProtectedSubmitInfo::GetsType) {
  _VkProtectedSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkProtectedSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkProtectedSubmitInfo::SetsType) {
  _VkProtectedSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkProtectedSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkProtectedSubmitInfo.sType", "Number");
  
    return;
  }
}// protectedSubmit
NAN_GETTER(_VkProtectedSubmitInfo::GetprotectedSubmit) {
  _VkProtectedSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkProtectedSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.protectedSubmit));
}NAN_SETTER(_VkProtectedSubmitInfo::SetprotectedSubmit) {
  _VkProtectedSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkProtectedSubmitInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.protectedSubmit = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkProtectedSubmitInfo.protectedSubmit", "Number");
  
    return;
  }
}
/** ## END VkProtectedSubmitInfo ## **/

/** ## BEGIN VkConditionalRenderingBeginInfoEXT ## **/

class _VkConditionalRenderingBeginInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkConditionalRenderingBeginInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkConditionalRenderingBeginInfoEXT();
    ~_VkConditionalRenderingBeginInfoEXT();

};

/*
#include "index.h"
#include "VkConditionalRenderingBeginInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkConditionalRenderingBeginInfoEXT::constructor;

_VkConditionalRenderingBeginInfoEXT::_VkConditionalRenderingBeginInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT;
  
}

_VkConditionalRenderingBeginInfoEXT::~_VkConditionalRenderingBeginInfoEXT() {
  //printf("VkConditionalRenderingBeginInfoEXT deconstructed!!\n");
  
  
  
  
  
}

void _VkConditionalRenderingBeginInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkConditionalRenderingBeginInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkConditionalRenderingBeginInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkConditionalRenderingBeginInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkConditionalRenderingBeginInfoEXT::flush() {
  _VkConditionalRenderingBeginInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkConditionalRenderingBeginInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkConditionalRenderingBeginInfoEXT* self = new _VkConditionalRenderingBeginInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("buffer").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkConditionalRenderingBeginInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkConditionalRenderingBeginInfoEXT::GetsType) {
  _VkConditionalRenderingBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkConditionalRenderingBeginInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkConditionalRenderingBeginInfoEXT::SetsType) {
  _VkConditionalRenderingBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkConditionalRenderingBeginInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkConditionalRenderingBeginInfoEXT.sType", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkConditionalRenderingBeginInfoEXT::Getbuffer) {
  _VkConditionalRenderingBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkConditionalRenderingBeginInfoEXT>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkConditionalRenderingBeginInfoEXT::Setbuffer) {
  _VkConditionalRenderingBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkConditionalRenderingBeginInfoEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkConditionalRenderingBeginInfoEXT.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkConditionalRenderingBeginInfoEXT.buffer", "[object VkBuffer]");
  
    return;
  }
}// offset
NAN_GETTER(_VkConditionalRenderingBeginInfoEXT::Getoffset) {
  _VkConditionalRenderingBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkConditionalRenderingBeginInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkConditionalRenderingBeginInfoEXT::Setoffset) {
  _VkConditionalRenderingBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkConditionalRenderingBeginInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkConditionalRenderingBeginInfoEXT.offset", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkConditionalRenderingBeginInfoEXT::Getflags) {
  _VkConditionalRenderingBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkConditionalRenderingBeginInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkConditionalRenderingBeginInfoEXT::Setflags) {
  _VkConditionalRenderingBeginInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkConditionalRenderingBeginInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkConditionalRenderingFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkConditionalRenderingBeginInfoEXT.flags", "Number");
  
    return;
  }
}
/** ## END VkConditionalRenderingBeginInfoEXT ## **/

/** ## BEGIN VkTextureLODGatherFormatPropertiesAMD ## **/

class _VkTextureLODGatherFormatPropertiesAMD: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetsupportsTextureGatherLODBiasAMD);

    // real instance
    VkTextureLODGatherFormatPropertiesAMD instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkTextureLODGatherFormatPropertiesAMD();
    ~_VkTextureLODGatherFormatPropertiesAMD();

};

/*
#include "index.h"
#include "VkTextureLODGatherFormatPropertiesAMD.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkTextureLODGatherFormatPropertiesAMD::constructor;

_VkTextureLODGatherFormatPropertiesAMD::_VkTextureLODGatherFormatPropertiesAMD() {
  instance.sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
  
}

_VkTextureLODGatherFormatPropertiesAMD::~_VkTextureLODGatherFormatPropertiesAMD() {
  //printf("VkTextureLODGatherFormatPropertiesAMD deconstructed!!\n");
  
  
  
}

void _VkTextureLODGatherFormatPropertiesAMD::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkTextureLODGatherFormatPropertiesAMD::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkTextureLODGatherFormatPropertiesAMD").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportsTextureGatherLODBiasAMD").ToLocalChecked(), GetsupportsTextureGatherLODBiasAMD, nullptr, ctor);
  Nan::Set(target, Nan::New("VkTextureLODGatherFormatPropertiesAMD").ToLocalChecked(), ctor->GetFunction());
}

bool _VkTextureLODGatherFormatPropertiesAMD::flush() {
  _VkTextureLODGatherFormatPropertiesAMD *self = this;
  
  return true;
}

NAN_METHOD(_VkTextureLODGatherFormatPropertiesAMD::New) {
  if (info.IsConstructCall()) {
    _VkTextureLODGatherFormatPropertiesAMD* self = new _VkTextureLODGatherFormatPropertiesAMD();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkTextureLODGatherFormatPropertiesAMD constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkTextureLODGatherFormatPropertiesAMD::GetsType) {
  _VkTextureLODGatherFormatPropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkTextureLODGatherFormatPropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// supportsTextureGatherLODBiasAMD
NAN_GETTER(_VkTextureLODGatherFormatPropertiesAMD::GetsupportsTextureGatherLODBiasAMD) {
  _VkTextureLODGatherFormatPropertiesAMD *self = Nan::ObjectWrap::Unwrap<_VkTextureLODGatherFormatPropertiesAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportsTextureGatherLODBiasAMD));
}
/** ## END VkTextureLODGatherFormatPropertiesAMD ## **/

/** ## BEGIN VkSamplerYcbcrConversionImageFormatPropertiesKHR ## **/

class _VkSamplerYcbcrConversionImageFormatPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkSamplerYcbcrConversionImageFormatPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSamplerYcbcrConversionImageFormatPropertiesKHR();
    ~_VkSamplerYcbcrConversionImageFormatPropertiesKHR();

};

/*
#include "index.h"
#include "VkSamplerYcbcrConversionImageFormatPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSamplerYcbcrConversionImageFormatPropertiesKHR::constructor;

_VkSamplerYcbcrConversionImageFormatPropertiesKHR::_VkSamplerYcbcrConversionImageFormatPropertiesKHR() {
  
  
}

_VkSamplerYcbcrConversionImageFormatPropertiesKHR::~_VkSamplerYcbcrConversionImageFormatPropertiesKHR() {
  //printf("VkSamplerYcbcrConversionImageFormatPropertiesKHR deconstructed!!\n");
  
}

void _VkSamplerYcbcrConversionImageFormatPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerYcbcrConversionImageFormatPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerYcbcrConversionImageFormatPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkSamplerYcbcrConversionImageFormatPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSamplerYcbcrConversionImageFormatPropertiesKHR::flush() {
  _VkSamplerYcbcrConversionImageFormatPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSamplerYcbcrConversionImageFormatPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkSamplerYcbcrConversionImageFormatPropertiesKHR* self = new _VkSamplerYcbcrConversionImageFormatPropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSamplerYcbcrConversionImageFormatPropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkSamplerYcbcrConversionImageFormatPropertiesKHR ## **/

/** ## BEGIN VkSamplerYcbcrConversionImageFormatProperties ## **/

class _VkSamplerYcbcrConversionImageFormatProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetcombinedImageSamplerDescriptorCount);

    // real instance
    VkSamplerYcbcrConversionImageFormatProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSamplerYcbcrConversionImageFormatProperties();
    ~_VkSamplerYcbcrConversionImageFormatProperties();

};

/*
#include "index.h"
#include "VkSamplerYcbcrConversionImageFormatProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSamplerYcbcrConversionImageFormatProperties::constructor;

_VkSamplerYcbcrConversionImageFormatProperties::_VkSamplerYcbcrConversionImageFormatProperties() {
  instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES;
  
}

_VkSamplerYcbcrConversionImageFormatProperties::~_VkSamplerYcbcrConversionImageFormatProperties() {
  //printf("VkSamplerYcbcrConversionImageFormatProperties deconstructed!!\n");
  
  
  
}

void _VkSamplerYcbcrConversionImageFormatProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerYcbcrConversionImageFormatProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerYcbcrConversionImageFormatProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("combinedImageSamplerDescriptorCount").ToLocalChecked(), GetcombinedImageSamplerDescriptorCount, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSamplerYcbcrConversionImageFormatProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSamplerYcbcrConversionImageFormatProperties::flush() {
  _VkSamplerYcbcrConversionImageFormatProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkSamplerYcbcrConversionImageFormatProperties::New) {
  if (info.IsConstructCall()) {
    _VkSamplerYcbcrConversionImageFormatProperties* self = new _VkSamplerYcbcrConversionImageFormatProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSamplerYcbcrConversionImageFormatProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSamplerYcbcrConversionImageFormatProperties::GetsType) {
  _VkSamplerYcbcrConversionImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// combinedImageSamplerDescriptorCount
NAN_GETTER(_VkSamplerYcbcrConversionImageFormatProperties::GetcombinedImageSamplerDescriptorCount) {
  _VkSamplerYcbcrConversionImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.combinedImageSamplerDescriptorCount));
}
/** ## END VkSamplerYcbcrConversionImageFormatProperties ## **/

/** ## BEGIN VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR ## **/

class _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR();
    ~_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::constructor;

_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR() {
  
  
}

_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::~_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR() {
  //printf("VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::flush() {
  _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR* self = new _VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceSamplerYcbcrConversionFeatures ## **/

class _VkPhysicalDeviceSamplerYcbcrConversionFeatures: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsamplerYcbcrConversion);
    static NAN_SETTER(SetsamplerYcbcrConversion);
    

    // real instance
    VkPhysicalDeviceSamplerYcbcrConversionFeatures instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSamplerYcbcrConversionFeatures();
    ~_VkPhysicalDeviceSamplerYcbcrConversionFeatures();

};

/*
#include "index.h"
#include "VkPhysicalDeviceSamplerYcbcrConversionFeatures.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSamplerYcbcrConversionFeatures::constructor;

_VkPhysicalDeviceSamplerYcbcrConversionFeatures::_VkPhysicalDeviceSamplerYcbcrConversionFeatures() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
  
}

_VkPhysicalDeviceSamplerYcbcrConversionFeatures::~_VkPhysicalDeviceSamplerYcbcrConversionFeatures() {
  //printf("VkPhysicalDeviceSamplerYcbcrConversionFeatures deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceSamplerYcbcrConversionFeatures::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSamplerYcbcrConversionFeatures::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSamplerYcbcrConversionFeatures").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("samplerYcbcrConversion").ToLocalChecked(), GetsamplerYcbcrConversion, SetsamplerYcbcrConversion, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceSamplerYcbcrConversionFeatures").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSamplerYcbcrConversionFeatures::flush() {
  _VkPhysicalDeviceSamplerYcbcrConversionFeatures *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSamplerYcbcrConversionFeatures::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSamplerYcbcrConversionFeatures* self = new _VkPhysicalDeviceSamplerYcbcrConversionFeatures();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("samplerYcbcrConversion").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSamplerYcbcrConversionFeatures constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetsType) {
  _VkPhysicalDeviceSamplerYcbcrConversionFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceSamplerYcbcrConversionFeatures::SetsType) {
  _VkPhysicalDeviceSamplerYcbcrConversionFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeatures.sType", "Number");
  
    return;
  }
}// samplerYcbcrConversion
NAN_GETTER(_VkPhysicalDeviceSamplerYcbcrConversionFeatures::GetsamplerYcbcrConversion) {
  _VkPhysicalDeviceSamplerYcbcrConversionFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.samplerYcbcrConversion));
}NAN_SETTER(_VkPhysicalDeviceSamplerYcbcrConversionFeatures::SetsamplerYcbcrConversion) {
  _VkPhysicalDeviceSamplerYcbcrConversionFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSamplerYcbcrConversionFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.samplerYcbcrConversion = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSamplerYcbcrConversionFeatures.samplerYcbcrConversion", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceSamplerYcbcrConversionFeatures ## **/

/** ## BEGIN VkImagePlaneMemoryRequirementsInfoKHR ## **/

class _VkImagePlaneMemoryRequirementsInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkImagePlaneMemoryRequirementsInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImagePlaneMemoryRequirementsInfoKHR();
    ~_VkImagePlaneMemoryRequirementsInfoKHR();

};

/*
#include "index.h"
#include "VkImagePlaneMemoryRequirementsInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImagePlaneMemoryRequirementsInfoKHR::constructor;

_VkImagePlaneMemoryRequirementsInfoKHR::_VkImagePlaneMemoryRequirementsInfoKHR() {
  
  
}

_VkImagePlaneMemoryRequirementsInfoKHR::~_VkImagePlaneMemoryRequirementsInfoKHR() {
  //printf("VkImagePlaneMemoryRequirementsInfoKHR deconstructed!!\n");
  
}

void _VkImagePlaneMemoryRequirementsInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImagePlaneMemoryRequirementsInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImagePlaneMemoryRequirementsInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkImagePlaneMemoryRequirementsInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImagePlaneMemoryRequirementsInfoKHR::flush() {
  _VkImagePlaneMemoryRequirementsInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImagePlaneMemoryRequirementsInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImagePlaneMemoryRequirementsInfoKHR* self = new _VkImagePlaneMemoryRequirementsInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImagePlaneMemoryRequirementsInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkImagePlaneMemoryRequirementsInfoKHR ## **/

/** ## BEGIN VkImagePlaneMemoryRequirementsInfo ## **/

class _VkImagePlaneMemoryRequirementsInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetplaneAspect);
    static NAN_SETTER(SetplaneAspect);
    

    // real instance
    VkImagePlaneMemoryRequirementsInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImagePlaneMemoryRequirementsInfo();
    ~_VkImagePlaneMemoryRequirementsInfo();

};

/*
#include "index.h"
#include "VkImagePlaneMemoryRequirementsInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImagePlaneMemoryRequirementsInfo::constructor;

_VkImagePlaneMemoryRequirementsInfo::_VkImagePlaneMemoryRequirementsInfo() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO;
  
}

_VkImagePlaneMemoryRequirementsInfo::~_VkImagePlaneMemoryRequirementsInfo() {
  //printf("VkImagePlaneMemoryRequirementsInfo deconstructed!!\n");
  
  
  
}

void _VkImagePlaneMemoryRequirementsInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImagePlaneMemoryRequirementsInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImagePlaneMemoryRequirementsInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("planeAspect").ToLocalChecked(), GetplaneAspect, SetplaneAspect, ctor);
  Nan::Set(target, Nan::New("VkImagePlaneMemoryRequirementsInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImagePlaneMemoryRequirementsInfo::flush() {
  _VkImagePlaneMemoryRequirementsInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkImagePlaneMemoryRequirementsInfo::New) {
  if (info.IsConstructCall()) {
    _VkImagePlaneMemoryRequirementsInfo* self = new _VkImagePlaneMemoryRequirementsInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("planeAspect").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImagePlaneMemoryRequirementsInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImagePlaneMemoryRequirementsInfo::GetsType) {
  _VkImagePlaneMemoryRequirementsInfo *self = Nan::ObjectWrap::Unwrap<_VkImagePlaneMemoryRequirementsInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImagePlaneMemoryRequirementsInfo::SetsType) {
  _VkImagePlaneMemoryRequirementsInfo *self = Nan::ObjectWrap::Unwrap<_VkImagePlaneMemoryRequirementsInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImagePlaneMemoryRequirementsInfo.sType", "Number");
  
    return;
  }
}// planeAspect
NAN_GETTER(_VkImagePlaneMemoryRequirementsInfo::GetplaneAspect) {
  _VkImagePlaneMemoryRequirementsInfo *self = Nan::ObjectWrap::Unwrap<_VkImagePlaneMemoryRequirementsInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.planeAspect));
}NAN_SETTER(_VkImagePlaneMemoryRequirementsInfo::SetplaneAspect) {
  _VkImagePlaneMemoryRequirementsInfo *self = Nan::ObjectWrap::Unwrap<_VkImagePlaneMemoryRequirementsInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.planeAspect = static_cast<VkImageAspectFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImagePlaneMemoryRequirementsInfo.planeAspect", "Number");
  
    return;
  }
}
/** ## END VkImagePlaneMemoryRequirementsInfo ## **/

/** ## BEGIN VkBindImagePlaneMemoryInfoKHR ## **/

class _VkBindImagePlaneMemoryInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkBindImagePlaneMemoryInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindImagePlaneMemoryInfoKHR();
    ~_VkBindImagePlaneMemoryInfoKHR();

};

/*
#include "index.h"
#include "VkBindImagePlaneMemoryInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindImagePlaneMemoryInfoKHR::constructor;

_VkBindImagePlaneMemoryInfoKHR::_VkBindImagePlaneMemoryInfoKHR() {
  
  
}

_VkBindImagePlaneMemoryInfoKHR::~_VkBindImagePlaneMemoryInfoKHR() {
  //printf("VkBindImagePlaneMemoryInfoKHR deconstructed!!\n");
  
}

void _VkBindImagePlaneMemoryInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindImagePlaneMemoryInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindImagePlaneMemoryInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkBindImagePlaneMemoryInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindImagePlaneMemoryInfoKHR::flush() {
  _VkBindImagePlaneMemoryInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkBindImagePlaneMemoryInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkBindImagePlaneMemoryInfoKHR* self = new _VkBindImagePlaneMemoryInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindImagePlaneMemoryInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkBindImagePlaneMemoryInfoKHR ## **/

/** ## BEGIN VkBindImagePlaneMemoryInfo ## **/

class _VkBindImagePlaneMemoryInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetplaneAspect);
    static NAN_SETTER(SetplaneAspect);
    

    // real instance
    VkBindImagePlaneMemoryInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindImagePlaneMemoryInfo();
    ~_VkBindImagePlaneMemoryInfo();

};

/*
#include "index.h"
#include "VkBindImagePlaneMemoryInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindImagePlaneMemoryInfo::constructor;

_VkBindImagePlaneMemoryInfo::_VkBindImagePlaneMemoryInfo() {
  instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO;
  
}

_VkBindImagePlaneMemoryInfo::~_VkBindImagePlaneMemoryInfo() {
  //printf("VkBindImagePlaneMemoryInfo deconstructed!!\n");
  
  
  
}

void _VkBindImagePlaneMemoryInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindImagePlaneMemoryInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindImagePlaneMemoryInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("planeAspect").ToLocalChecked(), GetplaneAspect, SetplaneAspect, ctor);
  Nan::Set(target, Nan::New("VkBindImagePlaneMemoryInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindImagePlaneMemoryInfo::flush() {
  _VkBindImagePlaneMemoryInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkBindImagePlaneMemoryInfo::New) {
  if (info.IsConstructCall()) {
    _VkBindImagePlaneMemoryInfo* self = new _VkBindImagePlaneMemoryInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("planeAspect").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindImagePlaneMemoryInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBindImagePlaneMemoryInfo::GetsType) {
  _VkBindImagePlaneMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImagePlaneMemoryInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBindImagePlaneMemoryInfo::SetsType) {
  _VkBindImagePlaneMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImagePlaneMemoryInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImagePlaneMemoryInfo.sType", "Number");
  
    return;
  }
}// planeAspect
NAN_GETTER(_VkBindImagePlaneMemoryInfo::GetplaneAspect) {
  _VkBindImagePlaneMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImagePlaneMemoryInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.planeAspect));
}NAN_SETTER(_VkBindImagePlaneMemoryInfo::SetplaneAspect) {
  _VkBindImagePlaneMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImagePlaneMemoryInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.planeAspect = static_cast<VkImageAspectFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImagePlaneMemoryInfo.planeAspect", "Number");
  
    return;
  }
}
/** ## END VkBindImagePlaneMemoryInfo ## **/

/** ## BEGIN VkSamplerYcbcrConversionCreateInfoKHR ## **/

class _VkSamplerYcbcrConversionCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkSamplerYcbcrConversionCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSamplerYcbcrConversionCreateInfoKHR();
    ~_VkSamplerYcbcrConversionCreateInfoKHR();

};

/*
#include "index.h"
#include "VkSamplerYcbcrConversionCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSamplerYcbcrConversionCreateInfoKHR::constructor;

_VkSamplerYcbcrConversionCreateInfoKHR::_VkSamplerYcbcrConversionCreateInfoKHR() {
  
  
}

_VkSamplerYcbcrConversionCreateInfoKHR::~_VkSamplerYcbcrConversionCreateInfoKHR() {
  //printf("VkSamplerYcbcrConversionCreateInfoKHR deconstructed!!\n");
  
}

void _VkSamplerYcbcrConversionCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerYcbcrConversionCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerYcbcrConversionCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkSamplerYcbcrConversionCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSamplerYcbcrConversionCreateInfoKHR::flush() {
  _VkSamplerYcbcrConversionCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSamplerYcbcrConversionCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkSamplerYcbcrConversionCreateInfoKHR* self = new _VkSamplerYcbcrConversionCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSamplerYcbcrConversionCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkSamplerYcbcrConversionCreateInfoKHR ## **/

/** ## BEGIN VkComponentMapping ## **/

class _VkComponentMapping: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getr);
    static NAN_SETTER(Setr);
    
    static NAN_GETTER(Getg);
    static NAN_SETTER(Setg);
    
    static NAN_GETTER(Getb);
    static NAN_SETTER(Setb);
    
    static NAN_GETTER(Geta);
    static NAN_SETTER(Seta);
    

    // real instance
    VkComponentMapping instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkComponentMapping();
    ~_VkComponentMapping();

};

/*
#include "index.h"
#include "VkComponentMapping.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkComponentMapping::constructor;

_VkComponentMapping::_VkComponentMapping() {
  
  
}

_VkComponentMapping::~_VkComponentMapping() {
  //printf("VkComponentMapping deconstructed!!\n");
  
  
  
  
  
}

void _VkComponentMapping::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkComponentMapping::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkComponentMapping").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("r").ToLocalChecked(), Getr, Setr, ctor);
  SetPrototypeAccessor(proto, Nan::New("g").ToLocalChecked(), Getg, Setg, ctor);
  SetPrototypeAccessor(proto, Nan::New("b").ToLocalChecked(), Getb, Setb, ctor);
  SetPrototypeAccessor(proto, Nan::New("a").ToLocalChecked(), Geta, Seta, ctor);
  Nan::Set(target, Nan::New("VkComponentMapping").ToLocalChecked(), ctor->GetFunction());
}

bool _VkComponentMapping::flush() {
  _VkComponentMapping *self = this;
  
  return true;
}

NAN_METHOD(_VkComponentMapping::New) {
  if (info.IsConstructCall()) {
    _VkComponentMapping* self = new _VkComponentMapping();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("r").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("g").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("b").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("a").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkComponentMapping constructor cannot be invoked without 'new'");
  }
};

// r
NAN_GETTER(_VkComponentMapping::Getr) {
  _VkComponentMapping *self = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.r));
}NAN_SETTER(_VkComponentMapping::Setr) {
  _VkComponentMapping *self = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(info.This());
  if (value->IsNumber()) {
    self->instance.r = static_cast<VkComponentSwizzle>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComponentMapping.r", "Number");
  
    return;
  }
}// g
NAN_GETTER(_VkComponentMapping::Getg) {
  _VkComponentMapping *self = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.g));
}NAN_SETTER(_VkComponentMapping::Setg) {
  _VkComponentMapping *self = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(info.This());
  if (value->IsNumber()) {
    self->instance.g = static_cast<VkComponentSwizzle>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComponentMapping.g", "Number");
  
    return;
  }
}// b
NAN_GETTER(_VkComponentMapping::Getb) {
  _VkComponentMapping *self = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.b));
}NAN_SETTER(_VkComponentMapping::Setb) {
  _VkComponentMapping *self = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(info.This());
  if (value->IsNumber()) {
    self->instance.b = static_cast<VkComponentSwizzle>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComponentMapping.b", "Number");
  
    return;
  }
}// a
NAN_GETTER(_VkComponentMapping::Geta) {
  _VkComponentMapping *self = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.a));
}NAN_SETTER(_VkComponentMapping::Seta) {
  _VkComponentMapping *self = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(info.This());
  if (value->IsNumber()) {
    self->instance.a = static_cast<VkComponentSwizzle>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComponentMapping.a", "Number");
  
    return;
  }
}
/** ## END VkComponentMapping ## **/

/** ## BEGIN VkSamplerYcbcrConversionCreateInfo ## **/

class _VkSamplerYcbcrConversionCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
    static NAN_GETTER(GetycbcrModel);
    static NAN_SETTER(SetycbcrModel);
    
    static NAN_GETTER(GetycbcrRange);
    static NAN_SETTER(SetycbcrRange);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> components;
      static NAN_GETTER(Getcomponents);
    static NAN_SETTER(Setcomponents);
    
    static NAN_GETTER(GetxChromaOffset);
    static NAN_SETTER(SetxChromaOffset);
    
    static NAN_GETTER(GetyChromaOffset);
    static NAN_SETTER(SetyChromaOffset);
    
    static NAN_GETTER(GetchromaFilter);
    static NAN_SETTER(SetchromaFilter);
    
    static NAN_GETTER(GetforceExplicitReconstruction);
    static NAN_SETTER(SetforceExplicitReconstruction);
    

    // real instance
    VkSamplerYcbcrConversionCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSamplerYcbcrConversionCreateInfo();
    ~_VkSamplerYcbcrConversionCreateInfo();

};

/*
#include "index.h"
#include "VkSamplerYcbcrConversionCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSamplerYcbcrConversionCreateInfo::constructor;

_VkSamplerYcbcrConversionCreateInfo::_VkSamplerYcbcrConversionCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO;
  
}

_VkSamplerYcbcrConversionCreateInfo::~_VkSamplerYcbcrConversionCreateInfo() {
  //printf("VkSamplerYcbcrConversionCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
}

void _VkSamplerYcbcrConversionCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerYcbcrConversionCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerYcbcrConversionCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("ycbcrModel").ToLocalChecked(), GetycbcrModel, SetycbcrModel, ctor);
  SetPrototypeAccessor(proto, Nan::New("ycbcrRange").ToLocalChecked(), GetycbcrRange, SetycbcrRange, ctor);
  SetPrototypeAccessor(proto, Nan::New("components").ToLocalChecked(), Getcomponents, Setcomponents, ctor);
  SetPrototypeAccessor(proto, Nan::New("xChromaOffset").ToLocalChecked(), GetxChromaOffset, SetxChromaOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("yChromaOffset").ToLocalChecked(), GetyChromaOffset, SetyChromaOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("chromaFilter").ToLocalChecked(), GetchromaFilter, SetchromaFilter, ctor);
  SetPrototypeAccessor(proto, Nan::New("forceExplicitReconstruction").ToLocalChecked(), GetforceExplicitReconstruction, SetforceExplicitReconstruction, ctor);
  Nan::Set(target, Nan::New("VkSamplerYcbcrConversionCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSamplerYcbcrConversionCreateInfo::flush() {
  _VkSamplerYcbcrConversionCreateInfo *self = this;
  if (!(self->components.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->components);
    
    _VkComponentMapping* result = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.components = result->instance;
  }
  return true;
}

NAN_METHOD(_VkSamplerYcbcrConversionCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkSamplerYcbcrConversionCreateInfo* self = new _VkSamplerYcbcrConversionCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("ycbcrModel").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("ycbcrRange").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("components").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("xChromaOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("yChromaOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("chromaFilter").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("forceExplicitReconstruction").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSamplerYcbcrConversionCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::GetsType) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::SetsType) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.sType", "Number");
  
    return;
  }
}// format
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::Getformat) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::Setformat) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.format", "Number");
  
    return;
  }
}// ycbcrModel
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::GetycbcrModel) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.ycbcrModel));
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::SetycbcrModel) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.ycbcrModel = static_cast<VkSamplerYcbcrModelConversion>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.ycbcrModel", "Number");
  
    return;
  }
}// ycbcrRange
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::GetycbcrRange) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.ycbcrRange));
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::SetycbcrRange) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.ycbcrRange = static_cast<VkSamplerYcbcrRange>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.ycbcrRange", "Number");
  
    return;
  }
}// components
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::Getcomponents) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (self->components.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->components);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::Setcomponents) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkComponentMapping::constructor)->HasInstance(obj)) {
      self->components.Reset<v8::Object>(value.As<v8::Object>());
      _VkComponentMapping* inst = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(obj);
      inst->flush();
      self->instance.components = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.components", "[object VkComponentMapping]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->components.Reset();
    memset(&self->instance.components, 0, sizeof(VkComponentMapping));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.components", "[object VkComponentMapping]");
  
    return;
  }
}// xChromaOffset
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::GetxChromaOffset) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.xChromaOffset));
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::SetxChromaOffset) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.xChromaOffset = static_cast<VkChromaLocation>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.xChromaOffset", "Number");
  
    return;
  }
}// yChromaOffset
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::GetyChromaOffset) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.yChromaOffset));
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::SetyChromaOffset) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.yChromaOffset = static_cast<VkChromaLocation>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.yChromaOffset", "Number");
  
    return;
  }
}// chromaFilter
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::GetchromaFilter) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.chromaFilter));
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::SetchromaFilter) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.chromaFilter = static_cast<VkFilter>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.chromaFilter", "Number");
  
    return;
  }
}// forceExplicitReconstruction
NAN_GETTER(_VkSamplerYcbcrConversionCreateInfo::GetforceExplicitReconstruction) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.forceExplicitReconstruction));
}NAN_SETTER(_VkSamplerYcbcrConversionCreateInfo::SetforceExplicitReconstruction) {
  _VkSamplerYcbcrConversionCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.forceExplicitReconstruction = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionCreateInfo.forceExplicitReconstruction", "Number");
  
    return;
  }
}
/** ## END VkSamplerYcbcrConversionCreateInfo ## **/

/** ## BEGIN VkSamplerYcbcrConversionInfoKHR ## **/

class _VkSamplerYcbcrConversionInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkSamplerYcbcrConversionInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSamplerYcbcrConversionInfoKHR();
    ~_VkSamplerYcbcrConversionInfoKHR();

};

/*
#include "index.h"
#include "VkSamplerYcbcrConversionInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSamplerYcbcrConversionInfoKHR::constructor;

_VkSamplerYcbcrConversionInfoKHR::_VkSamplerYcbcrConversionInfoKHR() {
  
  
}

_VkSamplerYcbcrConversionInfoKHR::~_VkSamplerYcbcrConversionInfoKHR() {
  //printf("VkSamplerYcbcrConversionInfoKHR deconstructed!!\n");
  
}

void _VkSamplerYcbcrConversionInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerYcbcrConversionInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerYcbcrConversionInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkSamplerYcbcrConversionInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSamplerYcbcrConversionInfoKHR::flush() {
  _VkSamplerYcbcrConversionInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSamplerYcbcrConversionInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkSamplerYcbcrConversionInfoKHR* self = new _VkSamplerYcbcrConversionInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSamplerYcbcrConversionInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkSamplerYcbcrConversionInfoKHR ## **/

/** ## BEGIN VkSamplerYcbcrConversionInfo ## **/

class _VkSamplerYcbcrConversionInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> conversion;
      static NAN_GETTER(Getconversion);
    static NAN_SETTER(Setconversion);
    

    // real instance
    VkSamplerYcbcrConversionInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSamplerYcbcrConversionInfo();
    ~_VkSamplerYcbcrConversionInfo();

};

/*
#include "index.h"
#include "VkSamplerYcbcrConversionInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSamplerYcbcrConversionInfo::constructor;

_VkSamplerYcbcrConversionInfo::_VkSamplerYcbcrConversionInfo() {
  instance.sType = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO;
  
}

_VkSamplerYcbcrConversionInfo::~_VkSamplerYcbcrConversionInfo() {
  //printf("VkSamplerYcbcrConversionInfo deconstructed!!\n");
  
  
  
}

void _VkSamplerYcbcrConversionInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerYcbcrConversionInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerYcbcrConversionInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("conversion").ToLocalChecked(), Getconversion, Setconversion, ctor);
  Nan::Set(target, Nan::New("VkSamplerYcbcrConversionInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSamplerYcbcrConversionInfo::flush() {
  _VkSamplerYcbcrConversionInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkSamplerYcbcrConversionInfo::New) {
  if (info.IsConstructCall()) {
    _VkSamplerYcbcrConversionInfo* self = new _VkSamplerYcbcrConversionInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("conversion").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSamplerYcbcrConversionInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSamplerYcbcrConversionInfo::GetsType) {
  _VkSamplerYcbcrConversionInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSamplerYcbcrConversionInfo::SetsType) {
  _VkSamplerYcbcrConversionInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionInfo.sType", "Number");
  
    return;
  }
}// conversion
NAN_GETTER(_VkSamplerYcbcrConversionInfo::Getconversion) {
  _VkSamplerYcbcrConversionInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionInfo>(info.This());
  if (self->conversion.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->conversion);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSamplerYcbcrConversionInfo::Setconversion) {
  _VkSamplerYcbcrConversionInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversionInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSamplerYcbcrConversion::constructor)->HasInstance(obj)) {
      self->conversion.Reset<v8::Object>(value.As<v8::Object>());
      _VkSamplerYcbcrConversion* inst = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversion>(obj);
      ;
      self->instance.conversion = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionInfo.conversion", "[object VkSamplerYcbcrConversion]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->conversion.Reset();
    self->instance.conversion = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerYcbcrConversionInfo.conversion", "[object VkSamplerYcbcrConversion]");
  
    return;
  }
}
/** ## END VkSamplerYcbcrConversionInfo ## **/

/** ## BEGIN VkPipelineTessellationDomainOriginStateCreateInfoKHR ## **/

class _VkPipelineTessellationDomainOriginStateCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPipelineTessellationDomainOriginStateCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineTessellationDomainOriginStateCreateInfoKHR();
    ~_VkPipelineTessellationDomainOriginStateCreateInfoKHR();

};

/*
#include "index.h"
#include "VkPipelineTessellationDomainOriginStateCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineTessellationDomainOriginStateCreateInfoKHR::constructor;

_VkPipelineTessellationDomainOriginStateCreateInfoKHR::_VkPipelineTessellationDomainOriginStateCreateInfoKHR() {
  
  
}

_VkPipelineTessellationDomainOriginStateCreateInfoKHR::~_VkPipelineTessellationDomainOriginStateCreateInfoKHR() {
  //printf("VkPipelineTessellationDomainOriginStateCreateInfoKHR deconstructed!!\n");
  
}

void _VkPipelineTessellationDomainOriginStateCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineTessellationDomainOriginStateCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineTessellationDomainOriginStateCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPipelineTessellationDomainOriginStateCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineTessellationDomainOriginStateCreateInfoKHR::flush() {
  _VkPipelineTessellationDomainOriginStateCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineTessellationDomainOriginStateCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkPipelineTessellationDomainOriginStateCreateInfoKHR* self = new _VkPipelineTessellationDomainOriginStateCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineTessellationDomainOriginStateCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPipelineTessellationDomainOriginStateCreateInfoKHR ## **/

/** ## BEGIN VkPipelineTessellationDomainOriginStateCreateInfo ## **/

class _VkPipelineTessellationDomainOriginStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdomainOrigin);
    static NAN_SETTER(SetdomainOrigin);
    

    // real instance
    VkPipelineTessellationDomainOriginStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineTessellationDomainOriginStateCreateInfo();
    ~_VkPipelineTessellationDomainOriginStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineTessellationDomainOriginStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineTessellationDomainOriginStateCreateInfo::constructor;

_VkPipelineTessellationDomainOriginStateCreateInfo::_VkPipelineTessellationDomainOriginStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO;
  
}

_VkPipelineTessellationDomainOriginStateCreateInfo::~_VkPipelineTessellationDomainOriginStateCreateInfo() {
  //printf("VkPipelineTessellationDomainOriginStateCreateInfo deconstructed!!\n");
  
  
  
}

void _VkPipelineTessellationDomainOriginStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineTessellationDomainOriginStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineTessellationDomainOriginStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("domainOrigin").ToLocalChecked(), GetdomainOrigin, SetdomainOrigin, ctor);
  Nan::Set(target, Nan::New("VkPipelineTessellationDomainOriginStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineTessellationDomainOriginStateCreateInfo::flush() {
  _VkPipelineTessellationDomainOriginStateCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineTessellationDomainOriginStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineTessellationDomainOriginStateCreateInfo* self = new _VkPipelineTessellationDomainOriginStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("domainOrigin").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineTessellationDomainOriginStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineTessellationDomainOriginStateCreateInfo::GetsType) {
  _VkPipelineTessellationDomainOriginStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationDomainOriginStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineTessellationDomainOriginStateCreateInfo::SetsType) {
  _VkPipelineTessellationDomainOriginStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationDomainOriginStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfo.sType", "Number");
  
    return;
  }
}// domainOrigin
NAN_GETTER(_VkPipelineTessellationDomainOriginStateCreateInfo::GetdomainOrigin) {
  _VkPipelineTessellationDomainOriginStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationDomainOriginStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.domainOrigin));
}NAN_SETTER(_VkPipelineTessellationDomainOriginStateCreateInfo::SetdomainOrigin) {
  _VkPipelineTessellationDomainOriginStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationDomainOriginStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.domainOrigin = static_cast<VkTessellationDomainOrigin>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineTessellationDomainOriginStateCreateInfo.domainOrigin", "Number");
  
    return;
  }
}
/** ## END VkPipelineTessellationDomainOriginStateCreateInfo ## **/

/** ## BEGIN VkImageViewUsageCreateInfoKHR ## **/

class _VkImageViewUsageCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkImageViewUsageCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageViewUsageCreateInfoKHR();
    ~_VkImageViewUsageCreateInfoKHR();

};

/*
#include "index.h"
#include "VkImageViewUsageCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageViewUsageCreateInfoKHR::constructor;

_VkImageViewUsageCreateInfoKHR::_VkImageViewUsageCreateInfoKHR() {
  
  
}

_VkImageViewUsageCreateInfoKHR::~_VkImageViewUsageCreateInfoKHR() {
  //printf("VkImageViewUsageCreateInfoKHR deconstructed!!\n");
  
}

void _VkImageViewUsageCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageViewUsageCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageViewUsageCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkImageViewUsageCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageViewUsageCreateInfoKHR::flush() {
  _VkImageViewUsageCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImageViewUsageCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImageViewUsageCreateInfoKHR* self = new _VkImageViewUsageCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageViewUsageCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkImageViewUsageCreateInfoKHR ## **/

/** ## BEGIN VkImageViewUsageCreateInfo ## **/

class _VkImageViewUsageCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getusage);
    static NAN_SETTER(Setusage);
    

    // real instance
    VkImageViewUsageCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageViewUsageCreateInfo();
    ~_VkImageViewUsageCreateInfo();

};

/*
#include "index.h"
#include "VkImageViewUsageCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageViewUsageCreateInfo::constructor;

_VkImageViewUsageCreateInfo::_VkImageViewUsageCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO;
  
}

_VkImageViewUsageCreateInfo::~_VkImageViewUsageCreateInfo() {
  //printf("VkImageViewUsageCreateInfo deconstructed!!\n");
  
  
  
}

void _VkImageViewUsageCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageViewUsageCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageViewUsageCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("usage").ToLocalChecked(), Getusage, Setusage, ctor);
  Nan::Set(target, Nan::New("VkImageViewUsageCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageViewUsageCreateInfo::flush() {
  _VkImageViewUsageCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkImageViewUsageCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkImageViewUsageCreateInfo* self = new _VkImageViewUsageCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("usage").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageViewUsageCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageViewUsageCreateInfo::GetsType) {
  _VkImageViewUsageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewUsageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageViewUsageCreateInfo::SetsType) {
  _VkImageViewUsageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewUsageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewUsageCreateInfo.sType", "Number");
  
    return;
  }
}// usage
NAN_GETTER(_VkImageViewUsageCreateInfo::Getusage) {
  _VkImageViewUsageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewUsageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.usage));
}NAN_SETTER(_VkImageViewUsageCreateInfo::Setusage) {
  _VkImageViewUsageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewUsageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.usage = static_cast<VkImageUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewUsageCreateInfo.usage", "Number");
  
    return;
  }
}
/** ## END VkImageViewUsageCreateInfo ## **/

/** ## BEGIN VkMemoryDedicatedAllocateInfoKHR ## **/

class _VkMemoryDedicatedAllocateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkMemoryDedicatedAllocateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryDedicatedAllocateInfoKHR();
    ~_VkMemoryDedicatedAllocateInfoKHR();

};

/*
#include "index.h"
#include "VkMemoryDedicatedAllocateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryDedicatedAllocateInfoKHR::constructor;

_VkMemoryDedicatedAllocateInfoKHR::_VkMemoryDedicatedAllocateInfoKHR() {
  
  
}

_VkMemoryDedicatedAllocateInfoKHR::~_VkMemoryDedicatedAllocateInfoKHR() {
  //printf("VkMemoryDedicatedAllocateInfoKHR deconstructed!!\n");
  
}

void _VkMemoryDedicatedAllocateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryDedicatedAllocateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryDedicatedAllocateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkMemoryDedicatedAllocateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryDedicatedAllocateInfoKHR::flush() {
  _VkMemoryDedicatedAllocateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryDedicatedAllocateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkMemoryDedicatedAllocateInfoKHR* self = new _VkMemoryDedicatedAllocateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryDedicatedAllocateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkMemoryDedicatedAllocateInfoKHR ## **/

/** ## BEGIN VkMemoryDedicatedAllocateInfo ## **/

class _VkMemoryDedicatedAllocateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    

    // real instance
    VkMemoryDedicatedAllocateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryDedicatedAllocateInfo();
    ~_VkMemoryDedicatedAllocateInfo();

};

/*
#include "index.h"
#include "VkMemoryDedicatedAllocateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryDedicatedAllocateInfo::constructor;

_VkMemoryDedicatedAllocateInfo::_VkMemoryDedicatedAllocateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO;
  
}

_VkMemoryDedicatedAllocateInfo::~_VkMemoryDedicatedAllocateInfo() {
  //printf("VkMemoryDedicatedAllocateInfo deconstructed!!\n");
  
  
  
  
}

void _VkMemoryDedicatedAllocateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryDedicatedAllocateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryDedicatedAllocateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  Nan::Set(target, Nan::New("VkMemoryDedicatedAllocateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryDedicatedAllocateInfo::flush() {
  _VkMemoryDedicatedAllocateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryDedicatedAllocateInfo::New) {
  if (info.IsConstructCall()) {
    _VkMemoryDedicatedAllocateInfo* self = new _VkMemoryDedicatedAllocateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("image").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("buffer").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryDedicatedAllocateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryDedicatedAllocateInfo::GetsType) {
  _VkMemoryDedicatedAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkMemoryDedicatedAllocateInfo::SetsType) {
  _VkMemoryDedicatedAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryDedicatedAllocateInfo.sType", "Number");
  
    return;
  }
}// image
NAN_GETTER(_VkMemoryDedicatedAllocateInfo::Getimage) {
  _VkMemoryDedicatedAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedAllocateInfo>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkMemoryDedicatedAllocateInfo::Setimage) {
  _VkMemoryDedicatedAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedAllocateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkMemoryDedicatedAllocateInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryDedicatedAllocateInfo.image", "[object VkImage]");
  
    return;
  }
}// buffer
NAN_GETTER(_VkMemoryDedicatedAllocateInfo::Getbuffer) {
  _VkMemoryDedicatedAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedAllocateInfo>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkMemoryDedicatedAllocateInfo::Setbuffer) {
  _VkMemoryDedicatedAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedAllocateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkMemoryDedicatedAllocateInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryDedicatedAllocateInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkMemoryDedicatedAllocateInfo ## **/

/** ## BEGIN VkMemoryDedicatedRequirementsKHR ## **/

class _VkMemoryDedicatedRequirementsKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkMemoryDedicatedRequirementsKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryDedicatedRequirementsKHR();
    ~_VkMemoryDedicatedRequirementsKHR();

};

/*
#include "index.h"
#include "VkMemoryDedicatedRequirementsKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryDedicatedRequirementsKHR::constructor;

_VkMemoryDedicatedRequirementsKHR::_VkMemoryDedicatedRequirementsKHR() {
  
  
}

_VkMemoryDedicatedRequirementsKHR::~_VkMemoryDedicatedRequirementsKHR() {
  //printf("VkMemoryDedicatedRequirementsKHR deconstructed!!\n");
  
}

void _VkMemoryDedicatedRequirementsKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryDedicatedRequirementsKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryDedicatedRequirementsKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkMemoryDedicatedRequirementsKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryDedicatedRequirementsKHR::flush() {
  _VkMemoryDedicatedRequirementsKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryDedicatedRequirementsKHR::New) {
  if (info.IsConstructCall()) {
    _VkMemoryDedicatedRequirementsKHR* self = new _VkMemoryDedicatedRequirementsKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryDedicatedRequirementsKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkMemoryDedicatedRequirementsKHR ## **/

/** ## BEGIN VkMemoryDedicatedRequirements ## **/

class _VkMemoryDedicatedRequirements: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetprefersDedicatedAllocation);
    static NAN_GETTER(GetrequiresDedicatedAllocation);

    // real instance
    VkMemoryDedicatedRequirements instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryDedicatedRequirements();
    ~_VkMemoryDedicatedRequirements();

};

/*
#include "index.h"
#include "VkMemoryDedicatedRequirements.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryDedicatedRequirements::constructor;

_VkMemoryDedicatedRequirements::_VkMemoryDedicatedRequirements() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS;
  
}

_VkMemoryDedicatedRequirements::~_VkMemoryDedicatedRequirements() {
  //printf("VkMemoryDedicatedRequirements deconstructed!!\n");
  
  
  
  
}

void _VkMemoryDedicatedRequirements::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryDedicatedRequirements::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryDedicatedRequirements").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("prefersDedicatedAllocation").ToLocalChecked(), GetprefersDedicatedAllocation, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("requiresDedicatedAllocation").ToLocalChecked(), GetrequiresDedicatedAllocation, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMemoryDedicatedRequirements").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryDedicatedRequirements::flush() {
  _VkMemoryDedicatedRequirements *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryDedicatedRequirements::New) {
  if (info.IsConstructCall()) {
    _VkMemoryDedicatedRequirements* self = new _VkMemoryDedicatedRequirements();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryDedicatedRequirements constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryDedicatedRequirements::GetsType) {
  _VkMemoryDedicatedRequirements *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// prefersDedicatedAllocation
NAN_GETTER(_VkMemoryDedicatedRequirements::GetprefersDedicatedAllocation) {
  _VkMemoryDedicatedRequirements *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.prefersDedicatedAllocation));
}// requiresDedicatedAllocation
NAN_GETTER(_VkMemoryDedicatedRequirements::GetrequiresDedicatedAllocation) {
  _VkMemoryDedicatedRequirements *self = Nan::ObjectWrap::Unwrap<_VkMemoryDedicatedRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.requiresDedicatedAllocation));
}
/** ## END VkMemoryDedicatedRequirements ## **/

/** ## BEGIN VkPhysicalDevicePointClippingPropertiesKHR ## **/

class _VkPhysicalDevicePointClippingPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDevicePointClippingPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDevicePointClippingPropertiesKHR();
    ~_VkPhysicalDevicePointClippingPropertiesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDevicePointClippingPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDevicePointClippingPropertiesKHR::constructor;

_VkPhysicalDevicePointClippingPropertiesKHR::_VkPhysicalDevicePointClippingPropertiesKHR() {
  
  
}

_VkPhysicalDevicePointClippingPropertiesKHR::~_VkPhysicalDevicePointClippingPropertiesKHR() {
  //printf("VkPhysicalDevicePointClippingPropertiesKHR deconstructed!!\n");
  
}

void _VkPhysicalDevicePointClippingPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDevicePointClippingPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDevicePointClippingPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDevicePointClippingPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDevicePointClippingPropertiesKHR::flush() {
  _VkPhysicalDevicePointClippingPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDevicePointClippingPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDevicePointClippingPropertiesKHR* self = new _VkPhysicalDevicePointClippingPropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDevicePointClippingPropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDevicePointClippingPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDevicePointClippingProperties ## **/

class _VkPhysicalDevicePointClippingProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetpointClippingBehavior);

    // real instance
    VkPhysicalDevicePointClippingProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDevicePointClippingProperties();
    ~_VkPhysicalDevicePointClippingProperties();

};

/*
#include "index.h"
#include "VkPhysicalDevicePointClippingProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDevicePointClippingProperties::constructor;

_VkPhysicalDevicePointClippingProperties::_VkPhysicalDevicePointClippingProperties() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
  
}

_VkPhysicalDevicePointClippingProperties::~_VkPhysicalDevicePointClippingProperties() {
  //printf("VkPhysicalDevicePointClippingProperties deconstructed!!\n");
  
  
  
}

void _VkPhysicalDevicePointClippingProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDevicePointClippingProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDevicePointClippingProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pointClippingBehavior").ToLocalChecked(), GetpointClippingBehavior, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDevicePointClippingProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDevicePointClippingProperties::flush() {
  _VkPhysicalDevicePointClippingProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDevicePointClippingProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDevicePointClippingProperties* self = new _VkPhysicalDevicePointClippingProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDevicePointClippingProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDevicePointClippingProperties::GetsType) {
  _VkPhysicalDevicePointClippingProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePointClippingProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// pointClippingBehavior
NAN_GETTER(_VkPhysicalDevicePointClippingProperties::GetpointClippingBehavior) {
  _VkPhysicalDevicePointClippingProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePointClippingProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pointClippingBehavior));
}
/** ## END VkPhysicalDevicePointClippingProperties ## **/

/** ## BEGIN VkSparseImageMemoryRequirements2KHR ## **/

class _VkSparseImageMemoryRequirements2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkSparseImageMemoryRequirements2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageMemoryRequirements2KHR();
    ~_VkSparseImageMemoryRequirements2KHR();

};

/*
#include "index.h"
#include "VkSparseImageMemoryRequirements2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageMemoryRequirements2KHR::constructor;

_VkSparseImageMemoryRequirements2KHR::_VkSparseImageMemoryRequirements2KHR() {
  
  
}

_VkSparseImageMemoryRequirements2KHR::~_VkSparseImageMemoryRequirements2KHR() {
  //printf("VkSparseImageMemoryRequirements2KHR deconstructed!!\n");
  
}

void _VkSparseImageMemoryRequirements2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageMemoryRequirements2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageMemoryRequirements2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkSparseImageMemoryRequirements2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageMemoryRequirements2KHR::flush() {
  _VkSparseImageMemoryRequirements2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSparseImageMemoryRequirements2KHR::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageMemoryRequirements2KHR* self = new _VkSparseImageMemoryRequirements2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageMemoryRequirements2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkSparseImageMemoryRequirements2KHR ## **/

/** ## BEGIN VkExtent3D ## **/

class _VkExtent3D: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getwidth);
    static NAN_SETTER(Setwidth);
    
    static NAN_GETTER(Getheight);
    static NAN_SETTER(Setheight);
    
    static NAN_GETTER(Getdepth);
    static NAN_SETTER(Setdepth);
    

    // real instance
    VkExtent3D instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExtent3D();
    ~_VkExtent3D();

};

/*
#include "index.h"
#include "VkExtent3D.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExtent3D::constructor;

_VkExtent3D::_VkExtent3D() {
  
  
}

_VkExtent3D::~_VkExtent3D() {
  //printf("VkExtent3D deconstructed!!\n");
  
  
  
  
}

void _VkExtent3D::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExtent3D::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExtent3D").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("width").ToLocalChecked(), Getwidth, Setwidth, ctor);
  SetPrototypeAccessor(proto, Nan::New("height").ToLocalChecked(), Getheight, Setheight, ctor);
  SetPrototypeAccessor(proto, Nan::New("depth").ToLocalChecked(), Getdepth, Setdepth, ctor);
  Nan::Set(target, Nan::New("VkExtent3D").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExtent3D::flush() {
  _VkExtent3D *self = this;
  
  return true;
}

NAN_METHOD(_VkExtent3D::New) {
  if (info.IsConstructCall()) {
    _VkExtent3D* self = new _VkExtent3D();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("width").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("height").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("depth").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExtent3D constructor cannot be invoked without 'new'");
  }
};

// width
NAN_GETTER(_VkExtent3D::Getwidth) {
  _VkExtent3D *self = Nan::ObjectWrap::Unwrap<_VkExtent3D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.width));
}NAN_SETTER(_VkExtent3D::Setwidth) {
  _VkExtent3D *self = Nan::ObjectWrap::Unwrap<_VkExtent3D>(info.This());
  if (value->IsNumber()) {
    self->instance.width = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExtent3D.width", "Number");
  
    return;
  }
}// height
NAN_GETTER(_VkExtent3D::Getheight) {
  _VkExtent3D *self = Nan::ObjectWrap::Unwrap<_VkExtent3D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.height));
}NAN_SETTER(_VkExtent3D::Setheight) {
  _VkExtent3D *self = Nan::ObjectWrap::Unwrap<_VkExtent3D>(info.This());
  if (value->IsNumber()) {
    self->instance.height = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExtent3D.height", "Number");
  
    return;
  }
}// depth
NAN_GETTER(_VkExtent3D::Getdepth) {
  _VkExtent3D *self = Nan::ObjectWrap::Unwrap<_VkExtent3D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depth));
}NAN_SETTER(_VkExtent3D::Setdepth) {
  _VkExtent3D *self = Nan::ObjectWrap::Unwrap<_VkExtent3D>(info.This());
  if (value->IsNumber()) {
    self->instance.depth = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExtent3D.depth", "Number");
  
    return;
  }
}
/** ## END VkExtent3D ## **/

/** ## BEGIN VkSparseImageFormatProperties ## **/

class _VkSparseImageFormatProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetaspectMask);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageGranularity;
      static NAN_GETTER(GetimageGranularity);
    static NAN_GETTER(Getflags);

    // real instance
    VkSparseImageFormatProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageFormatProperties();
    ~_VkSparseImageFormatProperties();

};

/*
#include "index.h"
#include "VkSparseImageFormatProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageFormatProperties::constructor;

_VkSparseImageFormatProperties::_VkSparseImageFormatProperties() {
  
  
}

_VkSparseImageFormatProperties::~_VkSparseImageFormatProperties() {
  //printf("VkSparseImageFormatProperties deconstructed!!\n");
  
  
  
  
}

void _VkSparseImageFormatProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageFormatProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageFormatProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("aspectMask").ToLocalChecked(), GetaspectMask, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageGranularity").ToLocalChecked(), GetimageGranularity, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSparseImageFormatProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageFormatProperties::flush() {
  _VkSparseImageFormatProperties *self = this;
  if (!(self->imageGranularity.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->imageGranularity);
    
  }
  return true;
}

NAN_METHOD(_VkSparseImageFormatProperties::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageFormatProperties* self = new _VkSparseImageFormatProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageFormatProperties constructor cannot be invoked without 'new'");
  }
};

// aspectMask
NAN_GETTER(_VkSparseImageFormatProperties::GetaspectMask) {
  _VkSparseImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkSparseImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.aspectMask));
}// imageGranularity
NAN_GETTER(_VkSparseImageFormatProperties::GetimageGranularity) {
  _VkSparseImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkSparseImageFormatProperties>(info.This());
  if (self->imageGranularity.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageGranularity);
    info.GetReturnValue().Set(obj);
  }
}// flags
NAN_GETTER(_VkSparseImageFormatProperties::Getflags) {
  _VkSparseImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkSparseImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}
/** ## END VkSparseImageFormatProperties ## **/

/** ## BEGIN VkSparseImageMemoryRequirements ## **/

class _VkSparseImageMemoryRequirements: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> formatProperties;
      static NAN_GETTER(GetformatProperties);
    static NAN_GETTER(GetimageMipTailFirstLod);
    static NAN_GETTER(GetimageMipTailSize);
    static NAN_GETTER(GetimageMipTailOffset);
    static NAN_GETTER(GetimageMipTailStride);

    // real instance
    VkSparseImageMemoryRequirements instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageMemoryRequirements();
    ~_VkSparseImageMemoryRequirements();

};

/*
#include "index.h"
#include "VkSparseImageMemoryRequirements.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageMemoryRequirements::constructor;

_VkSparseImageMemoryRequirements::_VkSparseImageMemoryRequirements() {
  
  
}

_VkSparseImageMemoryRequirements::~_VkSparseImageMemoryRequirements() {
  //printf("VkSparseImageMemoryRequirements deconstructed!!\n");
  
  
  
  
  
  
}

void _VkSparseImageMemoryRequirements::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageMemoryRequirements::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageMemoryRequirements").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("formatProperties").ToLocalChecked(), GetformatProperties, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageMipTailFirstLod").ToLocalChecked(), GetimageMipTailFirstLod, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageMipTailSize").ToLocalChecked(), GetimageMipTailSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageMipTailOffset").ToLocalChecked(), GetimageMipTailOffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageMipTailStride").ToLocalChecked(), GetimageMipTailStride, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSparseImageMemoryRequirements").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageMemoryRequirements::flush() {
  _VkSparseImageMemoryRequirements *self = this;
  if (!(self->formatProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->formatProperties);
    
  }
  return true;
}

NAN_METHOD(_VkSparseImageMemoryRequirements::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageMemoryRequirements* self = new _VkSparseImageMemoryRequirements();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageMemoryRequirements constructor cannot be invoked without 'new'");
  }
};

// formatProperties
NAN_GETTER(_VkSparseImageMemoryRequirements::GetformatProperties) {
  _VkSparseImageMemoryRequirements *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryRequirements>(info.This());
  if (self->formatProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->formatProperties);
    info.GetReturnValue().Set(obj);
  }
}// imageMipTailFirstLod
NAN_GETTER(_VkSparseImageMemoryRequirements::GetimageMipTailFirstLod) {
  _VkSparseImageMemoryRequirements *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageMipTailFirstLod));
}// imageMipTailSize
NAN_GETTER(_VkSparseImageMemoryRequirements::GetimageMipTailSize) {
  _VkSparseImageMemoryRequirements *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageMipTailSize));
}// imageMipTailOffset
NAN_GETTER(_VkSparseImageMemoryRequirements::GetimageMipTailOffset) {
  _VkSparseImageMemoryRequirements *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageMipTailOffset));
}// imageMipTailStride
NAN_GETTER(_VkSparseImageMemoryRequirements::GetimageMipTailStride) {
  _VkSparseImageMemoryRequirements *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageMipTailStride));
}
/** ## END VkSparseImageMemoryRequirements ## **/

/** ## BEGIN VkSparseImageMemoryRequirements2 ## **/

class _VkSparseImageMemoryRequirements2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memoryRequirements;
      static NAN_GETTER(GetmemoryRequirements);

    // real instance
    VkSparseImageMemoryRequirements2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageMemoryRequirements2();
    ~_VkSparseImageMemoryRequirements2();

};

/*
#include "index.h"
#include "VkSparseImageMemoryRequirements2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageMemoryRequirements2::constructor;

_VkSparseImageMemoryRequirements2::_VkSparseImageMemoryRequirements2() {
  instance.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2;
  
}

_VkSparseImageMemoryRequirements2::~_VkSparseImageMemoryRequirements2() {
  //printf("VkSparseImageMemoryRequirements2 deconstructed!!\n");
  
  
  
}

void _VkSparseImageMemoryRequirements2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageMemoryRequirements2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageMemoryRequirements2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryRequirements").ToLocalChecked(), GetmemoryRequirements, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSparseImageMemoryRequirements2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageMemoryRequirements2::flush() {
  _VkSparseImageMemoryRequirements2 *self = this;
  if (!(self->memoryRequirements.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->memoryRequirements);
    
  }
  return true;
}

NAN_METHOD(_VkSparseImageMemoryRequirements2::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageMemoryRequirements2* self = new _VkSparseImageMemoryRequirements2();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageMemoryRequirements2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSparseImageMemoryRequirements2::GetsType) {
  _VkSparseImageMemoryRequirements2 *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryRequirements2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// memoryRequirements
NAN_GETTER(_VkSparseImageMemoryRequirements2::GetmemoryRequirements) {
  _VkSparseImageMemoryRequirements2 *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryRequirements2>(info.This());
  if (self->memoryRequirements.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memoryRequirements);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkSparseImageMemoryRequirements2 ## **/

/** ## BEGIN VkMemoryRequirements2KHR ## **/

class _VkMemoryRequirements2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkMemoryRequirements2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryRequirements2KHR();
    ~_VkMemoryRequirements2KHR();

};

/*
#include "index.h"
#include "VkMemoryRequirements2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryRequirements2KHR::constructor;

_VkMemoryRequirements2KHR::_VkMemoryRequirements2KHR() {
  
  
}

_VkMemoryRequirements2KHR::~_VkMemoryRequirements2KHR() {
  //printf("VkMemoryRequirements2KHR deconstructed!!\n");
  
}

void _VkMemoryRequirements2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryRequirements2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryRequirements2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkMemoryRequirements2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryRequirements2KHR::flush() {
  _VkMemoryRequirements2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryRequirements2KHR::New) {
  if (info.IsConstructCall()) {
    _VkMemoryRequirements2KHR* self = new _VkMemoryRequirements2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryRequirements2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkMemoryRequirements2KHR ## **/

/** ## BEGIN VkMemoryRequirements ## **/

class _VkMemoryRequirements: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getsize);
    static NAN_GETTER(Getalignment);
    static NAN_GETTER(GetmemoryTypeBits);

    // real instance
    VkMemoryRequirements instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryRequirements();
    ~_VkMemoryRequirements();

};

/*
#include "index.h"
#include "VkMemoryRequirements.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryRequirements::constructor;

_VkMemoryRequirements::_VkMemoryRequirements() {
  
  
}

_VkMemoryRequirements::~_VkMemoryRequirements() {
  //printf("VkMemoryRequirements deconstructed!!\n");
  
  
  
  
}

void _VkMemoryRequirements::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryRequirements::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryRequirements").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("alignment").ToLocalChecked(), Getalignment, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryTypeBits").ToLocalChecked(), GetmemoryTypeBits, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMemoryRequirements").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryRequirements::flush() {
  _VkMemoryRequirements *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryRequirements::New) {
  if (info.IsConstructCall()) {
    _VkMemoryRequirements* self = new _VkMemoryRequirements();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryRequirements constructor cannot be invoked without 'new'");
  }
};

// size
NAN_GETTER(_VkMemoryRequirements::Getsize) {
  _VkMemoryRequirements *self = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}// alignment
NAN_GETTER(_VkMemoryRequirements::Getalignment) {
  _VkMemoryRequirements *self = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.alignment));
}// memoryTypeBits
NAN_GETTER(_VkMemoryRequirements::GetmemoryTypeBits) {
  _VkMemoryRequirements *self = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryTypeBits));
}
/** ## END VkMemoryRequirements ## **/

/** ## BEGIN VkMemoryRequirements2 ## **/

class _VkMemoryRequirements2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memoryRequirements;
      static NAN_GETTER(GetmemoryRequirements);

    // real instance
    VkMemoryRequirements2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryRequirements2();
    ~_VkMemoryRequirements2();

};

/*
#include "index.h"
#include "VkMemoryRequirements2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryRequirements2::constructor;

_VkMemoryRequirements2::_VkMemoryRequirements2() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2;
  
}

_VkMemoryRequirements2::~_VkMemoryRequirements2() {
  //printf("VkMemoryRequirements2 deconstructed!!\n");
  
  
  
}

void _VkMemoryRequirements2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryRequirements2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryRequirements2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryRequirements").ToLocalChecked(), GetmemoryRequirements, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMemoryRequirements2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryRequirements2::flush() {
  _VkMemoryRequirements2 *self = this;
  if (!(self->memoryRequirements.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->memoryRequirements);
    
  }
  return true;
}

NAN_METHOD(_VkMemoryRequirements2::New) {
  if (info.IsConstructCall()) {
    _VkMemoryRequirements2* self = new _VkMemoryRequirements2();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryRequirements2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryRequirements2::GetsType) {
  _VkMemoryRequirements2 *self = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// memoryRequirements
NAN_GETTER(_VkMemoryRequirements2::GetmemoryRequirements) {
  _VkMemoryRequirements2 *self = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements2>(info.This());
  if (self->memoryRequirements.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memoryRequirements);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkMemoryRequirements2 ## **/

/** ## BEGIN VkImageSparseMemoryRequirementsInfo2KHR ## **/

class _VkImageSparseMemoryRequirementsInfo2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkImageSparseMemoryRequirementsInfo2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageSparseMemoryRequirementsInfo2KHR();
    ~_VkImageSparseMemoryRequirementsInfo2KHR();

};

/*
#include "index.h"
#include "VkImageSparseMemoryRequirementsInfo2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageSparseMemoryRequirementsInfo2KHR::constructor;

_VkImageSparseMemoryRequirementsInfo2KHR::_VkImageSparseMemoryRequirementsInfo2KHR() {
  
  
}

_VkImageSparseMemoryRequirementsInfo2KHR::~_VkImageSparseMemoryRequirementsInfo2KHR() {
  //printf("VkImageSparseMemoryRequirementsInfo2KHR deconstructed!!\n");
  
}

void _VkImageSparseMemoryRequirementsInfo2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageSparseMemoryRequirementsInfo2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageSparseMemoryRequirementsInfo2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkImageSparseMemoryRequirementsInfo2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageSparseMemoryRequirementsInfo2KHR::flush() {
  _VkImageSparseMemoryRequirementsInfo2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImageSparseMemoryRequirementsInfo2KHR::New) {
  if (info.IsConstructCall()) {
    _VkImageSparseMemoryRequirementsInfo2KHR* self = new _VkImageSparseMemoryRequirementsInfo2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageSparseMemoryRequirementsInfo2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkImageSparseMemoryRequirementsInfo2KHR ## **/

/** ## BEGIN VkImageSparseMemoryRequirementsInfo2 ## **/

class _VkImageSparseMemoryRequirementsInfo2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    

    // real instance
    VkImageSparseMemoryRequirementsInfo2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageSparseMemoryRequirementsInfo2();
    ~_VkImageSparseMemoryRequirementsInfo2();

};

/*
#include "index.h"
#include "VkImageSparseMemoryRequirementsInfo2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageSparseMemoryRequirementsInfo2::constructor;

_VkImageSparseMemoryRequirementsInfo2::_VkImageSparseMemoryRequirementsInfo2() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2;
  
}

_VkImageSparseMemoryRequirementsInfo2::~_VkImageSparseMemoryRequirementsInfo2() {
  //printf("VkImageSparseMemoryRequirementsInfo2 deconstructed!!\n");
  
  
  
}

void _VkImageSparseMemoryRequirementsInfo2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageSparseMemoryRequirementsInfo2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageSparseMemoryRequirementsInfo2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  Nan::Set(target, Nan::New("VkImageSparseMemoryRequirementsInfo2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageSparseMemoryRequirementsInfo2::flush() {
  _VkImageSparseMemoryRequirementsInfo2 *self = this;
  
  return true;
}

NAN_METHOD(_VkImageSparseMemoryRequirementsInfo2::New) {
  if (info.IsConstructCall()) {
    _VkImageSparseMemoryRequirementsInfo2* self = new _VkImageSparseMemoryRequirementsInfo2();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("image").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageSparseMemoryRequirementsInfo2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageSparseMemoryRequirementsInfo2::GetsType) {
  _VkImageSparseMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkImageSparseMemoryRequirementsInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageSparseMemoryRequirementsInfo2::SetsType) {
  _VkImageSparseMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkImageSparseMemoryRequirementsInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSparseMemoryRequirementsInfo2.sType", "Number");
  
    return;
  }
}// image
NAN_GETTER(_VkImageSparseMemoryRequirementsInfo2::Getimage) {
  _VkImageSparseMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkImageSparseMemoryRequirementsInfo2>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageSparseMemoryRequirementsInfo2::Setimage) {
  _VkImageSparseMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkImageSparseMemoryRequirementsInfo2>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageSparseMemoryRequirementsInfo2.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSparseMemoryRequirementsInfo2.image", "[object VkImage]");
  
    return;
  }
}
/** ## END VkImageSparseMemoryRequirementsInfo2 ## **/

/** ## BEGIN VkImageMemoryRequirementsInfo2KHR ## **/

class _VkImageMemoryRequirementsInfo2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkImageMemoryRequirementsInfo2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageMemoryRequirementsInfo2KHR();
    ~_VkImageMemoryRequirementsInfo2KHR();

};

/*
#include "index.h"
#include "VkImageMemoryRequirementsInfo2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageMemoryRequirementsInfo2KHR::constructor;

_VkImageMemoryRequirementsInfo2KHR::_VkImageMemoryRequirementsInfo2KHR() {
  
  
}

_VkImageMemoryRequirementsInfo2KHR::~_VkImageMemoryRequirementsInfo2KHR() {
  //printf("VkImageMemoryRequirementsInfo2KHR deconstructed!!\n");
  
}

void _VkImageMemoryRequirementsInfo2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageMemoryRequirementsInfo2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageMemoryRequirementsInfo2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkImageMemoryRequirementsInfo2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageMemoryRequirementsInfo2KHR::flush() {
  _VkImageMemoryRequirementsInfo2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImageMemoryRequirementsInfo2KHR::New) {
  if (info.IsConstructCall()) {
    _VkImageMemoryRequirementsInfo2KHR* self = new _VkImageMemoryRequirementsInfo2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageMemoryRequirementsInfo2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkImageMemoryRequirementsInfo2KHR ## **/

/** ## BEGIN VkImageMemoryRequirementsInfo2 ## **/

class _VkImageMemoryRequirementsInfo2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    

    // real instance
    VkImageMemoryRequirementsInfo2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageMemoryRequirementsInfo2();
    ~_VkImageMemoryRequirementsInfo2();

};

/*
#include "index.h"
#include "VkImageMemoryRequirementsInfo2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageMemoryRequirementsInfo2::constructor;

_VkImageMemoryRequirementsInfo2::_VkImageMemoryRequirementsInfo2() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2;
  
}

_VkImageMemoryRequirementsInfo2::~_VkImageMemoryRequirementsInfo2() {
  //printf("VkImageMemoryRequirementsInfo2 deconstructed!!\n");
  
  
  
}

void _VkImageMemoryRequirementsInfo2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageMemoryRequirementsInfo2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageMemoryRequirementsInfo2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  Nan::Set(target, Nan::New("VkImageMemoryRequirementsInfo2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageMemoryRequirementsInfo2::flush() {
  _VkImageMemoryRequirementsInfo2 *self = this;
  
  return true;
}

NAN_METHOD(_VkImageMemoryRequirementsInfo2::New) {
  if (info.IsConstructCall()) {
    _VkImageMemoryRequirementsInfo2* self = new _VkImageMemoryRequirementsInfo2();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("image").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageMemoryRequirementsInfo2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageMemoryRequirementsInfo2::GetsType) {
  _VkImageMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryRequirementsInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageMemoryRequirementsInfo2::SetsType) {
  _VkImageMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryRequirementsInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryRequirementsInfo2.sType", "Number");
  
    return;
  }
}// image
NAN_GETTER(_VkImageMemoryRequirementsInfo2::Getimage) {
  _VkImageMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryRequirementsInfo2>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageMemoryRequirementsInfo2::Setimage) {
  _VkImageMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryRequirementsInfo2>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageMemoryRequirementsInfo2.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryRequirementsInfo2.image", "[object VkImage]");
  
    return;
  }
}
/** ## END VkImageMemoryRequirementsInfo2 ## **/

/** ## BEGIN VkBufferMemoryRequirementsInfo2KHR ## **/

class _VkBufferMemoryRequirementsInfo2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkBufferMemoryRequirementsInfo2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferMemoryRequirementsInfo2KHR();
    ~_VkBufferMemoryRequirementsInfo2KHR();

};

/*
#include "index.h"
#include "VkBufferMemoryRequirementsInfo2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferMemoryRequirementsInfo2KHR::constructor;

_VkBufferMemoryRequirementsInfo2KHR::_VkBufferMemoryRequirementsInfo2KHR() {
  
  
}

_VkBufferMemoryRequirementsInfo2KHR::~_VkBufferMemoryRequirementsInfo2KHR() {
  //printf("VkBufferMemoryRequirementsInfo2KHR deconstructed!!\n");
  
}

void _VkBufferMemoryRequirementsInfo2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferMemoryRequirementsInfo2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferMemoryRequirementsInfo2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkBufferMemoryRequirementsInfo2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferMemoryRequirementsInfo2KHR::flush() {
  _VkBufferMemoryRequirementsInfo2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkBufferMemoryRequirementsInfo2KHR::New) {
  if (info.IsConstructCall()) {
    _VkBufferMemoryRequirementsInfo2KHR* self = new _VkBufferMemoryRequirementsInfo2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferMemoryRequirementsInfo2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkBufferMemoryRequirementsInfo2KHR ## **/

/** ## BEGIN VkBufferMemoryRequirementsInfo2 ## **/

class _VkBufferMemoryRequirementsInfo2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    

    // real instance
    VkBufferMemoryRequirementsInfo2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferMemoryRequirementsInfo2();
    ~_VkBufferMemoryRequirementsInfo2();

};

/*
#include "index.h"
#include "VkBufferMemoryRequirementsInfo2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferMemoryRequirementsInfo2::constructor;

_VkBufferMemoryRequirementsInfo2::_VkBufferMemoryRequirementsInfo2() {
  instance.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2;
  
}

_VkBufferMemoryRequirementsInfo2::~_VkBufferMemoryRequirementsInfo2() {
  //printf("VkBufferMemoryRequirementsInfo2 deconstructed!!\n");
  
  
  
}

void _VkBufferMemoryRequirementsInfo2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferMemoryRequirementsInfo2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferMemoryRequirementsInfo2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  Nan::Set(target, Nan::New("VkBufferMemoryRequirementsInfo2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferMemoryRequirementsInfo2::flush() {
  _VkBufferMemoryRequirementsInfo2 *self = this;
  
  return true;
}

NAN_METHOD(_VkBufferMemoryRequirementsInfo2::New) {
  if (info.IsConstructCall()) {
    _VkBufferMemoryRequirementsInfo2* self = new _VkBufferMemoryRequirementsInfo2();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("buffer").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferMemoryRequirementsInfo2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBufferMemoryRequirementsInfo2::GetsType) {
  _VkBufferMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryRequirementsInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBufferMemoryRequirementsInfo2::SetsType) {
  _VkBufferMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryRequirementsInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryRequirementsInfo2.sType", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkBufferMemoryRequirementsInfo2::Getbuffer) {
  _VkBufferMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryRequirementsInfo2>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBufferMemoryRequirementsInfo2::Setbuffer) {
  _VkBufferMemoryRequirementsInfo2 *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryRequirementsInfo2>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryRequirementsInfo2.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryRequirementsInfo2.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkBufferMemoryRequirementsInfo2 ## **/

/** ## BEGIN VkPhysicalDeviceSubgroupProperties ## **/

class _VkPhysicalDeviceSubgroupProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetsubgroupSize);
    static NAN_GETTER(GetsupportedStages);
    static NAN_GETTER(GetsupportedOperations);
    static NAN_GETTER(GetquadOperationsInAllStages);

    // real instance
    VkPhysicalDeviceSubgroupProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSubgroupProperties();
    ~_VkPhysicalDeviceSubgroupProperties();

};

/*
#include "index.h"
#include "VkPhysicalDeviceSubgroupProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSubgroupProperties::constructor;

_VkPhysicalDeviceSubgroupProperties::_VkPhysicalDeviceSubgroupProperties() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
  
}

_VkPhysicalDeviceSubgroupProperties::~_VkPhysicalDeviceSubgroupProperties() {
  //printf("VkPhysicalDeviceSubgroupProperties deconstructed!!\n");
  
  
  
  
  
  
}

void _VkPhysicalDeviceSubgroupProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSubgroupProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSubgroupProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("subgroupSize").ToLocalChecked(), GetsubgroupSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedStages").ToLocalChecked(), GetsupportedStages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedOperations").ToLocalChecked(), GetsupportedOperations, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("quadOperationsInAllStages").ToLocalChecked(), GetquadOperationsInAllStages, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceSubgroupProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSubgroupProperties::flush() {
  _VkPhysicalDeviceSubgroupProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSubgroupProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSubgroupProperties* self = new _VkPhysicalDeviceSubgroupProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSubgroupProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceSubgroupProperties::GetsType) {
  _VkPhysicalDeviceSubgroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSubgroupProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// subgroupSize
NAN_GETTER(_VkPhysicalDeviceSubgroupProperties::GetsubgroupSize) {
  _VkPhysicalDeviceSubgroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSubgroupProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subgroupSize));
}// supportedStages
NAN_GETTER(_VkPhysicalDeviceSubgroupProperties::GetsupportedStages) {
  _VkPhysicalDeviceSubgroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSubgroupProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedStages));
}// supportedOperations
NAN_GETTER(_VkPhysicalDeviceSubgroupProperties::GetsupportedOperations) {
  _VkPhysicalDeviceSubgroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSubgroupProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedOperations));
}// quadOperationsInAllStages
NAN_GETTER(_VkPhysicalDeviceSubgroupProperties::GetquadOperationsInAllStages) {
  _VkPhysicalDeviceSubgroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSubgroupProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.quadOperationsInAllStages));
}
/** ## END VkPhysicalDeviceSubgroupProperties ## **/

/** ## BEGIN VkPhysicalDevice16BitStorageFeaturesKHR ## **/

class _VkPhysicalDevice16BitStorageFeaturesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDevice16BitStorageFeaturesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDevice16BitStorageFeaturesKHR();
    ~_VkPhysicalDevice16BitStorageFeaturesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDevice16BitStorageFeaturesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDevice16BitStorageFeaturesKHR::constructor;

_VkPhysicalDevice16BitStorageFeaturesKHR::_VkPhysicalDevice16BitStorageFeaturesKHR() {
  
  
}

_VkPhysicalDevice16BitStorageFeaturesKHR::~_VkPhysicalDevice16BitStorageFeaturesKHR() {
  //printf("VkPhysicalDevice16BitStorageFeaturesKHR deconstructed!!\n");
  
}

void _VkPhysicalDevice16BitStorageFeaturesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDevice16BitStorageFeaturesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDevice16BitStorageFeaturesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDevice16BitStorageFeaturesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDevice16BitStorageFeaturesKHR::flush() {
  _VkPhysicalDevice16BitStorageFeaturesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDevice16BitStorageFeaturesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDevice16BitStorageFeaturesKHR* self = new _VkPhysicalDevice16BitStorageFeaturesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDevice16BitStorageFeaturesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDevice16BitStorageFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDevice16BitStorageFeatures ## **/

class _VkPhysicalDevice16BitStorageFeatures: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetstorageBuffer16BitAccess);
    static NAN_SETTER(SetstorageBuffer16BitAccess);
    
    static NAN_GETTER(GetuniformAndStorageBuffer16BitAccess);
    static NAN_SETTER(SetuniformAndStorageBuffer16BitAccess);
    
    static NAN_GETTER(GetstoragePushConstant16);
    static NAN_SETTER(SetstoragePushConstant16);
    
    static NAN_GETTER(GetstorageInputOutput16);
    static NAN_SETTER(SetstorageInputOutput16);
    

    // real instance
    VkPhysicalDevice16BitStorageFeatures instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDevice16BitStorageFeatures();
    ~_VkPhysicalDevice16BitStorageFeatures();

};

/*
#include "index.h"
#include "VkPhysicalDevice16BitStorageFeatures.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDevice16BitStorageFeatures::constructor;

_VkPhysicalDevice16BitStorageFeatures::_VkPhysicalDevice16BitStorageFeatures() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
  
}

_VkPhysicalDevice16BitStorageFeatures::~_VkPhysicalDevice16BitStorageFeatures() {
  //printf("VkPhysicalDevice16BitStorageFeatures deconstructed!!\n");
  
  
  
  
  
  
}

void _VkPhysicalDevice16BitStorageFeatures::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDevice16BitStorageFeatures::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDevice16BitStorageFeatures").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("storageBuffer16BitAccess").ToLocalChecked(), GetstorageBuffer16BitAccess, SetstorageBuffer16BitAccess, ctor);
  SetPrototypeAccessor(proto, Nan::New("uniformAndStorageBuffer16BitAccess").ToLocalChecked(), GetuniformAndStorageBuffer16BitAccess, SetuniformAndStorageBuffer16BitAccess, ctor);
  SetPrototypeAccessor(proto, Nan::New("storagePushConstant16").ToLocalChecked(), GetstoragePushConstant16, SetstoragePushConstant16, ctor);
  SetPrototypeAccessor(proto, Nan::New("storageInputOutput16").ToLocalChecked(), GetstorageInputOutput16, SetstorageInputOutput16, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDevice16BitStorageFeatures").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDevice16BitStorageFeatures::flush() {
  _VkPhysicalDevice16BitStorageFeatures *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDevice16BitStorageFeatures::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDevice16BitStorageFeatures* self = new _VkPhysicalDevice16BitStorageFeatures();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("storageBuffer16BitAccess").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("uniformAndStorageBuffer16BitAccess").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("storagePushConstant16").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("storageInputOutput16").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDevice16BitStorageFeatures constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDevice16BitStorageFeatures::GetsType) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDevice16BitStorageFeatures::SetsType) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice16BitStorageFeatures.sType", "Number");
  
    return;
  }
}// storageBuffer16BitAccess
NAN_GETTER(_VkPhysicalDevice16BitStorageFeatures::GetstorageBuffer16BitAccess) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.storageBuffer16BitAccess));
}NAN_SETTER(_VkPhysicalDevice16BitStorageFeatures::SetstorageBuffer16BitAccess) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.storageBuffer16BitAccess = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice16BitStorageFeatures.storageBuffer16BitAccess", "Number");
  
    return;
  }
}// uniformAndStorageBuffer16BitAccess
NAN_GETTER(_VkPhysicalDevice16BitStorageFeatures::GetuniformAndStorageBuffer16BitAccess) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.uniformAndStorageBuffer16BitAccess));
}NAN_SETTER(_VkPhysicalDevice16BitStorageFeatures::SetuniformAndStorageBuffer16BitAccess) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.uniformAndStorageBuffer16BitAccess = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice16BitStorageFeatures.uniformAndStorageBuffer16BitAccess", "Number");
  
    return;
  }
}// storagePushConstant16
NAN_GETTER(_VkPhysicalDevice16BitStorageFeatures::GetstoragePushConstant16) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.storagePushConstant16));
}NAN_SETTER(_VkPhysicalDevice16BitStorageFeatures::SetstoragePushConstant16) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.storagePushConstant16 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice16BitStorageFeatures.storagePushConstant16", "Number");
  
    return;
  }
}// storageInputOutput16
NAN_GETTER(_VkPhysicalDevice16BitStorageFeatures::GetstorageInputOutput16) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.storageInputOutput16));
}NAN_SETTER(_VkPhysicalDevice16BitStorageFeatures::SetstorageInputOutput16) {
  _VkPhysicalDevice16BitStorageFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice16BitStorageFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.storageInputOutput16 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDevice16BitStorageFeatures.storageInputOutput16", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDevice16BitStorageFeatures ## **/

/** ## BEGIN VkSharedPresentSurfaceCapabilitiesKHR ## **/

class _VkSharedPresentSurfaceCapabilitiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetsharedPresentSupportedUsageFlags);

    // real instance
    VkSharedPresentSurfaceCapabilitiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSharedPresentSurfaceCapabilitiesKHR();
    ~_VkSharedPresentSurfaceCapabilitiesKHR();

};

/*
#include "index.h"
#include "VkSharedPresentSurfaceCapabilitiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSharedPresentSurfaceCapabilitiesKHR::constructor;

_VkSharedPresentSurfaceCapabilitiesKHR::_VkSharedPresentSurfaceCapabilitiesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR;
  
}

_VkSharedPresentSurfaceCapabilitiesKHR::~_VkSharedPresentSurfaceCapabilitiesKHR() {
  //printf("VkSharedPresentSurfaceCapabilitiesKHR deconstructed!!\n");
  
  
  
}

void _VkSharedPresentSurfaceCapabilitiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSharedPresentSurfaceCapabilitiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSharedPresentSurfaceCapabilitiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sharedPresentSupportedUsageFlags").ToLocalChecked(), GetsharedPresentSupportedUsageFlags, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSharedPresentSurfaceCapabilitiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSharedPresentSurfaceCapabilitiesKHR::flush() {
  _VkSharedPresentSurfaceCapabilitiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSharedPresentSurfaceCapabilitiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkSharedPresentSurfaceCapabilitiesKHR* self = new _VkSharedPresentSurfaceCapabilitiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSharedPresentSurfaceCapabilitiesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSharedPresentSurfaceCapabilitiesKHR::GetsType) {
  _VkSharedPresentSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSharedPresentSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// sharedPresentSupportedUsageFlags
NAN_GETTER(_VkSharedPresentSurfaceCapabilitiesKHR::GetsharedPresentSupportedUsageFlags) {
  _VkSharedPresentSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSharedPresentSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sharedPresentSupportedUsageFlags));
}
/** ## END VkSharedPresentSurfaceCapabilitiesKHR ## **/

/** ## BEGIN VkDisplayPlaneCapabilitiesKHR ## **/

class _VkDisplayPlaneCapabilitiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsupportedAlpha);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> minSrcPosition;
      static NAN_GETTER(GetminSrcPosition);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxSrcPosition;
      static NAN_GETTER(GetmaxSrcPosition);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> minSrcExtent;
      static NAN_GETTER(GetminSrcExtent);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxSrcExtent;
      static NAN_GETTER(GetmaxSrcExtent);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> minDstPosition;
      static NAN_GETTER(GetminDstPosition);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxDstPosition;
      static NAN_GETTER(GetmaxDstPosition);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> minDstExtent;
      static NAN_GETTER(GetminDstExtent);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxDstExtent;
      static NAN_GETTER(GetmaxDstExtent);

    // real instance
    VkDisplayPlaneCapabilitiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayPlaneCapabilitiesKHR();
    ~_VkDisplayPlaneCapabilitiesKHR();

};

/*
#include "index.h"
#include "VkDisplayPlaneCapabilitiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayPlaneCapabilitiesKHR::constructor;

_VkDisplayPlaneCapabilitiesKHR::_VkDisplayPlaneCapabilitiesKHR() {
  
  
}

_VkDisplayPlaneCapabilitiesKHR::~_VkDisplayPlaneCapabilitiesKHR() {
  //printf("VkDisplayPlaneCapabilitiesKHR deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
}

void _VkDisplayPlaneCapabilitiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayPlaneCapabilitiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayPlaneCapabilitiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("supportedAlpha").ToLocalChecked(), GetsupportedAlpha, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minSrcPosition").ToLocalChecked(), GetminSrcPosition, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSrcPosition").ToLocalChecked(), GetmaxSrcPosition, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minSrcExtent").ToLocalChecked(), GetminSrcExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSrcExtent").ToLocalChecked(), GetmaxSrcExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minDstPosition").ToLocalChecked(), GetminDstPosition, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDstPosition").ToLocalChecked(), GetmaxDstPosition, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minDstExtent").ToLocalChecked(), GetminDstExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDstExtent").ToLocalChecked(), GetmaxDstExtent, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDisplayPlaneCapabilitiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayPlaneCapabilitiesKHR::flush() {
  _VkDisplayPlaneCapabilitiesKHR *self = this;
  if (!(self->minSrcPosition.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->minSrcPosition);
    
  }if (!(self->maxSrcPosition.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxSrcPosition);
    
  }if (!(self->minSrcExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->minSrcExtent);
    
  }if (!(self->maxSrcExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxSrcExtent);
    
  }if (!(self->minDstPosition.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->minDstPosition);
    
  }if (!(self->maxDstPosition.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxDstPosition);
    
  }if (!(self->minDstExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->minDstExtent);
    
  }if (!(self->maxDstExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxDstExtent);
    
  }
  return true;
}

NAN_METHOD(_VkDisplayPlaneCapabilitiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayPlaneCapabilitiesKHR* self = new _VkDisplayPlaneCapabilitiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayPlaneCapabilitiesKHR constructor cannot be invoked without 'new'");
  }
};

// supportedAlpha
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetsupportedAlpha) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedAlpha));
}// minSrcPosition
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetminSrcPosition) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  if (self->minSrcPosition.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->minSrcPosition);
    info.GetReturnValue().Set(obj);
  }
}// maxSrcPosition
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetmaxSrcPosition) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  if (self->maxSrcPosition.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxSrcPosition);
    info.GetReturnValue().Set(obj);
  }
}// minSrcExtent
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetminSrcExtent) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  if (self->minSrcExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->minSrcExtent);
    info.GetReturnValue().Set(obj);
  }
}// maxSrcExtent
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetmaxSrcExtent) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  if (self->maxSrcExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxSrcExtent);
    info.GetReturnValue().Set(obj);
  }
}// minDstPosition
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetminDstPosition) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  if (self->minDstPosition.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->minDstPosition);
    info.GetReturnValue().Set(obj);
  }
}// maxDstPosition
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetmaxDstPosition) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  if (self->maxDstPosition.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxDstPosition);
    info.GetReturnValue().Set(obj);
  }
}// minDstExtent
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetminDstExtent) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  if (self->minDstExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->minDstExtent);
    info.GetReturnValue().Set(obj);
  }
}// maxDstExtent
NAN_GETTER(_VkDisplayPlaneCapabilitiesKHR::GetmaxDstExtent) {
  _VkDisplayPlaneCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilitiesKHR>(info.This());
  if (self->maxDstExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxDstExtent);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkDisplayPlaneCapabilitiesKHR ## **/

/** ## BEGIN VkDisplayPlaneCapabilities2KHR ## **/

class _VkDisplayPlaneCapabilities2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> capabilities;
      static NAN_GETTER(Getcapabilities);

    // real instance
    VkDisplayPlaneCapabilities2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayPlaneCapabilities2KHR();
    ~_VkDisplayPlaneCapabilities2KHR();

};

/*
#include "index.h"
#include "VkDisplayPlaneCapabilities2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayPlaneCapabilities2KHR::constructor;

_VkDisplayPlaneCapabilities2KHR::_VkDisplayPlaneCapabilities2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR;
  
}

_VkDisplayPlaneCapabilities2KHR::~_VkDisplayPlaneCapabilities2KHR() {
  //printf("VkDisplayPlaneCapabilities2KHR deconstructed!!\n");
  
  
  
}

void _VkDisplayPlaneCapabilities2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayPlaneCapabilities2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayPlaneCapabilities2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("capabilities").ToLocalChecked(), Getcapabilities, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDisplayPlaneCapabilities2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayPlaneCapabilities2KHR::flush() {
  _VkDisplayPlaneCapabilities2KHR *self = this;
  if (!(self->capabilities.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->capabilities);
    
  }
  return true;
}

NAN_METHOD(_VkDisplayPlaneCapabilities2KHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayPlaneCapabilities2KHR* self = new _VkDisplayPlaneCapabilities2KHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayPlaneCapabilities2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayPlaneCapabilities2KHR::GetsType) {
  _VkDisplayPlaneCapabilities2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilities2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// capabilities
NAN_GETTER(_VkDisplayPlaneCapabilities2KHR::Getcapabilities) {
  _VkDisplayPlaneCapabilities2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneCapabilities2KHR>(info.This());
  if (self->capabilities.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->capabilities);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkDisplayPlaneCapabilities2KHR ## **/

/** ## BEGIN VkDisplayPlaneInfo2KHR ## **/

class _VkDisplayPlaneInfo2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> mode;
      static NAN_GETTER(Getmode);
    static NAN_SETTER(Setmode);
    
    static NAN_GETTER(GetplaneIndex);
    static NAN_SETTER(SetplaneIndex);
    

    // real instance
    VkDisplayPlaneInfo2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayPlaneInfo2KHR();
    ~_VkDisplayPlaneInfo2KHR();

};

/*
#include "index.h"
#include "VkDisplayPlaneInfo2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayPlaneInfo2KHR::constructor;

_VkDisplayPlaneInfo2KHR::_VkDisplayPlaneInfo2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR;
  
}

_VkDisplayPlaneInfo2KHR::~_VkDisplayPlaneInfo2KHR() {
  //printf("VkDisplayPlaneInfo2KHR deconstructed!!\n");
  
  
  
  
}

void _VkDisplayPlaneInfo2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayPlaneInfo2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayPlaneInfo2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("mode").ToLocalChecked(), Getmode, Setmode, ctor);
  SetPrototypeAccessor(proto, Nan::New("planeIndex").ToLocalChecked(), GetplaneIndex, SetplaneIndex, ctor);
  Nan::Set(target, Nan::New("VkDisplayPlaneInfo2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayPlaneInfo2KHR::flush() {
  _VkDisplayPlaneInfo2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDisplayPlaneInfo2KHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayPlaneInfo2KHR* self = new _VkDisplayPlaneInfo2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("mode").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("planeIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayPlaneInfo2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayPlaneInfo2KHR::GetsType) {
  _VkDisplayPlaneInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDisplayPlaneInfo2KHR::SetsType) {
  _VkDisplayPlaneInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPlaneInfo2KHR.sType", "Number");
  
    return;
  }
}// mode
NAN_GETTER(_VkDisplayPlaneInfo2KHR::Getmode) {
  _VkDisplayPlaneInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneInfo2KHR>(info.This());
  if (self->mode.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->mode);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDisplayPlaneInfo2KHR::Setmode) {
  _VkDisplayPlaneInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneInfo2KHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDisplayModeKHR::constructor)->HasInstance(obj)) {
      self->mode.Reset<v8::Object>(value.As<v8::Object>());
      _VkDisplayModeKHR* inst = Nan::ObjectWrap::Unwrap<_VkDisplayModeKHR>(obj);
      ;
      self->instance.mode = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDisplayPlaneInfo2KHR.mode", "[object VkDisplayModeKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->mode.Reset();
    self->instance.mode = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPlaneInfo2KHR.mode", "[object VkDisplayModeKHR]");
  
    return;
  }
}// planeIndex
NAN_GETTER(_VkDisplayPlaneInfo2KHR::GetplaneIndex) {
  _VkDisplayPlaneInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.planeIndex));
}NAN_SETTER(_VkDisplayPlaneInfo2KHR::SetplaneIndex) {
  _VkDisplayPlaneInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.planeIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPlaneInfo2KHR.planeIndex", "Number");
  
    return;
  }
}
/** ## END VkDisplayPlaneInfo2KHR ## **/

/** ## BEGIN VkDisplayModeParametersKHR ## **/

class _VkDisplayModeParametersKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> visibleRegion;
      static NAN_GETTER(GetvisibleRegion);
    static NAN_SETTER(SetvisibleRegion);
    
    static NAN_GETTER(GetrefreshRate);
    static NAN_SETTER(SetrefreshRate);
    

    // real instance
    VkDisplayModeParametersKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayModeParametersKHR();
    ~_VkDisplayModeParametersKHR();

};

/*
#include "index.h"
#include "VkDisplayModeParametersKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayModeParametersKHR::constructor;

_VkDisplayModeParametersKHR::_VkDisplayModeParametersKHR() {
  
  
}

_VkDisplayModeParametersKHR::~_VkDisplayModeParametersKHR() {
  //printf("VkDisplayModeParametersKHR deconstructed!!\n");
  
  
  
}

void _VkDisplayModeParametersKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayModeParametersKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayModeParametersKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("visibleRegion").ToLocalChecked(), GetvisibleRegion, SetvisibleRegion, ctor);
  SetPrototypeAccessor(proto, Nan::New("refreshRate").ToLocalChecked(), GetrefreshRate, SetrefreshRate, ctor);
  Nan::Set(target, Nan::New("VkDisplayModeParametersKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayModeParametersKHR::flush() {
  _VkDisplayModeParametersKHR *self = this;
  if (!(self->visibleRegion.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->visibleRegion);
    
    _VkExtent2D* result = Nan::ObjectWrap::Unwrap<_VkExtent2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.visibleRegion = result->instance;
  }
  return true;
}

NAN_METHOD(_VkDisplayModeParametersKHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayModeParametersKHR* self = new _VkDisplayModeParametersKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("visibleRegion").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("refreshRate").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayModeParametersKHR constructor cannot be invoked without 'new'");
  }
};

// visibleRegion
NAN_GETTER(_VkDisplayModeParametersKHR::GetvisibleRegion) {
  _VkDisplayModeParametersKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeParametersKHR>(info.This());
  if (self->visibleRegion.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->visibleRegion);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDisplayModeParametersKHR::SetvisibleRegion) {
  _VkDisplayModeParametersKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeParametersKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent2D::constructor)->HasInstance(obj)) {
      self->visibleRegion.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent2D* inst = Nan::ObjectWrap::Unwrap<_VkExtent2D>(obj);
      inst->flush();
      self->instance.visibleRegion = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDisplayModeParametersKHR.visibleRegion", "[object VkExtent2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->visibleRegion.Reset();
    memset(&self->instance.visibleRegion, 0, sizeof(VkExtent2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayModeParametersKHR.visibleRegion", "[object VkExtent2D]");
  
    return;
  }
}// refreshRate
NAN_GETTER(_VkDisplayModeParametersKHR::GetrefreshRate) {
  _VkDisplayModeParametersKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeParametersKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.refreshRate));
}NAN_SETTER(_VkDisplayModeParametersKHR::SetrefreshRate) {
  _VkDisplayModeParametersKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeParametersKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.refreshRate = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayModeParametersKHR.refreshRate", "Number");
  
    return;
  }
}
/** ## END VkDisplayModeParametersKHR ## **/

/** ## BEGIN VkDisplayModePropertiesKHR ## **/

class _VkDisplayModePropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> displayMode;
      static NAN_GETTER(GetdisplayMode);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> parameters;
      static NAN_GETTER(Getparameters);

    // real instance
    VkDisplayModePropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayModePropertiesKHR();
    ~_VkDisplayModePropertiesKHR();

};

/*
#include "index.h"
#include "VkDisplayModePropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayModePropertiesKHR::constructor;

_VkDisplayModePropertiesKHR::_VkDisplayModePropertiesKHR() {
  
  
}

_VkDisplayModePropertiesKHR::~_VkDisplayModePropertiesKHR() {
  //printf("VkDisplayModePropertiesKHR deconstructed!!\n");
  
  
  
}

void _VkDisplayModePropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayModePropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayModePropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("displayMode").ToLocalChecked(), GetdisplayMode, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("parameters").ToLocalChecked(), Getparameters, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDisplayModePropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayModePropertiesKHR::flush() {
  _VkDisplayModePropertiesKHR *self = this;
  if (!(self->parameters.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->parameters);
    
  }
  return true;
}

NAN_METHOD(_VkDisplayModePropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayModePropertiesKHR* self = new _VkDisplayModePropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayModePropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// displayMode
NAN_GETTER(_VkDisplayModePropertiesKHR::GetdisplayMode) {
  _VkDisplayModePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModePropertiesKHR>(info.This());
  if (self->displayMode.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->displayMode);
    info.GetReturnValue().Set(obj);
  }
}// parameters
NAN_GETTER(_VkDisplayModePropertiesKHR::Getparameters) {
  _VkDisplayModePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModePropertiesKHR>(info.This());
  if (self->parameters.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->parameters);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkDisplayModePropertiesKHR ## **/

/** ## BEGIN VkDisplayModeProperties2KHR ## **/

class _VkDisplayModeProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> displayModeProperties;
      static NAN_GETTER(GetdisplayModeProperties);

    // real instance
    VkDisplayModeProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayModeProperties2KHR();
    ~_VkDisplayModeProperties2KHR();

};

/*
#include "index.h"
#include "VkDisplayModeProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayModeProperties2KHR::constructor;

_VkDisplayModeProperties2KHR::_VkDisplayModeProperties2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR;
  
}

_VkDisplayModeProperties2KHR::~_VkDisplayModeProperties2KHR() {
  //printf("VkDisplayModeProperties2KHR deconstructed!!\n");
  
  
  
}

void _VkDisplayModeProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayModeProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayModeProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayModeProperties").ToLocalChecked(), GetdisplayModeProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDisplayModeProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayModeProperties2KHR::flush() {
  _VkDisplayModeProperties2KHR *self = this;
  if (!(self->displayModeProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->displayModeProperties);
    
  }
  return true;
}

NAN_METHOD(_VkDisplayModeProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayModeProperties2KHR* self = new _VkDisplayModeProperties2KHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayModeProperties2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayModeProperties2KHR::GetsType) {
  _VkDisplayModeProperties2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeProperties2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// displayModeProperties
NAN_GETTER(_VkDisplayModeProperties2KHR::GetdisplayModeProperties) {
  _VkDisplayModeProperties2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeProperties2KHR>(info.This());
  if (self->displayModeProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->displayModeProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkDisplayModeProperties2KHR ## **/

/** ## BEGIN VkDisplayPlanePropertiesKHR ## **/

class _VkDisplayPlanePropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> currentDisplay;
      static NAN_GETTER(GetcurrentDisplay);
    static NAN_GETTER(GetcurrentStackIndex);

    // real instance
    VkDisplayPlanePropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayPlanePropertiesKHR();
    ~_VkDisplayPlanePropertiesKHR();

};

/*
#include "index.h"
#include "VkDisplayPlanePropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayPlanePropertiesKHR::constructor;

_VkDisplayPlanePropertiesKHR::_VkDisplayPlanePropertiesKHR() {
  
  
}

_VkDisplayPlanePropertiesKHR::~_VkDisplayPlanePropertiesKHR() {
  //printf("VkDisplayPlanePropertiesKHR deconstructed!!\n");
  
  
  
}

void _VkDisplayPlanePropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayPlanePropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayPlanePropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("currentDisplay").ToLocalChecked(), GetcurrentDisplay, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("currentStackIndex").ToLocalChecked(), GetcurrentStackIndex, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDisplayPlanePropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayPlanePropertiesKHR::flush() {
  _VkDisplayPlanePropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDisplayPlanePropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayPlanePropertiesKHR* self = new _VkDisplayPlanePropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayPlanePropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// currentDisplay
NAN_GETTER(_VkDisplayPlanePropertiesKHR::GetcurrentDisplay) {
  _VkDisplayPlanePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlanePropertiesKHR>(info.This());
  if (self->currentDisplay.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->currentDisplay);
    info.GetReturnValue().Set(obj);
  }
}// currentStackIndex
NAN_GETTER(_VkDisplayPlanePropertiesKHR::GetcurrentStackIndex) {
  _VkDisplayPlanePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlanePropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.currentStackIndex));
}
/** ## END VkDisplayPlanePropertiesKHR ## **/

/** ## BEGIN VkDisplayPlaneProperties2KHR ## **/

class _VkDisplayPlaneProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> displayPlaneProperties;
      static NAN_GETTER(GetdisplayPlaneProperties);

    // real instance
    VkDisplayPlaneProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayPlaneProperties2KHR();
    ~_VkDisplayPlaneProperties2KHR();

};

/*
#include "index.h"
#include "VkDisplayPlaneProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayPlaneProperties2KHR::constructor;

_VkDisplayPlaneProperties2KHR::_VkDisplayPlaneProperties2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR;
  
}

_VkDisplayPlaneProperties2KHR::~_VkDisplayPlaneProperties2KHR() {
  //printf("VkDisplayPlaneProperties2KHR deconstructed!!\n");
  
  
  
}

void _VkDisplayPlaneProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayPlaneProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayPlaneProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayPlaneProperties").ToLocalChecked(), GetdisplayPlaneProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDisplayPlaneProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayPlaneProperties2KHR::flush() {
  _VkDisplayPlaneProperties2KHR *self = this;
  if (!(self->displayPlaneProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->displayPlaneProperties);
    
  }
  return true;
}

NAN_METHOD(_VkDisplayPlaneProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayPlaneProperties2KHR* self = new _VkDisplayPlaneProperties2KHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayPlaneProperties2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayPlaneProperties2KHR::GetsType) {
  _VkDisplayPlaneProperties2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneProperties2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// displayPlaneProperties
NAN_GETTER(_VkDisplayPlaneProperties2KHR::GetdisplayPlaneProperties) {
  _VkDisplayPlaneProperties2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPlaneProperties2KHR>(info.This());
  if (self->displayPlaneProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->displayPlaneProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkDisplayPlaneProperties2KHR ## **/

/** ## BEGIN VkDisplayPropertiesKHR ## **/

class _VkDisplayPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> display;
      static NAN_GETTER(Getdisplay);
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> displayName;
    static NAN_GETTER(GetdisplayName);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> physicalDimensions;
      static NAN_GETTER(GetphysicalDimensions);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> physicalResolution;
      static NAN_GETTER(GetphysicalResolution);
    static NAN_GETTER(GetsupportedTransforms);
    static NAN_GETTER(GetplaneReorderPossible);
    static NAN_GETTER(GetpersistentContent);

    // real instance
    VkDisplayPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayPropertiesKHR();
    ~_VkDisplayPropertiesKHR();

};

/*
#include "index.h"
#include "VkDisplayPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayPropertiesKHR::constructor;

_VkDisplayPropertiesKHR::_VkDisplayPropertiesKHR() {
  
  
}

_VkDisplayPropertiesKHR::~_VkDisplayPropertiesKHR() {
  //printf("VkDisplayPropertiesKHR deconstructed!!\n");
  
  
  displayName.Reset();
  
  
  
  
  
  
}

void _VkDisplayPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("display").ToLocalChecked(), Getdisplay, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayName").ToLocalChecked(), GetdisplayName, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("physicalDimensions").ToLocalChecked(), GetphysicalDimensions, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("physicalResolution").ToLocalChecked(), GetphysicalResolution, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedTransforms").ToLocalChecked(), GetsupportedTransforms, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("planeReorderPossible").ToLocalChecked(), GetplaneReorderPossible, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("persistentContent").ToLocalChecked(), GetpersistentContent, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDisplayPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayPropertiesKHR::flush() {
  _VkDisplayPropertiesKHR *self = this;
  if (!(self->physicalDimensions.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->physicalDimensions);
    
  }if (!(self->physicalResolution.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->physicalResolution);
    
  }
  return true;
}

NAN_METHOD(_VkDisplayPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayPropertiesKHR* self = new _VkDisplayPropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayPropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// display
NAN_GETTER(_VkDisplayPropertiesKHR::Getdisplay) {
  _VkDisplayPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPropertiesKHR>(info.This());
  if (self->display.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->display);
    info.GetReturnValue().Set(obj);
  }
}// displayName
NAN_GETTER(_VkDisplayPropertiesKHR::GetdisplayName) {
  _VkDisplayPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPropertiesKHR>(info.This());
  if (self->displayName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->displayName);
    info.GetReturnValue().Set(str);
  }
}// physicalDimensions
NAN_GETTER(_VkDisplayPropertiesKHR::GetphysicalDimensions) {
  _VkDisplayPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPropertiesKHR>(info.This());
  if (self->physicalDimensions.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->physicalDimensions);
    info.GetReturnValue().Set(obj);
  }
}// physicalResolution
NAN_GETTER(_VkDisplayPropertiesKHR::GetphysicalResolution) {
  _VkDisplayPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPropertiesKHR>(info.This());
  if (self->physicalResolution.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->physicalResolution);
    info.GetReturnValue().Set(obj);
  }
}// supportedTransforms
NAN_GETTER(_VkDisplayPropertiesKHR::GetsupportedTransforms) {
  _VkDisplayPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedTransforms));
}// planeReorderPossible
NAN_GETTER(_VkDisplayPropertiesKHR::GetplaneReorderPossible) {
  _VkDisplayPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.planeReorderPossible));
}// persistentContent
NAN_GETTER(_VkDisplayPropertiesKHR::GetpersistentContent) {
  _VkDisplayPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.persistentContent));
}
/** ## END VkDisplayPropertiesKHR ## **/

/** ## BEGIN VkDisplayProperties2KHR ## **/

class _VkDisplayProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> displayProperties;
      static NAN_GETTER(GetdisplayProperties);

    // real instance
    VkDisplayProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayProperties2KHR();
    ~_VkDisplayProperties2KHR();

};

/*
#include "index.h"
#include "VkDisplayProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayProperties2KHR::constructor;

_VkDisplayProperties2KHR::_VkDisplayProperties2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR;
  
}

_VkDisplayProperties2KHR::~_VkDisplayProperties2KHR() {
  //printf("VkDisplayProperties2KHR deconstructed!!\n");
  
  
  
}

void _VkDisplayProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayProperties").ToLocalChecked(), GetdisplayProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDisplayProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayProperties2KHR::flush() {
  _VkDisplayProperties2KHR *self = this;
  if (!(self->displayProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->displayProperties);
    
  }
  return true;
}

NAN_METHOD(_VkDisplayProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayProperties2KHR* self = new _VkDisplayProperties2KHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayProperties2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayProperties2KHR::GetsType) {
  _VkDisplayProperties2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayProperties2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// displayProperties
NAN_GETTER(_VkDisplayProperties2KHR::GetdisplayProperties) {
  _VkDisplayProperties2KHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayProperties2KHR>(info.This());
  if (self->displayProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->displayProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkDisplayProperties2KHR ## **/

/** ## BEGIN VkSurfaceFormatKHR ## **/

class _VkSurfaceFormatKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getformat);
    static NAN_GETTER(GetcolorSpace);

    // real instance
    VkSurfaceFormatKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSurfaceFormatKHR();
    ~_VkSurfaceFormatKHR();

};

/*
#include "index.h"
#include "VkSurfaceFormatKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSurfaceFormatKHR::constructor;

_VkSurfaceFormatKHR::_VkSurfaceFormatKHR() {
  
  
}

_VkSurfaceFormatKHR::~_VkSurfaceFormatKHR() {
  //printf("VkSurfaceFormatKHR deconstructed!!\n");
  
  
  
}

void _VkSurfaceFormatKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSurfaceFormatKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSurfaceFormatKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("colorSpace").ToLocalChecked(), GetcolorSpace, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSurfaceFormatKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSurfaceFormatKHR::flush() {
  _VkSurfaceFormatKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSurfaceFormatKHR::New) {
  if (info.IsConstructCall()) {
    _VkSurfaceFormatKHR* self = new _VkSurfaceFormatKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSurfaceFormatKHR constructor cannot be invoked without 'new'");
  }
};

// format
NAN_GETTER(_VkSurfaceFormatKHR::Getformat) {
  _VkSurfaceFormatKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceFormatKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}// colorSpace
NAN_GETTER(_VkSurfaceFormatKHR::GetcolorSpace) {
  _VkSurfaceFormatKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceFormatKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.colorSpace));
}
/** ## END VkSurfaceFormatKHR ## **/

/** ## BEGIN VkSurfaceFormat2KHR ## **/

class _VkSurfaceFormat2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> surfaceFormat;
      static NAN_GETTER(GetsurfaceFormat);

    // real instance
    VkSurfaceFormat2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSurfaceFormat2KHR();
    ~_VkSurfaceFormat2KHR();

};

/*
#include "index.h"
#include "VkSurfaceFormat2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSurfaceFormat2KHR::constructor;

_VkSurfaceFormat2KHR::_VkSurfaceFormat2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR;
  
}

_VkSurfaceFormat2KHR::~_VkSurfaceFormat2KHR() {
  //printf("VkSurfaceFormat2KHR deconstructed!!\n");
  
  
  
}

void _VkSurfaceFormat2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSurfaceFormat2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSurfaceFormat2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("surfaceFormat").ToLocalChecked(), GetsurfaceFormat, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSurfaceFormat2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSurfaceFormat2KHR::flush() {
  _VkSurfaceFormat2KHR *self = this;
  if (!(self->surfaceFormat.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->surfaceFormat);
    
  }
  return true;
}

NAN_METHOD(_VkSurfaceFormat2KHR::New) {
  if (info.IsConstructCall()) {
    _VkSurfaceFormat2KHR* self = new _VkSurfaceFormat2KHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSurfaceFormat2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSurfaceFormat2KHR::GetsType) {
  _VkSurfaceFormat2KHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceFormat2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// surfaceFormat
NAN_GETTER(_VkSurfaceFormat2KHR::GetsurfaceFormat) {
  _VkSurfaceFormat2KHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceFormat2KHR>(info.This());
  if (self->surfaceFormat.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->surfaceFormat);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkSurfaceFormat2KHR ## **/

/** ## BEGIN VkSurfaceCapabilitiesKHR ## **/

class _VkSurfaceCapabilitiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetminImageCount);
    static NAN_GETTER(GetmaxImageCount);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> currentExtent;
      static NAN_GETTER(GetcurrentExtent);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> minImageExtent;
      static NAN_GETTER(GetminImageExtent);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxImageExtent;
      static NAN_GETTER(GetmaxImageExtent);
    static NAN_GETTER(GetmaxImageArrayLayers);
    static NAN_GETTER(GetsupportedTransforms);
    static NAN_GETTER(GetcurrentTransform);
    static NAN_GETTER(GetsupportedCompositeAlpha);
    static NAN_GETTER(GetsupportedUsageFlags);

    // real instance
    VkSurfaceCapabilitiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSurfaceCapabilitiesKHR();
    ~_VkSurfaceCapabilitiesKHR();

};

/*
#include "index.h"
#include "VkSurfaceCapabilitiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSurfaceCapabilitiesKHR::constructor;

_VkSurfaceCapabilitiesKHR::_VkSurfaceCapabilitiesKHR() {
  
  
}

_VkSurfaceCapabilitiesKHR::~_VkSurfaceCapabilitiesKHR() {
  //printf("VkSurfaceCapabilitiesKHR deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
}

void _VkSurfaceCapabilitiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSurfaceCapabilitiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSurfaceCapabilitiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("minImageCount").ToLocalChecked(), GetminImageCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageCount").ToLocalChecked(), GetmaxImageCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("currentExtent").ToLocalChecked(), GetcurrentExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minImageExtent").ToLocalChecked(), GetminImageExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageExtent").ToLocalChecked(), GetmaxImageExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageArrayLayers").ToLocalChecked(), GetmaxImageArrayLayers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedTransforms").ToLocalChecked(), GetsupportedTransforms, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("currentTransform").ToLocalChecked(), GetcurrentTransform, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedCompositeAlpha").ToLocalChecked(), GetsupportedCompositeAlpha, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedUsageFlags").ToLocalChecked(), GetsupportedUsageFlags, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSurfaceCapabilitiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSurfaceCapabilitiesKHR::flush() {
  _VkSurfaceCapabilitiesKHR *self = this;
  if (!(self->currentExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->currentExtent);
    
  }if (!(self->minImageExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->minImageExtent);
    
  }if (!(self->maxImageExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxImageExtent);
    
  }
  return true;
}

NAN_METHOD(_VkSurfaceCapabilitiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkSurfaceCapabilitiesKHR* self = new _VkSurfaceCapabilitiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSurfaceCapabilitiesKHR constructor cannot be invoked without 'new'");
  }
};

// minImageCount
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetminImageCount) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minImageCount));
}// maxImageCount
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetmaxImageCount) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageCount));
}// currentExtent
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetcurrentExtent) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  if (self->currentExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->currentExtent);
    info.GetReturnValue().Set(obj);
  }
}// minImageExtent
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetminImageExtent) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  if (self->minImageExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->minImageExtent);
    info.GetReturnValue().Set(obj);
  }
}// maxImageExtent
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetmaxImageExtent) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  if (self->maxImageExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxImageExtent);
    info.GetReturnValue().Set(obj);
  }
}// maxImageArrayLayers
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetmaxImageArrayLayers) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageArrayLayers));
}// supportedTransforms
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetsupportedTransforms) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedTransforms));
}// currentTransform
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetcurrentTransform) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.currentTransform));
}// supportedCompositeAlpha
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetsupportedCompositeAlpha) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedCompositeAlpha));
}// supportedUsageFlags
NAN_GETTER(_VkSurfaceCapabilitiesKHR::GetsupportedUsageFlags) {
  _VkSurfaceCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedUsageFlags));
}
/** ## END VkSurfaceCapabilitiesKHR ## **/

/** ## BEGIN VkSurfaceCapabilities2KHR ## **/

class _VkSurfaceCapabilities2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> surfaceCapabilities;
      static NAN_GETTER(GetsurfaceCapabilities);

    // real instance
    VkSurfaceCapabilities2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSurfaceCapabilities2KHR();
    ~_VkSurfaceCapabilities2KHR();

};

/*
#include "index.h"
#include "VkSurfaceCapabilities2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSurfaceCapabilities2KHR::constructor;

_VkSurfaceCapabilities2KHR::_VkSurfaceCapabilities2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR;
  
}

_VkSurfaceCapabilities2KHR::~_VkSurfaceCapabilities2KHR() {
  //printf("VkSurfaceCapabilities2KHR deconstructed!!\n");
  
  
  
}

void _VkSurfaceCapabilities2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSurfaceCapabilities2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSurfaceCapabilities2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("surfaceCapabilities").ToLocalChecked(), GetsurfaceCapabilities, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSurfaceCapabilities2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSurfaceCapabilities2KHR::flush() {
  _VkSurfaceCapabilities2KHR *self = this;
  if (!(self->surfaceCapabilities.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->surfaceCapabilities);
    
  }
  return true;
}

NAN_METHOD(_VkSurfaceCapabilities2KHR::New) {
  if (info.IsConstructCall()) {
    _VkSurfaceCapabilities2KHR* self = new _VkSurfaceCapabilities2KHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSurfaceCapabilities2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSurfaceCapabilities2KHR::GetsType) {
  _VkSurfaceCapabilities2KHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// surfaceCapabilities
NAN_GETTER(_VkSurfaceCapabilities2KHR::GetsurfaceCapabilities) {
  _VkSurfaceCapabilities2KHR *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2KHR>(info.This());
  if (self->surfaceCapabilities.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->surfaceCapabilities);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkSurfaceCapabilities2KHR ## **/

/** ## BEGIN VkPhysicalDeviceSurfaceInfo2KHR ## **/

class _VkPhysicalDeviceSurfaceInfo2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> surface;
      static NAN_GETTER(Getsurface);
    static NAN_SETTER(Setsurface);
    

    // real instance
    VkPhysicalDeviceSurfaceInfo2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSurfaceInfo2KHR();
    ~_VkPhysicalDeviceSurfaceInfo2KHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceSurfaceInfo2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSurfaceInfo2KHR::constructor;

_VkPhysicalDeviceSurfaceInfo2KHR::_VkPhysicalDeviceSurfaceInfo2KHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR;
  
}

_VkPhysicalDeviceSurfaceInfo2KHR::~_VkPhysicalDeviceSurfaceInfo2KHR() {
  //printf("VkPhysicalDeviceSurfaceInfo2KHR deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceSurfaceInfo2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSurfaceInfo2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSurfaceInfo2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("surface").ToLocalChecked(), Getsurface, Setsurface, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceSurfaceInfo2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSurfaceInfo2KHR::flush() {
  _VkPhysicalDeviceSurfaceInfo2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSurfaceInfo2KHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSurfaceInfo2KHR* self = new _VkPhysicalDeviceSurfaceInfo2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("surface").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSurfaceInfo2KHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceSurfaceInfo2KHR::GetsType) {
  _VkPhysicalDeviceSurfaceInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSurfaceInfo2KHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceSurfaceInfo2KHR::SetsType) {
  _VkPhysicalDeviceSurfaceInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSurfaceInfo2KHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSurfaceInfo2KHR.sType", "Number");
  
    return;
  }
}// surface
NAN_GETTER(_VkPhysicalDeviceSurfaceInfo2KHR::Getsurface) {
  _VkPhysicalDeviceSurfaceInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSurfaceInfo2KHR>(info.This());
  if (self->surface.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->surface);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPhysicalDeviceSurfaceInfo2KHR::Setsurface) {
  _VkPhysicalDeviceSurfaceInfo2KHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSurfaceInfo2KHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSurfaceKHR::constructor)->HasInstance(obj)) {
      self->surface.Reset<v8::Object>(value.As<v8::Object>());
      _VkSurfaceKHR* inst = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(obj);
      ;
      self->instance.surface = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSurfaceInfo2KHR.surface", "[object VkSurfaceKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->surface.Reset();
    self->instance.surface = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSurfaceInfo2KHR.surface", "[object VkSurfaceKHR]");
  
    return;
  }
}
/** ## END VkPhysicalDeviceSurfaceInfo2KHR ## **/

/** ## BEGIN VkRenderPassInputAttachmentAspectCreateInfoKHR ## **/

class _VkRenderPassInputAttachmentAspectCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkRenderPassInputAttachmentAspectCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassInputAttachmentAspectCreateInfoKHR();
    ~_VkRenderPassInputAttachmentAspectCreateInfoKHR();

};

/*
#include "index.h"
#include "VkRenderPassInputAttachmentAspectCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassInputAttachmentAspectCreateInfoKHR::constructor;

_VkRenderPassInputAttachmentAspectCreateInfoKHR::_VkRenderPassInputAttachmentAspectCreateInfoKHR() {
  
  
}

_VkRenderPassInputAttachmentAspectCreateInfoKHR::~_VkRenderPassInputAttachmentAspectCreateInfoKHR() {
  //printf("VkRenderPassInputAttachmentAspectCreateInfoKHR deconstructed!!\n");
  
}

void _VkRenderPassInputAttachmentAspectCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassInputAttachmentAspectCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassInputAttachmentAspectCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkRenderPassInputAttachmentAspectCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassInputAttachmentAspectCreateInfoKHR::flush() {
  _VkRenderPassInputAttachmentAspectCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkRenderPassInputAttachmentAspectCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassInputAttachmentAspectCreateInfoKHR* self = new _VkRenderPassInputAttachmentAspectCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassInputAttachmentAspectCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkRenderPassInputAttachmentAspectCreateInfoKHR ## **/

/** ## BEGIN VkInputAttachmentAspectReference ## **/

class _VkInputAttachmentAspectReference: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getsubpass);
    static NAN_SETTER(Setsubpass);
    
    static NAN_GETTER(GetinputAttachmentIndex);
    static NAN_SETTER(SetinputAttachmentIndex);
    
    static NAN_GETTER(GetaspectMask);
    static NAN_SETTER(SetaspectMask);
    

    // real instance
    VkInputAttachmentAspectReference instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkInputAttachmentAspectReference();
    ~_VkInputAttachmentAspectReference();

};

/*
#include "index.h"
#include "VkInputAttachmentAspectReference.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkInputAttachmentAspectReference::constructor;

_VkInputAttachmentAspectReference::_VkInputAttachmentAspectReference() {
  
  
}

_VkInputAttachmentAspectReference::~_VkInputAttachmentAspectReference() {
  //printf("VkInputAttachmentAspectReference deconstructed!!\n");
  
  
  
  
}

void _VkInputAttachmentAspectReference::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkInputAttachmentAspectReference::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkInputAttachmentAspectReference").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("subpass").ToLocalChecked(), Getsubpass, Setsubpass, ctor);
  SetPrototypeAccessor(proto, Nan::New("inputAttachmentIndex").ToLocalChecked(), GetinputAttachmentIndex, SetinputAttachmentIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("aspectMask").ToLocalChecked(), GetaspectMask, SetaspectMask, ctor);
  Nan::Set(target, Nan::New("VkInputAttachmentAspectReference").ToLocalChecked(), ctor->GetFunction());
}

bool _VkInputAttachmentAspectReference::flush() {
  _VkInputAttachmentAspectReference *self = this;
  
  return true;
}

NAN_METHOD(_VkInputAttachmentAspectReference::New) {
  if (info.IsConstructCall()) {
    _VkInputAttachmentAspectReference* self = new _VkInputAttachmentAspectReference();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("subpass").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("inputAttachmentIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("aspectMask").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkInputAttachmentAspectReference constructor cannot be invoked without 'new'");
  }
};

// subpass
NAN_GETTER(_VkInputAttachmentAspectReference::Getsubpass) {
  _VkInputAttachmentAspectReference *self = Nan::ObjectWrap::Unwrap<_VkInputAttachmentAspectReference>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subpass));
}NAN_SETTER(_VkInputAttachmentAspectReference::Setsubpass) {
  _VkInputAttachmentAspectReference *self = Nan::ObjectWrap::Unwrap<_VkInputAttachmentAspectReference>(info.This());
  if (value->IsNumber()) {
    self->instance.subpass = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkInputAttachmentAspectReference.subpass", "Number");
  
    return;
  }
}// inputAttachmentIndex
NAN_GETTER(_VkInputAttachmentAspectReference::GetinputAttachmentIndex) {
  _VkInputAttachmentAspectReference *self = Nan::ObjectWrap::Unwrap<_VkInputAttachmentAspectReference>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.inputAttachmentIndex));
}NAN_SETTER(_VkInputAttachmentAspectReference::SetinputAttachmentIndex) {
  _VkInputAttachmentAspectReference *self = Nan::ObjectWrap::Unwrap<_VkInputAttachmentAspectReference>(info.This());
  if (value->IsNumber()) {
    self->instance.inputAttachmentIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkInputAttachmentAspectReference.inputAttachmentIndex", "Number");
  
    return;
  }
}// aspectMask
NAN_GETTER(_VkInputAttachmentAspectReference::GetaspectMask) {
  _VkInputAttachmentAspectReference *self = Nan::ObjectWrap::Unwrap<_VkInputAttachmentAspectReference>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.aspectMask));
}NAN_SETTER(_VkInputAttachmentAspectReference::SetaspectMask) {
  _VkInputAttachmentAspectReference *self = Nan::ObjectWrap::Unwrap<_VkInputAttachmentAspectReference>(info.This());
  if (value->IsNumber()) {
    self->instance.aspectMask = static_cast<VkImageAspectFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkInputAttachmentAspectReference.aspectMask", "Number");
  
    return;
  }
}
/** ## END VkInputAttachmentAspectReference ## **/

/** ## BEGIN VkRenderPassInputAttachmentAspectCreateInfo ## **/

class _VkRenderPassInputAttachmentAspectCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetaspectReferenceCount);
    static NAN_SETTER(SetaspectReferenceCount);
    
    std::vector<VkInputAttachmentAspectReference>* vpAspectReferences;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAspectReferences;
    static NAN_GETTER(GetpAspectReferences);
    static NAN_SETTER(SetpAspectReferences);
    

    // real instance
    VkRenderPassInputAttachmentAspectCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassInputAttachmentAspectCreateInfo();
    ~_VkRenderPassInputAttachmentAspectCreateInfo();

};

/*
#include "index.h"
#include "VkRenderPassInputAttachmentAspectCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassInputAttachmentAspectCreateInfo::constructor;

_VkRenderPassInputAttachmentAspectCreateInfo::_VkRenderPassInputAttachmentAspectCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO;
  vpAspectReferences = new std::vector<VkInputAttachmentAspectReference>;
  
}

_VkRenderPassInputAttachmentAspectCreateInfo::~_VkRenderPassInputAttachmentAspectCreateInfo() {
  //printf("VkRenderPassInputAttachmentAspectCreateInfo deconstructed!!\n");
  
  
  
  vpAspectReferences->clear();
  delete vpAspectReferences;
  
  pAspectReferences.Reset();
  
}

void _VkRenderPassInputAttachmentAspectCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassInputAttachmentAspectCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassInputAttachmentAspectCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("aspectReferenceCount").ToLocalChecked(), GetaspectReferenceCount, SetaspectReferenceCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAspectReferences").ToLocalChecked(), GetpAspectReferences, SetpAspectReferences, ctor);
  Nan::Set(target, Nan::New("VkRenderPassInputAttachmentAspectCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassInputAttachmentAspectCreateInfo::flush() {
  _VkRenderPassInputAttachmentAspectCreateInfo *self = this;
  if (!(self->pAspectReferences.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAspectReferences);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.aspectReferenceCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences'");
      return false;
    }
    std::vector<VkInputAttachmentAspectReference>* data = self->vpAspectReferences;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkInputAttachmentAspectReference::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
        return false;
      }
      _VkInputAttachmentAspectReference* result = Nan::ObjectWrap::Unwrap<_VkInputAttachmentAspectReference>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAspectReferences = data->data();
  }
  return true;
}

NAN_METHOD(_VkRenderPassInputAttachmentAspectCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassInputAttachmentAspectCreateInfo* self = new _VkRenderPassInputAttachmentAspectCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("aspectReferenceCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pAspectReferences").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassInputAttachmentAspectCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRenderPassInputAttachmentAspectCreateInfo::GetsType) {
  _VkRenderPassInputAttachmentAspectCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassInputAttachmentAspectCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRenderPassInputAttachmentAspectCreateInfo::SetsType) {
  _VkRenderPassInputAttachmentAspectCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassInputAttachmentAspectCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.sType", "Number");
  
    return;
  }
}// aspectReferenceCount
NAN_GETTER(_VkRenderPassInputAttachmentAspectCreateInfo::GetaspectReferenceCount) {
  _VkRenderPassInputAttachmentAspectCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassInputAttachmentAspectCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.aspectReferenceCount));
}NAN_SETTER(_VkRenderPassInputAttachmentAspectCreateInfo::SetaspectReferenceCount) {
  _VkRenderPassInputAttachmentAspectCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassInputAttachmentAspectCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.aspectReferenceCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.aspectReferenceCount", "Number");
  
    return;
  }
}// pAspectReferences
NAN_GETTER(_VkRenderPassInputAttachmentAspectCreateInfo::GetpAspectReferences) {
  _VkRenderPassInputAttachmentAspectCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassInputAttachmentAspectCreateInfo>(info.This());
  if (self->pAspectReferences.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAspectReferences);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassInputAttachmentAspectCreateInfo::SetpAspectReferences) {
  _VkRenderPassInputAttachmentAspectCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassInputAttachmentAspectCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAspectReferences.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAspectReferences.Reset();
      self->instance.pAspectReferences = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAspectReferences = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences", "[object VkInputAttachmentAspectReference]");
  
    return;
  }
}
/** ## END VkRenderPassInputAttachmentAspectCreateInfo ## **/

/** ## BEGIN VkInputAttachmentAspectReferenceKHR ## **/

class _VkInputAttachmentAspectReferenceKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkInputAttachmentAspectReferenceKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkInputAttachmentAspectReferenceKHR();
    ~_VkInputAttachmentAspectReferenceKHR();

};

/*
#include "index.h"
#include "VkInputAttachmentAspectReferenceKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkInputAttachmentAspectReferenceKHR::constructor;

_VkInputAttachmentAspectReferenceKHR::_VkInputAttachmentAspectReferenceKHR() {
  
  
}

_VkInputAttachmentAspectReferenceKHR::~_VkInputAttachmentAspectReferenceKHR() {
  //printf("VkInputAttachmentAspectReferenceKHR deconstructed!!\n");
  
}

void _VkInputAttachmentAspectReferenceKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkInputAttachmentAspectReferenceKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkInputAttachmentAspectReferenceKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkInputAttachmentAspectReferenceKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkInputAttachmentAspectReferenceKHR::flush() {
  _VkInputAttachmentAspectReferenceKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkInputAttachmentAspectReferenceKHR::New) {
  if (info.IsConstructCall()) {
    _VkInputAttachmentAspectReferenceKHR* self = new _VkInputAttachmentAspectReferenceKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkInputAttachmentAspectReferenceKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkInputAttachmentAspectReferenceKHR ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ## **/

class _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetperViewPositionAllComponents);

    // real instance
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
    ~_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::constructor;

_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
  
}

_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::~_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX() {
  //printf("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("perViewPositionAllComponents").ToLocalChecked(), GetperViewPositionAllComponents, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::flush() {
  _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* self = new _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetsType) {
  _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// perViewPositionAllComponents
NAN_GETTER(_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX::GetperViewPositionAllComponents) {
  _VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.perViewPositionAllComponents));
}
/** ## END VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ## **/

/** ## BEGIN VkPipelineDiscardRectangleStateCreateInfoEXT ## **/

class _VkPipelineDiscardRectangleStateCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetdiscardRectangleMode);
    static NAN_SETTER(SetdiscardRectangleMode);
    
    static NAN_GETTER(GetdiscardRectangleCount);
    static NAN_SETTER(SetdiscardRectangleCount);
    
    std::vector<VkRect2D>* vpDiscardRectangles;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDiscardRectangles;
    static NAN_GETTER(GetpDiscardRectangles);
    static NAN_SETTER(SetpDiscardRectangles);
    

    // real instance
    VkPipelineDiscardRectangleStateCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineDiscardRectangleStateCreateInfoEXT();
    ~_VkPipelineDiscardRectangleStateCreateInfoEXT();

};

/*
#include "index.h"
#include "VkPipelineDiscardRectangleStateCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineDiscardRectangleStateCreateInfoEXT::constructor;

_VkPipelineDiscardRectangleStateCreateInfoEXT::_VkPipelineDiscardRectangleStateCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT;
  vpDiscardRectangles = new std::vector<VkRect2D>;
  
}

_VkPipelineDiscardRectangleStateCreateInfoEXT::~_VkPipelineDiscardRectangleStateCreateInfoEXT() {
  //printf("VkPipelineDiscardRectangleStateCreateInfoEXT deconstructed!!\n");
  
  
  
  
  
  vpDiscardRectangles->clear();
  delete vpDiscardRectangles;
  
  pDiscardRectangles.Reset();
  
}

void _VkPipelineDiscardRectangleStateCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineDiscardRectangleStateCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineDiscardRectangleStateCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("discardRectangleMode").ToLocalChecked(), GetdiscardRectangleMode, SetdiscardRectangleMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("discardRectangleCount").ToLocalChecked(), GetdiscardRectangleCount, SetdiscardRectangleCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDiscardRectangles").ToLocalChecked(), GetpDiscardRectangles, SetpDiscardRectangles, ctor);
  Nan::Set(target, Nan::New("VkPipelineDiscardRectangleStateCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineDiscardRectangleStateCreateInfoEXT::flush() {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = this;
  if (!(self->pDiscardRectangles.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pDiscardRectangles);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.discardRectangleCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'discardRectangleCount' for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles'");
      return false;
    }
    std::vector<VkRect2D>* data = self->vpDiscardRectangles;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkRect2D::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDiscardRectangles = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineDiscardRectangleStateCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkPipelineDiscardRectangleStateCreateInfoEXT* self = new _VkPipelineDiscardRectangleStateCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("discardRectangleMode").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("discardRectangleCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pDiscardRectangles").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineDiscardRectangleStateCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::GetsType) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::SetsType) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::Getflags) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::Setflags) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineDiscardRectangleStateCreateFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.flags", "Number");
  
    return;
  }
}// discardRectangleMode
NAN_GETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::GetdiscardRectangleMode) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.discardRectangleMode));
}NAN_SETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::SetdiscardRectangleMode) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.discardRectangleMode = static_cast<VkDiscardRectangleModeEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleMode", "Number");
  
    return;
  }
}// discardRectangleCount
NAN_GETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::GetdiscardRectangleCount) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.discardRectangleCount));
}NAN_SETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::SetdiscardRectangleCount) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.discardRectangleCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleCount", "Number");
  
    return;
  }
}// pDiscardRectangles
NAN_GETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::GetpDiscardRectangles) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  if (self->pDiscardRectangles.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDiscardRectangles);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineDiscardRectangleStateCreateInfoEXT::SetpDiscardRectangles) {
  _VkPipelineDiscardRectangleStateCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkPipelineDiscardRectangleStateCreateInfoEXT>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pDiscardRectangles.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pDiscardRectangles.Reset();
      self->instance.pDiscardRectangles = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pDiscardRectangles = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkPipelineDiscardRectangleStateCreateInfoEXT ## **/

/** ## BEGIN VkPhysicalDeviceDiscardRectanglePropertiesEXT ## **/

class _VkPhysicalDeviceDiscardRectanglePropertiesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxDiscardRectangles);

    // real instance
    VkPhysicalDeviceDiscardRectanglePropertiesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceDiscardRectanglePropertiesEXT();
    ~_VkPhysicalDeviceDiscardRectanglePropertiesEXT();

};

/*
#include "index.h"
#include "VkPhysicalDeviceDiscardRectanglePropertiesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceDiscardRectanglePropertiesEXT::constructor;

_VkPhysicalDeviceDiscardRectanglePropertiesEXT::_VkPhysicalDeviceDiscardRectanglePropertiesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
  
}

_VkPhysicalDeviceDiscardRectanglePropertiesEXT::~_VkPhysicalDeviceDiscardRectanglePropertiesEXT() {
  //printf("VkPhysicalDeviceDiscardRectanglePropertiesEXT deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceDiscardRectanglePropertiesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceDiscardRectanglePropertiesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceDiscardRectanglePropertiesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDiscardRectangles").ToLocalChecked(), GetmaxDiscardRectangles, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceDiscardRectanglePropertiesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceDiscardRectanglePropertiesEXT::flush() {
  _VkPhysicalDeviceDiscardRectanglePropertiesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceDiscardRectanglePropertiesEXT::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceDiscardRectanglePropertiesEXT* self = new _VkPhysicalDeviceDiscardRectanglePropertiesEXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceDiscardRectanglePropertiesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetsType) {
  _VkPhysicalDeviceDiscardRectanglePropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxDiscardRectangles
NAN_GETTER(_VkPhysicalDeviceDiscardRectanglePropertiesEXT::GetmaxDiscardRectangles) {
  _VkPhysicalDeviceDiscardRectanglePropertiesEXT *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDiscardRectanglePropertiesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDiscardRectangles));
}
/** ## END VkPhysicalDeviceDiscardRectanglePropertiesEXT ## **/

/** ## BEGIN VkViewportSwizzleNV ## **/

class _VkViewportSwizzleNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getx);
    static NAN_SETTER(Setx);
    
    static NAN_GETTER(Gety);
    static NAN_SETTER(Sety);
    
    static NAN_GETTER(Getz);
    static NAN_SETTER(Setz);
    
    static NAN_GETTER(Getw);
    static NAN_SETTER(Setw);
    

    // real instance
    VkViewportSwizzleNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkViewportSwizzleNV();
    ~_VkViewportSwizzleNV();

};

/*
#include "index.h"
#include "VkViewportSwizzleNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkViewportSwizzleNV::constructor;

_VkViewportSwizzleNV::_VkViewportSwizzleNV() {
  
  
}

_VkViewportSwizzleNV::~_VkViewportSwizzleNV() {
  //printf("VkViewportSwizzleNV deconstructed!!\n");
  
  
  
  
  
}

void _VkViewportSwizzleNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkViewportSwizzleNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkViewportSwizzleNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("x").ToLocalChecked(), Getx, Setx, ctor);
  SetPrototypeAccessor(proto, Nan::New("y").ToLocalChecked(), Gety, Sety, ctor);
  SetPrototypeAccessor(proto, Nan::New("z").ToLocalChecked(), Getz, Setz, ctor);
  SetPrototypeAccessor(proto, Nan::New("w").ToLocalChecked(), Getw, Setw, ctor);
  Nan::Set(target, Nan::New("VkViewportSwizzleNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkViewportSwizzleNV::flush() {
  _VkViewportSwizzleNV *self = this;
  
  return true;
}

NAN_METHOD(_VkViewportSwizzleNV::New) {
  if (info.IsConstructCall()) {
    _VkViewportSwizzleNV* self = new _VkViewportSwizzleNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("x").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("y").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("z").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("w").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkViewportSwizzleNV constructor cannot be invoked without 'new'");
  }
};

// x
NAN_GETTER(_VkViewportSwizzleNV::Getx) {
  _VkViewportSwizzleNV *self = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.x));
}NAN_SETTER(_VkViewportSwizzleNV::Setx) {
  _VkViewportSwizzleNV *self = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(info.This());
  if (value->IsNumber()) {
    self->instance.x = static_cast<VkViewportCoordinateSwizzleNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewportSwizzleNV.x", "Number");
  
    return;
  }
}// y
NAN_GETTER(_VkViewportSwizzleNV::Gety) {
  _VkViewportSwizzleNV *self = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.y));
}NAN_SETTER(_VkViewportSwizzleNV::Sety) {
  _VkViewportSwizzleNV *self = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(info.This());
  if (value->IsNumber()) {
    self->instance.y = static_cast<VkViewportCoordinateSwizzleNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewportSwizzleNV.y", "Number");
  
    return;
  }
}// z
NAN_GETTER(_VkViewportSwizzleNV::Getz) {
  _VkViewportSwizzleNV *self = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.z));
}NAN_SETTER(_VkViewportSwizzleNV::Setz) {
  _VkViewportSwizzleNV *self = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(info.This());
  if (value->IsNumber()) {
    self->instance.z = static_cast<VkViewportCoordinateSwizzleNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewportSwizzleNV.z", "Number");
  
    return;
  }
}// w
NAN_GETTER(_VkViewportSwizzleNV::Getw) {
  _VkViewportSwizzleNV *self = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.w));
}NAN_SETTER(_VkViewportSwizzleNV::Setw) {
  _VkViewportSwizzleNV *self = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(info.This());
  if (value->IsNumber()) {
    self->instance.w = static_cast<VkViewportCoordinateSwizzleNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewportSwizzleNV.w", "Number");
  
    return;
  }
}
/** ## END VkViewportSwizzleNV ## **/

/** ## BEGIN VkPipelineViewportSwizzleStateCreateInfoNV ## **/

class _VkPipelineViewportSwizzleStateCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetviewportCount);
    static NAN_SETTER(SetviewportCount);
    
    std::vector<VkViewportSwizzleNV>* vpViewportSwizzles;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pViewportSwizzles;
    static NAN_GETTER(GetpViewportSwizzles);
    static NAN_SETTER(SetpViewportSwizzles);
    

    // real instance
    VkPipelineViewportSwizzleStateCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineViewportSwizzleStateCreateInfoNV();
    ~_VkPipelineViewportSwizzleStateCreateInfoNV();

};

/*
#include "index.h"
#include "VkPipelineViewportSwizzleStateCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineViewportSwizzleStateCreateInfoNV::constructor;

_VkPipelineViewportSwizzleStateCreateInfoNV::_VkPipelineViewportSwizzleStateCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV;
  vpViewportSwizzles = new std::vector<VkViewportSwizzleNV>;
  
}

_VkPipelineViewportSwizzleStateCreateInfoNV::~_VkPipelineViewportSwizzleStateCreateInfoNV() {
  //printf("VkPipelineViewportSwizzleStateCreateInfoNV deconstructed!!\n");
  
  
  
  
  vpViewportSwizzles->clear();
  delete vpViewportSwizzles;
  
  pViewportSwizzles.Reset();
  
}

void _VkPipelineViewportSwizzleStateCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineViewportSwizzleStateCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineViewportSwizzleStateCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewportCount").ToLocalChecked(), GetviewportCount, SetviewportCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pViewportSwizzles").ToLocalChecked(), GetpViewportSwizzles, SetpViewportSwizzles, ctor);
  Nan::Set(target, Nan::New("VkPipelineViewportSwizzleStateCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineViewportSwizzleStateCreateInfoNV::flush() {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = this;
  if (!(self->pViewportSwizzles.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pViewportSwizzles);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.viewportCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'viewportCount' for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles'");
      return false;
    }
    std::vector<VkViewportSwizzleNV>* data = self->vpViewportSwizzles;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkViewportSwizzleNV::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles", "[object VkViewportSwizzleNV]");
  
        return false;
      }
      _VkViewportSwizzleNV* result = Nan::ObjectWrap::Unwrap<_VkViewportSwizzleNV>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pViewportSwizzles = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineViewportSwizzleStateCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkPipelineViewportSwizzleStateCreateInfoNV* self = new _VkPipelineViewportSwizzleStateCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("viewportCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pViewportSwizzles").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineViewportSwizzleStateCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineViewportSwizzleStateCreateInfoNV::GetsType) {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineViewportSwizzleStateCreateInfoNV::SetsType) {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineViewportSwizzleStateCreateInfoNV::Getflags) {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineViewportSwizzleStateCreateInfoNV::Setflags) {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineViewportSwizzleStateCreateFlagsNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.flags", "Number");
  
    return;
  }
}// viewportCount
NAN_GETTER(_VkPipelineViewportSwizzleStateCreateInfoNV::GetviewportCount) {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewportCount));
}NAN_SETTER(_VkPipelineViewportSwizzleStateCreateInfoNV::SetviewportCount) {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.viewportCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.viewportCount", "Number");
  
    return;
  }
}// pViewportSwizzles
NAN_GETTER(_VkPipelineViewportSwizzleStateCreateInfoNV::GetpViewportSwizzles) {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info.This());
  if (self->pViewportSwizzles.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pViewportSwizzles);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineViewportSwizzleStateCreateInfoNV::SetpViewportSwizzles) {
  _VkPipelineViewportSwizzleStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportSwizzleStateCreateInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pViewportSwizzles.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pViewportSwizzles.Reset();
      self->instance.pViewportSwizzles = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles", "[object VkViewportSwizzleNV]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pViewportSwizzles = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles", "[object VkViewportSwizzleNV]");
  
    return;
  }
}
/** ## END VkPipelineViewportSwizzleStateCreateInfoNV ## **/

/** ## BEGIN VkViewportWScalingNV ## **/

class _VkViewportWScalingNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getxcoeff);
    static NAN_SETTER(Setxcoeff);
    
    static NAN_GETTER(Getycoeff);
    static NAN_SETTER(Setycoeff);
    

    // real instance
    VkViewportWScalingNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkViewportWScalingNV();
    ~_VkViewportWScalingNV();

};

/*
#include "index.h"
#include "VkViewportWScalingNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkViewportWScalingNV::constructor;

_VkViewportWScalingNV::_VkViewportWScalingNV() {
  
  
}

_VkViewportWScalingNV::~_VkViewportWScalingNV() {
  //printf("VkViewportWScalingNV deconstructed!!\n");
  
  
  
}

void _VkViewportWScalingNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkViewportWScalingNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkViewportWScalingNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("xcoeff").ToLocalChecked(), Getxcoeff, Setxcoeff, ctor);
  SetPrototypeAccessor(proto, Nan::New("ycoeff").ToLocalChecked(), Getycoeff, Setycoeff, ctor);
  Nan::Set(target, Nan::New("VkViewportWScalingNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkViewportWScalingNV::flush() {
  _VkViewportWScalingNV *self = this;
  
  return true;
}

NAN_METHOD(_VkViewportWScalingNV::New) {
  if (info.IsConstructCall()) {
    _VkViewportWScalingNV* self = new _VkViewportWScalingNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("xcoeff").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("ycoeff").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkViewportWScalingNV constructor cannot be invoked without 'new'");
  }
};

// xcoeff
NAN_GETTER(_VkViewportWScalingNV::Getxcoeff) {
  _VkViewportWScalingNV *self = Nan::ObjectWrap::Unwrap<_VkViewportWScalingNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.xcoeff));
}NAN_SETTER(_VkViewportWScalingNV::Setxcoeff) {
  _VkViewportWScalingNV *self = Nan::ObjectWrap::Unwrap<_VkViewportWScalingNV>(info.This());
  if (value->IsNumber()) {
    self->instance.xcoeff = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewportWScalingNV.xcoeff", "Number");
  
    return;
  }
}// ycoeff
NAN_GETTER(_VkViewportWScalingNV::Getycoeff) {
  _VkViewportWScalingNV *self = Nan::ObjectWrap::Unwrap<_VkViewportWScalingNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.ycoeff));
}NAN_SETTER(_VkViewportWScalingNV::Setycoeff) {
  _VkViewportWScalingNV *self = Nan::ObjectWrap::Unwrap<_VkViewportWScalingNV>(info.This());
  if (value->IsNumber()) {
    self->instance.ycoeff = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewportWScalingNV.ycoeff", "Number");
  
    return;
  }
}
/** ## END VkViewportWScalingNV ## **/

/** ## BEGIN VkPipelineViewportWScalingStateCreateInfoNV ## **/

class _VkPipelineViewportWScalingStateCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetviewportWScalingEnable);
    static NAN_SETTER(SetviewportWScalingEnable);
    
    static NAN_GETTER(GetviewportCount);
    static NAN_SETTER(SetviewportCount);
    
    std::vector<VkViewportWScalingNV>* vpViewportWScalings;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pViewportWScalings;
    static NAN_GETTER(GetpViewportWScalings);
    static NAN_SETTER(SetpViewportWScalings);
    

    // real instance
    VkPipelineViewportWScalingStateCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineViewportWScalingStateCreateInfoNV();
    ~_VkPipelineViewportWScalingStateCreateInfoNV();

};

/*
#include "index.h"
#include "VkPipelineViewportWScalingStateCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineViewportWScalingStateCreateInfoNV::constructor;

_VkPipelineViewportWScalingStateCreateInfoNV::_VkPipelineViewportWScalingStateCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV;
  vpViewportWScalings = new std::vector<VkViewportWScalingNV>;
  
}

_VkPipelineViewportWScalingStateCreateInfoNV::~_VkPipelineViewportWScalingStateCreateInfoNV() {
  //printf("VkPipelineViewportWScalingStateCreateInfoNV deconstructed!!\n");
  
  
  
  
  vpViewportWScalings->clear();
  delete vpViewportWScalings;
  
  pViewportWScalings.Reset();
  
}

void _VkPipelineViewportWScalingStateCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineViewportWScalingStateCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineViewportWScalingStateCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewportWScalingEnable").ToLocalChecked(), GetviewportWScalingEnable, SetviewportWScalingEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewportCount").ToLocalChecked(), GetviewportCount, SetviewportCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pViewportWScalings").ToLocalChecked(), GetpViewportWScalings, SetpViewportWScalings, ctor);
  Nan::Set(target, Nan::New("VkPipelineViewportWScalingStateCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineViewportWScalingStateCreateInfoNV::flush() {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = this;
  if (!(self->pViewportWScalings.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pViewportWScalings);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.viewportCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'viewportCount' for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings'");
      return false;
    }
    std::vector<VkViewportWScalingNV>* data = self->vpViewportWScalings;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkViewportWScalingNV::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings", "[object VkViewportWScalingNV]");
  
        return false;
      }
      _VkViewportWScalingNV* result = Nan::ObjectWrap::Unwrap<_VkViewportWScalingNV>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pViewportWScalings = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineViewportWScalingStateCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkPipelineViewportWScalingStateCreateInfoNV* self = new _VkPipelineViewportWScalingStateCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("viewportWScalingEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("viewportCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pViewportWScalings").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineViewportWScalingStateCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineViewportWScalingStateCreateInfoNV::GetsType) {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineViewportWScalingStateCreateInfoNV::SetsType) {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.sType", "Number");
  
    return;
  }
}// viewportWScalingEnable
NAN_GETTER(_VkPipelineViewportWScalingStateCreateInfoNV::GetviewportWScalingEnable) {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewportWScalingEnable));
}NAN_SETTER(_VkPipelineViewportWScalingStateCreateInfoNV::SetviewportWScalingEnable) {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.viewportWScalingEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.viewportWScalingEnable", "Number");
  
    return;
  }
}// viewportCount
NAN_GETTER(_VkPipelineViewportWScalingStateCreateInfoNV::GetviewportCount) {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewportCount));
}NAN_SETTER(_VkPipelineViewportWScalingStateCreateInfoNV::SetviewportCount) {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.viewportCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.viewportCount", "Number");
  
    return;
  }
}// pViewportWScalings
NAN_GETTER(_VkPipelineViewportWScalingStateCreateInfoNV::GetpViewportWScalings) {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info.This());
  if (self->pViewportWScalings.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pViewportWScalings);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineViewportWScalingStateCreateInfoNV::SetpViewportWScalings) {
  _VkPipelineViewportWScalingStateCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportWScalingStateCreateInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pViewportWScalings.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pViewportWScalings.Reset();
      self->instance.pViewportWScalings = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings", "[object VkViewportWScalingNV]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pViewportWScalings = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings", "[object VkViewportWScalingNV]");
  
    return;
  }
}
/** ## END VkPipelineViewportWScalingStateCreateInfoNV ## **/

/** ## BEGIN VkPresentTimeGOOGLE ## **/

class _VkPresentTimeGOOGLE: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetpresentID);
    static NAN_SETTER(SetpresentID);
    
    static NAN_GETTER(GetdesiredPresentTime);
    static NAN_SETTER(SetdesiredPresentTime);
    

    // real instance
    VkPresentTimeGOOGLE instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPresentTimeGOOGLE();
    ~_VkPresentTimeGOOGLE();

};

/*
#include "index.h"
#include "VkPresentTimeGOOGLE.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPresentTimeGOOGLE::constructor;

_VkPresentTimeGOOGLE::_VkPresentTimeGOOGLE() {
  
  
}

_VkPresentTimeGOOGLE::~_VkPresentTimeGOOGLE() {
  //printf("VkPresentTimeGOOGLE deconstructed!!\n");
  
  
  
}

void _VkPresentTimeGOOGLE::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPresentTimeGOOGLE::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPresentTimeGOOGLE").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("presentID").ToLocalChecked(), GetpresentID, SetpresentID, ctor);
  SetPrototypeAccessor(proto, Nan::New("desiredPresentTime").ToLocalChecked(), GetdesiredPresentTime, SetdesiredPresentTime, ctor);
  Nan::Set(target, Nan::New("VkPresentTimeGOOGLE").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPresentTimeGOOGLE::flush() {
  _VkPresentTimeGOOGLE *self = this;
  
  return true;
}

NAN_METHOD(_VkPresentTimeGOOGLE::New) {
  if (info.IsConstructCall()) {
    _VkPresentTimeGOOGLE* self = new _VkPresentTimeGOOGLE();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("presentID").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("desiredPresentTime").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPresentTimeGOOGLE constructor cannot be invoked without 'new'");
  }
};

// presentID
NAN_GETTER(_VkPresentTimeGOOGLE::GetpresentID) {
  _VkPresentTimeGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimeGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.presentID));
}NAN_SETTER(_VkPresentTimeGOOGLE::SetpresentID) {
  _VkPresentTimeGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimeGOOGLE>(info.This());
  if (value->IsNumber()) {
    self->instance.presentID = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentTimeGOOGLE.presentID", "Number");
  
    return;
  }
}// desiredPresentTime
NAN_GETTER(_VkPresentTimeGOOGLE::GetdesiredPresentTime) {
  _VkPresentTimeGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimeGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.desiredPresentTime));
}NAN_SETTER(_VkPresentTimeGOOGLE::SetdesiredPresentTime) {
  _VkPresentTimeGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimeGOOGLE>(info.This());
  if (value->IsNumber()) {
    self->instance.desiredPresentTime = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentTimeGOOGLE.desiredPresentTime", "Number");
  
    return;
  }
}
/** ## END VkPresentTimeGOOGLE ## **/

/** ## BEGIN VkPresentTimesInfoGOOGLE ## **/

class _VkPresentTimesInfoGOOGLE: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetswapchainCount);
    static NAN_SETTER(SetswapchainCount);
    
    std::vector<VkPresentTimeGOOGLE>* vpTimes;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pTimes;
    static NAN_GETTER(GetpTimes);
    static NAN_SETTER(SetpTimes);
    

    // real instance
    VkPresentTimesInfoGOOGLE instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPresentTimesInfoGOOGLE();
    ~_VkPresentTimesInfoGOOGLE();

};

/*
#include "index.h"
#include "VkPresentTimesInfoGOOGLE.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPresentTimesInfoGOOGLE::constructor;

_VkPresentTimesInfoGOOGLE::_VkPresentTimesInfoGOOGLE() {
  instance.sType = VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE;
  vpTimes = new std::vector<VkPresentTimeGOOGLE>;
  
}

_VkPresentTimesInfoGOOGLE::~_VkPresentTimesInfoGOOGLE() {
  //printf("VkPresentTimesInfoGOOGLE deconstructed!!\n");
  
  
  
  vpTimes->clear();
  delete vpTimes;
  
  pTimes.Reset();
  
}

void _VkPresentTimesInfoGOOGLE::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPresentTimesInfoGOOGLE::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPresentTimesInfoGOOGLE").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("swapchainCount").ToLocalChecked(), GetswapchainCount, SetswapchainCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pTimes").ToLocalChecked(), GetpTimes, SetpTimes, ctor);
  Nan::Set(target, Nan::New("VkPresentTimesInfoGOOGLE").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPresentTimesInfoGOOGLE::flush() {
  _VkPresentTimesInfoGOOGLE *self = this;
  if (!(self->pTimes.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pTimes);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.swapchainCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'swapchainCount' for 'VkPresentTimesInfoGOOGLE.pTimes'");
      return false;
    }
    std::vector<VkPresentTimeGOOGLE>* data = self->vpTimes;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkPresentTimeGOOGLE::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPresentTimesInfoGOOGLE.pTimes", "[object VkPresentTimeGOOGLE]");
  
        return false;
      }
      _VkPresentTimeGOOGLE* result = Nan::ObjectWrap::Unwrap<_VkPresentTimeGOOGLE>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pTimes = data->data();
  }
  return true;
}

NAN_METHOD(_VkPresentTimesInfoGOOGLE::New) {
  if (info.IsConstructCall()) {
    _VkPresentTimesInfoGOOGLE* self = new _VkPresentTimesInfoGOOGLE();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("swapchainCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pTimes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPresentTimesInfoGOOGLE constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPresentTimesInfoGOOGLE::GetsType) {
  _VkPresentTimesInfoGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimesInfoGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPresentTimesInfoGOOGLE::SetsType) {
  _VkPresentTimesInfoGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimesInfoGOOGLE>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentTimesInfoGOOGLE.sType", "Number");
  
    return;
  }
}// swapchainCount
NAN_GETTER(_VkPresentTimesInfoGOOGLE::GetswapchainCount) {
  _VkPresentTimesInfoGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimesInfoGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.swapchainCount));
}NAN_SETTER(_VkPresentTimesInfoGOOGLE::SetswapchainCount) {
  _VkPresentTimesInfoGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimesInfoGOOGLE>(info.This());
  if (value->IsNumber()) {
    self->instance.swapchainCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentTimesInfoGOOGLE.swapchainCount", "Number");
  
    return;
  }
}// pTimes
NAN_GETTER(_VkPresentTimesInfoGOOGLE::GetpTimes) {
  _VkPresentTimesInfoGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimesInfoGOOGLE>(info.This());
  if (self->pTimes.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pTimes);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPresentTimesInfoGOOGLE::SetpTimes) {
  _VkPresentTimesInfoGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPresentTimesInfoGOOGLE>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pTimes.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pTimes.Reset();
      self->instance.pTimes = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPresentTimesInfoGOOGLE.pTimes", "[object VkPresentTimeGOOGLE]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pTimes = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentTimesInfoGOOGLE.pTimes", "[object VkPresentTimeGOOGLE]");
  
    return;
  }
}
/** ## END VkPresentTimesInfoGOOGLE ## **/

/** ## BEGIN VkPastPresentationTimingGOOGLE ## **/

class _VkPastPresentationTimingGOOGLE: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetpresentID);
    static NAN_GETTER(GetdesiredPresentTime);
    static NAN_GETTER(GetactualPresentTime);
    static NAN_GETTER(GetearliestPresentTime);
    static NAN_GETTER(GetpresentMargin);

    // real instance
    VkPastPresentationTimingGOOGLE instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPastPresentationTimingGOOGLE();
    ~_VkPastPresentationTimingGOOGLE();

};

/*
#include "index.h"
#include "VkPastPresentationTimingGOOGLE.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPastPresentationTimingGOOGLE::constructor;

_VkPastPresentationTimingGOOGLE::_VkPastPresentationTimingGOOGLE() {
  
  
}

_VkPastPresentationTimingGOOGLE::~_VkPastPresentationTimingGOOGLE() {
  //printf("VkPastPresentationTimingGOOGLE deconstructed!!\n");
  
  
  
  
  
  
}

void _VkPastPresentationTimingGOOGLE::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPastPresentationTimingGOOGLE::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPastPresentationTimingGOOGLE").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("presentID").ToLocalChecked(), GetpresentID, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("desiredPresentTime").ToLocalChecked(), GetdesiredPresentTime, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("actualPresentTime").ToLocalChecked(), GetactualPresentTime, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("earliestPresentTime").ToLocalChecked(), GetearliestPresentTime, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("presentMargin").ToLocalChecked(), GetpresentMargin, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPastPresentationTimingGOOGLE").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPastPresentationTimingGOOGLE::flush() {
  _VkPastPresentationTimingGOOGLE *self = this;
  
  return true;
}

NAN_METHOD(_VkPastPresentationTimingGOOGLE::New) {
  if (info.IsConstructCall()) {
    _VkPastPresentationTimingGOOGLE* self = new _VkPastPresentationTimingGOOGLE();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPastPresentationTimingGOOGLE constructor cannot be invoked without 'new'");
  }
};

// presentID
NAN_GETTER(_VkPastPresentationTimingGOOGLE::GetpresentID) {
  _VkPastPresentationTimingGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPastPresentationTimingGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.presentID));
}// desiredPresentTime
NAN_GETTER(_VkPastPresentationTimingGOOGLE::GetdesiredPresentTime) {
  _VkPastPresentationTimingGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPastPresentationTimingGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.desiredPresentTime));
}// actualPresentTime
NAN_GETTER(_VkPastPresentationTimingGOOGLE::GetactualPresentTime) {
  _VkPastPresentationTimingGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPastPresentationTimingGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.actualPresentTime));
}// earliestPresentTime
NAN_GETTER(_VkPastPresentationTimingGOOGLE::GetearliestPresentTime) {
  _VkPastPresentationTimingGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPastPresentationTimingGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.earliestPresentTime));
}// presentMargin
NAN_GETTER(_VkPastPresentationTimingGOOGLE::GetpresentMargin) {
  _VkPastPresentationTimingGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkPastPresentationTimingGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.presentMargin));
}
/** ## END VkPastPresentationTimingGOOGLE ## **/

/** ## BEGIN VkRefreshCycleDurationGOOGLE ## **/

class _VkRefreshCycleDurationGOOGLE: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetrefreshDuration);

    // real instance
    VkRefreshCycleDurationGOOGLE instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRefreshCycleDurationGOOGLE();
    ~_VkRefreshCycleDurationGOOGLE();

};

/*
#include "index.h"
#include "VkRefreshCycleDurationGOOGLE.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRefreshCycleDurationGOOGLE::constructor;

_VkRefreshCycleDurationGOOGLE::_VkRefreshCycleDurationGOOGLE() {
  
  
}

_VkRefreshCycleDurationGOOGLE::~_VkRefreshCycleDurationGOOGLE() {
  //printf("VkRefreshCycleDurationGOOGLE deconstructed!!\n");
  
  
}

void _VkRefreshCycleDurationGOOGLE::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRefreshCycleDurationGOOGLE::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRefreshCycleDurationGOOGLE").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("refreshDuration").ToLocalChecked(), GetrefreshDuration, nullptr, ctor);
  Nan::Set(target, Nan::New("VkRefreshCycleDurationGOOGLE").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRefreshCycleDurationGOOGLE::flush() {
  _VkRefreshCycleDurationGOOGLE *self = this;
  
  return true;
}

NAN_METHOD(_VkRefreshCycleDurationGOOGLE::New) {
  if (info.IsConstructCall()) {
    _VkRefreshCycleDurationGOOGLE* self = new _VkRefreshCycleDurationGOOGLE();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRefreshCycleDurationGOOGLE constructor cannot be invoked without 'new'");
  }
};

// refreshDuration
NAN_GETTER(_VkRefreshCycleDurationGOOGLE::GetrefreshDuration) {
  _VkRefreshCycleDurationGOOGLE *self = Nan::ObjectWrap::Unwrap<_VkRefreshCycleDurationGOOGLE>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.refreshDuration));
}
/** ## END VkRefreshCycleDurationGOOGLE ## **/

/** ## BEGIN VkXYColorEXT ## **/

class _VkXYColorEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getx);
    static NAN_SETTER(Setx);
    
    static NAN_GETTER(Gety);
    static NAN_SETTER(Sety);
    

    // real instance
    VkXYColorEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkXYColorEXT();
    ~_VkXYColorEXT();

};

/*
#include "index.h"
#include "VkXYColorEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkXYColorEXT::constructor;

_VkXYColorEXT::_VkXYColorEXT() {
  
  
}

_VkXYColorEXT::~_VkXYColorEXT() {
  //printf("VkXYColorEXT deconstructed!!\n");
  
  
  
}

void _VkXYColorEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkXYColorEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkXYColorEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("x").ToLocalChecked(), Getx, Setx, ctor);
  SetPrototypeAccessor(proto, Nan::New("y").ToLocalChecked(), Gety, Sety, ctor);
  Nan::Set(target, Nan::New("VkXYColorEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkXYColorEXT::flush() {
  _VkXYColorEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkXYColorEXT::New) {
  if (info.IsConstructCall()) {
    _VkXYColorEXT* self = new _VkXYColorEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("x").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("y").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkXYColorEXT constructor cannot be invoked without 'new'");
  }
};

// x
NAN_GETTER(_VkXYColorEXT::Getx) {
  _VkXYColorEXT *self = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.x));
}NAN_SETTER(_VkXYColorEXT::Setx) {
  _VkXYColorEXT *self = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.x = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkXYColorEXT.x", "Number");
  
    return;
  }
}// y
NAN_GETTER(_VkXYColorEXT::Gety) {
  _VkXYColorEXT *self = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.y));
}NAN_SETTER(_VkXYColorEXT::Sety) {
  _VkXYColorEXT *self = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.y = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkXYColorEXT.y", "Number");
  
    return;
  }
}
/** ## END VkXYColorEXT ## **/

/** ## BEGIN VkHdrMetadataEXT ## **/

class _VkHdrMetadataEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> displayPrimaryRed;
      static NAN_GETTER(GetdisplayPrimaryRed);
    static NAN_SETTER(SetdisplayPrimaryRed);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> displayPrimaryGreen;
      static NAN_GETTER(GetdisplayPrimaryGreen);
    static NAN_SETTER(SetdisplayPrimaryGreen);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> displayPrimaryBlue;
      static NAN_GETTER(GetdisplayPrimaryBlue);
    static NAN_SETTER(SetdisplayPrimaryBlue);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> whitePoint;
      static NAN_GETTER(GetwhitePoint);
    static NAN_SETTER(SetwhitePoint);
    
    static NAN_GETTER(GetmaxLuminance);
    static NAN_SETTER(SetmaxLuminance);
    
    static NAN_GETTER(GetminLuminance);
    static NAN_SETTER(SetminLuminance);
    
    static NAN_GETTER(GetmaxContentLightLevel);
    static NAN_SETTER(SetmaxContentLightLevel);
    
    static NAN_GETTER(GetmaxFrameAverageLightLevel);
    static NAN_SETTER(SetmaxFrameAverageLightLevel);
    

    // real instance
    VkHdrMetadataEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkHdrMetadataEXT();
    ~_VkHdrMetadataEXT();

};

/*
#include "index.h"
#include "VkHdrMetadataEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkHdrMetadataEXT::constructor;

_VkHdrMetadataEXT::_VkHdrMetadataEXT() {
  instance.sType = VK_STRUCTURE_TYPE_HDR_METADATA_EXT;
  
}

_VkHdrMetadataEXT::~_VkHdrMetadataEXT() {
  //printf("VkHdrMetadataEXT deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
}

void _VkHdrMetadataEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkHdrMetadataEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkHdrMetadataEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayPrimaryRed").ToLocalChecked(), GetdisplayPrimaryRed, SetdisplayPrimaryRed, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayPrimaryGreen").ToLocalChecked(), GetdisplayPrimaryGreen, SetdisplayPrimaryGreen, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayPrimaryBlue").ToLocalChecked(), GetdisplayPrimaryBlue, SetdisplayPrimaryBlue, ctor);
  SetPrototypeAccessor(proto, Nan::New("whitePoint").ToLocalChecked(), GetwhitePoint, SetwhitePoint, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxLuminance").ToLocalChecked(), GetmaxLuminance, SetmaxLuminance, ctor);
  SetPrototypeAccessor(proto, Nan::New("minLuminance").ToLocalChecked(), GetminLuminance, SetminLuminance, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxContentLightLevel").ToLocalChecked(), GetmaxContentLightLevel, SetmaxContentLightLevel, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFrameAverageLightLevel").ToLocalChecked(), GetmaxFrameAverageLightLevel, SetmaxFrameAverageLightLevel, ctor);
  Nan::Set(target, Nan::New("VkHdrMetadataEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkHdrMetadataEXT::flush() {
  _VkHdrMetadataEXT *self = this;
  if (!(self->displayPrimaryRed.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->displayPrimaryRed);
    
    _VkXYColorEXT* result = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.displayPrimaryRed = result->instance;
  }if (!(self->displayPrimaryGreen.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->displayPrimaryGreen);
    
    _VkXYColorEXT* result = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.displayPrimaryGreen = result->instance;
  }if (!(self->displayPrimaryBlue.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->displayPrimaryBlue);
    
    _VkXYColorEXT* result = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.displayPrimaryBlue = result->instance;
  }if (!(self->whitePoint.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->whitePoint);
    
    _VkXYColorEXT* result = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.whitePoint = result->instance;
  }
  return true;
}

NAN_METHOD(_VkHdrMetadataEXT::New) {
  if (info.IsConstructCall()) {
    _VkHdrMetadataEXT* self = new _VkHdrMetadataEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("displayPrimaryRed").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("displayPrimaryGreen").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("displayPrimaryBlue").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("whitePoint").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("maxLuminance").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("minLuminance").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("maxContentLightLevel").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("maxFrameAverageLightLevel").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkHdrMetadataEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkHdrMetadataEXT::GetsType) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkHdrMetadataEXT::SetsType) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.sType", "Number");
  
    return;
  }
}// displayPrimaryRed
NAN_GETTER(_VkHdrMetadataEXT::GetdisplayPrimaryRed) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (self->displayPrimaryRed.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->displayPrimaryRed);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkHdrMetadataEXT::SetdisplayPrimaryRed) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkXYColorEXT::constructor)->HasInstance(obj)) {
      self->displayPrimaryRed.Reset<v8::Object>(value.As<v8::Object>());
      _VkXYColorEXT* inst = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(obj);
      inst->flush();
      self->instance.displayPrimaryRed = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.displayPrimaryRed", "[object VkXYColorEXT]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->displayPrimaryRed.Reset();
    memset(&self->instance.displayPrimaryRed, 0, sizeof(VkXYColorEXT));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.displayPrimaryRed", "[object VkXYColorEXT]");
  
    return;
  }
}// displayPrimaryGreen
NAN_GETTER(_VkHdrMetadataEXT::GetdisplayPrimaryGreen) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (self->displayPrimaryGreen.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->displayPrimaryGreen);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkHdrMetadataEXT::SetdisplayPrimaryGreen) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkXYColorEXT::constructor)->HasInstance(obj)) {
      self->displayPrimaryGreen.Reset<v8::Object>(value.As<v8::Object>());
      _VkXYColorEXT* inst = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(obj);
      inst->flush();
      self->instance.displayPrimaryGreen = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.displayPrimaryGreen", "[object VkXYColorEXT]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->displayPrimaryGreen.Reset();
    memset(&self->instance.displayPrimaryGreen, 0, sizeof(VkXYColorEXT));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.displayPrimaryGreen", "[object VkXYColorEXT]");
  
    return;
  }
}// displayPrimaryBlue
NAN_GETTER(_VkHdrMetadataEXT::GetdisplayPrimaryBlue) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (self->displayPrimaryBlue.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->displayPrimaryBlue);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkHdrMetadataEXT::SetdisplayPrimaryBlue) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkXYColorEXT::constructor)->HasInstance(obj)) {
      self->displayPrimaryBlue.Reset<v8::Object>(value.As<v8::Object>());
      _VkXYColorEXT* inst = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(obj);
      inst->flush();
      self->instance.displayPrimaryBlue = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.displayPrimaryBlue", "[object VkXYColorEXT]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->displayPrimaryBlue.Reset();
    memset(&self->instance.displayPrimaryBlue, 0, sizeof(VkXYColorEXT));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.displayPrimaryBlue", "[object VkXYColorEXT]");
  
    return;
  }
}// whitePoint
NAN_GETTER(_VkHdrMetadataEXT::GetwhitePoint) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (self->whitePoint.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->whitePoint);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkHdrMetadataEXT::SetwhitePoint) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkXYColorEXT::constructor)->HasInstance(obj)) {
      self->whitePoint.Reset<v8::Object>(value.As<v8::Object>());
      _VkXYColorEXT* inst = Nan::ObjectWrap::Unwrap<_VkXYColorEXT>(obj);
      inst->flush();
      self->instance.whitePoint = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.whitePoint", "[object VkXYColorEXT]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->whitePoint.Reset();
    memset(&self->instance.whitePoint, 0, sizeof(VkXYColorEXT));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.whitePoint", "[object VkXYColorEXT]");
  
    return;
  }
}// maxLuminance
NAN_GETTER(_VkHdrMetadataEXT::GetmaxLuminance) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxLuminance));
}NAN_SETTER(_VkHdrMetadataEXT::SetmaxLuminance) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.maxLuminance = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.maxLuminance", "Number");
  
    return;
  }
}// minLuminance
NAN_GETTER(_VkHdrMetadataEXT::GetminLuminance) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minLuminance));
}NAN_SETTER(_VkHdrMetadataEXT::SetminLuminance) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.minLuminance = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.minLuminance", "Number");
  
    return;
  }
}// maxContentLightLevel
NAN_GETTER(_VkHdrMetadataEXT::GetmaxContentLightLevel) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxContentLightLevel));
}NAN_SETTER(_VkHdrMetadataEXT::SetmaxContentLightLevel) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.maxContentLightLevel = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.maxContentLightLevel", "Number");
  
    return;
  }
}// maxFrameAverageLightLevel
NAN_GETTER(_VkHdrMetadataEXT::GetmaxFrameAverageLightLevel) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxFrameAverageLightLevel));
}NAN_SETTER(_VkHdrMetadataEXT::SetmaxFrameAverageLightLevel) {
  _VkHdrMetadataEXT *self = Nan::ObjectWrap::Unwrap<_VkHdrMetadataEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.maxFrameAverageLightLevel = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkHdrMetadataEXT.maxFrameAverageLightLevel", "Number");
  
    return;
  }
}
/** ## END VkHdrMetadataEXT ## **/

/** ## BEGIN VkDescriptorUpdateTemplateCreateInfoKHR ## **/

class _VkDescriptorUpdateTemplateCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkDescriptorUpdateTemplateCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorUpdateTemplateCreateInfoKHR();
    ~_VkDescriptorUpdateTemplateCreateInfoKHR();

};

/*
#include "index.h"
#include "VkDescriptorUpdateTemplateCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorUpdateTemplateCreateInfoKHR::constructor;

_VkDescriptorUpdateTemplateCreateInfoKHR::_VkDescriptorUpdateTemplateCreateInfoKHR() {
  
  
}

_VkDescriptorUpdateTemplateCreateInfoKHR::~_VkDescriptorUpdateTemplateCreateInfoKHR() {
  //printf("VkDescriptorUpdateTemplateCreateInfoKHR deconstructed!!\n");
  
}

void _VkDescriptorUpdateTemplateCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorUpdateTemplateCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorUpdateTemplateCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkDescriptorUpdateTemplateCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorUpdateTemplateCreateInfoKHR::flush() {
  _VkDescriptorUpdateTemplateCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorUpdateTemplateCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorUpdateTemplateCreateInfoKHR* self = new _VkDescriptorUpdateTemplateCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorUpdateTemplateCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkDescriptorUpdateTemplateCreateInfoKHR ## **/

/** ## BEGIN VkDescriptorUpdateTemplateEntry ## **/

class _VkDescriptorUpdateTemplateEntry: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetdstBinding);
    static NAN_SETTER(SetdstBinding);
    
    static NAN_GETTER(GetdstArrayElement);
    static NAN_SETTER(SetdstArrayElement);
    
    static NAN_GETTER(GetdescriptorCount);
    static NAN_SETTER(SetdescriptorCount);
    
    static NAN_GETTER(GetdescriptorType);
    static NAN_SETTER(SetdescriptorType);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
    static NAN_GETTER(Getstride);
    static NAN_SETTER(Setstride);
    

    // real instance
    VkDescriptorUpdateTemplateEntry instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorUpdateTemplateEntry();
    ~_VkDescriptorUpdateTemplateEntry();

};

/*
#include "index.h"
#include "VkDescriptorUpdateTemplateEntry.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorUpdateTemplateEntry::constructor;

_VkDescriptorUpdateTemplateEntry::_VkDescriptorUpdateTemplateEntry() {
  
  
}

_VkDescriptorUpdateTemplateEntry::~_VkDescriptorUpdateTemplateEntry() {
  //printf("VkDescriptorUpdateTemplateEntry deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkDescriptorUpdateTemplateEntry::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorUpdateTemplateEntry::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorUpdateTemplateEntry").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("dstBinding").ToLocalChecked(), GetdstBinding, SetdstBinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstArrayElement").ToLocalChecked(), GetdstArrayElement, SetdstArrayElement, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorCount").ToLocalChecked(), GetdescriptorCount, SetdescriptorCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorType").ToLocalChecked(), GetdescriptorType, SetdescriptorType, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("stride").ToLocalChecked(), Getstride, Setstride, ctor);
  Nan::Set(target, Nan::New("VkDescriptorUpdateTemplateEntry").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorUpdateTemplateEntry::flush() {
  _VkDescriptorUpdateTemplateEntry *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorUpdateTemplateEntry::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorUpdateTemplateEntry* self = new _VkDescriptorUpdateTemplateEntry();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("dstBinding").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("dstArrayElement").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("descriptorCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("descriptorType").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("stride").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorUpdateTemplateEntry constructor cannot be invoked without 'new'");
  }
};

// dstBinding
NAN_GETTER(_VkDescriptorUpdateTemplateEntry::GetdstBinding) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstBinding));
}NAN_SETTER(_VkDescriptorUpdateTemplateEntry::SetdstBinding) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.dstBinding = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateEntry.dstBinding", "Number");
  
    return;
  }
}// dstArrayElement
NAN_GETTER(_VkDescriptorUpdateTemplateEntry::GetdstArrayElement) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstArrayElement));
}NAN_SETTER(_VkDescriptorUpdateTemplateEntry::SetdstArrayElement) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.dstArrayElement = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateEntry.dstArrayElement", "Number");
  
    return;
  }
}// descriptorCount
NAN_GETTER(_VkDescriptorUpdateTemplateEntry::GetdescriptorCount) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorCount));
}NAN_SETTER(_VkDescriptorUpdateTemplateEntry::SetdescriptorCount) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateEntry.descriptorCount", "Number");
  
    return;
  }
}// descriptorType
NAN_GETTER(_VkDescriptorUpdateTemplateEntry::GetdescriptorType) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorType));
}NAN_SETTER(_VkDescriptorUpdateTemplateEntry::SetdescriptorType) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorType = static_cast<VkDescriptorType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateEntry.descriptorType", "Number");
  
    return;
  }
}// offset
NAN_GETTER(_VkDescriptorUpdateTemplateEntry::Getoffset) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkDescriptorUpdateTemplateEntry::Setoffset) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateEntry.offset", "Number");
  
    return;
  }
}// stride
NAN_GETTER(_VkDescriptorUpdateTemplateEntry::Getstride) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stride));
}NAN_SETTER(_VkDescriptorUpdateTemplateEntry::Setstride) {
  _VkDescriptorUpdateTemplateEntry *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(info.This());
  if (value->IsNumber()) {
    self->instance.stride = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateEntry.stride", "Number");
  
    return;
  }
}
/** ## END VkDescriptorUpdateTemplateEntry ## **/

/** ## BEGIN VkDescriptorUpdateTemplateCreateInfo ## **/

class _VkDescriptorUpdateTemplateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetdescriptorUpdateEntryCount);
    static NAN_SETTER(SetdescriptorUpdateEntryCount);
    
    std::vector<VkDescriptorUpdateTemplateEntry>* vpDescriptorUpdateEntries;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDescriptorUpdateEntries;
    static NAN_GETTER(GetpDescriptorUpdateEntries);
    static NAN_SETTER(SetpDescriptorUpdateEntries);
    
    static NAN_GETTER(GettemplateType);
    static NAN_SETTER(SettemplateType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> descriptorSetLayout;
      static NAN_GETTER(GetdescriptorSetLayout);
    static NAN_SETTER(SetdescriptorSetLayout);
    
    static NAN_GETTER(GetpipelineBindPoint);
    static NAN_SETTER(SetpipelineBindPoint);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pipelineLayout;
      static NAN_GETTER(GetpipelineLayout);
    static NAN_SETTER(SetpipelineLayout);
    
    static NAN_GETTER(Getset);
    static NAN_SETTER(Setset);
    

    // real instance
    VkDescriptorUpdateTemplateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorUpdateTemplateCreateInfo();
    ~_VkDescriptorUpdateTemplateCreateInfo();

};

/*
#include "index.h"
#include "VkDescriptorUpdateTemplateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorUpdateTemplateCreateInfo::constructor;

_VkDescriptorUpdateTemplateCreateInfo::_VkDescriptorUpdateTemplateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
  vpDescriptorUpdateEntries = new std::vector<VkDescriptorUpdateTemplateEntry>;
  
}

_VkDescriptorUpdateTemplateCreateInfo::~_VkDescriptorUpdateTemplateCreateInfo() {
  //printf("VkDescriptorUpdateTemplateCreateInfo deconstructed!!\n");
  
  
  
  
  vpDescriptorUpdateEntries->clear();
  delete vpDescriptorUpdateEntries;
  
  pDescriptorUpdateEntries.Reset();
  
  
  
  
  
  
}

void _VkDescriptorUpdateTemplateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorUpdateTemplateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorUpdateTemplateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorUpdateEntryCount").ToLocalChecked(), GetdescriptorUpdateEntryCount, SetdescriptorUpdateEntryCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDescriptorUpdateEntries").ToLocalChecked(), GetpDescriptorUpdateEntries, SetpDescriptorUpdateEntries, ctor);
  SetPrototypeAccessor(proto, Nan::New("templateType").ToLocalChecked(), GettemplateType, SettemplateType, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorSetLayout").ToLocalChecked(), GetdescriptorSetLayout, SetdescriptorSetLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineBindPoint").ToLocalChecked(), GetpipelineBindPoint, SetpipelineBindPoint, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineLayout").ToLocalChecked(), GetpipelineLayout, SetpipelineLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("set").ToLocalChecked(), Getset, Setset, ctor);
  Nan::Set(target, Nan::New("VkDescriptorUpdateTemplateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorUpdateTemplateCreateInfo::flush() {
  _VkDescriptorUpdateTemplateCreateInfo *self = this;
  if (!(self->pDescriptorUpdateEntries.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pDescriptorUpdateEntries);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.descriptorUpdateEntryCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries'");
      return false;
    }
    std::vector<VkDescriptorUpdateTemplateEntry>* data = self->vpDescriptorUpdateEntries;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDescriptorUpdateTemplateEntry::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
        return false;
      }
      _VkDescriptorUpdateTemplateEntry* result = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateEntry>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDescriptorUpdateEntries = data->data();
  }
  return true;
}

NAN_METHOD(_VkDescriptorUpdateTemplateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorUpdateTemplateCreateInfo* self = new _VkDescriptorUpdateTemplateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("descriptorUpdateEntryCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pDescriptorUpdateEntries").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("templateType").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("descriptorSetLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pipelineBindPoint").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pipelineLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("set").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorUpdateTemplateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::GetsType) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::SetsType) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::Getflags) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::Setflags) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDescriptorUpdateTemplateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.flags", "Number");
  
    return;
  }
}// descriptorUpdateEntryCount
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::GetdescriptorUpdateEntryCount) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorUpdateEntryCount));
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::SetdescriptorUpdateEntryCount) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorUpdateEntryCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.descriptorUpdateEntryCount", "Number");
  
    return;
  }
}// pDescriptorUpdateEntries
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::GetpDescriptorUpdateEntries) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (self->pDescriptorUpdateEntries.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDescriptorUpdateEntries);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::SetpDescriptorUpdateEntries) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pDescriptorUpdateEntries.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pDescriptorUpdateEntries.Reset();
      self->instance.pDescriptorUpdateEntries = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pDescriptorUpdateEntries = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries", "[object VkDescriptorUpdateTemplateEntry]");
  
    return;
  }
}// templateType
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::GettemplateType) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.templateType));
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::SettemplateType) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.templateType = static_cast<VkDescriptorUpdateTemplateType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.templateType", "Number");
  
    return;
  }
}// descriptorSetLayout
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::GetdescriptorSetLayout) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (self->descriptorSetLayout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->descriptorSetLayout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::SetdescriptorSetLayout) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDescriptorSetLayout::constructor)->HasInstance(obj)) {
      self->descriptorSetLayout.Reset<v8::Object>(value.As<v8::Object>());
      _VkDescriptorSetLayout* inst = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayout>(obj);
      ;
      self->instance.descriptorSetLayout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.descriptorSetLayout", "[object VkDescriptorSetLayout]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->descriptorSetLayout.Reset();
    self->instance.descriptorSetLayout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.descriptorSetLayout", "[object VkDescriptorSetLayout]");
  
    return;
  }
}// pipelineBindPoint
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::GetpipelineBindPoint) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pipelineBindPoint));
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::SetpipelineBindPoint) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pipelineBindPoint", "Number");
  
    return;
  }
}// pipelineLayout
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::GetpipelineLayout) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (self->pipelineLayout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pipelineLayout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::SetpipelineLayout) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineLayout::constructor)->HasInstance(obj)) {
      self->pipelineLayout.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineLayout* inst = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(obj);
      ;
      self->instance.pipelineLayout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pipelineLayout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pipelineLayout.Reset();
    self->instance.pipelineLayout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.pipelineLayout", "[object VkPipelineLayout]");
  
    return;
  }
}// set
NAN_GETTER(_VkDescriptorUpdateTemplateCreateInfo::Getset) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.set));
}NAN_SETTER(_VkDescriptorUpdateTemplateCreateInfo::Setset) {
  _VkDescriptorUpdateTemplateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.set = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorUpdateTemplateCreateInfo.set", "Number");
  
    return;
  }
}
/** ## END VkDescriptorUpdateTemplateCreateInfo ## **/

/** ## BEGIN VkDescriptorUpdateTemplateEntryKHR ## **/

class _VkDescriptorUpdateTemplateEntryKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkDescriptorUpdateTemplateEntryKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorUpdateTemplateEntryKHR();
    ~_VkDescriptorUpdateTemplateEntryKHR();

};

/*
#include "index.h"
#include "VkDescriptorUpdateTemplateEntryKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorUpdateTemplateEntryKHR::constructor;

_VkDescriptorUpdateTemplateEntryKHR::_VkDescriptorUpdateTemplateEntryKHR() {
  
  
}

_VkDescriptorUpdateTemplateEntryKHR::~_VkDescriptorUpdateTemplateEntryKHR() {
  //printf("VkDescriptorUpdateTemplateEntryKHR deconstructed!!\n");
  
}

void _VkDescriptorUpdateTemplateEntryKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorUpdateTemplateEntryKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorUpdateTemplateEntryKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkDescriptorUpdateTemplateEntryKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorUpdateTemplateEntryKHR::flush() {
  _VkDescriptorUpdateTemplateEntryKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorUpdateTemplateEntryKHR::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorUpdateTemplateEntryKHR* self = new _VkDescriptorUpdateTemplateEntryKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorUpdateTemplateEntryKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkDescriptorUpdateTemplateEntryKHR ## **/

/** ## BEGIN VkDeviceGroupSwapchainCreateInfoKHR ## **/

class _VkDeviceGroupSwapchainCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getmodes);
    static NAN_SETTER(Setmodes);
    

    // real instance
    VkDeviceGroupSwapchainCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupSwapchainCreateInfoKHR();
    ~_VkDeviceGroupSwapchainCreateInfoKHR();

};

/*
#include "index.h"
#include "VkDeviceGroupSwapchainCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupSwapchainCreateInfoKHR::constructor;

_VkDeviceGroupSwapchainCreateInfoKHR::_VkDeviceGroupSwapchainCreateInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR;
  
}

_VkDeviceGroupSwapchainCreateInfoKHR::~_VkDeviceGroupSwapchainCreateInfoKHR() {
  //printf("VkDeviceGroupSwapchainCreateInfoKHR deconstructed!!\n");
  
  
  
}

void _VkDeviceGroupSwapchainCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupSwapchainCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupSwapchainCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("modes").ToLocalChecked(), Getmodes, Setmodes, ctor);
  Nan::Set(target, Nan::New("VkDeviceGroupSwapchainCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupSwapchainCreateInfoKHR::flush() {
  _VkDeviceGroupSwapchainCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupSwapchainCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupSwapchainCreateInfoKHR* self = new _VkDeviceGroupSwapchainCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("modes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupSwapchainCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGroupSwapchainCreateInfoKHR::GetsType) {
  _VkDeviceGroupSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGroupSwapchainCreateInfoKHR::SetsType) {
  _VkDeviceGroupSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSwapchainCreateInfoKHR.sType", "Number");
  
    return;
  }
}// modes
NAN_GETTER(_VkDeviceGroupSwapchainCreateInfoKHR::Getmodes) {
  _VkDeviceGroupSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.modes));
}NAN_SETTER(_VkDeviceGroupSwapchainCreateInfoKHR::Setmodes) {
  _VkDeviceGroupSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.modes = static_cast<VkDeviceGroupPresentModeFlagsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSwapchainCreateInfoKHR.modes", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupSwapchainCreateInfoKHR ## **/

/** ## BEGIN VkDeviceGroupDeviceCreateInfoKHR ## **/

class _VkDeviceGroupDeviceCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkDeviceGroupDeviceCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupDeviceCreateInfoKHR();
    ~_VkDeviceGroupDeviceCreateInfoKHR();

};

/*
#include "index.h"
#include "VkDeviceGroupDeviceCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupDeviceCreateInfoKHR::constructor;

_VkDeviceGroupDeviceCreateInfoKHR::_VkDeviceGroupDeviceCreateInfoKHR() {
  
  
}

_VkDeviceGroupDeviceCreateInfoKHR::~_VkDeviceGroupDeviceCreateInfoKHR() {
  //printf("VkDeviceGroupDeviceCreateInfoKHR deconstructed!!\n");
  
}

void _VkDeviceGroupDeviceCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupDeviceCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupDeviceCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkDeviceGroupDeviceCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupDeviceCreateInfoKHR::flush() {
  _VkDeviceGroupDeviceCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupDeviceCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupDeviceCreateInfoKHR* self = new _VkDeviceGroupDeviceCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupDeviceCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkDeviceGroupDeviceCreateInfoKHR ## **/

/** ## BEGIN VkDeviceGroupDeviceCreateInfo ## **/

class _VkDeviceGroupDeviceCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetphysicalDeviceCount);
    static NAN_SETTER(SetphysicalDeviceCount);
    
    std::vector<VkPhysicalDevice>* vpPhysicalDevices;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pPhysicalDevices;
    static NAN_GETTER(GetpPhysicalDevices);
    static NAN_SETTER(SetpPhysicalDevices);
    

    // real instance
    VkDeviceGroupDeviceCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupDeviceCreateInfo();
    ~_VkDeviceGroupDeviceCreateInfo();

};

/*
#include "index.h"
#include "VkDeviceGroupDeviceCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupDeviceCreateInfo::constructor;

_VkDeviceGroupDeviceCreateInfo::_VkDeviceGroupDeviceCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO;
  vpPhysicalDevices = new std::vector<VkPhysicalDevice>;
  
}

_VkDeviceGroupDeviceCreateInfo::~_VkDeviceGroupDeviceCreateInfo() {
  //printf("VkDeviceGroupDeviceCreateInfo deconstructed!!\n");
  
  
  
  vpPhysicalDevices->clear();
  delete vpPhysicalDevices;
  
  pPhysicalDevices.Reset();
  
}

void _VkDeviceGroupDeviceCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupDeviceCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupDeviceCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("physicalDeviceCount").ToLocalChecked(), GetphysicalDeviceCount, SetphysicalDeviceCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pPhysicalDevices").ToLocalChecked(), GetpPhysicalDevices, SetpPhysicalDevices, ctor);
  Nan::Set(target, Nan::New("VkDeviceGroupDeviceCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupDeviceCreateInfo::flush() {
  _VkDeviceGroupDeviceCreateInfo *self = this;
  if (!(self->pPhysicalDevices.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pPhysicalDevices);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.physicalDeviceCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices'");
      return false;
    }
    std::vector<VkPhysicalDevice>* data = self->vpPhysicalDevices;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkPhysicalDevice::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupDeviceCreateInfo.pPhysicalDevices", "[object VkPhysicalDevice]");
  
        return false;
      }
      _VkPhysicalDevice* result = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pPhysicalDevices = data->data();
  }
  return true;
}

NAN_METHOD(_VkDeviceGroupDeviceCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupDeviceCreateInfo* self = new _VkDeviceGroupDeviceCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("physicalDeviceCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pPhysicalDevices").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupDeviceCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGroupDeviceCreateInfo::GetsType) {
  _VkDeviceGroupDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupDeviceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGroupDeviceCreateInfo::SetsType) {
  _VkDeviceGroupDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupDeviceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupDeviceCreateInfo.sType", "Number");
  
    return;
  }
}// physicalDeviceCount
NAN_GETTER(_VkDeviceGroupDeviceCreateInfo::GetphysicalDeviceCount) {
  _VkDeviceGroupDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupDeviceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.physicalDeviceCount));
}NAN_SETTER(_VkDeviceGroupDeviceCreateInfo::SetphysicalDeviceCount) {
  _VkDeviceGroupDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupDeviceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.physicalDeviceCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupDeviceCreateInfo.physicalDeviceCount", "Number");
  
    return;
  }
}// pPhysicalDevices
NAN_GETTER(_VkDeviceGroupDeviceCreateInfo::GetpPhysicalDevices) {
  _VkDeviceGroupDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupDeviceCreateInfo>(info.This());
  if (self->pPhysicalDevices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pPhysicalDevices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceGroupDeviceCreateInfo::SetpPhysicalDevices) {
  _VkDeviceGroupDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupDeviceCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pPhysicalDevices.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pPhysicalDevices.Reset();
      self->instance.pPhysicalDevices = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupDeviceCreateInfo.pPhysicalDevices", "[object VkPhysicalDevice]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pPhysicalDevices = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupDeviceCreateInfo.pPhysicalDevices", "[object VkPhysicalDevice]");
  
    return;
  }
}
/** ## END VkDeviceGroupDeviceCreateInfo ## **/

/** ## BEGIN VkDeviceGroupPresentInfoKHR ## **/

class _VkDeviceGroupPresentInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetswapchainCount);
    static NAN_SETTER(SetswapchainCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDeviceMasks;
    static NAN_GETTER(GetpDeviceMasks);
    static NAN_SETTER(SetpDeviceMasks);
    
    static NAN_GETTER(Getmode);
    static NAN_SETTER(Setmode);
    

    // real instance
    VkDeviceGroupPresentInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupPresentInfoKHR();
    ~_VkDeviceGroupPresentInfoKHR();

};

/*
#include "index.h"
#include "VkDeviceGroupPresentInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupPresentInfoKHR::constructor;

_VkDeviceGroupPresentInfoKHR::_VkDeviceGroupPresentInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
  
}

_VkDeviceGroupPresentInfoKHR::~_VkDeviceGroupPresentInfoKHR() {
  //printf("VkDeviceGroupPresentInfoKHR deconstructed!!\n");
  
  
  
  pDeviceMasks.Reset();
  
  
}

void _VkDeviceGroupPresentInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupPresentInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupPresentInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("swapchainCount").ToLocalChecked(), GetswapchainCount, SetswapchainCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDeviceMasks").ToLocalChecked(), GetpDeviceMasks, SetpDeviceMasks, ctor);
  SetPrototypeAccessor(proto, Nan::New("mode").ToLocalChecked(), Getmode, Setmode, ctor);
  Nan::Set(target, Nan::New("VkDeviceGroupPresentInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupPresentInfoKHR::flush() {
  _VkDeviceGroupPresentInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupPresentInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupPresentInfoKHR* self = new _VkDeviceGroupPresentInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("swapchainCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pDeviceMasks").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("mode").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupPresentInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGroupPresentInfoKHR::GetsType) {
  _VkDeviceGroupPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGroupPresentInfoKHR::SetsType) {
  _VkDeviceGroupPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupPresentInfoKHR.sType", "Number");
  
    return;
  }
}// swapchainCount
NAN_GETTER(_VkDeviceGroupPresentInfoKHR::GetswapchainCount) {
  _VkDeviceGroupPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.swapchainCount));
}NAN_SETTER(_VkDeviceGroupPresentInfoKHR::SetswapchainCount) {
  _VkDeviceGroupPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.swapchainCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupPresentInfoKHR.swapchainCount", "Number");
  
    return;
  }
}// pDeviceMasks
NAN_GETTER(_VkDeviceGroupPresentInfoKHR::GetpDeviceMasks) {
  _VkDeviceGroupPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentInfoKHR>(info.This());
  if (self->pDeviceMasks.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDeviceMasks);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceGroupPresentInfoKHR::SetpDeviceMasks) {
  _VkDeviceGroupPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pDeviceMasks.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupPresentInfoKHR.pDeviceMasks", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDeviceMasks.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupPresentInfoKHR.pDeviceMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDeviceMasks = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pDeviceMasks = nullptr;
  }
}// mode
NAN_GETTER(_VkDeviceGroupPresentInfoKHR::Getmode) {
  _VkDeviceGroupPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.mode));
}NAN_SETTER(_VkDeviceGroupPresentInfoKHR::Setmode) {
  _VkDeviceGroupPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.mode = static_cast<VkDeviceGroupPresentModeFlagBitsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupPresentInfoKHR.mode", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupPresentInfoKHR ## **/

/** ## BEGIN VkAcquireNextImageInfoKHR ## **/

class _VkAcquireNextImageInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> swapchain;
      static NAN_GETTER(Getswapchain);
    static NAN_SETTER(Setswapchain);
    
    static NAN_GETTER(Gettimeout);
    static NAN_SETTER(Settimeout);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> semaphore;
      static NAN_GETTER(Getsemaphore);
    static NAN_SETTER(Setsemaphore);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> fence;
      static NAN_GETTER(Getfence);
    static NAN_SETTER(Setfence);
    
    static NAN_GETTER(GetdeviceMask);
    static NAN_SETTER(SetdeviceMask);
    

    // real instance
    VkAcquireNextImageInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAcquireNextImageInfoKHR();
    ~_VkAcquireNextImageInfoKHR();

};

/*
#include "index.h"
#include "VkAcquireNextImageInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAcquireNextImageInfoKHR::constructor;

_VkAcquireNextImageInfoKHR::_VkAcquireNextImageInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR;
  
}

_VkAcquireNextImageInfoKHR::~_VkAcquireNextImageInfoKHR() {
  //printf("VkAcquireNextImageInfoKHR deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkAcquireNextImageInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAcquireNextImageInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAcquireNextImageInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("swapchain").ToLocalChecked(), Getswapchain, Setswapchain, ctor);
  SetPrototypeAccessor(proto, Nan::New("timeout").ToLocalChecked(), Gettimeout, Settimeout, ctor);
  SetPrototypeAccessor(proto, Nan::New("semaphore").ToLocalChecked(), Getsemaphore, Setsemaphore, ctor);
  SetPrototypeAccessor(proto, Nan::New("fence").ToLocalChecked(), Getfence, Setfence, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceMask").ToLocalChecked(), GetdeviceMask, SetdeviceMask, ctor);
  Nan::Set(target, Nan::New("VkAcquireNextImageInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAcquireNextImageInfoKHR::flush() {
  _VkAcquireNextImageInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkAcquireNextImageInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkAcquireNextImageInfoKHR* self = new _VkAcquireNextImageInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("swapchain").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("timeout").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("semaphore").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("fence").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("deviceMask").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAcquireNextImageInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkAcquireNextImageInfoKHR::GetsType) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkAcquireNextImageInfoKHR::SetsType) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.sType", "Number");
  
    return;
  }
}// swapchain
NAN_GETTER(_VkAcquireNextImageInfoKHR::Getswapchain) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  if (self->swapchain.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->swapchain);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkAcquireNextImageInfoKHR::Setswapchain) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSwapchainKHR::constructor)->HasInstance(obj)) {
      self->swapchain.Reset<v8::Object>(value.As<v8::Object>());
      _VkSwapchainKHR* inst = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(obj);
      ;
      self->instance.swapchain = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->swapchain.Reset();
    self->instance.swapchain = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
    return;
  }
}// timeout
NAN_GETTER(_VkAcquireNextImageInfoKHR::Gettimeout) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.timeout));
}NAN_SETTER(_VkAcquireNextImageInfoKHR::Settimeout) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.timeout = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.timeout", "Number");
  
    return;
  }
}// semaphore
NAN_GETTER(_VkAcquireNextImageInfoKHR::Getsemaphore) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  if (self->semaphore.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->semaphore);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkAcquireNextImageInfoKHR::Setsemaphore) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSemaphore::constructor)->HasInstance(obj)) {
      self->semaphore.Reset<v8::Object>(value.As<v8::Object>());
      _VkSemaphore* inst = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      ;
      self->instance.semaphore = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->semaphore.Reset();
    self->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// fence
NAN_GETTER(_VkAcquireNextImageInfoKHR::Getfence) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  if (self->fence.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->fence);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkAcquireNextImageInfoKHR::Setfence) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkFence::constructor)->HasInstance(obj)) {
      self->fence.Reset<v8::Object>(value.As<v8::Object>());
      _VkFence* inst = Nan::ObjectWrap::Unwrap<_VkFence>(obj);
      ;
      self->instance.fence = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->fence.Reset();
    self->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// deviceMask
NAN_GETTER(_VkAcquireNextImageInfoKHR::GetdeviceMask) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceMask));
}NAN_SETTER(_VkAcquireNextImageInfoKHR::SetdeviceMask) {
  _VkAcquireNextImageInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkAcquireNextImageInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceMask = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAcquireNextImageInfoKHR.deviceMask", "Number");
  
    return;
  }
}
/** ## END VkAcquireNextImageInfoKHR ## **/

/** ## BEGIN VkBindImageMemorySwapchainInfoKHR ## **/

class _VkBindImageMemorySwapchainInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> swapchain;
      static NAN_GETTER(Getswapchain);
    static NAN_SETTER(Setswapchain);
    
    static NAN_GETTER(GetimageIndex);
    static NAN_SETTER(SetimageIndex);
    

    // real instance
    VkBindImageMemorySwapchainInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindImageMemorySwapchainInfoKHR();
    ~_VkBindImageMemorySwapchainInfoKHR();

};

/*
#include "index.h"
#include "VkBindImageMemorySwapchainInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindImageMemorySwapchainInfoKHR::constructor;

_VkBindImageMemorySwapchainInfoKHR::_VkBindImageMemorySwapchainInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
  
}

_VkBindImageMemorySwapchainInfoKHR::~_VkBindImageMemorySwapchainInfoKHR() {
  //printf("VkBindImageMemorySwapchainInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkBindImageMemorySwapchainInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindImageMemorySwapchainInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindImageMemorySwapchainInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("swapchain").ToLocalChecked(), Getswapchain, Setswapchain, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageIndex").ToLocalChecked(), GetimageIndex, SetimageIndex, ctor);
  Nan::Set(target, Nan::New("VkBindImageMemorySwapchainInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindImageMemorySwapchainInfoKHR::flush() {
  _VkBindImageMemorySwapchainInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkBindImageMemorySwapchainInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkBindImageMemorySwapchainInfoKHR* self = new _VkBindImageMemorySwapchainInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("swapchain").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("imageIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindImageMemorySwapchainInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBindImageMemorySwapchainInfoKHR::GetsType) {
  _VkBindImageMemorySwapchainInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemorySwapchainInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBindImageMemorySwapchainInfoKHR::SetsType) {
  _VkBindImageMemorySwapchainInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemorySwapchainInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemorySwapchainInfoKHR.sType", "Number");
  
    return;
  }
}// swapchain
NAN_GETTER(_VkBindImageMemorySwapchainInfoKHR::Getswapchain) {
  _VkBindImageMemorySwapchainInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemorySwapchainInfoKHR>(info.This());
  if (self->swapchain.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->swapchain);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindImageMemorySwapchainInfoKHR::Setswapchain) {
  _VkBindImageMemorySwapchainInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemorySwapchainInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSwapchainKHR::constructor)->HasInstance(obj)) {
      self->swapchain.Reset<v8::Object>(value.As<v8::Object>());
      _VkSwapchainKHR* inst = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(obj);
      ;
      self->instance.swapchain = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindImageMemorySwapchainInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->swapchain.Reset();
    self->instance.swapchain = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemorySwapchainInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
    return;
  }
}// imageIndex
NAN_GETTER(_VkBindImageMemorySwapchainInfoKHR::GetimageIndex) {
  _VkBindImageMemorySwapchainInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemorySwapchainInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageIndex));
}NAN_SETTER(_VkBindImageMemorySwapchainInfoKHR::SetimageIndex) {
  _VkBindImageMemorySwapchainInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemorySwapchainInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.imageIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemorySwapchainInfoKHR.imageIndex", "Number");
  
    return;
  }
}
/** ## END VkBindImageMemorySwapchainInfoKHR ## **/

/** ## BEGIN VkImageSwapchainCreateInfoKHR ## **/

class _VkImageSwapchainCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> swapchain;
      static NAN_GETTER(Getswapchain);
    static NAN_SETTER(Setswapchain);
    

    // real instance
    VkImageSwapchainCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageSwapchainCreateInfoKHR();
    ~_VkImageSwapchainCreateInfoKHR();

};

/*
#include "index.h"
#include "VkImageSwapchainCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageSwapchainCreateInfoKHR::constructor;

_VkImageSwapchainCreateInfoKHR::_VkImageSwapchainCreateInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR;
  
}

_VkImageSwapchainCreateInfoKHR::~_VkImageSwapchainCreateInfoKHR() {
  //printf("VkImageSwapchainCreateInfoKHR deconstructed!!\n");
  
  
  
}

void _VkImageSwapchainCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageSwapchainCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageSwapchainCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("swapchain").ToLocalChecked(), Getswapchain, Setswapchain, ctor);
  Nan::Set(target, Nan::New("VkImageSwapchainCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageSwapchainCreateInfoKHR::flush() {
  _VkImageSwapchainCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImageSwapchainCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImageSwapchainCreateInfoKHR* self = new _VkImageSwapchainCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("swapchain").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageSwapchainCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageSwapchainCreateInfoKHR::GetsType) {
  _VkImageSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageSwapchainCreateInfoKHR::SetsType) {
  _VkImageSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSwapchainCreateInfoKHR.sType", "Number");
  
    return;
  }
}// swapchain
NAN_GETTER(_VkImageSwapchainCreateInfoKHR::Getswapchain) {
  _VkImageSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageSwapchainCreateInfoKHR>(info.This());
  if (self->swapchain.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->swapchain);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageSwapchainCreateInfoKHR::Setswapchain) {
  _VkImageSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImageSwapchainCreateInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSwapchainKHR::constructor)->HasInstance(obj)) {
      self->swapchain.Reset<v8::Object>(value.As<v8::Object>());
      _VkSwapchainKHR* inst = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(obj);
      ;
      self->instance.swapchain = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageSwapchainCreateInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->swapchain.Reset();
    self->instance.swapchain = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSwapchainCreateInfoKHR.swapchain", "[object VkSwapchainKHR]");
  
    return;
  }
}
/** ## END VkImageSwapchainCreateInfoKHR ## **/

/** ## BEGIN VkDeviceGroupPresentCapabilitiesKHR ## **/

class _VkDeviceGroupPresentCapabilitiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    std::vector<uint32_t>* vpresentMask;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> presentMask;
    static NAN_GETTER(GetpresentMask);
    static NAN_GETTER(Getmodes);

    // real instance
    VkDeviceGroupPresentCapabilitiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupPresentCapabilitiesKHR();
    ~_VkDeviceGroupPresentCapabilitiesKHR();

};

/*
#include <string.h>
#include "index.h"
#include "VkDeviceGroupPresentCapabilitiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupPresentCapabilitiesKHR::constructor;

_VkDeviceGroupPresentCapabilitiesKHR::_VkDeviceGroupPresentCapabilitiesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR;
  vpresentMask = new std::vector<uint32_t>;
  
}

_VkDeviceGroupPresentCapabilitiesKHR::~_VkDeviceGroupPresentCapabilitiesKHR() {
  //printf("VkDeviceGroupPresentCapabilitiesKHR deconstructed!!\n");
  
  
  vpresentMask->clear();
  delete vpresentMask;
  
  
  
}

void _VkDeviceGroupPresentCapabilitiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupPresentCapabilitiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupPresentCapabilitiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("presentMask").ToLocalChecked(), GetpresentMask, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("modes").ToLocalChecked(), Getmodes, nullptr, ctor);
  Nan::Set(target, Nan::New("VkDeviceGroupPresentCapabilitiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupPresentCapabilitiesKHR::flush() {
  _VkDeviceGroupPresentCapabilitiesKHR *self = this;
  if (!(self->presentMask.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->presentMask);
    
  }
  return true;
}

NAN_METHOD(_VkDeviceGroupPresentCapabilitiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupPresentCapabilitiesKHR* self = new _VkDeviceGroupPresentCapabilitiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupPresentCapabilitiesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGroupPresentCapabilitiesKHR::GetsType) {
  _VkDeviceGroupPresentCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// presentMask
NAN_GETTER(_VkDeviceGroupPresentCapabilitiesKHR::GetpresentMask) {
  _VkDeviceGroupPresentCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentCapabilitiesKHR>(info.This());
  if (self->presentMask.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->presentMask));
  }
}// modes
NAN_GETTER(_VkDeviceGroupPresentCapabilitiesKHR::Getmodes) {
  _VkDeviceGroupPresentCapabilitiesKHR *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupPresentCapabilitiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.modes));
}
/** ## END VkDeviceGroupPresentCapabilitiesKHR ## **/

/** ## BEGIN VkDeviceGroupBindSparseInfoKHR ## **/

class _VkDeviceGroupBindSparseInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkDeviceGroupBindSparseInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupBindSparseInfoKHR();
    ~_VkDeviceGroupBindSparseInfoKHR();

};

/*
#include "index.h"
#include "VkDeviceGroupBindSparseInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupBindSparseInfoKHR::constructor;

_VkDeviceGroupBindSparseInfoKHR::_VkDeviceGroupBindSparseInfoKHR() {
  
  
}

_VkDeviceGroupBindSparseInfoKHR::~_VkDeviceGroupBindSparseInfoKHR() {
  //printf("VkDeviceGroupBindSparseInfoKHR deconstructed!!\n");
  
}

void _VkDeviceGroupBindSparseInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupBindSparseInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupBindSparseInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkDeviceGroupBindSparseInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupBindSparseInfoKHR::flush() {
  _VkDeviceGroupBindSparseInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupBindSparseInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupBindSparseInfoKHR* self = new _VkDeviceGroupBindSparseInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupBindSparseInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkDeviceGroupBindSparseInfoKHR ## **/

/** ## BEGIN VkDeviceGroupBindSparseInfo ## **/

class _VkDeviceGroupBindSparseInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetresourceDeviceIndex);
    static NAN_SETTER(SetresourceDeviceIndex);
    
    static NAN_GETTER(GetmemoryDeviceIndex);
    static NAN_SETTER(SetmemoryDeviceIndex);
    

    // real instance
    VkDeviceGroupBindSparseInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupBindSparseInfo();
    ~_VkDeviceGroupBindSparseInfo();

};

/*
#include "index.h"
#include "VkDeviceGroupBindSparseInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupBindSparseInfo::constructor;

_VkDeviceGroupBindSparseInfo::_VkDeviceGroupBindSparseInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
  
}

_VkDeviceGroupBindSparseInfo::~_VkDeviceGroupBindSparseInfo() {
  //printf("VkDeviceGroupBindSparseInfo deconstructed!!\n");
  
  
  
  
}

void _VkDeviceGroupBindSparseInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupBindSparseInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupBindSparseInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("resourceDeviceIndex").ToLocalChecked(), GetresourceDeviceIndex, SetresourceDeviceIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryDeviceIndex").ToLocalChecked(), GetmemoryDeviceIndex, SetmemoryDeviceIndex, ctor);
  Nan::Set(target, Nan::New("VkDeviceGroupBindSparseInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupBindSparseInfo::flush() {
  _VkDeviceGroupBindSparseInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupBindSparseInfo::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupBindSparseInfo* self = new _VkDeviceGroupBindSparseInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("resourceDeviceIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("memoryDeviceIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupBindSparseInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGroupBindSparseInfo::GetsType) {
  _VkDeviceGroupBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGroupBindSparseInfo::SetsType) {
  _VkDeviceGroupBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupBindSparseInfo.sType", "Number");
  
    return;
  }
}// resourceDeviceIndex
NAN_GETTER(_VkDeviceGroupBindSparseInfo::GetresourceDeviceIndex) {
  _VkDeviceGroupBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.resourceDeviceIndex));
}NAN_SETTER(_VkDeviceGroupBindSparseInfo::SetresourceDeviceIndex) {
  _VkDeviceGroupBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.resourceDeviceIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupBindSparseInfo.resourceDeviceIndex", "Number");
  
    return;
  }
}// memoryDeviceIndex
NAN_GETTER(_VkDeviceGroupBindSparseInfo::GetmemoryDeviceIndex) {
  _VkDeviceGroupBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryDeviceIndex));
}NAN_SETTER(_VkDeviceGroupBindSparseInfo::SetmemoryDeviceIndex) {
  _VkDeviceGroupBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.memoryDeviceIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupBindSparseInfo.memoryDeviceIndex", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupBindSparseInfo ## **/

/** ## BEGIN VkDeviceGroupSubmitInfoKHR ## **/

class _VkDeviceGroupSubmitInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkDeviceGroupSubmitInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupSubmitInfoKHR();
    ~_VkDeviceGroupSubmitInfoKHR();

};

/*
#include "index.h"
#include "VkDeviceGroupSubmitInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupSubmitInfoKHR::constructor;

_VkDeviceGroupSubmitInfoKHR::_VkDeviceGroupSubmitInfoKHR() {
  
  
}

_VkDeviceGroupSubmitInfoKHR::~_VkDeviceGroupSubmitInfoKHR() {
  //printf("VkDeviceGroupSubmitInfoKHR deconstructed!!\n");
  
}

void _VkDeviceGroupSubmitInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupSubmitInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupSubmitInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkDeviceGroupSubmitInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupSubmitInfoKHR::flush() {
  _VkDeviceGroupSubmitInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupSubmitInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupSubmitInfoKHR* self = new _VkDeviceGroupSubmitInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupSubmitInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkDeviceGroupSubmitInfoKHR ## **/

/** ## BEGIN VkDeviceGroupSubmitInfo ## **/

class _VkDeviceGroupSubmitInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetwaitSemaphoreCount);
    static NAN_SETTER(SetwaitSemaphoreCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pWaitSemaphoreDeviceIndices;
    static NAN_GETTER(GetpWaitSemaphoreDeviceIndices);
    static NAN_SETTER(SetpWaitSemaphoreDeviceIndices);
    
    static NAN_GETTER(GetcommandBufferCount);
    static NAN_SETTER(SetcommandBufferCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pCommandBufferDeviceMasks;
    static NAN_GETTER(GetpCommandBufferDeviceMasks);
    static NAN_SETTER(SetpCommandBufferDeviceMasks);
    
    static NAN_GETTER(GetsignalSemaphoreCount);
    static NAN_SETTER(SetsignalSemaphoreCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSignalSemaphoreDeviceIndices;
    static NAN_GETTER(GetpSignalSemaphoreDeviceIndices);
    static NAN_SETTER(SetpSignalSemaphoreDeviceIndices);
    

    // real instance
    VkDeviceGroupSubmitInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupSubmitInfo();
    ~_VkDeviceGroupSubmitInfo();

};

/*
#include "index.h"
#include "VkDeviceGroupSubmitInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupSubmitInfo::constructor;

_VkDeviceGroupSubmitInfo::_VkDeviceGroupSubmitInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO;
  
}

_VkDeviceGroupSubmitInfo::~_VkDeviceGroupSubmitInfo() {
  //printf("VkDeviceGroupSubmitInfo deconstructed!!\n");
  
  
  
  pWaitSemaphoreDeviceIndices.Reset();
  
  
  pCommandBufferDeviceMasks.Reset();
  
  
  pSignalSemaphoreDeviceIndices.Reset();
  
}

void _VkDeviceGroupSubmitInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupSubmitInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupSubmitInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("waitSemaphoreCount").ToLocalChecked(), GetwaitSemaphoreCount, SetwaitSemaphoreCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pWaitSemaphoreDeviceIndices").ToLocalChecked(), GetpWaitSemaphoreDeviceIndices, SetpWaitSemaphoreDeviceIndices, ctor);
  SetPrototypeAccessor(proto, Nan::New("commandBufferCount").ToLocalChecked(), GetcommandBufferCount, SetcommandBufferCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pCommandBufferDeviceMasks").ToLocalChecked(), GetpCommandBufferDeviceMasks, SetpCommandBufferDeviceMasks, ctor);
  SetPrototypeAccessor(proto, Nan::New("signalSemaphoreCount").ToLocalChecked(), GetsignalSemaphoreCount, SetsignalSemaphoreCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSignalSemaphoreDeviceIndices").ToLocalChecked(), GetpSignalSemaphoreDeviceIndices, SetpSignalSemaphoreDeviceIndices, ctor);
  Nan::Set(target, Nan::New("VkDeviceGroupSubmitInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupSubmitInfo::flush() {
  _VkDeviceGroupSubmitInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupSubmitInfo::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupSubmitInfo* self = new _VkDeviceGroupSubmitInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("waitSemaphoreCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pWaitSemaphoreDeviceIndices").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("commandBufferCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pCommandBufferDeviceMasks").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("signalSemaphoreCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pSignalSemaphoreDeviceIndices").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupSubmitInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGroupSubmitInfo::GetsType) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGroupSubmitInfo::SetsType) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.sType", "Number");
  
    return;
  }
}// waitSemaphoreCount
NAN_GETTER(_VkDeviceGroupSubmitInfo::GetwaitSemaphoreCount) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.waitSemaphoreCount));
}NAN_SETTER(_VkDeviceGroupSubmitInfo::SetwaitSemaphoreCount) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.waitSemaphoreCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphoreDeviceIndices
NAN_GETTER(_VkDeviceGroupSubmitInfo::GetpWaitSemaphoreDeviceIndices) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  if (self->pWaitSemaphoreDeviceIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pWaitSemaphoreDeviceIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceGroupSubmitInfo::SetpWaitSemaphoreDeviceIndices) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pWaitSemaphoreDeviceIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.pWaitSemaphoreDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pWaitSemaphoreDeviceIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.pWaitSemaphoreDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pWaitSemaphoreDeviceIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pWaitSemaphoreDeviceIndices = nullptr;
  }
}// commandBufferCount
NAN_GETTER(_VkDeviceGroupSubmitInfo::GetcommandBufferCount) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.commandBufferCount));
}NAN_SETTER(_VkDeviceGroupSubmitInfo::SetcommandBufferCount) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.commandBufferCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.commandBufferCount", "Number");
  
    return;
  }
}// pCommandBufferDeviceMasks
NAN_GETTER(_VkDeviceGroupSubmitInfo::GetpCommandBufferDeviceMasks) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  if (self->pCommandBufferDeviceMasks.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pCommandBufferDeviceMasks);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceGroupSubmitInfo::SetpCommandBufferDeviceMasks) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pCommandBufferDeviceMasks.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.pCommandBufferDeviceMasks", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pCommandBufferDeviceMasks.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.pCommandBufferDeviceMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pCommandBufferDeviceMasks = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pCommandBufferDeviceMasks = nullptr;
  }
}// signalSemaphoreCount
NAN_GETTER(_VkDeviceGroupSubmitInfo::GetsignalSemaphoreCount) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.signalSemaphoreCount));
}NAN_SETTER(_VkDeviceGroupSubmitInfo::SetsignalSemaphoreCount) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.signalSemaphoreCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.signalSemaphoreCount", "Number");
  
    return;
  }
}// pSignalSemaphoreDeviceIndices
NAN_GETTER(_VkDeviceGroupSubmitInfo::GetpSignalSemaphoreDeviceIndices) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  if (self->pSignalSemaphoreDeviceIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSignalSemaphoreDeviceIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceGroupSubmitInfo::SetpSignalSemaphoreDeviceIndices) {
  _VkDeviceGroupSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupSubmitInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pSignalSemaphoreDeviceIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.pSignalSemaphoreDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pSignalSemaphoreDeviceIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupSubmitInfo.pSignalSemaphoreDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pSignalSemaphoreDeviceIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pSignalSemaphoreDeviceIndices = nullptr;
  }
}
/** ## END VkDeviceGroupSubmitInfo ## **/

/** ## BEGIN VkDeviceGroupCommandBufferBeginInfoKHR ## **/

class _VkDeviceGroupCommandBufferBeginInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkDeviceGroupCommandBufferBeginInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupCommandBufferBeginInfoKHR();
    ~_VkDeviceGroupCommandBufferBeginInfoKHR();

};

/*
#include "index.h"
#include "VkDeviceGroupCommandBufferBeginInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupCommandBufferBeginInfoKHR::constructor;

_VkDeviceGroupCommandBufferBeginInfoKHR::_VkDeviceGroupCommandBufferBeginInfoKHR() {
  
  
}

_VkDeviceGroupCommandBufferBeginInfoKHR::~_VkDeviceGroupCommandBufferBeginInfoKHR() {
  //printf("VkDeviceGroupCommandBufferBeginInfoKHR deconstructed!!\n");
  
}

void _VkDeviceGroupCommandBufferBeginInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupCommandBufferBeginInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupCommandBufferBeginInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkDeviceGroupCommandBufferBeginInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupCommandBufferBeginInfoKHR::flush() {
  _VkDeviceGroupCommandBufferBeginInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupCommandBufferBeginInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupCommandBufferBeginInfoKHR* self = new _VkDeviceGroupCommandBufferBeginInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupCommandBufferBeginInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkDeviceGroupCommandBufferBeginInfoKHR ## **/

/** ## BEGIN VkDeviceGroupCommandBufferBeginInfo ## **/

class _VkDeviceGroupCommandBufferBeginInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdeviceMask);
    static NAN_SETTER(SetdeviceMask);
    

    // real instance
    VkDeviceGroupCommandBufferBeginInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupCommandBufferBeginInfo();
    ~_VkDeviceGroupCommandBufferBeginInfo();

};

/*
#include "index.h"
#include "VkDeviceGroupCommandBufferBeginInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupCommandBufferBeginInfo::constructor;

_VkDeviceGroupCommandBufferBeginInfo::_VkDeviceGroupCommandBufferBeginInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO;
  
}

_VkDeviceGroupCommandBufferBeginInfo::~_VkDeviceGroupCommandBufferBeginInfo() {
  //printf("VkDeviceGroupCommandBufferBeginInfo deconstructed!!\n");
  
  
  
}

void _VkDeviceGroupCommandBufferBeginInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupCommandBufferBeginInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupCommandBufferBeginInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceMask").ToLocalChecked(), GetdeviceMask, SetdeviceMask, ctor);
  Nan::Set(target, Nan::New("VkDeviceGroupCommandBufferBeginInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupCommandBufferBeginInfo::flush() {
  _VkDeviceGroupCommandBufferBeginInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupCommandBufferBeginInfo::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupCommandBufferBeginInfo* self = new _VkDeviceGroupCommandBufferBeginInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("deviceMask").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupCommandBufferBeginInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGroupCommandBufferBeginInfo::GetsType) {
  _VkDeviceGroupCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupCommandBufferBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGroupCommandBufferBeginInfo::SetsType) {
  _VkDeviceGroupCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupCommandBufferBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupCommandBufferBeginInfo.sType", "Number");
  
    return;
  }
}// deviceMask
NAN_GETTER(_VkDeviceGroupCommandBufferBeginInfo::GetdeviceMask) {
  _VkDeviceGroupCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupCommandBufferBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceMask));
}NAN_SETTER(_VkDeviceGroupCommandBufferBeginInfo::SetdeviceMask) {
  _VkDeviceGroupCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupCommandBufferBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceMask = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupCommandBufferBeginInfo.deviceMask", "Number");
  
    return;
  }
}
/** ## END VkDeviceGroupCommandBufferBeginInfo ## **/

/** ## BEGIN VkDeviceGroupRenderPassBeginInfoKHR ## **/

class _VkDeviceGroupRenderPassBeginInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkDeviceGroupRenderPassBeginInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupRenderPassBeginInfoKHR();
    ~_VkDeviceGroupRenderPassBeginInfoKHR();

};

/*
#include "index.h"
#include "VkDeviceGroupRenderPassBeginInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupRenderPassBeginInfoKHR::constructor;

_VkDeviceGroupRenderPassBeginInfoKHR::_VkDeviceGroupRenderPassBeginInfoKHR() {
  
  
}

_VkDeviceGroupRenderPassBeginInfoKHR::~_VkDeviceGroupRenderPassBeginInfoKHR() {
  //printf("VkDeviceGroupRenderPassBeginInfoKHR deconstructed!!\n");
  
}

void _VkDeviceGroupRenderPassBeginInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupRenderPassBeginInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupRenderPassBeginInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkDeviceGroupRenderPassBeginInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupRenderPassBeginInfoKHR::flush() {
  _VkDeviceGroupRenderPassBeginInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGroupRenderPassBeginInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupRenderPassBeginInfoKHR* self = new _VkDeviceGroupRenderPassBeginInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupRenderPassBeginInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkDeviceGroupRenderPassBeginInfoKHR ## **/

/** ## BEGIN VkDeviceGroupRenderPassBeginInfo ## **/

class _VkDeviceGroupRenderPassBeginInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdeviceMask);
    static NAN_SETTER(SetdeviceMask);
    
    static NAN_GETTER(GetdeviceRenderAreaCount);
    static NAN_SETTER(SetdeviceRenderAreaCount);
    
    std::vector<VkRect2D>* vpDeviceRenderAreas;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDeviceRenderAreas;
    static NAN_GETTER(GetpDeviceRenderAreas);
    static NAN_SETTER(SetpDeviceRenderAreas);
    

    // real instance
    VkDeviceGroupRenderPassBeginInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGroupRenderPassBeginInfo();
    ~_VkDeviceGroupRenderPassBeginInfo();

};

/*
#include "index.h"
#include "VkDeviceGroupRenderPassBeginInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGroupRenderPassBeginInfo::constructor;

_VkDeviceGroupRenderPassBeginInfo::_VkDeviceGroupRenderPassBeginInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO;
  vpDeviceRenderAreas = new std::vector<VkRect2D>;
  
}

_VkDeviceGroupRenderPassBeginInfo::~_VkDeviceGroupRenderPassBeginInfo() {
  //printf("VkDeviceGroupRenderPassBeginInfo deconstructed!!\n");
  
  
  
  
  vpDeviceRenderAreas->clear();
  delete vpDeviceRenderAreas;
  
  pDeviceRenderAreas.Reset();
  
}

void _VkDeviceGroupRenderPassBeginInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGroupRenderPassBeginInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGroupRenderPassBeginInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceMask").ToLocalChecked(), GetdeviceMask, SetdeviceMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceRenderAreaCount").ToLocalChecked(), GetdeviceRenderAreaCount, SetdeviceRenderAreaCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDeviceRenderAreas").ToLocalChecked(), GetpDeviceRenderAreas, SetpDeviceRenderAreas, ctor);
  Nan::Set(target, Nan::New("VkDeviceGroupRenderPassBeginInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGroupRenderPassBeginInfo::flush() {
  _VkDeviceGroupRenderPassBeginInfo *self = this;
  if (!(self->pDeviceRenderAreas.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pDeviceRenderAreas);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.deviceRenderAreaCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas'");
      return false;
    }
    std::vector<VkRect2D>* data = self->vpDeviceRenderAreas;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkRect2D::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDeviceRenderAreas = data->data();
  }
  return true;
}

NAN_METHOD(_VkDeviceGroupRenderPassBeginInfo::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGroupRenderPassBeginInfo* self = new _VkDeviceGroupRenderPassBeginInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("deviceMask").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("deviceRenderAreaCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pDeviceRenderAreas").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGroupRenderPassBeginInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGroupRenderPassBeginInfo::GetsType) {
  _VkDeviceGroupRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupRenderPassBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGroupRenderPassBeginInfo::SetsType) {
  _VkDeviceGroupRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupRenderPassBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupRenderPassBeginInfo.sType", "Number");
  
    return;
  }
}// deviceMask
NAN_GETTER(_VkDeviceGroupRenderPassBeginInfo::GetdeviceMask) {
  _VkDeviceGroupRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupRenderPassBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceMask));
}NAN_SETTER(_VkDeviceGroupRenderPassBeginInfo::SetdeviceMask) {
  _VkDeviceGroupRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupRenderPassBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceMask = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupRenderPassBeginInfo.deviceMask", "Number");
  
    return;
  }
}// deviceRenderAreaCount
NAN_GETTER(_VkDeviceGroupRenderPassBeginInfo::GetdeviceRenderAreaCount) {
  _VkDeviceGroupRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupRenderPassBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceRenderAreaCount));
}NAN_SETTER(_VkDeviceGroupRenderPassBeginInfo::SetdeviceRenderAreaCount) {
  _VkDeviceGroupRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupRenderPassBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceRenderAreaCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupRenderPassBeginInfo.deviceRenderAreaCount", "Number");
  
    return;
  }
}// pDeviceRenderAreas
NAN_GETTER(_VkDeviceGroupRenderPassBeginInfo::GetpDeviceRenderAreas) {
  _VkDeviceGroupRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupRenderPassBeginInfo>(info.This());
  if (self->pDeviceRenderAreas.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDeviceRenderAreas);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceGroupRenderPassBeginInfo::SetpDeviceRenderAreas) {
  _VkDeviceGroupRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceGroupRenderPassBeginInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pDeviceRenderAreas.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pDeviceRenderAreas.Reset();
      self->instance.pDeviceRenderAreas = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pDeviceRenderAreas = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkDeviceGroupRenderPassBeginInfo ## **/

/** ## BEGIN VkBindImageMemoryDeviceGroupInfoKHR ## **/

class _VkBindImageMemoryDeviceGroupInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkBindImageMemoryDeviceGroupInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindImageMemoryDeviceGroupInfoKHR();
    ~_VkBindImageMemoryDeviceGroupInfoKHR();

};

/*
#include "index.h"
#include "VkBindImageMemoryDeviceGroupInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindImageMemoryDeviceGroupInfoKHR::constructor;

_VkBindImageMemoryDeviceGroupInfoKHR::_VkBindImageMemoryDeviceGroupInfoKHR() {
  
  
}

_VkBindImageMemoryDeviceGroupInfoKHR::~_VkBindImageMemoryDeviceGroupInfoKHR() {
  //printf("VkBindImageMemoryDeviceGroupInfoKHR deconstructed!!\n");
  
}

void _VkBindImageMemoryDeviceGroupInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindImageMemoryDeviceGroupInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindImageMemoryDeviceGroupInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkBindImageMemoryDeviceGroupInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindImageMemoryDeviceGroupInfoKHR::flush() {
  _VkBindImageMemoryDeviceGroupInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkBindImageMemoryDeviceGroupInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkBindImageMemoryDeviceGroupInfoKHR* self = new _VkBindImageMemoryDeviceGroupInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindImageMemoryDeviceGroupInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkBindImageMemoryDeviceGroupInfoKHR ## **/

/** ## BEGIN VkBindImageMemoryDeviceGroupInfo ## **/

class _VkBindImageMemoryDeviceGroupInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdeviceIndexCount);
    static NAN_SETTER(SetdeviceIndexCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDeviceIndices;
    static NAN_GETTER(GetpDeviceIndices);
    static NAN_SETTER(SetpDeviceIndices);
    
    static NAN_GETTER(GetsplitInstanceBindRegionCount);
    static NAN_SETTER(SetsplitInstanceBindRegionCount);
    
    std::vector<VkRect2D>* vpSplitInstanceBindRegions;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSplitInstanceBindRegions;
    static NAN_GETTER(GetpSplitInstanceBindRegions);
    static NAN_SETTER(SetpSplitInstanceBindRegions);
    

    // real instance
    VkBindImageMemoryDeviceGroupInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindImageMemoryDeviceGroupInfo();
    ~_VkBindImageMemoryDeviceGroupInfo();

};

/*
#include "index.h"
#include "VkBindImageMemoryDeviceGroupInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindImageMemoryDeviceGroupInfo::constructor;

_VkBindImageMemoryDeviceGroupInfo::_VkBindImageMemoryDeviceGroupInfo() {
  instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO;
  vpSplitInstanceBindRegions = new std::vector<VkRect2D>;
  
}

_VkBindImageMemoryDeviceGroupInfo::~_VkBindImageMemoryDeviceGroupInfo() {
  //printf("VkBindImageMemoryDeviceGroupInfo deconstructed!!\n");
  
  
  
  pDeviceIndices.Reset();
  
  
  vpSplitInstanceBindRegions->clear();
  delete vpSplitInstanceBindRegions;
  
  pSplitInstanceBindRegions.Reset();
  
}

void _VkBindImageMemoryDeviceGroupInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindImageMemoryDeviceGroupInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindImageMemoryDeviceGroupInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceIndexCount").ToLocalChecked(), GetdeviceIndexCount, SetdeviceIndexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDeviceIndices").ToLocalChecked(), GetpDeviceIndices, SetpDeviceIndices, ctor);
  SetPrototypeAccessor(proto, Nan::New("splitInstanceBindRegionCount").ToLocalChecked(), GetsplitInstanceBindRegionCount, SetsplitInstanceBindRegionCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSplitInstanceBindRegions").ToLocalChecked(), GetpSplitInstanceBindRegions, SetpSplitInstanceBindRegions, ctor);
  Nan::Set(target, Nan::New("VkBindImageMemoryDeviceGroupInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindImageMemoryDeviceGroupInfo::flush() {
  _VkBindImageMemoryDeviceGroupInfo *self = this;
  if (!(self->pSplitInstanceBindRegions.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSplitInstanceBindRegions);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.splitInstanceBindRegionCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions'");
      return false;
    }
    std::vector<VkRect2D>* data = self->vpSplitInstanceBindRegions;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkRect2D::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSplitInstanceBindRegions = data->data();
  }
  return true;
}

NAN_METHOD(_VkBindImageMemoryDeviceGroupInfo::New) {
  if (info.IsConstructCall()) {
    _VkBindImageMemoryDeviceGroupInfo* self = new _VkBindImageMemoryDeviceGroupInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("deviceIndexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pDeviceIndices").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("splitInstanceBindRegionCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pSplitInstanceBindRegions").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindImageMemoryDeviceGroupInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBindImageMemoryDeviceGroupInfo::GetsType) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBindImageMemoryDeviceGroupInfo::SetsType) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryDeviceGroupInfo.sType", "Number");
  
    return;
  }
}// deviceIndexCount
NAN_GETTER(_VkBindImageMemoryDeviceGroupInfo::GetdeviceIndexCount) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceIndexCount));
}NAN_SETTER(_VkBindImageMemoryDeviceGroupInfo::SetdeviceIndexCount) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceIndexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryDeviceGroupInfo.deviceIndexCount", "Number");
  
    return;
  }
}// pDeviceIndices
NAN_GETTER(_VkBindImageMemoryDeviceGroupInfo::GetpDeviceIndices) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  if (self->pDeviceIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDeviceIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindImageMemoryDeviceGroupInfo::SetpDeviceIndices) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pDeviceIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDeviceIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDeviceIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pDeviceIndices = nullptr;
  }
}// splitInstanceBindRegionCount
NAN_GETTER(_VkBindImageMemoryDeviceGroupInfo::GetsplitInstanceBindRegionCount) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.splitInstanceBindRegionCount));
}NAN_SETTER(_VkBindImageMemoryDeviceGroupInfo::SetsplitInstanceBindRegionCount) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.splitInstanceBindRegionCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryDeviceGroupInfo.splitInstanceBindRegionCount", "Number");
  
    return;
  }
}// pSplitInstanceBindRegions
NAN_GETTER(_VkBindImageMemoryDeviceGroupInfo::GetpSplitInstanceBindRegions) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  if (self->pSplitInstanceBindRegions.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSplitInstanceBindRegions);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindImageMemoryDeviceGroupInfo::SetpSplitInstanceBindRegions) {
  _VkBindImageMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryDeviceGroupInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSplitInstanceBindRegions.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSplitInstanceBindRegions.Reset();
      self->instance.pSplitInstanceBindRegions = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSplitInstanceBindRegions = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkBindImageMemoryDeviceGroupInfo ## **/

/** ## BEGIN VkBindImageMemoryInfoKHR ## **/

class _VkBindImageMemoryInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkBindImageMemoryInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindImageMemoryInfoKHR();
    ~_VkBindImageMemoryInfoKHR();

};

/*
#include "index.h"
#include "VkBindImageMemoryInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindImageMemoryInfoKHR::constructor;

_VkBindImageMemoryInfoKHR::_VkBindImageMemoryInfoKHR() {
  
  
}

_VkBindImageMemoryInfoKHR::~_VkBindImageMemoryInfoKHR() {
  //printf("VkBindImageMemoryInfoKHR deconstructed!!\n");
  
}

void _VkBindImageMemoryInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindImageMemoryInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindImageMemoryInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkBindImageMemoryInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindImageMemoryInfoKHR::flush() {
  _VkBindImageMemoryInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkBindImageMemoryInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkBindImageMemoryInfoKHR* self = new _VkBindImageMemoryInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindImageMemoryInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkBindImageMemoryInfoKHR ## **/

/** ## BEGIN VkBindImageMemoryInfo ## **/

class _VkBindImageMemoryInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memory;
      static NAN_GETTER(Getmemory);
    static NAN_SETTER(Setmemory);
    
    static NAN_GETTER(GetmemoryOffset);
    static NAN_SETTER(SetmemoryOffset);
    

    // real instance
    VkBindImageMemoryInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindImageMemoryInfo();
    ~_VkBindImageMemoryInfo();

};

/*
#include "index.h"
#include "VkBindImageMemoryInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindImageMemoryInfo::constructor;

_VkBindImageMemoryInfo::_VkBindImageMemoryInfo() {
  instance.sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO;
  
}

_VkBindImageMemoryInfo::~_VkBindImageMemoryInfo() {
  //printf("VkBindImageMemoryInfo deconstructed!!\n");
  
  
  
  
  
}

void _VkBindImageMemoryInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindImageMemoryInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindImageMemoryInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  SetPrototypeAccessor(proto, Nan::New("memory").ToLocalChecked(), Getmemory, Setmemory, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryOffset").ToLocalChecked(), GetmemoryOffset, SetmemoryOffset, ctor);
  Nan::Set(target, Nan::New("VkBindImageMemoryInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindImageMemoryInfo::flush() {
  _VkBindImageMemoryInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkBindImageMemoryInfo::New) {
  if (info.IsConstructCall()) {
    _VkBindImageMemoryInfo* self = new _VkBindImageMemoryInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("image").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("memory").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("memoryOffset").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindImageMemoryInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBindImageMemoryInfo::GetsType) {
  _VkBindImageMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBindImageMemoryInfo::SetsType) {
  _VkBindImageMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryInfo.sType", "Number");
  
    return;
  }
}// image
NAN_GETTER(_VkBindImageMemoryInfo::Getimage) {
  _VkBindImageMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryInfo>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindImageMemoryInfo::Setimage) {
  _VkBindImageMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryInfo.image", "[object VkImage]");
  
    return;
  }
}// memory
NAN_GETTER(_VkBindImageMemoryInfo::Getmemory) {
  _VkBindImageMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryInfo>(info.This());
  if (self->memory.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memory);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindImageMemoryInfo::Setmemory) {
  _VkBindImageMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj)) {
      self->memory.Reset<v8::Object>(value.As<v8::Object>());
      _VkDeviceMemory* inst = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      ;
      self->instance.memory = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryInfo.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->memory.Reset();
    self->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryInfo.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
NAN_GETTER(_VkBindImageMemoryInfo::GetmemoryOffset) {
  _VkBindImageMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryOffset));
}NAN_SETTER(_VkBindImageMemoryInfo::SetmemoryOffset) {
  _VkBindImageMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindImageMemoryInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.memoryOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindImageMemoryInfo.memoryOffset", "Number");
  
    return;
  }
}
/** ## END VkBindImageMemoryInfo ## **/

/** ## BEGIN VkBindBufferMemoryDeviceGroupInfoKHR ## **/

class _VkBindBufferMemoryDeviceGroupInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkBindBufferMemoryDeviceGroupInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindBufferMemoryDeviceGroupInfoKHR();
    ~_VkBindBufferMemoryDeviceGroupInfoKHR();

};

/*
#include "index.h"
#include "VkBindBufferMemoryDeviceGroupInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindBufferMemoryDeviceGroupInfoKHR::constructor;

_VkBindBufferMemoryDeviceGroupInfoKHR::_VkBindBufferMemoryDeviceGroupInfoKHR() {
  
  
}

_VkBindBufferMemoryDeviceGroupInfoKHR::~_VkBindBufferMemoryDeviceGroupInfoKHR() {
  //printf("VkBindBufferMemoryDeviceGroupInfoKHR deconstructed!!\n");
  
}

void _VkBindBufferMemoryDeviceGroupInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindBufferMemoryDeviceGroupInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindBufferMemoryDeviceGroupInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkBindBufferMemoryDeviceGroupInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindBufferMemoryDeviceGroupInfoKHR::flush() {
  _VkBindBufferMemoryDeviceGroupInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkBindBufferMemoryDeviceGroupInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkBindBufferMemoryDeviceGroupInfoKHR* self = new _VkBindBufferMemoryDeviceGroupInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindBufferMemoryDeviceGroupInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkBindBufferMemoryDeviceGroupInfoKHR ## **/

/** ## BEGIN VkBindBufferMemoryDeviceGroupInfo ## **/

class _VkBindBufferMemoryDeviceGroupInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdeviceIndexCount);
    static NAN_SETTER(SetdeviceIndexCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDeviceIndices;
    static NAN_GETTER(GetpDeviceIndices);
    static NAN_SETTER(SetpDeviceIndices);
    

    // real instance
    VkBindBufferMemoryDeviceGroupInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindBufferMemoryDeviceGroupInfo();
    ~_VkBindBufferMemoryDeviceGroupInfo();

};

/*
#include "index.h"
#include "VkBindBufferMemoryDeviceGroupInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindBufferMemoryDeviceGroupInfo::constructor;

_VkBindBufferMemoryDeviceGroupInfo::_VkBindBufferMemoryDeviceGroupInfo() {
  instance.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO;
  
}

_VkBindBufferMemoryDeviceGroupInfo::~_VkBindBufferMemoryDeviceGroupInfo() {
  //printf("VkBindBufferMemoryDeviceGroupInfo deconstructed!!\n");
  
  
  
  pDeviceIndices.Reset();
  
}

void _VkBindBufferMemoryDeviceGroupInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindBufferMemoryDeviceGroupInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindBufferMemoryDeviceGroupInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceIndexCount").ToLocalChecked(), GetdeviceIndexCount, SetdeviceIndexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDeviceIndices").ToLocalChecked(), GetpDeviceIndices, SetpDeviceIndices, ctor);
  Nan::Set(target, Nan::New("VkBindBufferMemoryDeviceGroupInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindBufferMemoryDeviceGroupInfo::flush() {
  _VkBindBufferMemoryDeviceGroupInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkBindBufferMemoryDeviceGroupInfo::New) {
  if (info.IsConstructCall()) {
    _VkBindBufferMemoryDeviceGroupInfo* self = new _VkBindBufferMemoryDeviceGroupInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("deviceIndexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pDeviceIndices").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindBufferMemoryDeviceGroupInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBindBufferMemoryDeviceGroupInfo::GetsType) {
  _VkBindBufferMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryDeviceGroupInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBindBufferMemoryDeviceGroupInfo::SetsType) {
  _VkBindBufferMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryDeviceGroupInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.sType", "Number");
  
    return;
  }
}// deviceIndexCount
NAN_GETTER(_VkBindBufferMemoryDeviceGroupInfo::GetdeviceIndexCount) {
  _VkBindBufferMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryDeviceGroupInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceIndexCount));
}NAN_SETTER(_VkBindBufferMemoryDeviceGroupInfo::SetdeviceIndexCount) {
  _VkBindBufferMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryDeviceGroupInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceIndexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.deviceIndexCount", "Number");
  
    return;
  }
}// pDeviceIndices
NAN_GETTER(_VkBindBufferMemoryDeviceGroupInfo::GetpDeviceIndices) {
  _VkBindBufferMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryDeviceGroupInfo>(info.This());
  if (self->pDeviceIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDeviceIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindBufferMemoryDeviceGroupInfo::SetpDeviceIndices) {
  _VkBindBufferMemoryDeviceGroupInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryDeviceGroupInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pDeviceIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.pDeviceIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDeviceIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryDeviceGroupInfo.pDeviceIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDeviceIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pDeviceIndices = nullptr;
  }
}
/** ## END VkBindBufferMemoryDeviceGroupInfo ## **/

/** ## BEGIN VkBindBufferMemoryInfoKHR ## **/

class _VkBindBufferMemoryInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkBindBufferMemoryInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindBufferMemoryInfoKHR();
    ~_VkBindBufferMemoryInfoKHR();

};

/*
#include "index.h"
#include "VkBindBufferMemoryInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindBufferMemoryInfoKHR::constructor;

_VkBindBufferMemoryInfoKHR::_VkBindBufferMemoryInfoKHR() {
  
  
}

_VkBindBufferMemoryInfoKHR::~_VkBindBufferMemoryInfoKHR() {
  //printf("VkBindBufferMemoryInfoKHR deconstructed!!\n");
  
}

void _VkBindBufferMemoryInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindBufferMemoryInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindBufferMemoryInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkBindBufferMemoryInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindBufferMemoryInfoKHR::flush() {
  _VkBindBufferMemoryInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkBindBufferMemoryInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkBindBufferMemoryInfoKHR* self = new _VkBindBufferMemoryInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindBufferMemoryInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkBindBufferMemoryInfoKHR ## **/

/** ## BEGIN VkBindBufferMemoryInfo ## **/

class _VkBindBufferMemoryInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memory;
      static NAN_GETTER(Getmemory);
    static NAN_SETTER(Setmemory);
    
    static NAN_GETTER(GetmemoryOffset);
    static NAN_SETTER(SetmemoryOffset);
    

    // real instance
    VkBindBufferMemoryInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindBufferMemoryInfo();
    ~_VkBindBufferMemoryInfo();

};

/*
#include "index.h"
#include "VkBindBufferMemoryInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindBufferMemoryInfo::constructor;

_VkBindBufferMemoryInfo::_VkBindBufferMemoryInfo() {
  instance.sType = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO;
  
}

_VkBindBufferMemoryInfo::~_VkBindBufferMemoryInfo() {
  //printf("VkBindBufferMemoryInfo deconstructed!!\n");
  
  
  
  
  
}

void _VkBindBufferMemoryInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindBufferMemoryInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindBufferMemoryInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("memory").ToLocalChecked(), Getmemory, Setmemory, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryOffset").ToLocalChecked(), GetmemoryOffset, SetmemoryOffset, ctor);
  Nan::Set(target, Nan::New("VkBindBufferMemoryInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindBufferMemoryInfo::flush() {
  _VkBindBufferMemoryInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkBindBufferMemoryInfo::New) {
  if (info.IsConstructCall()) {
    _VkBindBufferMemoryInfo* self = new _VkBindBufferMemoryInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("buffer").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("memory").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("memoryOffset").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindBufferMemoryInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBindBufferMemoryInfo::GetsType) {
  _VkBindBufferMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBindBufferMemoryInfo::SetsType) {
  _VkBindBufferMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryInfo.sType", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkBindBufferMemoryInfo::Getbuffer) {
  _VkBindBufferMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryInfo>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindBufferMemoryInfo::Setbuffer) {
  _VkBindBufferMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}// memory
NAN_GETTER(_VkBindBufferMemoryInfo::Getmemory) {
  _VkBindBufferMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryInfo>(info.This());
  if (self->memory.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memory);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindBufferMemoryInfo::Setmemory) {
  _VkBindBufferMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj)) {
      self->memory.Reset<v8::Object>(value.As<v8::Object>());
      _VkDeviceMemory* inst = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      ;
      self->instance.memory = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryInfo.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->memory.Reset();
    self->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryInfo.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
NAN_GETTER(_VkBindBufferMemoryInfo::GetmemoryOffset) {
  _VkBindBufferMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryOffset));
}NAN_SETTER(_VkBindBufferMemoryInfo::SetmemoryOffset) {
  _VkBindBufferMemoryInfo *self = Nan::ObjectWrap::Unwrap<_VkBindBufferMemoryInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.memoryOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindBufferMemoryInfo.memoryOffset", "Number");
  
    return;
  }
}
/** ## END VkBindBufferMemoryInfo ## **/

/** ## BEGIN VkMemoryAllocateFlagsInfoKHR ## **/

class _VkMemoryAllocateFlagsInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkMemoryAllocateFlagsInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryAllocateFlagsInfoKHR();
    ~_VkMemoryAllocateFlagsInfoKHR();

};

/*
#include "index.h"
#include "VkMemoryAllocateFlagsInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryAllocateFlagsInfoKHR::constructor;

_VkMemoryAllocateFlagsInfoKHR::_VkMemoryAllocateFlagsInfoKHR() {
  
  
}

_VkMemoryAllocateFlagsInfoKHR::~_VkMemoryAllocateFlagsInfoKHR() {
  //printf("VkMemoryAllocateFlagsInfoKHR deconstructed!!\n");
  
}

void _VkMemoryAllocateFlagsInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryAllocateFlagsInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryAllocateFlagsInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkMemoryAllocateFlagsInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryAllocateFlagsInfoKHR::flush() {
  _VkMemoryAllocateFlagsInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryAllocateFlagsInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkMemoryAllocateFlagsInfoKHR* self = new _VkMemoryAllocateFlagsInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryAllocateFlagsInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkMemoryAllocateFlagsInfoKHR ## **/

/** ## BEGIN VkMemoryAllocateFlagsInfo ## **/

class _VkMemoryAllocateFlagsInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetdeviceMask);
    static NAN_SETTER(SetdeviceMask);
    

    // real instance
    VkMemoryAllocateFlagsInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryAllocateFlagsInfo();
    ~_VkMemoryAllocateFlagsInfo();

};

/*
#include "index.h"
#include "VkMemoryAllocateFlagsInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryAllocateFlagsInfo::constructor;

_VkMemoryAllocateFlagsInfo::_VkMemoryAllocateFlagsInfo() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO;
  
}

_VkMemoryAllocateFlagsInfo::~_VkMemoryAllocateFlagsInfo() {
  //printf("VkMemoryAllocateFlagsInfo deconstructed!!\n");
  
  
  
  
}

void _VkMemoryAllocateFlagsInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryAllocateFlagsInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryAllocateFlagsInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceMask").ToLocalChecked(), GetdeviceMask, SetdeviceMask, ctor);
  Nan::Set(target, Nan::New("VkMemoryAllocateFlagsInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryAllocateFlagsInfo::flush() {
  _VkMemoryAllocateFlagsInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryAllocateFlagsInfo::New) {
  if (info.IsConstructCall()) {
    _VkMemoryAllocateFlagsInfo* self = new _VkMemoryAllocateFlagsInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("deviceMask").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryAllocateFlagsInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryAllocateFlagsInfo::GetsType) {
  _VkMemoryAllocateFlagsInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateFlagsInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkMemoryAllocateFlagsInfo::SetsType) {
  _VkMemoryAllocateFlagsInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateFlagsInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryAllocateFlagsInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkMemoryAllocateFlagsInfo::Getflags) {
  _VkMemoryAllocateFlagsInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateFlagsInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkMemoryAllocateFlagsInfo::Setflags) {
  _VkMemoryAllocateFlagsInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateFlagsInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkMemoryAllocateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryAllocateFlagsInfo.flags", "Number");
  
    return;
  }
}// deviceMask
NAN_GETTER(_VkMemoryAllocateFlagsInfo::GetdeviceMask) {
  _VkMemoryAllocateFlagsInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateFlagsInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceMask));
}NAN_SETTER(_VkMemoryAllocateFlagsInfo::SetdeviceMask) {
  _VkMemoryAllocateFlagsInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateFlagsInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceMask = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryAllocateFlagsInfo.deviceMask", "Number");
  
    return;
  }
}
/** ## END VkMemoryAllocateFlagsInfo ## **/

/** ## BEGIN VkPhysicalDeviceGroupPropertiesKHR ## **/

class _VkPhysicalDeviceGroupPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceGroupPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceGroupPropertiesKHR();
    ~_VkPhysicalDeviceGroupPropertiesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceGroupPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceGroupPropertiesKHR::constructor;

_VkPhysicalDeviceGroupPropertiesKHR::_VkPhysicalDeviceGroupPropertiesKHR() {
  
  
}

_VkPhysicalDeviceGroupPropertiesKHR::~_VkPhysicalDeviceGroupPropertiesKHR() {
  //printf("VkPhysicalDeviceGroupPropertiesKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceGroupPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceGroupPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceGroupPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceGroupPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceGroupPropertiesKHR::flush() {
  _VkPhysicalDeviceGroupPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceGroupPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceGroupPropertiesKHR* self = new _VkPhysicalDeviceGroupPropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceGroupPropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceGroupPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceGroupProperties ## **/

class _VkPhysicalDeviceGroupProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetphysicalDeviceCount);
    std::vector<VkPhysicalDevice>* vphysicalDevices;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> physicalDevices;
    static NAN_GETTER(GetphysicalDevices);
    static NAN_GETTER(GetsubsetAllocation);

    // real instance
    VkPhysicalDeviceGroupProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceGroupProperties();
    ~_VkPhysicalDeviceGroupProperties();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceGroupProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceGroupProperties::constructor;

_VkPhysicalDeviceGroupProperties::_VkPhysicalDeviceGroupProperties() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES;
  vphysicalDevices = new std::vector<VkPhysicalDevice>;
  
}

_VkPhysicalDeviceGroupProperties::~_VkPhysicalDeviceGroupProperties() {
  //printf("VkPhysicalDeviceGroupProperties deconstructed!!\n");
  
  
  
  vphysicalDevices->clear();
  delete vphysicalDevices;
  
  
  
}

void _VkPhysicalDeviceGroupProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceGroupProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceGroupProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("physicalDeviceCount").ToLocalChecked(), GetphysicalDeviceCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("physicalDevices").ToLocalChecked(), GetphysicalDevices, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("subsetAllocation").ToLocalChecked(), GetsubsetAllocation, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceGroupProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceGroupProperties::flush() {
  _VkPhysicalDeviceGroupProperties *self = this;
  if (!(self->physicalDevices.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->physicalDevices);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceGroupProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceGroupProperties* self = new _VkPhysicalDeviceGroupProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceGroupProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceGroupProperties::GetsType) {
  _VkPhysicalDeviceGroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceGroupProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// physicalDeviceCount
NAN_GETTER(_VkPhysicalDeviceGroupProperties::GetphysicalDeviceCount) {
  _VkPhysicalDeviceGroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceGroupProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.physicalDeviceCount));
}// physicalDevices
NAN_GETTER(_VkPhysicalDeviceGroupProperties::GetphysicalDevices) {
  _VkPhysicalDeviceGroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceGroupProperties>(info.This());
  if (self->physicalDevices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->physicalDevices));
  }
}// subsetAllocation
NAN_GETTER(_VkPhysicalDeviceGroupProperties::GetsubsetAllocation) {
  _VkPhysicalDeviceGroupProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceGroupProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subsetAllocation));
}
/** ## END VkPhysicalDeviceGroupProperties ## **/

/** ## BEGIN VkSwapchainCounterCreateInfoEXT ## **/

class _VkSwapchainCounterCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsurfaceCounters);
    static NAN_SETTER(SetsurfaceCounters);
    

    // real instance
    VkSwapchainCounterCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSwapchainCounterCreateInfoEXT();
    ~_VkSwapchainCounterCreateInfoEXT();

};

/*
#include "index.h"
#include "VkSwapchainCounterCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSwapchainCounterCreateInfoEXT::constructor;

_VkSwapchainCounterCreateInfoEXT::_VkSwapchainCounterCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT;
  
}

_VkSwapchainCounterCreateInfoEXT::~_VkSwapchainCounterCreateInfoEXT() {
  //printf("VkSwapchainCounterCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkSwapchainCounterCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSwapchainCounterCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSwapchainCounterCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("surfaceCounters").ToLocalChecked(), GetsurfaceCounters, SetsurfaceCounters, ctor);
  Nan::Set(target, Nan::New("VkSwapchainCounterCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSwapchainCounterCreateInfoEXT::flush() {
  _VkSwapchainCounterCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkSwapchainCounterCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkSwapchainCounterCreateInfoEXT* self = new _VkSwapchainCounterCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("surfaceCounters").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSwapchainCounterCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSwapchainCounterCreateInfoEXT::GetsType) {
  _VkSwapchainCounterCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCounterCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSwapchainCounterCreateInfoEXT::SetsType) {
  _VkSwapchainCounterCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCounterCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCounterCreateInfoEXT.sType", "Number");
  
    return;
  }
}// surfaceCounters
NAN_GETTER(_VkSwapchainCounterCreateInfoEXT::GetsurfaceCounters) {
  _VkSwapchainCounterCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCounterCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.surfaceCounters));
}NAN_SETTER(_VkSwapchainCounterCreateInfoEXT::SetsurfaceCounters) {
  _VkSwapchainCounterCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCounterCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.surfaceCounters = static_cast<VkSurfaceCounterFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCounterCreateInfoEXT.surfaceCounters", "Number");
  
    return;
  }
}
/** ## END VkSwapchainCounterCreateInfoEXT ## **/

/** ## BEGIN VkDisplayEventInfoEXT ## **/

class _VkDisplayEventInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdisplayEvent);
    static NAN_SETTER(SetdisplayEvent);
    

    // real instance
    VkDisplayEventInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayEventInfoEXT();
    ~_VkDisplayEventInfoEXT();

};

/*
#include "index.h"
#include "VkDisplayEventInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayEventInfoEXT::constructor;

_VkDisplayEventInfoEXT::_VkDisplayEventInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT;
  
}

_VkDisplayEventInfoEXT::~_VkDisplayEventInfoEXT() {
  //printf("VkDisplayEventInfoEXT deconstructed!!\n");
  
  
  
}

void _VkDisplayEventInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayEventInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayEventInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayEvent").ToLocalChecked(), GetdisplayEvent, SetdisplayEvent, ctor);
  Nan::Set(target, Nan::New("VkDisplayEventInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayEventInfoEXT::flush() {
  _VkDisplayEventInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDisplayEventInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDisplayEventInfoEXT* self = new _VkDisplayEventInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("displayEvent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayEventInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayEventInfoEXT::GetsType) {
  _VkDisplayEventInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDisplayEventInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDisplayEventInfoEXT::SetsType) {
  _VkDisplayEventInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDisplayEventInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayEventInfoEXT.sType", "Number");
  
    return;
  }
}// displayEvent
NAN_GETTER(_VkDisplayEventInfoEXT::GetdisplayEvent) {
  _VkDisplayEventInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDisplayEventInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.displayEvent));
}NAN_SETTER(_VkDisplayEventInfoEXT::SetdisplayEvent) {
  _VkDisplayEventInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDisplayEventInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.displayEvent = static_cast<VkDisplayEventTypeEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayEventInfoEXT.displayEvent", "Number");
  
    return;
  }
}
/** ## END VkDisplayEventInfoEXT ## **/

/** ## BEGIN VkDeviceEventInfoEXT ## **/

class _VkDeviceEventInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdeviceEvent);
    static NAN_SETTER(SetdeviceEvent);
    

    // real instance
    VkDeviceEventInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceEventInfoEXT();
    ~_VkDeviceEventInfoEXT();

};

/*
#include "index.h"
#include "VkDeviceEventInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceEventInfoEXT::constructor;

_VkDeviceEventInfoEXT::_VkDeviceEventInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT;
  
}

_VkDeviceEventInfoEXT::~_VkDeviceEventInfoEXT() {
  //printf("VkDeviceEventInfoEXT deconstructed!!\n");
  
  
  
}

void _VkDeviceEventInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceEventInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceEventInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceEvent").ToLocalChecked(), GetdeviceEvent, SetdeviceEvent, ctor);
  Nan::Set(target, Nan::New("VkDeviceEventInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceEventInfoEXT::flush() {
  _VkDeviceEventInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceEventInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDeviceEventInfoEXT* self = new _VkDeviceEventInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("deviceEvent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceEventInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceEventInfoEXT::GetsType) {
  _VkDeviceEventInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDeviceEventInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceEventInfoEXT::SetsType) {
  _VkDeviceEventInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDeviceEventInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceEventInfoEXT.sType", "Number");
  
    return;
  }
}// deviceEvent
NAN_GETTER(_VkDeviceEventInfoEXT::GetdeviceEvent) {
  _VkDeviceEventInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDeviceEventInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceEvent));
}NAN_SETTER(_VkDeviceEventInfoEXT::SetdeviceEvent) {
  _VkDeviceEventInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDeviceEventInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.deviceEvent = static_cast<VkDeviceEventTypeEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceEventInfoEXT.deviceEvent", "Number");
  
    return;
  }
}
/** ## END VkDeviceEventInfoEXT ## **/

/** ## BEGIN VkDisplayPowerInfoEXT ## **/

class _VkDisplayPowerInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetpowerState);
    static NAN_SETTER(SetpowerState);
    

    // real instance
    VkDisplayPowerInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayPowerInfoEXT();
    ~_VkDisplayPowerInfoEXT();

};

/*
#include "index.h"
#include "VkDisplayPowerInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayPowerInfoEXT::constructor;

_VkDisplayPowerInfoEXT::_VkDisplayPowerInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT;
  
}

_VkDisplayPowerInfoEXT::~_VkDisplayPowerInfoEXT() {
  //printf("VkDisplayPowerInfoEXT deconstructed!!\n");
  
  
  
}

void _VkDisplayPowerInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayPowerInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayPowerInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("powerState").ToLocalChecked(), GetpowerState, SetpowerState, ctor);
  Nan::Set(target, Nan::New("VkDisplayPowerInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayPowerInfoEXT::flush() {
  _VkDisplayPowerInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDisplayPowerInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDisplayPowerInfoEXT* self = new _VkDisplayPowerInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("powerState").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayPowerInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayPowerInfoEXT::GetsType) {
  _VkDisplayPowerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDisplayPowerInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDisplayPowerInfoEXT::SetsType) {
  _VkDisplayPowerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDisplayPowerInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPowerInfoEXT.sType", "Number");
  
    return;
  }
}// powerState
NAN_GETTER(_VkDisplayPowerInfoEXT::GetpowerState) {
  _VkDisplayPowerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDisplayPowerInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.powerState));
}NAN_SETTER(_VkDisplayPowerInfoEXT::SetpowerState) {
  _VkDisplayPowerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDisplayPowerInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.powerState = static_cast<VkDisplayPowerStateEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPowerInfoEXT.powerState", "Number");
  
    return;
  }
}
/** ## END VkDisplayPowerInfoEXT ## **/

/** ## BEGIN VkSurfaceCapabilities2EXT ## **/

class _VkSurfaceCapabilities2EXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetminImageCount);
    static NAN_GETTER(GetmaxImageCount);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> currentExtent;
      static NAN_GETTER(GetcurrentExtent);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> minImageExtent;
      static NAN_GETTER(GetminImageExtent);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxImageExtent;
      static NAN_GETTER(GetmaxImageExtent);
    static NAN_GETTER(GetmaxImageArrayLayers);
    static NAN_GETTER(GetsupportedTransforms);
    static NAN_GETTER(GetcurrentTransform);
    static NAN_GETTER(GetsupportedCompositeAlpha);
    static NAN_GETTER(GetsupportedUsageFlags);
    static NAN_GETTER(GetsupportedSurfaceCounters);

    // real instance
    VkSurfaceCapabilities2EXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSurfaceCapabilities2EXT();
    ~_VkSurfaceCapabilities2EXT();

};

/*
#include "index.h"
#include "VkSurfaceCapabilities2EXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSurfaceCapabilities2EXT::constructor;

_VkSurfaceCapabilities2EXT::_VkSurfaceCapabilities2EXT() {
  instance.sType = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT;
  
}

_VkSurfaceCapabilities2EXT::~_VkSurfaceCapabilities2EXT() {
  //printf("VkSurfaceCapabilities2EXT deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkSurfaceCapabilities2EXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSurfaceCapabilities2EXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSurfaceCapabilities2EXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minImageCount").ToLocalChecked(), GetminImageCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageCount").ToLocalChecked(), GetmaxImageCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("currentExtent").ToLocalChecked(), GetcurrentExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minImageExtent").ToLocalChecked(), GetminImageExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageExtent").ToLocalChecked(), GetmaxImageExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageArrayLayers").ToLocalChecked(), GetmaxImageArrayLayers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedTransforms").ToLocalChecked(), GetsupportedTransforms, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("currentTransform").ToLocalChecked(), GetcurrentTransform, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedCompositeAlpha").ToLocalChecked(), GetsupportedCompositeAlpha, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedUsageFlags").ToLocalChecked(), GetsupportedUsageFlags, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("supportedSurfaceCounters").ToLocalChecked(), GetsupportedSurfaceCounters, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSurfaceCapabilities2EXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSurfaceCapabilities2EXT::flush() {
  _VkSurfaceCapabilities2EXT *self = this;
  if (!(self->currentExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->currentExtent);
    
  }if (!(self->minImageExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->minImageExtent);
    
  }if (!(self->maxImageExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxImageExtent);
    
  }
  return true;
}

NAN_METHOD(_VkSurfaceCapabilities2EXT::New) {
  if (info.IsConstructCall()) {
    _VkSurfaceCapabilities2EXT* self = new _VkSurfaceCapabilities2EXT();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSurfaceCapabilities2EXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetsType) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// minImageCount
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetminImageCount) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minImageCount));
}// maxImageCount
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetmaxImageCount) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageCount));
}// currentExtent
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetcurrentExtent) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  if (self->currentExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->currentExtent);
    info.GetReturnValue().Set(obj);
  }
}// minImageExtent
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetminImageExtent) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  if (self->minImageExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->minImageExtent);
    info.GetReturnValue().Set(obj);
  }
}// maxImageExtent
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetmaxImageExtent) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  if (self->maxImageExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxImageExtent);
    info.GetReturnValue().Set(obj);
  }
}// maxImageArrayLayers
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetmaxImageArrayLayers) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageArrayLayers));
}// supportedTransforms
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetsupportedTransforms) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedTransforms));
}// currentTransform
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetcurrentTransform) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.currentTransform));
}// supportedCompositeAlpha
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetsupportedCompositeAlpha) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedCompositeAlpha));
}// supportedUsageFlags
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetsupportedUsageFlags) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedUsageFlags));
}// supportedSurfaceCounters
NAN_GETTER(_VkSurfaceCapabilities2EXT::GetsupportedSurfaceCounters) {
  _VkSurfaceCapabilities2EXT *self = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilities2EXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.supportedSurfaceCounters));
}
/** ## END VkSurfaceCapabilities2EXT ## **/

/** ## BEGIN VkRenderPassMultiviewCreateInfoKHR ## **/

class _VkRenderPassMultiviewCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkRenderPassMultiviewCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassMultiviewCreateInfoKHR();
    ~_VkRenderPassMultiviewCreateInfoKHR();

};

/*
#include "index.h"
#include "VkRenderPassMultiviewCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassMultiviewCreateInfoKHR::constructor;

_VkRenderPassMultiviewCreateInfoKHR::_VkRenderPassMultiviewCreateInfoKHR() {
  
  
}

_VkRenderPassMultiviewCreateInfoKHR::~_VkRenderPassMultiviewCreateInfoKHR() {
  //printf("VkRenderPassMultiviewCreateInfoKHR deconstructed!!\n");
  
}

void _VkRenderPassMultiviewCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassMultiviewCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassMultiviewCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkRenderPassMultiviewCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassMultiviewCreateInfoKHR::flush() {
  _VkRenderPassMultiviewCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkRenderPassMultiviewCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassMultiviewCreateInfoKHR* self = new _VkRenderPassMultiviewCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassMultiviewCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkRenderPassMultiviewCreateInfoKHR ## **/

/** ## BEGIN VkRenderPassMultiviewCreateInfo ## **/

class _VkRenderPassMultiviewCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsubpassCount);
    static NAN_SETTER(SetsubpassCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pViewMasks;
    static NAN_GETTER(GetpViewMasks);
    static NAN_SETTER(SetpViewMasks);
    
    static NAN_GETTER(GetdependencyCount);
    static NAN_SETTER(SetdependencyCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pViewOffsets;
    static NAN_GETTER(GetpViewOffsets);
    static NAN_SETTER(SetpViewOffsets);
    
    static NAN_GETTER(GetcorrelationMaskCount);
    static NAN_SETTER(SetcorrelationMaskCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pCorrelationMasks;
    static NAN_GETTER(GetpCorrelationMasks);
    static NAN_SETTER(SetpCorrelationMasks);
    

    // real instance
    VkRenderPassMultiviewCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassMultiviewCreateInfo();
    ~_VkRenderPassMultiviewCreateInfo();

};

/*
#include "index.h"
#include "VkRenderPassMultiviewCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassMultiviewCreateInfo::constructor;

_VkRenderPassMultiviewCreateInfo::_VkRenderPassMultiviewCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO;
  
}

_VkRenderPassMultiviewCreateInfo::~_VkRenderPassMultiviewCreateInfo() {
  //printf("VkRenderPassMultiviewCreateInfo deconstructed!!\n");
  
  
  
  pViewMasks.Reset();
  
  
  pViewOffsets.Reset();
  
  
  pCorrelationMasks.Reset();
  
}

void _VkRenderPassMultiviewCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassMultiviewCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassMultiviewCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("subpassCount").ToLocalChecked(), GetsubpassCount, SetsubpassCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pViewMasks").ToLocalChecked(), GetpViewMasks, SetpViewMasks, ctor);
  SetPrototypeAccessor(proto, Nan::New("dependencyCount").ToLocalChecked(), GetdependencyCount, SetdependencyCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pViewOffsets").ToLocalChecked(), GetpViewOffsets, SetpViewOffsets, ctor);
  SetPrototypeAccessor(proto, Nan::New("correlationMaskCount").ToLocalChecked(), GetcorrelationMaskCount, SetcorrelationMaskCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pCorrelationMasks").ToLocalChecked(), GetpCorrelationMasks, SetpCorrelationMasks, ctor);
  Nan::Set(target, Nan::New("VkRenderPassMultiviewCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassMultiviewCreateInfo::flush() {
  _VkRenderPassMultiviewCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkRenderPassMultiviewCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassMultiviewCreateInfo* self = new _VkRenderPassMultiviewCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("subpassCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pViewMasks").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("dependencyCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pViewOffsets").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("correlationMaskCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pCorrelationMasks").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassMultiviewCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRenderPassMultiviewCreateInfo::GetsType) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRenderPassMultiviewCreateInfo::SetsType) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.sType", "Number");
  
    return;
  }
}// subpassCount
NAN_GETTER(_VkRenderPassMultiviewCreateInfo::GetsubpassCount) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subpassCount));
}NAN_SETTER(_VkRenderPassMultiviewCreateInfo::SetsubpassCount) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.subpassCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.subpassCount", "Number");
  
    return;
  }
}// pViewMasks
NAN_GETTER(_VkRenderPassMultiviewCreateInfo::GetpViewMasks) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  if (self->pViewMasks.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pViewMasks);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassMultiviewCreateInfo::SetpViewMasks) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pViewMasks.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.pViewMasks", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pViewMasks.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.pViewMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pViewMasks = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pViewMasks = nullptr;
  }
}// dependencyCount
NAN_GETTER(_VkRenderPassMultiviewCreateInfo::GetdependencyCount) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dependencyCount));
}NAN_SETTER(_VkRenderPassMultiviewCreateInfo::SetdependencyCount) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.dependencyCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.dependencyCount", "Number");
  
    return;
  }
}// pViewOffsets
NAN_GETTER(_VkRenderPassMultiviewCreateInfo::GetpViewOffsets) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  if (self->pViewOffsets.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pViewOffsets);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassMultiviewCreateInfo::SetpViewOffsets) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pViewOffsets.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.pViewOffsets", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pViewOffsets.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.pViewOffsets", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pViewOffsets = getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pViewOffsets = nullptr;
  }
}// correlationMaskCount
NAN_GETTER(_VkRenderPassMultiviewCreateInfo::GetcorrelationMaskCount) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.correlationMaskCount));
}NAN_SETTER(_VkRenderPassMultiviewCreateInfo::SetcorrelationMaskCount) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.correlationMaskCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.correlationMaskCount", "Number");
  
    return;
  }
}// pCorrelationMasks
NAN_GETTER(_VkRenderPassMultiviewCreateInfo::GetpCorrelationMasks) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  if (self->pCorrelationMasks.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pCorrelationMasks);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassMultiviewCreateInfo::SetpCorrelationMasks) {
  _VkRenderPassMultiviewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassMultiviewCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pCorrelationMasks.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.pCorrelationMasks", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pCorrelationMasks.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassMultiviewCreateInfo.pCorrelationMasks", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pCorrelationMasks = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pCorrelationMasks = nullptr;
  }
}
/** ## END VkRenderPassMultiviewCreateInfo ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewPropertiesKHR ## **/

class _VkPhysicalDeviceMultiviewPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceMultiviewPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMultiviewPropertiesKHR();
    ~_VkPhysicalDeviceMultiviewPropertiesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMultiviewPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMultiviewPropertiesKHR::constructor;

_VkPhysicalDeviceMultiviewPropertiesKHR::_VkPhysicalDeviceMultiviewPropertiesKHR() {
  
  
}

_VkPhysicalDeviceMultiviewPropertiesKHR::~_VkPhysicalDeviceMultiviewPropertiesKHR() {
  //printf("VkPhysicalDeviceMultiviewPropertiesKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceMultiviewPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMultiviewPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMultiviewPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceMultiviewPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMultiviewPropertiesKHR::flush() {
  _VkPhysicalDeviceMultiviewPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMultiviewPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMultiviewPropertiesKHR* self = new _VkPhysicalDeviceMultiviewPropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMultiviewPropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceMultiviewPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewProperties ## **/

class _VkPhysicalDeviceMultiviewProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxMultiviewViewCount);
    static NAN_GETTER(GetmaxMultiviewInstanceIndex);

    // real instance
    VkPhysicalDeviceMultiviewProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMultiviewProperties();
    ~_VkPhysicalDeviceMultiviewProperties();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMultiviewProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMultiviewProperties::constructor;

_VkPhysicalDeviceMultiviewProperties::_VkPhysicalDeviceMultiviewProperties() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
  
}

_VkPhysicalDeviceMultiviewProperties::~_VkPhysicalDeviceMultiviewProperties() {
  //printf("VkPhysicalDeviceMultiviewProperties deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceMultiviewProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMultiviewProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMultiviewProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMultiviewViewCount").ToLocalChecked(), GetmaxMultiviewViewCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMultiviewInstanceIndex").ToLocalChecked(), GetmaxMultiviewInstanceIndex, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMultiviewProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMultiviewProperties::flush() {
  _VkPhysicalDeviceMultiviewProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMultiviewProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMultiviewProperties* self = new _VkPhysicalDeviceMultiviewProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMultiviewProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMultiviewProperties::GetsType) {
  _VkPhysicalDeviceMultiviewProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxMultiviewViewCount
NAN_GETTER(_VkPhysicalDeviceMultiviewProperties::GetmaxMultiviewViewCount) {
  _VkPhysicalDeviceMultiviewProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMultiviewViewCount));
}// maxMultiviewInstanceIndex
NAN_GETTER(_VkPhysicalDeviceMultiviewProperties::GetmaxMultiviewInstanceIndex) {
  _VkPhysicalDeviceMultiviewProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMultiviewInstanceIndex));
}
/** ## END VkPhysicalDeviceMultiviewProperties ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewFeaturesKHR ## **/

class _VkPhysicalDeviceMultiviewFeaturesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceMultiviewFeaturesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMultiviewFeaturesKHR();
    ~_VkPhysicalDeviceMultiviewFeaturesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMultiviewFeaturesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMultiviewFeaturesKHR::constructor;

_VkPhysicalDeviceMultiviewFeaturesKHR::_VkPhysicalDeviceMultiviewFeaturesKHR() {
  
  
}

_VkPhysicalDeviceMultiviewFeaturesKHR::~_VkPhysicalDeviceMultiviewFeaturesKHR() {
  //printf("VkPhysicalDeviceMultiviewFeaturesKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceMultiviewFeaturesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMultiviewFeaturesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMultiviewFeaturesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceMultiviewFeaturesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMultiviewFeaturesKHR::flush() {
  _VkPhysicalDeviceMultiviewFeaturesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMultiviewFeaturesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMultiviewFeaturesKHR* self = new _VkPhysicalDeviceMultiviewFeaturesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMultiviewFeaturesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceMultiviewFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceMultiviewFeatures ## **/

class _VkPhysicalDeviceMultiviewFeatures: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getmultiview);
    static NAN_SETTER(Setmultiview);
    
    static NAN_GETTER(GetmultiviewGeometryShader);
    static NAN_SETTER(SetmultiviewGeometryShader);
    
    static NAN_GETTER(GetmultiviewTessellationShader);
    static NAN_SETTER(SetmultiviewTessellationShader);
    

    // real instance
    VkPhysicalDeviceMultiviewFeatures instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMultiviewFeatures();
    ~_VkPhysicalDeviceMultiviewFeatures();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMultiviewFeatures.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMultiviewFeatures::constructor;

_VkPhysicalDeviceMultiviewFeatures::_VkPhysicalDeviceMultiviewFeatures() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
  
}

_VkPhysicalDeviceMultiviewFeatures::~_VkPhysicalDeviceMultiviewFeatures() {
  //printf("VkPhysicalDeviceMultiviewFeatures deconstructed!!\n");
  
  
  
  
  
}

void _VkPhysicalDeviceMultiviewFeatures::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMultiviewFeatures::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMultiviewFeatures").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("multiview").ToLocalChecked(), Getmultiview, Setmultiview, ctor);
  SetPrototypeAccessor(proto, Nan::New("multiviewGeometryShader").ToLocalChecked(), GetmultiviewGeometryShader, SetmultiviewGeometryShader, ctor);
  SetPrototypeAccessor(proto, Nan::New("multiviewTessellationShader").ToLocalChecked(), GetmultiviewTessellationShader, SetmultiviewTessellationShader, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMultiviewFeatures").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMultiviewFeatures::flush() {
  _VkPhysicalDeviceMultiviewFeatures *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMultiviewFeatures::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMultiviewFeatures* self = new _VkPhysicalDeviceMultiviewFeatures();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("multiview").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("multiviewGeometryShader").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("multiviewTessellationShader").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMultiviewFeatures constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMultiviewFeatures::GetsType) {
  _VkPhysicalDeviceMultiviewFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceMultiviewFeatures::SetsType) {
  _VkPhysicalDeviceMultiviewFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewFeatures>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMultiviewFeatures.sType", "Number");
  
    return;
  }
}// multiview
NAN_GETTER(_VkPhysicalDeviceMultiviewFeatures::Getmultiview) {
  _VkPhysicalDeviceMultiviewFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.multiview));
}NAN_SETTER(_VkPhysicalDeviceMultiviewFeatures::Setmultiview) {
  _VkPhysicalDeviceMultiviewFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.multiview = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMultiviewFeatures.multiview", "Number");
  
    return;
  }
}// multiviewGeometryShader
NAN_GETTER(_VkPhysicalDeviceMultiviewFeatures::GetmultiviewGeometryShader) {
  _VkPhysicalDeviceMultiviewFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.multiviewGeometryShader));
}NAN_SETTER(_VkPhysicalDeviceMultiviewFeatures::SetmultiviewGeometryShader) {
  _VkPhysicalDeviceMultiviewFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.multiviewGeometryShader = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMultiviewFeatures.multiviewGeometryShader", "Number");
  
    return;
  }
}// multiviewTessellationShader
NAN_GETTER(_VkPhysicalDeviceMultiviewFeatures::GetmultiviewTessellationShader) {
  _VkPhysicalDeviceMultiviewFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.multiviewTessellationShader));
}NAN_SETTER(_VkPhysicalDeviceMultiviewFeatures::SetmultiviewTessellationShader) {
  _VkPhysicalDeviceMultiviewFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMultiviewFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.multiviewTessellationShader = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceMultiviewFeatures.multiviewTessellationShader", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceMultiviewFeatures ## **/

/** ## BEGIN VkFenceGetFdInfoKHR ## **/

class _VkFenceGetFdInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> fence;
      static NAN_GETTER(Getfence);
    static NAN_SETTER(Setfence);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkFenceGetFdInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkFenceGetFdInfoKHR();
    ~_VkFenceGetFdInfoKHR();

};

/*
#include "index.h"
#include "VkFenceGetFdInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkFenceGetFdInfoKHR::constructor;

_VkFenceGetFdInfoKHR::_VkFenceGetFdInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR;
  
}

_VkFenceGetFdInfoKHR::~_VkFenceGetFdInfoKHR() {
  //printf("VkFenceGetFdInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkFenceGetFdInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFenceGetFdInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFenceGetFdInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fence").ToLocalChecked(), Getfence, Setfence, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkFenceGetFdInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkFenceGetFdInfoKHR::flush() {
  _VkFenceGetFdInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkFenceGetFdInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkFenceGetFdInfoKHR* self = new _VkFenceGetFdInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("fence").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkFenceGetFdInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkFenceGetFdInfoKHR::GetsType) {
  _VkFenceGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkFenceGetFdInfoKHR::SetsType) {
  _VkFenceGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFenceGetFdInfoKHR.sType", "Number");
  
    return;
  }
}// fence
NAN_GETTER(_VkFenceGetFdInfoKHR::Getfence) {
  _VkFenceGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetFdInfoKHR>(info.This());
  if (self->fence.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->fence);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkFenceGetFdInfoKHR::Setfence) {
  _VkFenceGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetFdInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkFence::constructor)->HasInstance(obj)) {
      self->fence.Reset<v8::Object>(value.As<v8::Object>());
      _VkFence* inst = Nan::ObjectWrap::Unwrap<_VkFence>(obj);
      ;
      self->instance.fence = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkFenceGetFdInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->fence.Reset();
    self->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFenceGetFdInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// handleType
NAN_GETTER(_VkFenceGetFdInfoKHR::GethandleType) {
  _VkFenceGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkFenceGetFdInfoKHR::SethandleType) {
  _VkFenceGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFenceGetFdInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkFenceGetFdInfoKHR ## **/

/** ## BEGIN VkImportFenceFdInfoKHR ## **/

class _VkImportFenceFdInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> fence;
      static NAN_GETTER(Getfence);
    static NAN_SETTER(Setfence);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    
    static NAN_GETTER(Getfd);
    static NAN_SETTER(Setfd);
    

    // real instance
    VkImportFenceFdInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImportFenceFdInfoKHR();
    ~_VkImportFenceFdInfoKHR();

};

/*
#include "index.h"
#include "VkImportFenceFdInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImportFenceFdInfoKHR::constructor;

_VkImportFenceFdInfoKHR::_VkImportFenceFdInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR;
  
}

_VkImportFenceFdInfoKHR::~_VkImportFenceFdInfoKHR() {
  //printf("VkImportFenceFdInfoKHR deconstructed!!\n");
  
  
  
  
  
  
}

void _VkImportFenceFdInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImportFenceFdInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImportFenceFdInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fence").ToLocalChecked(), Getfence, Setfence, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fd").ToLocalChecked(), Getfd, Setfd, ctor);
  Nan::Set(target, Nan::New("VkImportFenceFdInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImportFenceFdInfoKHR::flush() {
  _VkImportFenceFdInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImportFenceFdInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImportFenceFdInfoKHR* self = new _VkImportFenceFdInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("fence").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("handleType").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("fd").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImportFenceFdInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImportFenceFdInfoKHR::GetsType) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImportFenceFdInfoKHR::SetsType) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceFdInfoKHR.sType", "Number");
  
    return;
  }
}// fence
NAN_GETTER(_VkImportFenceFdInfoKHR::Getfence) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  if (self->fence.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->fence);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImportFenceFdInfoKHR::Setfence) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkFence::constructor)->HasInstance(obj)) {
      self->fence.Reset<v8::Object>(value.As<v8::Object>());
      _VkFence* inst = Nan::ObjectWrap::Unwrap<_VkFence>(obj);
      ;
      self->instance.fence = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImportFenceFdInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->fence.Reset();
    self->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceFdInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// flags
NAN_GETTER(_VkImportFenceFdInfoKHR::Getflags) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkImportFenceFdInfoKHR::Setflags) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkFenceImportFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceFdInfoKHR.flags", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkImportFenceFdInfoKHR::GethandleType) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkImportFenceFdInfoKHR::SethandleType) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceFdInfoKHR.handleType", "Number");
  
    return;
  }
}// fd
NAN_GETTER(_VkImportFenceFdInfoKHR::Getfd) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fd));
}NAN_SETTER(_VkImportFenceFdInfoKHR::Setfd) {
  _VkImportFenceFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.fd = static_cast<int>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceFdInfoKHR.fd", "Number");
  
    return;
  }
}
/** ## END VkImportFenceFdInfoKHR ## **/

/** ## BEGIN VkFenceGetWin32HandleInfoKHR ## **/

class _VkFenceGetWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> fence;
      static NAN_GETTER(Getfence);
    static NAN_SETTER(Setfence);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkFenceGetWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkFenceGetWin32HandleInfoKHR();
    ~_VkFenceGetWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkFenceGetWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkFenceGetWin32HandleInfoKHR::constructor;

_VkFenceGetWin32HandleInfoKHR::_VkFenceGetWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR;
  
}

_VkFenceGetWin32HandleInfoKHR::~_VkFenceGetWin32HandleInfoKHR() {
  //printf("VkFenceGetWin32HandleInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkFenceGetWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFenceGetWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFenceGetWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fence").ToLocalChecked(), Getfence, Setfence, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkFenceGetWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkFenceGetWin32HandleInfoKHR::flush() {
  _VkFenceGetWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkFenceGetWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkFenceGetWin32HandleInfoKHR* self = new _VkFenceGetWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("fence").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkFenceGetWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkFenceGetWin32HandleInfoKHR::GetsType) {
  _VkFenceGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkFenceGetWin32HandleInfoKHR::SetsType) {
  _VkFenceGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFenceGetWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// fence
NAN_GETTER(_VkFenceGetWin32HandleInfoKHR::Getfence) {
  _VkFenceGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetWin32HandleInfoKHR>(info.This());
  if (self->fence.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->fence);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkFenceGetWin32HandleInfoKHR::Setfence) {
  _VkFenceGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetWin32HandleInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkFence::constructor)->HasInstance(obj)) {
      self->fence.Reset<v8::Object>(value.As<v8::Object>());
      _VkFence* inst = Nan::ObjectWrap::Unwrap<_VkFence>(obj);
      ;
      self->instance.fence = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkFenceGetWin32HandleInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->fence.Reset();
    self->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFenceGetWin32HandleInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// handleType
NAN_GETTER(_VkFenceGetWin32HandleInfoKHR::GethandleType) {
  _VkFenceGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkFenceGetWin32HandleInfoKHR::SethandleType) {
  _VkFenceGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkFenceGetWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFenceGetWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkFenceGetWin32HandleInfoKHR ## **/

/** ## BEGIN VkExportFenceWin32HandleInfoKHR ## **/

class _VkExportFenceWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    

    // real instance
    VkExportFenceWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportFenceWin32HandleInfoKHR();
    ~_VkExportFenceWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkExportFenceWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportFenceWin32HandleInfoKHR::constructor;

_VkExportFenceWin32HandleInfoKHR::_VkExportFenceWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
  
}

_VkExportFenceWin32HandleInfoKHR::~_VkExportFenceWin32HandleInfoKHR() {
  //printf("VkExportFenceWin32HandleInfoKHR deconstructed!!\n");
  
  
}

void _VkExportFenceWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportFenceWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportFenceWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  Nan::Set(target, Nan::New("VkExportFenceWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportFenceWin32HandleInfoKHR::flush() {
  _VkExportFenceWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExportFenceWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkExportFenceWin32HandleInfoKHR* self = new _VkExportFenceWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportFenceWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExportFenceWin32HandleInfoKHR::GetsType) {
  _VkExportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkExportFenceWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExportFenceWin32HandleInfoKHR::SetsType) {
  _VkExportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkExportFenceWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportFenceWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}
/** ## END VkExportFenceWin32HandleInfoKHR ## **/

/** ## BEGIN VkImportFenceWin32HandleInfoKHR ## **/

class _VkImportFenceWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> fence;
      static NAN_GETTER(Getfence);
    static NAN_SETTER(Setfence);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkImportFenceWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImportFenceWin32HandleInfoKHR();
    ~_VkImportFenceWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkImportFenceWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImportFenceWin32HandleInfoKHR::constructor;

_VkImportFenceWin32HandleInfoKHR::_VkImportFenceWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR;
  
}

_VkImportFenceWin32HandleInfoKHR::~_VkImportFenceWin32HandleInfoKHR() {
  //printf("VkImportFenceWin32HandleInfoKHR deconstructed!!\n");
  
  
  
  
  
}

void _VkImportFenceWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImportFenceWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImportFenceWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fence").ToLocalChecked(), Getfence, Setfence, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkImportFenceWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImportFenceWin32HandleInfoKHR::flush() {
  _VkImportFenceWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImportFenceWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImportFenceWin32HandleInfoKHR* self = new _VkImportFenceWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("fence").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImportFenceWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImportFenceWin32HandleInfoKHR::GetsType) {
  _VkImportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImportFenceWin32HandleInfoKHR::SetsType) {
  _VkImportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// fence
NAN_GETTER(_VkImportFenceWin32HandleInfoKHR::Getfence) {
  _VkImportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceWin32HandleInfoKHR>(info.This());
  if (self->fence.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->fence);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImportFenceWin32HandleInfoKHR::Setfence) {
  _VkImportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceWin32HandleInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkFence::constructor)->HasInstance(obj)) {
      self->fence.Reset<v8::Object>(value.As<v8::Object>());
      _VkFence* inst = Nan::ObjectWrap::Unwrap<_VkFence>(obj);
      ;
      self->instance.fence = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImportFenceWin32HandleInfoKHR.fence", "[object VkFence]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->fence.Reset();
    self->instance.fence = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceWin32HandleInfoKHR.fence", "[object VkFence]");
  
    return;
  }
}// flags
NAN_GETTER(_VkImportFenceWin32HandleInfoKHR::Getflags) {
  _VkImportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkImportFenceWin32HandleInfoKHR::Setflags) {
  _VkImportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkFenceImportFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceWin32HandleInfoKHR.flags", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkImportFenceWin32HandleInfoKHR::GethandleType) {
  _VkImportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkImportFenceWin32HandleInfoKHR::SethandleType) {
  _VkImportFenceWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportFenceWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportFenceWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportFenceWin32HandleInfoKHR ## **/

/** ## BEGIN VkExportFenceCreateInfoKHR ## **/

class _VkExportFenceCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExportFenceCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportFenceCreateInfoKHR();
    ~_VkExportFenceCreateInfoKHR();

};

/*
#include "index.h"
#include "VkExportFenceCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportFenceCreateInfoKHR::constructor;

_VkExportFenceCreateInfoKHR::_VkExportFenceCreateInfoKHR() {
  
  
}

_VkExportFenceCreateInfoKHR::~_VkExportFenceCreateInfoKHR() {
  //printf("VkExportFenceCreateInfoKHR deconstructed!!\n");
  
}

void _VkExportFenceCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportFenceCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportFenceCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExportFenceCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportFenceCreateInfoKHR::flush() {
  _VkExportFenceCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExportFenceCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkExportFenceCreateInfoKHR* self = new _VkExportFenceCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportFenceCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExportFenceCreateInfoKHR ## **/

/** ## BEGIN VkExportFenceCreateInfo ## **/

class _VkExportFenceCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleTypes);
    static NAN_SETTER(SethandleTypes);
    

    // real instance
    VkExportFenceCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportFenceCreateInfo();
    ~_VkExportFenceCreateInfo();

};

/*
#include "index.h"
#include "VkExportFenceCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportFenceCreateInfo::constructor;

_VkExportFenceCreateInfo::_VkExportFenceCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
  
}

_VkExportFenceCreateInfo::~_VkExportFenceCreateInfo() {
  //printf("VkExportFenceCreateInfo deconstructed!!\n");
  
  
  
}

void _VkExportFenceCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportFenceCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportFenceCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleTypes").ToLocalChecked(), GethandleTypes, SethandleTypes, ctor);
  Nan::Set(target, Nan::New("VkExportFenceCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportFenceCreateInfo::flush() {
  _VkExportFenceCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkExportFenceCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkExportFenceCreateInfo* self = new _VkExportFenceCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleTypes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportFenceCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExportFenceCreateInfo::GetsType) {
  _VkExportFenceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportFenceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExportFenceCreateInfo::SetsType) {
  _VkExportFenceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportFenceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportFenceCreateInfo.sType", "Number");
  
    return;
  }
}// handleTypes
NAN_GETTER(_VkExportFenceCreateInfo::GethandleTypes) {
  _VkExportFenceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportFenceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleTypes));
}NAN_SETTER(_VkExportFenceCreateInfo::SethandleTypes) {
  _VkExportFenceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportFenceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleTypes = static_cast<VkExternalFenceHandleTypeFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportFenceCreateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportFenceCreateInfo ## **/

/** ## BEGIN VkExternalFencePropertiesKHR ## **/

class _VkExternalFencePropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExternalFencePropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalFencePropertiesKHR();
    ~_VkExternalFencePropertiesKHR();

};

/*
#include "index.h"
#include "VkExternalFencePropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalFencePropertiesKHR::constructor;

_VkExternalFencePropertiesKHR::_VkExternalFencePropertiesKHR() {
  
  
}

_VkExternalFencePropertiesKHR::~_VkExternalFencePropertiesKHR() {
  //printf("VkExternalFencePropertiesKHR deconstructed!!\n");
  
}

void _VkExternalFencePropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalFencePropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalFencePropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExternalFencePropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalFencePropertiesKHR::flush() {
  _VkExternalFencePropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalFencePropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkExternalFencePropertiesKHR* self = new _VkExternalFencePropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalFencePropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExternalFencePropertiesKHR ## **/

/** ## BEGIN VkExternalFenceProperties ## **/

class _VkExternalFenceProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetexportFromImportedHandleTypes);
    static NAN_GETTER(GetcompatibleHandleTypes);
    static NAN_GETTER(GetexternalFenceFeatures);

    // real instance
    VkExternalFenceProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalFenceProperties();
    ~_VkExternalFenceProperties();

};

/*
#include "index.h"
#include "VkExternalFenceProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalFenceProperties::constructor;

_VkExternalFenceProperties::_VkExternalFenceProperties() {
  instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES;
  
}

_VkExternalFenceProperties::~_VkExternalFenceProperties() {
  //printf("VkExternalFenceProperties deconstructed!!\n");
  
  
  
  
  
}

void _VkExternalFenceProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalFenceProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalFenceProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("exportFromImportedHandleTypes").ToLocalChecked(), GetexportFromImportedHandleTypes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("compatibleHandleTypes").ToLocalChecked(), GetcompatibleHandleTypes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("externalFenceFeatures").ToLocalChecked(), GetexternalFenceFeatures, nullptr, ctor);
  Nan::Set(target, Nan::New("VkExternalFenceProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalFenceProperties::flush() {
  _VkExternalFenceProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalFenceProperties::New) {
  if (info.IsConstructCall()) {
    _VkExternalFenceProperties* self = new _VkExternalFenceProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalFenceProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExternalFenceProperties::GetsType) {
  _VkExternalFenceProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalFenceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// exportFromImportedHandleTypes
NAN_GETTER(_VkExternalFenceProperties::GetexportFromImportedHandleTypes) {
  _VkExternalFenceProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalFenceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.exportFromImportedHandleTypes));
}// compatibleHandleTypes
NAN_GETTER(_VkExternalFenceProperties::GetcompatibleHandleTypes) {
  _VkExternalFenceProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalFenceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compatibleHandleTypes));
}// externalFenceFeatures
NAN_GETTER(_VkExternalFenceProperties::GetexternalFenceFeatures) {
  _VkExternalFenceProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalFenceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.externalFenceFeatures));
}
/** ## END VkExternalFenceProperties ## **/

/** ## BEGIN VkPhysicalDeviceExternalFenceInfoKHR ## **/

class _VkPhysicalDeviceExternalFenceInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceExternalFenceInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalFenceInfoKHR();
    ~_VkPhysicalDeviceExternalFenceInfoKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalFenceInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalFenceInfoKHR::constructor;

_VkPhysicalDeviceExternalFenceInfoKHR::_VkPhysicalDeviceExternalFenceInfoKHR() {
  
  
}

_VkPhysicalDeviceExternalFenceInfoKHR::~_VkPhysicalDeviceExternalFenceInfoKHR() {
  //printf("VkPhysicalDeviceExternalFenceInfoKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceExternalFenceInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalFenceInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalFenceInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalFenceInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalFenceInfoKHR::flush() {
  _VkPhysicalDeviceExternalFenceInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalFenceInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalFenceInfoKHR* self = new _VkPhysicalDeviceExternalFenceInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalFenceInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceExternalFenceInfoKHR ## **/

/** ## BEGIN VkPhysicalDeviceExternalFenceInfo ## **/

class _VkPhysicalDeviceExternalFenceInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkPhysicalDeviceExternalFenceInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalFenceInfo();
    ~_VkPhysicalDeviceExternalFenceInfo();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalFenceInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalFenceInfo::constructor;

_VkPhysicalDeviceExternalFenceInfo::_VkPhysicalDeviceExternalFenceInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO;
  
}

_VkPhysicalDeviceExternalFenceInfo::~_VkPhysicalDeviceExternalFenceInfo() {
  //printf("VkPhysicalDeviceExternalFenceInfo deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceExternalFenceInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalFenceInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalFenceInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalFenceInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalFenceInfo::flush() {
  _VkPhysicalDeviceExternalFenceInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalFenceInfo::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalFenceInfo* self = new _VkPhysicalDeviceExternalFenceInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalFenceInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceExternalFenceInfo::GetsType) {
  _VkPhysicalDeviceExternalFenceInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalFenceInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceExternalFenceInfo::SetsType) {
  _VkPhysicalDeviceExternalFenceInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalFenceInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalFenceInfo.sType", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkPhysicalDeviceExternalFenceInfo::GethandleType) {
  _VkPhysicalDeviceExternalFenceInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalFenceInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkPhysicalDeviceExternalFenceInfo::SethandleType) {
  _VkPhysicalDeviceExternalFenceInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalFenceInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalFenceInfo.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalFenceInfo ## **/

/** ## BEGIN VkSemaphoreGetFdInfoKHR ## **/

class _VkSemaphoreGetFdInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> semaphore;
      static NAN_GETTER(Getsemaphore);
    static NAN_SETTER(Setsemaphore);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkSemaphoreGetFdInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSemaphoreGetFdInfoKHR();
    ~_VkSemaphoreGetFdInfoKHR();

};

/*
#include "index.h"
#include "VkSemaphoreGetFdInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSemaphoreGetFdInfoKHR::constructor;

_VkSemaphoreGetFdInfoKHR::_VkSemaphoreGetFdInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
  
}

_VkSemaphoreGetFdInfoKHR::~_VkSemaphoreGetFdInfoKHR() {
  //printf("VkSemaphoreGetFdInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkSemaphoreGetFdInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSemaphoreGetFdInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSemaphoreGetFdInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("semaphore").ToLocalChecked(), Getsemaphore, Setsemaphore, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkSemaphoreGetFdInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSemaphoreGetFdInfoKHR::flush() {
  _VkSemaphoreGetFdInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSemaphoreGetFdInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkSemaphoreGetFdInfoKHR* self = new _VkSemaphoreGetFdInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("semaphore").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSemaphoreGetFdInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSemaphoreGetFdInfoKHR::GetsType) {
  _VkSemaphoreGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSemaphoreGetFdInfoKHR::SetsType) {
  _VkSemaphoreGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSemaphoreGetFdInfoKHR.sType", "Number");
  
    return;
  }
}// semaphore
NAN_GETTER(_VkSemaphoreGetFdInfoKHR::Getsemaphore) {
  _VkSemaphoreGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetFdInfoKHR>(info.This());
  if (self->semaphore.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->semaphore);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSemaphoreGetFdInfoKHR::Setsemaphore) {
  _VkSemaphoreGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetFdInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSemaphore::constructor)->HasInstance(obj)) {
      self->semaphore.Reset<v8::Object>(value.As<v8::Object>());
      _VkSemaphore* inst = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      ;
      self->instance.semaphore = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSemaphoreGetFdInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->semaphore.Reset();
    self->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSemaphoreGetFdInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// handleType
NAN_GETTER(_VkSemaphoreGetFdInfoKHR::GethandleType) {
  _VkSemaphoreGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkSemaphoreGetFdInfoKHR::SethandleType) {
  _VkSemaphoreGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSemaphoreGetFdInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkSemaphoreGetFdInfoKHR ## **/

/** ## BEGIN VkImportSemaphoreFdInfoKHR ## **/

class _VkImportSemaphoreFdInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> semaphore;
      static NAN_GETTER(Getsemaphore);
    static NAN_SETTER(Setsemaphore);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    
    static NAN_GETTER(Getfd);
    static NAN_SETTER(Setfd);
    

    // real instance
    VkImportSemaphoreFdInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImportSemaphoreFdInfoKHR();
    ~_VkImportSemaphoreFdInfoKHR();

};

/*
#include "index.h"
#include "VkImportSemaphoreFdInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImportSemaphoreFdInfoKHR::constructor;

_VkImportSemaphoreFdInfoKHR::_VkImportSemaphoreFdInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
  
}

_VkImportSemaphoreFdInfoKHR::~_VkImportSemaphoreFdInfoKHR() {
  //printf("VkImportSemaphoreFdInfoKHR deconstructed!!\n");
  
  
  
  
  
  
}

void _VkImportSemaphoreFdInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImportSemaphoreFdInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImportSemaphoreFdInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("semaphore").ToLocalChecked(), Getsemaphore, Setsemaphore, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fd").ToLocalChecked(), Getfd, Setfd, ctor);
  Nan::Set(target, Nan::New("VkImportSemaphoreFdInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImportSemaphoreFdInfoKHR::flush() {
  _VkImportSemaphoreFdInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImportSemaphoreFdInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImportSemaphoreFdInfoKHR* self = new _VkImportSemaphoreFdInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("semaphore").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("handleType").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("fd").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImportSemaphoreFdInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImportSemaphoreFdInfoKHR::GetsType) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImportSemaphoreFdInfoKHR::SetsType) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreFdInfoKHR.sType", "Number");
  
    return;
  }
}// semaphore
NAN_GETTER(_VkImportSemaphoreFdInfoKHR::Getsemaphore) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  if (self->semaphore.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->semaphore);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImportSemaphoreFdInfoKHR::Setsemaphore) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSemaphore::constructor)->HasInstance(obj)) {
      self->semaphore.Reset<v8::Object>(value.As<v8::Object>());
      _VkSemaphore* inst = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      ;
      self->instance.semaphore = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreFdInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->semaphore.Reset();
    self->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreFdInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// flags
NAN_GETTER(_VkImportSemaphoreFdInfoKHR::Getflags) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkImportSemaphoreFdInfoKHR::Setflags) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSemaphoreImportFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreFdInfoKHR.flags", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkImportSemaphoreFdInfoKHR::GethandleType) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkImportSemaphoreFdInfoKHR::SethandleType) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreFdInfoKHR.handleType", "Number");
  
    return;
  }
}// fd
NAN_GETTER(_VkImportSemaphoreFdInfoKHR::Getfd) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fd));
}NAN_SETTER(_VkImportSemaphoreFdInfoKHR::Setfd) {
  _VkImportSemaphoreFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.fd = static_cast<int>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreFdInfoKHR.fd", "Number");
  
    return;
  }
}
/** ## END VkImportSemaphoreFdInfoKHR ## **/

/** ## BEGIN VkSemaphoreGetWin32HandleInfoKHR ## **/

class _VkSemaphoreGetWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> semaphore;
      static NAN_GETTER(Getsemaphore);
    static NAN_SETTER(Setsemaphore);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkSemaphoreGetWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSemaphoreGetWin32HandleInfoKHR();
    ~_VkSemaphoreGetWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkSemaphoreGetWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSemaphoreGetWin32HandleInfoKHR::constructor;

_VkSemaphoreGetWin32HandleInfoKHR::_VkSemaphoreGetWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR;
  
}

_VkSemaphoreGetWin32HandleInfoKHR::~_VkSemaphoreGetWin32HandleInfoKHR() {
  //printf("VkSemaphoreGetWin32HandleInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkSemaphoreGetWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSemaphoreGetWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSemaphoreGetWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("semaphore").ToLocalChecked(), Getsemaphore, Setsemaphore, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkSemaphoreGetWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSemaphoreGetWin32HandleInfoKHR::flush() {
  _VkSemaphoreGetWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSemaphoreGetWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkSemaphoreGetWin32HandleInfoKHR* self = new _VkSemaphoreGetWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("semaphore").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSemaphoreGetWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSemaphoreGetWin32HandleInfoKHR::GetsType) {
  _VkSemaphoreGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSemaphoreGetWin32HandleInfoKHR::SetsType) {
  _VkSemaphoreGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// semaphore
NAN_GETTER(_VkSemaphoreGetWin32HandleInfoKHR::Getsemaphore) {
  _VkSemaphoreGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetWin32HandleInfoKHR>(info.This());
  if (self->semaphore.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->semaphore);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSemaphoreGetWin32HandleInfoKHR::Setsemaphore) {
  _VkSemaphoreGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetWin32HandleInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSemaphore::constructor)->HasInstance(obj)) {
      self->semaphore.Reset<v8::Object>(value.As<v8::Object>());
      _VkSemaphore* inst = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      ;
      self->instance.semaphore = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->semaphore.Reset();
    self->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// handleType
NAN_GETTER(_VkSemaphoreGetWin32HandleInfoKHR::GethandleType) {
  _VkSemaphoreGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkSemaphoreGetWin32HandleInfoKHR::SethandleType) {
  _VkSemaphoreGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreGetWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSemaphoreGetWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkSemaphoreGetWin32HandleInfoKHR ## **/

/** ## BEGIN VkD3D12FenceSubmitInfoKHR ## **/

class _VkD3D12FenceSubmitInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetwaitSemaphoreValuesCount);
    static NAN_SETTER(SetwaitSemaphoreValuesCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pWaitSemaphoreValues;
    static NAN_GETTER(GetpWaitSemaphoreValues);
    static NAN_SETTER(SetpWaitSemaphoreValues);
    
    static NAN_GETTER(GetsignalSemaphoreValuesCount);
    static NAN_SETTER(SetsignalSemaphoreValuesCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSignalSemaphoreValues;
    static NAN_GETTER(GetpSignalSemaphoreValues);
    static NAN_SETTER(SetpSignalSemaphoreValues);
    

    // real instance
    VkD3D12FenceSubmitInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkD3D12FenceSubmitInfoKHR();
    ~_VkD3D12FenceSubmitInfoKHR();

};

/*
#include "index.h"
#include "VkD3D12FenceSubmitInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkD3D12FenceSubmitInfoKHR::constructor;

_VkD3D12FenceSubmitInfoKHR::_VkD3D12FenceSubmitInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR;
  
}

_VkD3D12FenceSubmitInfoKHR::~_VkD3D12FenceSubmitInfoKHR() {
  //printf("VkD3D12FenceSubmitInfoKHR deconstructed!!\n");
  
  
  
  pWaitSemaphoreValues.Reset();
  
  
  pSignalSemaphoreValues.Reset();
  
}

void _VkD3D12FenceSubmitInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkD3D12FenceSubmitInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkD3D12FenceSubmitInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("waitSemaphoreValuesCount").ToLocalChecked(), GetwaitSemaphoreValuesCount, SetwaitSemaphoreValuesCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pWaitSemaphoreValues").ToLocalChecked(), GetpWaitSemaphoreValues, SetpWaitSemaphoreValues, ctor);
  SetPrototypeAccessor(proto, Nan::New("signalSemaphoreValuesCount").ToLocalChecked(), GetsignalSemaphoreValuesCount, SetsignalSemaphoreValuesCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSignalSemaphoreValues").ToLocalChecked(), GetpSignalSemaphoreValues, SetpSignalSemaphoreValues, ctor);
  Nan::Set(target, Nan::New("VkD3D12FenceSubmitInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkD3D12FenceSubmitInfoKHR::flush() {
  _VkD3D12FenceSubmitInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkD3D12FenceSubmitInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkD3D12FenceSubmitInfoKHR* self = new _VkD3D12FenceSubmitInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("waitSemaphoreValuesCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pWaitSemaphoreValues").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("signalSemaphoreValuesCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pSignalSemaphoreValues").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkD3D12FenceSubmitInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkD3D12FenceSubmitInfoKHR::GetsType) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkD3D12FenceSubmitInfoKHR::SetsType) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkD3D12FenceSubmitInfoKHR.sType", "Number");
  
    return;
  }
}// waitSemaphoreValuesCount
NAN_GETTER(_VkD3D12FenceSubmitInfoKHR::GetwaitSemaphoreValuesCount) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.waitSemaphoreValuesCount));
}NAN_SETTER(_VkD3D12FenceSubmitInfoKHR::SetwaitSemaphoreValuesCount) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.waitSemaphoreValuesCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkD3D12FenceSubmitInfoKHR.waitSemaphoreValuesCount", "Number");
  
    return;
  }
}// pWaitSemaphoreValues
NAN_GETTER(_VkD3D12FenceSubmitInfoKHR::GetpWaitSemaphoreValues) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  if (self->pWaitSemaphoreValues.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pWaitSemaphoreValues);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkD3D12FenceSubmitInfoKHR::SetpWaitSemaphoreValues) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsBigUint64Array()) {
        self->pWaitSemaphoreValues.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkD3D12FenceSubmitInfoKHR.pWaitSemaphoreValues", "BigUint64Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pWaitSemaphoreValues.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkD3D12FenceSubmitInfoKHR.pWaitSemaphoreValues", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pWaitSemaphoreValues = getTypedArrayData<uint64_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pWaitSemaphoreValues = nullptr;
  }
}// signalSemaphoreValuesCount
NAN_GETTER(_VkD3D12FenceSubmitInfoKHR::GetsignalSemaphoreValuesCount) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.signalSemaphoreValuesCount));
}NAN_SETTER(_VkD3D12FenceSubmitInfoKHR::SetsignalSemaphoreValuesCount) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.signalSemaphoreValuesCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkD3D12FenceSubmitInfoKHR.signalSemaphoreValuesCount", "Number");
  
    return;
  }
}// pSignalSemaphoreValues
NAN_GETTER(_VkD3D12FenceSubmitInfoKHR::GetpSignalSemaphoreValues) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  if (self->pSignalSemaphoreValues.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSignalSemaphoreValues);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkD3D12FenceSubmitInfoKHR::SetpSignalSemaphoreValues) {
  _VkD3D12FenceSubmitInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkD3D12FenceSubmitInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsBigUint64Array()) {
        self->pSignalSemaphoreValues.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkD3D12FenceSubmitInfoKHR.pSignalSemaphoreValues", "BigUint64Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pSignalSemaphoreValues.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkD3D12FenceSubmitInfoKHR.pSignalSemaphoreValues", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pSignalSemaphoreValues = getTypedArrayData<uint64_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pSignalSemaphoreValues = nullptr;
  }
}
/** ## END VkD3D12FenceSubmitInfoKHR ## **/

/** ## BEGIN VkExportSemaphoreWin32HandleInfoKHR ## **/

class _VkExportSemaphoreWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    

    // real instance
    VkExportSemaphoreWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportSemaphoreWin32HandleInfoKHR();
    ~_VkExportSemaphoreWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkExportSemaphoreWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportSemaphoreWin32HandleInfoKHR::constructor;

_VkExportSemaphoreWin32HandleInfoKHR::_VkExportSemaphoreWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
  
}

_VkExportSemaphoreWin32HandleInfoKHR::~_VkExportSemaphoreWin32HandleInfoKHR() {
  //printf("VkExportSemaphoreWin32HandleInfoKHR deconstructed!!\n");
  
  
}

void _VkExportSemaphoreWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportSemaphoreWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportSemaphoreWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  Nan::Set(target, Nan::New("VkExportSemaphoreWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportSemaphoreWin32HandleInfoKHR::flush() {
  _VkExportSemaphoreWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExportSemaphoreWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkExportSemaphoreWin32HandleInfoKHR* self = new _VkExportSemaphoreWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportSemaphoreWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExportSemaphoreWin32HandleInfoKHR::GetsType) {
  _VkExportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkExportSemaphoreWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExportSemaphoreWin32HandleInfoKHR::SetsType) {
  _VkExportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkExportSemaphoreWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportSemaphoreWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}
/** ## END VkExportSemaphoreWin32HandleInfoKHR ## **/

/** ## BEGIN VkImportSemaphoreWin32HandleInfoKHR ## **/

class _VkImportSemaphoreWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> semaphore;
      static NAN_GETTER(Getsemaphore);
    static NAN_SETTER(Setsemaphore);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkImportSemaphoreWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImportSemaphoreWin32HandleInfoKHR();
    ~_VkImportSemaphoreWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkImportSemaphoreWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImportSemaphoreWin32HandleInfoKHR::constructor;

_VkImportSemaphoreWin32HandleInfoKHR::_VkImportSemaphoreWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
  
}

_VkImportSemaphoreWin32HandleInfoKHR::~_VkImportSemaphoreWin32HandleInfoKHR() {
  //printf("VkImportSemaphoreWin32HandleInfoKHR deconstructed!!\n");
  
  
  
  
  
}

void _VkImportSemaphoreWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImportSemaphoreWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImportSemaphoreWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("semaphore").ToLocalChecked(), Getsemaphore, Setsemaphore, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkImportSemaphoreWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImportSemaphoreWin32HandleInfoKHR::flush() {
  _VkImportSemaphoreWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImportSemaphoreWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImportSemaphoreWin32HandleInfoKHR* self = new _VkImportSemaphoreWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("semaphore").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImportSemaphoreWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImportSemaphoreWin32HandleInfoKHR::GetsType) {
  _VkImportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImportSemaphoreWin32HandleInfoKHR::SetsType) {
  _VkImportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// semaphore
NAN_GETTER(_VkImportSemaphoreWin32HandleInfoKHR::Getsemaphore) {
  _VkImportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreWin32HandleInfoKHR>(info.This());
  if (self->semaphore.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->semaphore);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImportSemaphoreWin32HandleInfoKHR::Setsemaphore) {
  _VkImportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreWin32HandleInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSemaphore::constructor)->HasInstance(obj)) {
      self->semaphore.Reset<v8::Object>(value.As<v8::Object>());
      _VkSemaphore* inst = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      ;
      self->instance.semaphore = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.semaphore", "[object VkSemaphore]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->semaphore.Reset();
    self->instance.semaphore = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.semaphore", "[object VkSemaphore]");
  
    return;
  }
}// flags
NAN_GETTER(_VkImportSemaphoreWin32HandleInfoKHR::Getflags) {
  _VkImportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkImportSemaphoreWin32HandleInfoKHR::Setflags) {
  _VkImportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSemaphoreImportFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.flags", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkImportSemaphoreWin32HandleInfoKHR::GethandleType) {
  _VkImportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkImportSemaphoreWin32HandleInfoKHR::SethandleType) {
  _VkImportSemaphoreWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportSemaphoreWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportSemaphoreWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportSemaphoreWin32HandleInfoKHR ## **/

/** ## BEGIN VkExportSemaphoreCreateInfoKHR ## **/

class _VkExportSemaphoreCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExportSemaphoreCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportSemaphoreCreateInfoKHR();
    ~_VkExportSemaphoreCreateInfoKHR();

};

/*
#include "index.h"
#include "VkExportSemaphoreCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportSemaphoreCreateInfoKHR::constructor;

_VkExportSemaphoreCreateInfoKHR::_VkExportSemaphoreCreateInfoKHR() {
  
  
}

_VkExportSemaphoreCreateInfoKHR::~_VkExportSemaphoreCreateInfoKHR() {
  //printf("VkExportSemaphoreCreateInfoKHR deconstructed!!\n");
  
}

void _VkExportSemaphoreCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportSemaphoreCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportSemaphoreCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExportSemaphoreCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportSemaphoreCreateInfoKHR::flush() {
  _VkExportSemaphoreCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExportSemaphoreCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkExportSemaphoreCreateInfoKHR* self = new _VkExportSemaphoreCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportSemaphoreCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExportSemaphoreCreateInfoKHR ## **/

/** ## BEGIN VkExportSemaphoreCreateInfo ## **/

class _VkExportSemaphoreCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleTypes);
    static NAN_SETTER(SethandleTypes);
    

    // real instance
    VkExportSemaphoreCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportSemaphoreCreateInfo();
    ~_VkExportSemaphoreCreateInfo();

};

/*
#include "index.h"
#include "VkExportSemaphoreCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportSemaphoreCreateInfo::constructor;

_VkExportSemaphoreCreateInfo::_VkExportSemaphoreCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
  
}

_VkExportSemaphoreCreateInfo::~_VkExportSemaphoreCreateInfo() {
  //printf("VkExportSemaphoreCreateInfo deconstructed!!\n");
  
  
  
}

void _VkExportSemaphoreCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportSemaphoreCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportSemaphoreCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleTypes").ToLocalChecked(), GethandleTypes, SethandleTypes, ctor);
  Nan::Set(target, Nan::New("VkExportSemaphoreCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportSemaphoreCreateInfo::flush() {
  _VkExportSemaphoreCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkExportSemaphoreCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkExportSemaphoreCreateInfo* self = new _VkExportSemaphoreCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleTypes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportSemaphoreCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExportSemaphoreCreateInfo::GetsType) {
  _VkExportSemaphoreCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportSemaphoreCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExportSemaphoreCreateInfo::SetsType) {
  _VkExportSemaphoreCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportSemaphoreCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportSemaphoreCreateInfo.sType", "Number");
  
    return;
  }
}// handleTypes
NAN_GETTER(_VkExportSemaphoreCreateInfo::GethandleTypes) {
  _VkExportSemaphoreCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportSemaphoreCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleTypes));
}NAN_SETTER(_VkExportSemaphoreCreateInfo::SethandleTypes) {
  _VkExportSemaphoreCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportSemaphoreCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleTypes = static_cast<VkExternalSemaphoreHandleTypeFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportSemaphoreCreateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportSemaphoreCreateInfo ## **/

/** ## BEGIN VkExternalSemaphorePropertiesKHR ## **/

class _VkExternalSemaphorePropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExternalSemaphorePropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalSemaphorePropertiesKHR();
    ~_VkExternalSemaphorePropertiesKHR();

};

/*
#include "index.h"
#include "VkExternalSemaphorePropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalSemaphorePropertiesKHR::constructor;

_VkExternalSemaphorePropertiesKHR::_VkExternalSemaphorePropertiesKHR() {
  
  
}

_VkExternalSemaphorePropertiesKHR::~_VkExternalSemaphorePropertiesKHR() {
  //printf("VkExternalSemaphorePropertiesKHR deconstructed!!\n");
  
}

void _VkExternalSemaphorePropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalSemaphorePropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalSemaphorePropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExternalSemaphorePropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalSemaphorePropertiesKHR::flush() {
  _VkExternalSemaphorePropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalSemaphorePropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkExternalSemaphorePropertiesKHR* self = new _VkExternalSemaphorePropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalSemaphorePropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExternalSemaphorePropertiesKHR ## **/

/** ## BEGIN VkExternalSemaphoreProperties ## **/

class _VkExternalSemaphoreProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetexportFromImportedHandleTypes);
    static NAN_GETTER(GetcompatibleHandleTypes);
    static NAN_GETTER(GetexternalSemaphoreFeatures);

    // real instance
    VkExternalSemaphoreProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalSemaphoreProperties();
    ~_VkExternalSemaphoreProperties();

};

/*
#include "index.h"
#include "VkExternalSemaphoreProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalSemaphoreProperties::constructor;

_VkExternalSemaphoreProperties::_VkExternalSemaphoreProperties() {
  instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES;
  
}

_VkExternalSemaphoreProperties::~_VkExternalSemaphoreProperties() {
  //printf("VkExternalSemaphoreProperties deconstructed!!\n");
  
  
  
  
  
}

void _VkExternalSemaphoreProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalSemaphoreProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalSemaphoreProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("exportFromImportedHandleTypes").ToLocalChecked(), GetexportFromImportedHandleTypes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("compatibleHandleTypes").ToLocalChecked(), GetcompatibleHandleTypes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("externalSemaphoreFeatures").ToLocalChecked(), GetexternalSemaphoreFeatures, nullptr, ctor);
  Nan::Set(target, Nan::New("VkExternalSemaphoreProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalSemaphoreProperties::flush() {
  _VkExternalSemaphoreProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalSemaphoreProperties::New) {
  if (info.IsConstructCall()) {
    _VkExternalSemaphoreProperties* self = new _VkExternalSemaphoreProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalSemaphoreProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExternalSemaphoreProperties::GetsType) {
  _VkExternalSemaphoreProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalSemaphoreProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// exportFromImportedHandleTypes
NAN_GETTER(_VkExternalSemaphoreProperties::GetexportFromImportedHandleTypes) {
  _VkExternalSemaphoreProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalSemaphoreProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.exportFromImportedHandleTypes));
}// compatibleHandleTypes
NAN_GETTER(_VkExternalSemaphoreProperties::GetcompatibleHandleTypes) {
  _VkExternalSemaphoreProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalSemaphoreProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compatibleHandleTypes));
}// externalSemaphoreFeatures
NAN_GETTER(_VkExternalSemaphoreProperties::GetexternalSemaphoreFeatures) {
  _VkExternalSemaphoreProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalSemaphoreProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.externalSemaphoreFeatures));
}
/** ## END VkExternalSemaphoreProperties ## **/

/** ## BEGIN VkPhysicalDeviceExternalSemaphoreInfoKHR ## **/

class _VkPhysicalDeviceExternalSemaphoreInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceExternalSemaphoreInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalSemaphoreInfoKHR();
    ~_VkPhysicalDeviceExternalSemaphoreInfoKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalSemaphoreInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalSemaphoreInfoKHR::constructor;

_VkPhysicalDeviceExternalSemaphoreInfoKHR::_VkPhysicalDeviceExternalSemaphoreInfoKHR() {
  
  
}

_VkPhysicalDeviceExternalSemaphoreInfoKHR::~_VkPhysicalDeviceExternalSemaphoreInfoKHR() {
  //printf("VkPhysicalDeviceExternalSemaphoreInfoKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceExternalSemaphoreInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalSemaphoreInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalSemaphoreInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalSemaphoreInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalSemaphoreInfoKHR::flush() {
  _VkPhysicalDeviceExternalSemaphoreInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalSemaphoreInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalSemaphoreInfoKHR* self = new _VkPhysicalDeviceExternalSemaphoreInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalSemaphoreInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceExternalSemaphoreInfoKHR ## **/

/** ## BEGIN VkPhysicalDeviceExternalSemaphoreInfo ## **/

class _VkPhysicalDeviceExternalSemaphoreInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkPhysicalDeviceExternalSemaphoreInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalSemaphoreInfo();
    ~_VkPhysicalDeviceExternalSemaphoreInfo();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalSemaphoreInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalSemaphoreInfo::constructor;

_VkPhysicalDeviceExternalSemaphoreInfo::_VkPhysicalDeviceExternalSemaphoreInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO;
  
}

_VkPhysicalDeviceExternalSemaphoreInfo::~_VkPhysicalDeviceExternalSemaphoreInfo() {
  //printf("VkPhysicalDeviceExternalSemaphoreInfo deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceExternalSemaphoreInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalSemaphoreInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalSemaphoreInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalSemaphoreInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalSemaphoreInfo::flush() {
  _VkPhysicalDeviceExternalSemaphoreInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalSemaphoreInfo::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalSemaphoreInfo* self = new _VkPhysicalDeviceExternalSemaphoreInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalSemaphoreInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceExternalSemaphoreInfo::GetsType) {
  _VkPhysicalDeviceExternalSemaphoreInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalSemaphoreInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceExternalSemaphoreInfo::SetsType) {
  _VkPhysicalDeviceExternalSemaphoreInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalSemaphoreInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfo.sType", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkPhysicalDeviceExternalSemaphoreInfo::GethandleType) {
  _VkPhysicalDeviceExternalSemaphoreInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalSemaphoreInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkPhysicalDeviceExternalSemaphoreInfo::SethandleType) {
  _VkPhysicalDeviceExternalSemaphoreInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalSemaphoreInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalSemaphoreInfo.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalSemaphoreInfo ## **/

/** ## BEGIN VkWin32KeyedMutexAcquireReleaseInfoKHR ## **/

class _VkWin32KeyedMutexAcquireReleaseInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetacquireCount);
    static NAN_SETTER(SetacquireCount);
    
    std::vector<VkDeviceMemory>* vpAcquireSyncs;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAcquireSyncs;
    static NAN_GETTER(GetpAcquireSyncs);
    static NAN_SETTER(SetpAcquireSyncs);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAcquireKeys;
    static NAN_GETTER(GetpAcquireKeys);
    static NAN_SETTER(SetpAcquireKeys);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAcquireTimeouts;
    static NAN_GETTER(GetpAcquireTimeouts);
    static NAN_SETTER(SetpAcquireTimeouts);
    
    static NAN_GETTER(GetreleaseCount);
    static NAN_SETTER(SetreleaseCount);
    
    std::vector<VkDeviceMemory>* vpReleaseSyncs;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pReleaseSyncs;
    static NAN_GETTER(GetpReleaseSyncs);
    static NAN_SETTER(SetpReleaseSyncs);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pReleaseKeys;
    static NAN_GETTER(GetpReleaseKeys);
    static NAN_SETTER(SetpReleaseKeys);
    

    // real instance
    VkWin32KeyedMutexAcquireReleaseInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkWin32KeyedMutexAcquireReleaseInfoKHR();
    ~_VkWin32KeyedMutexAcquireReleaseInfoKHR();

};

/*
#include "index.h"
#include "VkWin32KeyedMutexAcquireReleaseInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkWin32KeyedMutexAcquireReleaseInfoKHR::constructor;

_VkWin32KeyedMutexAcquireReleaseInfoKHR::_VkWin32KeyedMutexAcquireReleaseInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR;
  vpAcquireSyncs = new std::vector<VkDeviceMemory>;
  vpReleaseSyncs = new std::vector<VkDeviceMemory>;
  
}

_VkWin32KeyedMutexAcquireReleaseInfoKHR::~_VkWin32KeyedMutexAcquireReleaseInfoKHR() {
  //printf("VkWin32KeyedMutexAcquireReleaseInfoKHR deconstructed!!\n");
  
  
  
  vpAcquireSyncs->clear();
  delete vpAcquireSyncs;
  
  pAcquireSyncs.Reset();
  
  pAcquireKeys.Reset();
  
  pAcquireTimeouts.Reset();
  
  
  vpReleaseSyncs->clear();
  delete vpReleaseSyncs;
  
  pReleaseSyncs.Reset();
  
  pReleaseKeys.Reset();
  
}

void _VkWin32KeyedMutexAcquireReleaseInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkWin32KeyedMutexAcquireReleaseInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkWin32KeyedMutexAcquireReleaseInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("acquireCount").ToLocalChecked(), GetacquireCount, SetacquireCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAcquireSyncs").ToLocalChecked(), GetpAcquireSyncs, SetpAcquireSyncs, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAcquireKeys").ToLocalChecked(), GetpAcquireKeys, SetpAcquireKeys, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAcquireTimeouts").ToLocalChecked(), GetpAcquireTimeouts, SetpAcquireTimeouts, ctor);
  SetPrototypeAccessor(proto, Nan::New("releaseCount").ToLocalChecked(), GetreleaseCount, SetreleaseCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pReleaseSyncs").ToLocalChecked(), GetpReleaseSyncs, SetpReleaseSyncs, ctor);
  SetPrototypeAccessor(proto, Nan::New("pReleaseKeys").ToLocalChecked(), GetpReleaseKeys, SetpReleaseKeys, ctor);
  Nan::Set(target, Nan::New("VkWin32KeyedMutexAcquireReleaseInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkWin32KeyedMutexAcquireReleaseInfoKHR::flush() {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = this;
  if (!(self->pAcquireSyncs.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAcquireSyncs);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.acquireCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'acquireCount' for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs'");
      return false;
    }
    std::vector<VkDeviceMemory>* data = self->vpAcquireSyncs;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs", "[object VkDeviceMemory]");
  
        return false;
      }
      _VkDeviceMemory* result = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pAcquireSyncs = data->data();
  }if (!(self->pReleaseSyncs.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pReleaseSyncs);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.releaseCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'releaseCount' for 'VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs'");
      return false;
    }
    std::vector<VkDeviceMemory>* data = self->vpReleaseSyncs;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs", "[object VkDeviceMemory]");
  
        return false;
      }
      _VkDeviceMemory* result = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pReleaseSyncs = data->data();
  }
  return true;
}

NAN_METHOD(_VkWin32KeyedMutexAcquireReleaseInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkWin32KeyedMutexAcquireReleaseInfoKHR* self = new _VkWin32KeyedMutexAcquireReleaseInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("acquireCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pAcquireSyncs").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pAcquireKeys").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pAcquireTimeouts").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("releaseCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pReleaseSyncs").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pReleaseKeys").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkWin32KeyedMutexAcquireReleaseInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetsType) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetsType) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.sType", "Number");
  
    return;
  }
}// acquireCount
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetacquireCount) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.acquireCount));
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetacquireCount) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.acquireCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.acquireCount", "Number");
  
    return;
  }
}// pAcquireSyncs
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireSyncs) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  if (self->pAcquireSyncs.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAcquireSyncs);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireSyncs) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAcquireSyncs.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAcquireSyncs.Reset();
      self->instance.pAcquireSyncs = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs", "[object VkDeviceMemory]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAcquireSyncs = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireSyncs", "[object VkDeviceMemory]");
  
    return;
  }
}// pAcquireKeys
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireKeys) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  if (self->pAcquireKeys.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAcquireKeys);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireKeys) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsBigUint64Array()) {
        self->pAcquireKeys.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireKeys", "BigUint64Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pAcquireKeys.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireKeys", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pAcquireKeys = getTypedArrayData<uint64_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pAcquireKeys = nullptr;
  }
}// pAcquireTimeouts
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpAcquireTimeouts) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  if (self->pAcquireTimeouts.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAcquireTimeouts);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpAcquireTimeouts) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pAcquireTimeouts.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireTimeouts", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pAcquireTimeouts.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pAcquireTimeouts", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pAcquireTimeouts = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pAcquireTimeouts = nullptr;
  }
}// releaseCount
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetreleaseCount) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.releaseCount));
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetreleaseCount) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.releaseCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.releaseCount", "Number");
  
    return;
  }
}// pReleaseSyncs
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpReleaseSyncs) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  if (self->pReleaseSyncs.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pReleaseSyncs);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpReleaseSyncs) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pReleaseSyncs.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pReleaseSyncs.Reset();
      self->instance.pReleaseSyncs = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs", "[object VkDeviceMemory]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pReleaseSyncs = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseSyncs", "[object VkDeviceMemory]");
  
    return;
  }
}// pReleaseKeys
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::GetpReleaseKeys) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  if (self->pReleaseKeys.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pReleaseKeys);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoKHR::SetpReleaseKeys) {
  _VkWin32KeyedMutexAcquireReleaseInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsBigUint64Array()) {
        self->pReleaseKeys.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseKeys", "BigUint64Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pReleaseKeys.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoKHR.pReleaseKeys", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pReleaseKeys = getTypedArrayData<uint64_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pReleaseKeys = nullptr;
  }
}
/** ## END VkWin32KeyedMutexAcquireReleaseInfoKHR ## **/

/** ## BEGIN VkMemoryGetFdInfoKHR ## **/

class _VkMemoryGetFdInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memory;
      static NAN_GETTER(Getmemory);
    static NAN_SETTER(Setmemory);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkMemoryGetFdInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryGetFdInfoKHR();
    ~_VkMemoryGetFdInfoKHR();

};

/*
#include "index.h"
#include "VkMemoryGetFdInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryGetFdInfoKHR::constructor;

_VkMemoryGetFdInfoKHR::_VkMemoryGetFdInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
  
}

_VkMemoryGetFdInfoKHR::~_VkMemoryGetFdInfoKHR() {
  //printf("VkMemoryGetFdInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkMemoryGetFdInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryGetFdInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryGetFdInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("memory").ToLocalChecked(), Getmemory, Setmemory, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkMemoryGetFdInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryGetFdInfoKHR::flush() {
  _VkMemoryGetFdInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryGetFdInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkMemoryGetFdInfoKHR* self = new _VkMemoryGetFdInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("memory").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryGetFdInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryGetFdInfoKHR::GetsType) {
  _VkMemoryGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkMemoryGetFdInfoKHR::SetsType) {
  _VkMemoryGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryGetFdInfoKHR.sType", "Number");
  
    return;
  }
}// memory
NAN_GETTER(_VkMemoryGetFdInfoKHR::Getmemory) {
  _VkMemoryGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetFdInfoKHR>(info.This());
  if (self->memory.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memory);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkMemoryGetFdInfoKHR::Setmemory) {
  _VkMemoryGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetFdInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj)) {
      self->memory.Reset<v8::Object>(value.As<v8::Object>());
      _VkDeviceMemory* inst = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      ;
      self->instance.memory = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkMemoryGetFdInfoKHR.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->memory.Reset();
    self->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryGetFdInfoKHR.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// handleType
NAN_GETTER(_VkMemoryGetFdInfoKHR::GethandleType) {
  _VkMemoryGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkMemoryGetFdInfoKHR::SethandleType) {
  _VkMemoryGetFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryGetFdInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkMemoryGetFdInfoKHR ## **/

/** ## BEGIN VkMemoryFdPropertiesKHR ## **/

class _VkMemoryFdPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmemoryTypeBits);

    // real instance
    VkMemoryFdPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryFdPropertiesKHR();
    ~_VkMemoryFdPropertiesKHR();

};

/*
#include "index.h"
#include "VkMemoryFdPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryFdPropertiesKHR::constructor;

_VkMemoryFdPropertiesKHR::_VkMemoryFdPropertiesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR;
  
}

_VkMemoryFdPropertiesKHR::~_VkMemoryFdPropertiesKHR() {
  //printf("VkMemoryFdPropertiesKHR deconstructed!!\n");
  
  
  
}

void _VkMemoryFdPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryFdPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryFdPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryTypeBits").ToLocalChecked(), GetmemoryTypeBits, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMemoryFdPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryFdPropertiesKHR::flush() {
  _VkMemoryFdPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryFdPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkMemoryFdPropertiesKHR* self = new _VkMemoryFdPropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryFdPropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryFdPropertiesKHR::GetsType) {
  _VkMemoryFdPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryFdPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// memoryTypeBits
NAN_GETTER(_VkMemoryFdPropertiesKHR::GetmemoryTypeBits) {
  _VkMemoryFdPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryFdPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryTypeBits));
}
/** ## END VkMemoryFdPropertiesKHR ## **/

/** ## BEGIN VkImportMemoryFdInfoKHR ## **/

class _VkImportMemoryFdInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    
    static NAN_GETTER(Getfd);
    static NAN_SETTER(Setfd);
    

    // real instance
    VkImportMemoryFdInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImportMemoryFdInfoKHR();
    ~_VkImportMemoryFdInfoKHR();

};

/*
#include "index.h"
#include "VkImportMemoryFdInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImportMemoryFdInfoKHR::constructor;

_VkImportMemoryFdInfoKHR::_VkImportMemoryFdInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
  
}

_VkImportMemoryFdInfoKHR::~_VkImportMemoryFdInfoKHR() {
  //printf("VkImportMemoryFdInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkImportMemoryFdInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImportMemoryFdInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImportMemoryFdInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  SetPrototypeAccessor(proto, Nan::New("fd").ToLocalChecked(), Getfd, Setfd, ctor);
  Nan::Set(target, Nan::New("VkImportMemoryFdInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImportMemoryFdInfoKHR::flush() {
  _VkImportMemoryFdInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImportMemoryFdInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImportMemoryFdInfoKHR* self = new _VkImportMemoryFdInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleType").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("fd").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImportMemoryFdInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImportMemoryFdInfoKHR::GetsType) {
  _VkImportMemoryFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImportMemoryFdInfoKHR::SetsType) {
  _VkImportMemoryFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryFdInfoKHR.sType", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkImportMemoryFdInfoKHR::GethandleType) {
  _VkImportMemoryFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkImportMemoryFdInfoKHR::SethandleType) {
  _VkImportMemoryFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryFdInfoKHR.handleType", "Number");
  
    return;
  }
}// fd
NAN_GETTER(_VkImportMemoryFdInfoKHR::Getfd) {
  _VkImportMemoryFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryFdInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fd));
}NAN_SETTER(_VkImportMemoryFdInfoKHR::Setfd) {
  _VkImportMemoryFdInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryFdInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.fd = static_cast<int>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryFdInfoKHR.fd", "Number");
  
    return;
  }
}
/** ## END VkImportMemoryFdInfoKHR ## **/

/** ## BEGIN VkMemoryGetWin32HandleInfoKHR ## **/

class _VkMemoryGetWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memory;
      static NAN_GETTER(Getmemory);
    static NAN_SETTER(Setmemory);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkMemoryGetWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryGetWin32HandleInfoKHR();
    ~_VkMemoryGetWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkMemoryGetWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryGetWin32HandleInfoKHR::constructor;

_VkMemoryGetWin32HandleInfoKHR::_VkMemoryGetWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR;
  
}

_VkMemoryGetWin32HandleInfoKHR::~_VkMemoryGetWin32HandleInfoKHR() {
  //printf("VkMemoryGetWin32HandleInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkMemoryGetWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryGetWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryGetWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("memory").ToLocalChecked(), Getmemory, Setmemory, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkMemoryGetWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryGetWin32HandleInfoKHR::flush() {
  _VkMemoryGetWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryGetWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkMemoryGetWin32HandleInfoKHR* self = new _VkMemoryGetWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("memory").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryGetWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryGetWin32HandleInfoKHR::GetsType) {
  _VkMemoryGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkMemoryGetWin32HandleInfoKHR::SetsType) {
  _VkMemoryGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryGetWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// memory
NAN_GETTER(_VkMemoryGetWin32HandleInfoKHR::Getmemory) {
  _VkMemoryGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetWin32HandleInfoKHR>(info.This());
  if (self->memory.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memory);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkMemoryGetWin32HandleInfoKHR::Setmemory) {
  _VkMemoryGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetWin32HandleInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj)) {
      self->memory.Reset<v8::Object>(value.As<v8::Object>());
      _VkDeviceMemory* inst = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      ;
      self->instance.memory = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkMemoryGetWin32HandleInfoKHR.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->memory.Reset();
    self->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryGetWin32HandleInfoKHR.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// handleType
NAN_GETTER(_VkMemoryGetWin32HandleInfoKHR::GethandleType) {
  _VkMemoryGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkMemoryGetWin32HandleInfoKHR::SethandleType) {
  _VkMemoryGetWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryGetWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryGetWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkMemoryGetWin32HandleInfoKHR ## **/

/** ## BEGIN VkMemoryWin32HandlePropertiesKHR ## **/

class _VkMemoryWin32HandlePropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmemoryTypeBits);

    // real instance
    VkMemoryWin32HandlePropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryWin32HandlePropertiesKHR();
    ~_VkMemoryWin32HandlePropertiesKHR();

};

/*
#include "index.h"
#include "VkMemoryWin32HandlePropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryWin32HandlePropertiesKHR::constructor;

_VkMemoryWin32HandlePropertiesKHR::_VkMemoryWin32HandlePropertiesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR;
  
}

_VkMemoryWin32HandlePropertiesKHR::~_VkMemoryWin32HandlePropertiesKHR() {
  //printf("VkMemoryWin32HandlePropertiesKHR deconstructed!!\n");
  
  
  
}

void _VkMemoryWin32HandlePropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryWin32HandlePropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryWin32HandlePropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryTypeBits").ToLocalChecked(), GetmemoryTypeBits, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMemoryWin32HandlePropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryWin32HandlePropertiesKHR::flush() {
  _VkMemoryWin32HandlePropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryWin32HandlePropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkMemoryWin32HandlePropertiesKHR* self = new _VkMemoryWin32HandlePropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryWin32HandlePropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryWin32HandlePropertiesKHR::GetsType) {
  _VkMemoryWin32HandlePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryWin32HandlePropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// memoryTypeBits
NAN_GETTER(_VkMemoryWin32HandlePropertiesKHR::GetmemoryTypeBits) {
  _VkMemoryWin32HandlePropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkMemoryWin32HandlePropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryTypeBits));
}
/** ## END VkMemoryWin32HandlePropertiesKHR ## **/

/** ## BEGIN VkExportMemoryWin32HandleInfoKHR ## **/

class _VkExportMemoryWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    

    // real instance
    VkExportMemoryWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportMemoryWin32HandleInfoKHR();
    ~_VkExportMemoryWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkExportMemoryWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportMemoryWin32HandleInfoKHR::constructor;

_VkExportMemoryWin32HandleInfoKHR::_VkExportMemoryWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
  
}

_VkExportMemoryWin32HandleInfoKHR::~_VkExportMemoryWin32HandleInfoKHR() {
  //printf("VkExportMemoryWin32HandleInfoKHR deconstructed!!\n");
  
  
}

void _VkExportMemoryWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportMemoryWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportMemoryWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  Nan::Set(target, Nan::New("VkExportMemoryWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportMemoryWin32HandleInfoKHR::flush() {
  _VkExportMemoryWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExportMemoryWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkExportMemoryWin32HandleInfoKHR* self = new _VkExportMemoryWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportMemoryWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExportMemoryWin32HandleInfoKHR::GetsType) {
  _VkExportMemoryWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExportMemoryWin32HandleInfoKHR::SetsType) {
  _VkExportMemoryWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportMemoryWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}
/** ## END VkExportMemoryWin32HandleInfoKHR ## **/

/** ## BEGIN VkImportMemoryWin32HandleInfoKHR ## **/

class _VkImportMemoryWin32HandleInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkImportMemoryWin32HandleInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImportMemoryWin32HandleInfoKHR();
    ~_VkImportMemoryWin32HandleInfoKHR();

};

/*
#include "index.h"
#include "VkImportMemoryWin32HandleInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImportMemoryWin32HandleInfoKHR::constructor;

_VkImportMemoryWin32HandleInfoKHR::_VkImportMemoryWin32HandleInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
  
}

_VkImportMemoryWin32HandleInfoKHR::~_VkImportMemoryWin32HandleInfoKHR() {
  //printf("VkImportMemoryWin32HandleInfoKHR deconstructed!!\n");
  
  
  
}

void _VkImportMemoryWin32HandleInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImportMemoryWin32HandleInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImportMemoryWin32HandleInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkImportMemoryWin32HandleInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImportMemoryWin32HandleInfoKHR::flush() {
  _VkImportMemoryWin32HandleInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImportMemoryWin32HandleInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkImportMemoryWin32HandleInfoKHR* self = new _VkImportMemoryWin32HandleInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImportMemoryWin32HandleInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImportMemoryWin32HandleInfoKHR::GetsType) {
  _VkImportMemoryWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImportMemoryWin32HandleInfoKHR::SetsType) {
  _VkImportMemoryWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryWin32HandleInfoKHR.sType", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkImportMemoryWin32HandleInfoKHR::GethandleType) {
  _VkImportMemoryWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryWin32HandleInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkImportMemoryWin32HandleInfoKHR::SethandleType) {
  _VkImportMemoryWin32HandleInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryWin32HandleInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryWin32HandleInfoKHR.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportMemoryWin32HandleInfoKHR ## **/

/** ## BEGIN VkExportMemoryAllocateInfoKHR ## **/

class _VkExportMemoryAllocateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExportMemoryAllocateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportMemoryAllocateInfoKHR();
    ~_VkExportMemoryAllocateInfoKHR();

};

/*
#include "index.h"
#include "VkExportMemoryAllocateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportMemoryAllocateInfoKHR::constructor;

_VkExportMemoryAllocateInfoKHR::_VkExportMemoryAllocateInfoKHR() {
  
  
}

_VkExportMemoryAllocateInfoKHR::~_VkExportMemoryAllocateInfoKHR() {
  //printf("VkExportMemoryAllocateInfoKHR deconstructed!!\n");
  
}

void _VkExportMemoryAllocateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportMemoryAllocateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportMemoryAllocateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExportMemoryAllocateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportMemoryAllocateInfoKHR::flush() {
  _VkExportMemoryAllocateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExportMemoryAllocateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkExportMemoryAllocateInfoKHR* self = new _VkExportMemoryAllocateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportMemoryAllocateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExportMemoryAllocateInfoKHR ## **/

/** ## BEGIN VkExportMemoryAllocateInfo ## **/

class _VkExportMemoryAllocateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleTypes);
    static NAN_SETTER(SethandleTypes);
    

    // real instance
    VkExportMemoryAllocateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportMemoryAllocateInfo();
    ~_VkExportMemoryAllocateInfo();

};

/*
#include "index.h"
#include "VkExportMemoryAllocateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportMemoryAllocateInfo::constructor;

_VkExportMemoryAllocateInfo::_VkExportMemoryAllocateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO;
  
}

_VkExportMemoryAllocateInfo::~_VkExportMemoryAllocateInfo() {
  //printf("VkExportMemoryAllocateInfo deconstructed!!\n");
  
  
  
}

void _VkExportMemoryAllocateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportMemoryAllocateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportMemoryAllocateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleTypes").ToLocalChecked(), GethandleTypes, SethandleTypes, ctor);
  Nan::Set(target, Nan::New("VkExportMemoryAllocateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportMemoryAllocateInfo::flush() {
  _VkExportMemoryAllocateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkExportMemoryAllocateInfo::New) {
  if (info.IsConstructCall()) {
    _VkExportMemoryAllocateInfo* self = new _VkExportMemoryAllocateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleTypes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportMemoryAllocateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExportMemoryAllocateInfo::GetsType) {
  _VkExportMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExportMemoryAllocateInfo::SetsType) {
  _VkExportMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportMemoryAllocateInfo.sType", "Number");
  
    return;
  }
}// handleTypes
NAN_GETTER(_VkExportMemoryAllocateInfo::GethandleTypes) {
  _VkExportMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleTypes));
}NAN_SETTER(_VkExportMemoryAllocateInfo::SethandleTypes) {
  _VkExportMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportMemoryAllocateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportMemoryAllocateInfo ## **/

/** ## BEGIN VkExternalMemoryBufferCreateInfoKHR ## **/

class _VkExternalMemoryBufferCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExternalMemoryBufferCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalMemoryBufferCreateInfoKHR();
    ~_VkExternalMemoryBufferCreateInfoKHR();

};

/*
#include "index.h"
#include "VkExternalMemoryBufferCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalMemoryBufferCreateInfoKHR::constructor;

_VkExternalMemoryBufferCreateInfoKHR::_VkExternalMemoryBufferCreateInfoKHR() {
  
  
}

_VkExternalMemoryBufferCreateInfoKHR::~_VkExternalMemoryBufferCreateInfoKHR() {
  //printf("VkExternalMemoryBufferCreateInfoKHR deconstructed!!\n");
  
}

void _VkExternalMemoryBufferCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalMemoryBufferCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalMemoryBufferCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExternalMemoryBufferCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalMemoryBufferCreateInfoKHR::flush() {
  _VkExternalMemoryBufferCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalMemoryBufferCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkExternalMemoryBufferCreateInfoKHR* self = new _VkExternalMemoryBufferCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalMemoryBufferCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExternalMemoryBufferCreateInfoKHR ## **/

/** ## BEGIN VkExternalMemoryBufferCreateInfo ## **/

class _VkExternalMemoryBufferCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleTypes);
    static NAN_SETTER(SethandleTypes);
    

    // real instance
    VkExternalMemoryBufferCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalMemoryBufferCreateInfo();
    ~_VkExternalMemoryBufferCreateInfo();

};

/*
#include "index.h"
#include "VkExternalMemoryBufferCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalMemoryBufferCreateInfo::constructor;

_VkExternalMemoryBufferCreateInfo::_VkExternalMemoryBufferCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
  
}

_VkExternalMemoryBufferCreateInfo::~_VkExternalMemoryBufferCreateInfo() {
  //printf("VkExternalMemoryBufferCreateInfo deconstructed!!\n");
  
  
  
}

void _VkExternalMemoryBufferCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalMemoryBufferCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalMemoryBufferCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleTypes").ToLocalChecked(), GethandleTypes, SethandleTypes, ctor);
  Nan::Set(target, Nan::New("VkExternalMemoryBufferCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalMemoryBufferCreateInfo::flush() {
  _VkExternalMemoryBufferCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalMemoryBufferCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkExternalMemoryBufferCreateInfo* self = new _VkExternalMemoryBufferCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleTypes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalMemoryBufferCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExternalMemoryBufferCreateInfo::GetsType) {
  _VkExternalMemoryBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryBufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExternalMemoryBufferCreateInfo::SetsType) {
  _VkExternalMemoryBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryBufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExternalMemoryBufferCreateInfo.sType", "Number");
  
    return;
  }
}// handleTypes
NAN_GETTER(_VkExternalMemoryBufferCreateInfo::GethandleTypes) {
  _VkExternalMemoryBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryBufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleTypes));
}NAN_SETTER(_VkExternalMemoryBufferCreateInfo::SethandleTypes) {
  _VkExternalMemoryBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryBufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExternalMemoryBufferCreateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExternalMemoryBufferCreateInfo ## **/

/** ## BEGIN VkExternalMemoryImageCreateInfoKHR ## **/

class _VkExternalMemoryImageCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExternalMemoryImageCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalMemoryImageCreateInfoKHR();
    ~_VkExternalMemoryImageCreateInfoKHR();

};

/*
#include "index.h"
#include "VkExternalMemoryImageCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalMemoryImageCreateInfoKHR::constructor;

_VkExternalMemoryImageCreateInfoKHR::_VkExternalMemoryImageCreateInfoKHR() {
  
  
}

_VkExternalMemoryImageCreateInfoKHR::~_VkExternalMemoryImageCreateInfoKHR() {
  //printf("VkExternalMemoryImageCreateInfoKHR deconstructed!!\n");
  
}

void _VkExternalMemoryImageCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalMemoryImageCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalMemoryImageCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExternalMemoryImageCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalMemoryImageCreateInfoKHR::flush() {
  _VkExternalMemoryImageCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalMemoryImageCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkExternalMemoryImageCreateInfoKHR* self = new _VkExternalMemoryImageCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalMemoryImageCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExternalMemoryImageCreateInfoKHR ## **/

/** ## BEGIN VkExternalMemoryImageCreateInfo ## **/

class _VkExternalMemoryImageCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleTypes);
    static NAN_SETTER(SethandleTypes);
    

    // real instance
    VkExternalMemoryImageCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalMemoryImageCreateInfo();
    ~_VkExternalMemoryImageCreateInfo();

};

/*
#include "index.h"
#include "VkExternalMemoryImageCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalMemoryImageCreateInfo::constructor;

_VkExternalMemoryImageCreateInfo::_VkExternalMemoryImageCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
  
}

_VkExternalMemoryImageCreateInfo::~_VkExternalMemoryImageCreateInfo() {
  //printf("VkExternalMemoryImageCreateInfo deconstructed!!\n");
  
  
  
}

void _VkExternalMemoryImageCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalMemoryImageCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalMemoryImageCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleTypes").ToLocalChecked(), GethandleTypes, SethandleTypes, ctor);
  Nan::Set(target, Nan::New("VkExternalMemoryImageCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalMemoryImageCreateInfo::flush() {
  _VkExternalMemoryImageCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalMemoryImageCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkExternalMemoryImageCreateInfo* self = new _VkExternalMemoryImageCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleTypes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalMemoryImageCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExternalMemoryImageCreateInfo::GetsType) {
  _VkExternalMemoryImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExternalMemoryImageCreateInfo::SetsType) {
  _VkExternalMemoryImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExternalMemoryImageCreateInfo.sType", "Number");
  
    return;
  }
}// handleTypes
NAN_GETTER(_VkExternalMemoryImageCreateInfo::GethandleTypes) {
  _VkExternalMemoryImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleTypes));
}NAN_SETTER(_VkExternalMemoryImageCreateInfo::SethandleTypes) {
  _VkExternalMemoryImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExternalMemoryImageCreateInfo.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExternalMemoryImageCreateInfo ## **/

/** ## BEGIN VkPhysicalDeviceIDPropertiesKHR ## **/

class _VkPhysicalDeviceIDPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceIDPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceIDPropertiesKHR();
    ~_VkPhysicalDeviceIDPropertiesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceIDPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceIDPropertiesKHR::constructor;

_VkPhysicalDeviceIDPropertiesKHR::_VkPhysicalDeviceIDPropertiesKHR() {
  
  
}

_VkPhysicalDeviceIDPropertiesKHR::~_VkPhysicalDeviceIDPropertiesKHR() {
  //printf("VkPhysicalDeviceIDPropertiesKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceIDPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceIDPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceIDPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceIDPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceIDPropertiesKHR::flush() {
  _VkPhysicalDeviceIDPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceIDPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceIDPropertiesKHR* self = new _VkPhysicalDeviceIDPropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceIDPropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceIDPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceIDProperties ## **/

class _VkPhysicalDeviceIDProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    std::vector<uint8_t>* vdeviceUUID;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> deviceUUID;
    static NAN_GETTER(GetdeviceUUID);
    std::vector<uint8_t>* vdriverUUID;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> driverUUID;
    static NAN_GETTER(GetdriverUUID);
    std::vector<uint8_t>* vdeviceLUID;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> deviceLUID;
    static NAN_GETTER(GetdeviceLUID);
    static NAN_GETTER(GetdeviceNodeMask);
    static NAN_GETTER(GetdeviceLUIDValid);

    // real instance
    VkPhysicalDeviceIDProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceIDProperties();
    ~_VkPhysicalDeviceIDProperties();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceIDProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceIDProperties::constructor;

_VkPhysicalDeviceIDProperties::_VkPhysicalDeviceIDProperties() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
  vdeviceUUID = new std::vector<uint8_t>;
  vdriverUUID = new std::vector<uint8_t>;
  vdeviceLUID = new std::vector<uint8_t>;
  
}

_VkPhysicalDeviceIDProperties::~_VkPhysicalDeviceIDProperties() {
  //printf("VkPhysicalDeviceIDProperties deconstructed!!\n");
  
  
  vdeviceUUID->clear();
  delete vdeviceUUID;
  
  
  vdriverUUID->clear();
  delete vdriverUUID;
  
  
  vdeviceLUID->clear();
  delete vdeviceLUID;
  
  
  
  
}

void _VkPhysicalDeviceIDProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceIDProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceIDProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceUUID").ToLocalChecked(), GetdeviceUUID, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("driverUUID").ToLocalChecked(), GetdriverUUID, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceLUID").ToLocalChecked(), GetdeviceLUID, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceNodeMask").ToLocalChecked(), GetdeviceNodeMask, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceLUIDValid").ToLocalChecked(), GetdeviceLUIDValid, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceIDProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceIDProperties::flush() {
  _VkPhysicalDeviceIDProperties *self = this;
  if (!(self->deviceUUID.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->deviceUUID);
    
  }if (!(self->driverUUID.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->driverUUID);
    
  }if (!(self->deviceLUID.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->deviceLUID);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceIDProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceIDProperties* self = new _VkPhysicalDeviceIDProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceIDProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceIDProperties::GetsType) {
  _VkPhysicalDeviceIDProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceIDProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// deviceUUID
NAN_GETTER(_VkPhysicalDeviceIDProperties::GetdeviceUUID) {
  _VkPhysicalDeviceIDProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceIDProperties>(info.This());
  if (self->deviceUUID.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->deviceUUID));
  }
}// driverUUID
NAN_GETTER(_VkPhysicalDeviceIDProperties::GetdriverUUID) {
  _VkPhysicalDeviceIDProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceIDProperties>(info.This());
  if (self->driverUUID.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->driverUUID));
  }
}// deviceLUID
NAN_GETTER(_VkPhysicalDeviceIDProperties::GetdeviceLUID) {
  _VkPhysicalDeviceIDProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceIDProperties>(info.This());
  if (self->deviceLUID.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->deviceLUID));
  }
}// deviceNodeMask
NAN_GETTER(_VkPhysicalDeviceIDProperties::GetdeviceNodeMask) {
  _VkPhysicalDeviceIDProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceIDProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceNodeMask));
}// deviceLUIDValid
NAN_GETTER(_VkPhysicalDeviceIDProperties::GetdeviceLUIDValid) {
  _VkPhysicalDeviceIDProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceIDProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceLUIDValid));
}
/** ## END VkPhysicalDeviceIDProperties ## **/

/** ## BEGIN VkExternalBufferPropertiesKHR ## **/

class _VkExternalBufferPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExternalBufferPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalBufferPropertiesKHR();
    ~_VkExternalBufferPropertiesKHR();

};

/*
#include "index.h"
#include "VkExternalBufferPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalBufferPropertiesKHR::constructor;

_VkExternalBufferPropertiesKHR::_VkExternalBufferPropertiesKHR() {
  
  
}

_VkExternalBufferPropertiesKHR::~_VkExternalBufferPropertiesKHR() {
  //printf("VkExternalBufferPropertiesKHR deconstructed!!\n");
  
}

void _VkExternalBufferPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalBufferPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalBufferPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExternalBufferPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalBufferPropertiesKHR::flush() {
  _VkExternalBufferPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalBufferPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkExternalBufferPropertiesKHR* self = new _VkExternalBufferPropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalBufferPropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExternalBufferPropertiesKHR ## **/

/** ## BEGIN VkExternalMemoryProperties ## **/

class _VkExternalMemoryProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetexternalMemoryFeatures);
    static NAN_GETTER(GetexportFromImportedHandleTypes);
    static NAN_GETTER(GetcompatibleHandleTypes);

    // real instance
    VkExternalMemoryProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalMemoryProperties();
    ~_VkExternalMemoryProperties();

};

/*
#include "index.h"
#include "VkExternalMemoryProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalMemoryProperties::constructor;

_VkExternalMemoryProperties::_VkExternalMemoryProperties() {
  
  
}

_VkExternalMemoryProperties::~_VkExternalMemoryProperties() {
  //printf("VkExternalMemoryProperties deconstructed!!\n");
  
  
  
  
}

void _VkExternalMemoryProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalMemoryProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalMemoryProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("externalMemoryFeatures").ToLocalChecked(), GetexternalMemoryFeatures, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("exportFromImportedHandleTypes").ToLocalChecked(), GetexportFromImportedHandleTypes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("compatibleHandleTypes").ToLocalChecked(), GetcompatibleHandleTypes, nullptr, ctor);
  Nan::Set(target, Nan::New("VkExternalMemoryProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalMemoryProperties::flush() {
  _VkExternalMemoryProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalMemoryProperties::New) {
  if (info.IsConstructCall()) {
    _VkExternalMemoryProperties* self = new _VkExternalMemoryProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalMemoryProperties constructor cannot be invoked without 'new'");
  }
};

// externalMemoryFeatures
NAN_GETTER(_VkExternalMemoryProperties::GetexternalMemoryFeatures) {
  _VkExternalMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.externalMemoryFeatures));
}// exportFromImportedHandleTypes
NAN_GETTER(_VkExternalMemoryProperties::GetexportFromImportedHandleTypes) {
  _VkExternalMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.exportFromImportedHandleTypes));
}// compatibleHandleTypes
NAN_GETTER(_VkExternalMemoryProperties::GetcompatibleHandleTypes) {
  _VkExternalMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compatibleHandleTypes));
}
/** ## END VkExternalMemoryProperties ## **/

/** ## BEGIN VkExternalBufferProperties ## **/

class _VkExternalBufferProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> externalMemoryProperties;
      static NAN_GETTER(GetexternalMemoryProperties);

    // real instance
    VkExternalBufferProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalBufferProperties();
    ~_VkExternalBufferProperties();

};

/*
#include "index.h"
#include "VkExternalBufferProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalBufferProperties::constructor;

_VkExternalBufferProperties::_VkExternalBufferProperties() {
  instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES;
  
}

_VkExternalBufferProperties::~_VkExternalBufferProperties() {
  //printf("VkExternalBufferProperties deconstructed!!\n");
  
  
  
}

void _VkExternalBufferProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalBufferProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalBufferProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("externalMemoryProperties").ToLocalChecked(), GetexternalMemoryProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkExternalBufferProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalBufferProperties::flush() {
  _VkExternalBufferProperties *self = this;
  if (!(self->externalMemoryProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->externalMemoryProperties);
    
  }
  return true;
}

NAN_METHOD(_VkExternalBufferProperties::New) {
  if (info.IsConstructCall()) {
    _VkExternalBufferProperties* self = new _VkExternalBufferProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalBufferProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExternalBufferProperties::GetsType) {
  _VkExternalBufferProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalBufferProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// externalMemoryProperties
NAN_GETTER(_VkExternalBufferProperties::GetexternalMemoryProperties) {
  _VkExternalBufferProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalBufferProperties>(info.This());
  if (self->externalMemoryProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->externalMemoryProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkExternalBufferProperties ## **/

/** ## BEGIN VkPhysicalDeviceExternalBufferInfoKHR ## **/

class _VkPhysicalDeviceExternalBufferInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceExternalBufferInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalBufferInfoKHR();
    ~_VkPhysicalDeviceExternalBufferInfoKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalBufferInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalBufferInfoKHR::constructor;

_VkPhysicalDeviceExternalBufferInfoKHR::_VkPhysicalDeviceExternalBufferInfoKHR() {
  
  
}

_VkPhysicalDeviceExternalBufferInfoKHR::~_VkPhysicalDeviceExternalBufferInfoKHR() {
  //printf("VkPhysicalDeviceExternalBufferInfoKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceExternalBufferInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalBufferInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalBufferInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalBufferInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalBufferInfoKHR::flush() {
  _VkPhysicalDeviceExternalBufferInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalBufferInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalBufferInfoKHR* self = new _VkPhysicalDeviceExternalBufferInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalBufferInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceExternalBufferInfoKHR ## **/

/** ## BEGIN VkPhysicalDeviceExternalBufferInfo ## **/

class _VkPhysicalDeviceExternalBufferInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(Getusage);
    static NAN_SETTER(Setusage);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkPhysicalDeviceExternalBufferInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalBufferInfo();
    ~_VkPhysicalDeviceExternalBufferInfo();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalBufferInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalBufferInfo::constructor;

_VkPhysicalDeviceExternalBufferInfo::_VkPhysicalDeviceExternalBufferInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO;
  
}

_VkPhysicalDeviceExternalBufferInfo::~_VkPhysicalDeviceExternalBufferInfo() {
  //printf("VkPhysicalDeviceExternalBufferInfo deconstructed!!\n");
  
  
  
  
  
}

void _VkPhysicalDeviceExternalBufferInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalBufferInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalBufferInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("usage").ToLocalChecked(), Getusage, Setusage, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalBufferInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalBufferInfo::flush() {
  _VkPhysicalDeviceExternalBufferInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalBufferInfo::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalBufferInfo* self = new _VkPhysicalDeviceExternalBufferInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("usage").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalBufferInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceExternalBufferInfo::GetsType) {
  _VkPhysicalDeviceExternalBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalBufferInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceExternalBufferInfo::SetsType) {
  _VkPhysicalDeviceExternalBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalBufferInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalBufferInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPhysicalDeviceExternalBufferInfo::Getflags) {
  _VkPhysicalDeviceExternalBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalBufferInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPhysicalDeviceExternalBufferInfo::Setflags) {
  _VkPhysicalDeviceExternalBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalBufferInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkBufferCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalBufferInfo.flags", "Number");
  
    return;
  }
}// usage
NAN_GETTER(_VkPhysicalDeviceExternalBufferInfo::Getusage) {
  _VkPhysicalDeviceExternalBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalBufferInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.usage));
}NAN_SETTER(_VkPhysicalDeviceExternalBufferInfo::Setusage) {
  _VkPhysicalDeviceExternalBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalBufferInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.usage = static_cast<VkBufferUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalBufferInfo.usage", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkPhysicalDeviceExternalBufferInfo::GethandleType) {
  _VkPhysicalDeviceExternalBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalBufferInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkPhysicalDeviceExternalBufferInfo::SethandleType) {
  _VkPhysicalDeviceExternalBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalBufferInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalBufferInfo.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalBufferInfo ## **/

/** ## BEGIN VkExternalImageFormatPropertiesKHR ## **/

class _VkExternalImageFormatPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExternalImageFormatPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalImageFormatPropertiesKHR();
    ~_VkExternalImageFormatPropertiesKHR();

};

/*
#include "index.h"
#include "VkExternalImageFormatPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalImageFormatPropertiesKHR::constructor;

_VkExternalImageFormatPropertiesKHR::_VkExternalImageFormatPropertiesKHR() {
  
  
}

_VkExternalImageFormatPropertiesKHR::~_VkExternalImageFormatPropertiesKHR() {
  //printf("VkExternalImageFormatPropertiesKHR deconstructed!!\n");
  
}

void _VkExternalImageFormatPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalImageFormatPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalImageFormatPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExternalImageFormatPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalImageFormatPropertiesKHR::flush() {
  _VkExternalImageFormatPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalImageFormatPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkExternalImageFormatPropertiesKHR* self = new _VkExternalImageFormatPropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalImageFormatPropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExternalImageFormatPropertiesKHR ## **/

/** ## BEGIN VkExternalImageFormatProperties ## **/

class _VkExternalImageFormatProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> externalMemoryProperties;
      static NAN_GETTER(GetexternalMemoryProperties);

    // real instance
    VkExternalImageFormatProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalImageFormatProperties();
    ~_VkExternalImageFormatProperties();

};

/*
#include "index.h"
#include "VkExternalImageFormatProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalImageFormatProperties::constructor;

_VkExternalImageFormatProperties::_VkExternalImageFormatProperties() {
  instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES;
  
}

_VkExternalImageFormatProperties::~_VkExternalImageFormatProperties() {
  //printf("VkExternalImageFormatProperties deconstructed!!\n");
  
  
  
}

void _VkExternalImageFormatProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalImageFormatProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalImageFormatProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("externalMemoryProperties").ToLocalChecked(), GetexternalMemoryProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkExternalImageFormatProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalImageFormatProperties::flush() {
  _VkExternalImageFormatProperties *self = this;
  if (!(self->externalMemoryProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->externalMemoryProperties);
    
  }
  return true;
}

NAN_METHOD(_VkExternalImageFormatProperties::New) {
  if (info.IsConstructCall()) {
    _VkExternalImageFormatProperties* self = new _VkExternalImageFormatProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalImageFormatProperties constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExternalImageFormatProperties::GetsType) {
  _VkExternalImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// externalMemoryProperties
NAN_GETTER(_VkExternalImageFormatProperties::GetexternalMemoryProperties) {
  _VkExternalImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkExternalImageFormatProperties>(info.This());
  if (self->externalMemoryProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->externalMemoryProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkExternalImageFormatProperties ## **/

/** ## BEGIN VkPhysicalDeviceExternalImageFormatInfoKHR ## **/

class _VkPhysicalDeviceExternalImageFormatInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceExternalImageFormatInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalImageFormatInfoKHR();
    ~_VkPhysicalDeviceExternalImageFormatInfoKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalImageFormatInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalImageFormatInfoKHR::constructor;

_VkPhysicalDeviceExternalImageFormatInfoKHR::_VkPhysicalDeviceExternalImageFormatInfoKHR() {
  
  
}

_VkPhysicalDeviceExternalImageFormatInfoKHR::~_VkPhysicalDeviceExternalImageFormatInfoKHR() {
  //printf("VkPhysicalDeviceExternalImageFormatInfoKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceExternalImageFormatInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalImageFormatInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalImageFormatInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalImageFormatInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalImageFormatInfoKHR::flush() {
  _VkPhysicalDeviceExternalImageFormatInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalImageFormatInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalImageFormatInfoKHR* self = new _VkPhysicalDeviceExternalImageFormatInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalImageFormatInfoKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceExternalImageFormatInfoKHR ## **/

/** ## BEGIN VkPhysicalDeviceExternalImageFormatInfo ## **/

class _VkPhysicalDeviceExternalImageFormatInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkPhysicalDeviceExternalImageFormatInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceExternalImageFormatInfo();
    ~_VkPhysicalDeviceExternalImageFormatInfo();

};

/*
#include "index.h"
#include "VkPhysicalDeviceExternalImageFormatInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceExternalImageFormatInfo::constructor;

_VkPhysicalDeviceExternalImageFormatInfo::_VkPhysicalDeviceExternalImageFormatInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO;
  
}

_VkPhysicalDeviceExternalImageFormatInfo::~_VkPhysicalDeviceExternalImageFormatInfo() {
  //printf("VkPhysicalDeviceExternalImageFormatInfo deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceExternalImageFormatInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceExternalImageFormatInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceExternalImageFormatInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceExternalImageFormatInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceExternalImageFormatInfo::flush() {
  _VkPhysicalDeviceExternalImageFormatInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceExternalImageFormatInfo::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceExternalImageFormatInfo* self = new _VkPhysicalDeviceExternalImageFormatInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceExternalImageFormatInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceExternalImageFormatInfo::GetsType) {
  _VkPhysicalDeviceExternalImageFormatInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalImageFormatInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceExternalImageFormatInfo::SetsType) {
  _VkPhysicalDeviceExternalImageFormatInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalImageFormatInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalImageFormatInfo.sType", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkPhysicalDeviceExternalImageFormatInfo::GethandleType) {
  _VkPhysicalDeviceExternalImageFormatInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalImageFormatInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkPhysicalDeviceExternalImageFormatInfo::SethandleType) {
  _VkPhysicalDeviceExternalImageFormatInfo *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceExternalImageFormatInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceExternalImageFormatInfo.handleType", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceExternalImageFormatInfo ## **/

/** ## BEGIN VkExternalMemoryPropertiesKHR ## **/

class _VkExternalMemoryPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkExternalMemoryPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalMemoryPropertiesKHR();
    ~_VkExternalMemoryPropertiesKHR();

};

/*
#include "index.h"
#include "VkExternalMemoryPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalMemoryPropertiesKHR::constructor;

_VkExternalMemoryPropertiesKHR::_VkExternalMemoryPropertiesKHR() {
  
  
}

_VkExternalMemoryPropertiesKHR::~_VkExternalMemoryPropertiesKHR() {
  //printf("VkExternalMemoryPropertiesKHR deconstructed!!\n");
  
}

void _VkExternalMemoryPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalMemoryPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalMemoryPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkExternalMemoryPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalMemoryPropertiesKHR::flush() {
  _VkExternalMemoryPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalMemoryPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkExternalMemoryPropertiesKHR* self = new _VkExternalMemoryPropertiesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalMemoryPropertiesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkExternalMemoryPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceVariablePointerFeaturesKHR ## **/

class _VkPhysicalDeviceVariablePointerFeaturesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceVariablePointerFeaturesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceVariablePointerFeaturesKHR();
    ~_VkPhysicalDeviceVariablePointerFeaturesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceVariablePointerFeaturesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceVariablePointerFeaturesKHR::constructor;

_VkPhysicalDeviceVariablePointerFeaturesKHR::_VkPhysicalDeviceVariablePointerFeaturesKHR() {
  
  
}

_VkPhysicalDeviceVariablePointerFeaturesKHR::~_VkPhysicalDeviceVariablePointerFeaturesKHR() {
  //printf("VkPhysicalDeviceVariablePointerFeaturesKHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceVariablePointerFeaturesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceVariablePointerFeaturesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceVariablePointerFeaturesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceVariablePointerFeaturesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceVariablePointerFeaturesKHR::flush() {
  _VkPhysicalDeviceVariablePointerFeaturesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceVariablePointerFeaturesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceVariablePointerFeaturesKHR* self = new _VkPhysicalDeviceVariablePointerFeaturesKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceVariablePointerFeaturesKHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceVariablePointerFeaturesKHR ## **/

/** ## BEGIN VkPhysicalDeviceVariablePointerFeatures ## **/

class _VkPhysicalDeviceVariablePointerFeatures: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetvariablePointersStorageBuffer);
    static NAN_SETTER(SetvariablePointersStorageBuffer);
    
    static NAN_GETTER(GetvariablePointers);
    static NAN_SETTER(SetvariablePointers);
    

    // real instance
    VkPhysicalDeviceVariablePointerFeatures instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceVariablePointerFeatures();
    ~_VkPhysicalDeviceVariablePointerFeatures();

};

/*
#include "index.h"
#include "VkPhysicalDeviceVariablePointerFeatures.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceVariablePointerFeatures::constructor;

_VkPhysicalDeviceVariablePointerFeatures::_VkPhysicalDeviceVariablePointerFeatures() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
  
}

_VkPhysicalDeviceVariablePointerFeatures::~_VkPhysicalDeviceVariablePointerFeatures() {
  //printf("VkPhysicalDeviceVariablePointerFeatures deconstructed!!\n");
  
  
  
  
}

void _VkPhysicalDeviceVariablePointerFeatures::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceVariablePointerFeatures::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceVariablePointerFeatures").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("variablePointersStorageBuffer").ToLocalChecked(), GetvariablePointersStorageBuffer, SetvariablePointersStorageBuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("variablePointers").ToLocalChecked(), GetvariablePointers, SetvariablePointers, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceVariablePointerFeatures").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceVariablePointerFeatures::flush() {
  _VkPhysicalDeviceVariablePointerFeatures *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceVariablePointerFeatures::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceVariablePointerFeatures* self = new _VkPhysicalDeviceVariablePointerFeatures();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("variablePointersStorageBuffer").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("variablePointers").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceVariablePointerFeatures constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceVariablePointerFeatures::GetsType) {
  _VkPhysicalDeviceVariablePointerFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVariablePointerFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceVariablePointerFeatures::SetsType) {
  _VkPhysicalDeviceVariablePointerFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVariablePointerFeatures>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVariablePointerFeatures.sType", "Number");
  
    return;
  }
}// variablePointersStorageBuffer
NAN_GETTER(_VkPhysicalDeviceVariablePointerFeatures::GetvariablePointersStorageBuffer) {
  _VkPhysicalDeviceVariablePointerFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVariablePointerFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.variablePointersStorageBuffer));
}NAN_SETTER(_VkPhysicalDeviceVariablePointerFeatures::SetvariablePointersStorageBuffer) {
  _VkPhysicalDeviceVariablePointerFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVariablePointerFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.variablePointersStorageBuffer = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVariablePointerFeatures.variablePointersStorageBuffer", "Number");
  
    return;
  }
}// variablePointers
NAN_GETTER(_VkPhysicalDeviceVariablePointerFeatures::GetvariablePointers) {
  _VkPhysicalDeviceVariablePointerFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVariablePointerFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.variablePointers));
}NAN_SETTER(_VkPhysicalDeviceVariablePointerFeatures::SetvariablePointers) {
  _VkPhysicalDeviceVariablePointerFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceVariablePointerFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.variablePointers = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceVariablePointerFeatures.variablePointers", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceVariablePointerFeatures ## **/

/** ## BEGIN VkRectLayerKHR ## **/

class _VkRectLayerKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> offset;
      static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> extent;
      static NAN_GETTER(Getextent);
    static NAN_SETTER(Setextent);
    
    static NAN_GETTER(Getlayer);
    static NAN_SETTER(Setlayer);
    

    // real instance
    VkRectLayerKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRectLayerKHR();
    ~_VkRectLayerKHR();

};

/*
#include "index.h"
#include "VkRectLayerKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRectLayerKHR::constructor;

_VkRectLayerKHR::_VkRectLayerKHR() {
  
  
}

_VkRectLayerKHR::~_VkRectLayerKHR() {
  //printf("VkRectLayerKHR deconstructed!!\n");
  
  
  
  
}

void _VkRectLayerKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRectLayerKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRectLayerKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("extent").ToLocalChecked(), Getextent, Setextent, ctor);
  SetPrototypeAccessor(proto, Nan::New("layer").ToLocalChecked(), Getlayer, Setlayer, ctor);
  Nan::Set(target, Nan::New("VkRectLayerKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRectLayerKHR::flush() {
  _VkRectLayerKHR *self = this;
  if (!(self->offset.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->offset);
    
    _VkOffset2D* result = Nan::ObjectWrap::Unwrap<_VkOffset2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.offset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->extent);
    
    _VkExtent2D* result = Nan::ObjectWrap::Unwrap<_VkExtent2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkRectLayerKHR::New) {
  if (info.IsConstructCall()) {
    _VkRectLayerKHR* self = new _VkRectLayerKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("extent").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("layer").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRectLayerKHR constructor cannot be invoked without 'new'");
  }
};

// offset
NAN_GETTER(_VkRectLayerKHR::Getoffset) {
  _VkRectLayerKHR *self = Nan::ObjectWrap::Unwrap<_VkRectLayerKHR>(info.This());
  if (self->offset.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->offset);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRectLayerKHR::Setoffset) {
  _VkRectLayerKHR *self = Nan::ObjectWrap::Unwrap<_VkRectLayerKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkOffset2D::constructor)->HasInstance(obj)) {
      self->offset.Reset<v8::Object>(value.As<v8::Object>());
      _VkOffset2D* inst = Nan::ObjectWrap::Unwrap<_VkOffset2D>(obj);
      inst->flush();
      self->instance.offset = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRectLayerKHR.offset", "[object VkOffset2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->offset.Reset();
    memset(&self->instance.offset, 0, sizeof(VkOffset2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRectLayerKHR.offset", "[object VkOffset2D]");
  
    return;
  }
}// extent
NAN_GETTER(_VkRectLayerKHR::Getextent) {
  _VkRectLayerKHR *self = Nan::ObjectWrap::Unwrap<_VkRectLayerKHR>(info.This());
  if (self->extent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->extent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRectLayerKHR::Setextent) {
  _VkRectLayerKHR *self = Nan::ObjectWrap::Unwrap<_VkRectLayerKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent2D::constructor)->HasInstance(obj)) {
      self->extent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent2D* inst = Nan::ObjectWrap::Unwrap<_VkExtent2D>(obj);
      inst->flush();
      self->instance.extent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRectLayerKHR.extent", "[object VkExtent2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->extent.Reset();
    memset(&self->instance.extent, 0, sizeof(VkExtent2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRectLayerKHR.extent", "[object VkExtent2D]");
  
    return;
  }
}// layer
NAN_GETTER(_VkRectLayerKHR::Getlayer) {
  _VkRectLayerKHR *self = Nan::ObjectWrap::Unwrap<_VkRectLayerKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.layer));
}NAN_SETTER(_VkRectLayerKHR::Setlayer) {
  _VkRectLayerKHR *self = Nan::ObjectWrap::Unwrap<_VkRectLayerKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.layer = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRectLayerKHR.layer", "Number");
  
    return;
  }
}
/** ## END VkRectLayerKHR ## **/

/** ## BEGIN VkPresentRegionKHR ## **/

class _VkPresentRegionKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetrectangleCount);
    static NAN_SETTER(SetrectangleCount);
    
    std::vector<VkRectLayerKHR>* vpRectangles;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pRectangles;
    static NAN_GETTER(GetpRectangles);
    static NAN_SETTER(SetpRectangles);
    

    // real instance
    VkPresentRegionKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPresentRegionKHR();
    ~_VkPresentRegionKHR();

};

/*
#include "index.h"
#include "VkPresentRegionKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPresentRegionKHR::constructor;

_VkPresentRegionKHR::_VkPresentRegionKHR() {
  
  vpRectangles = new std::vector<VkRectLayerKHR>;
  
}

_VkPresentRegionKHR::~_VkPresentRegionKHR() {
  //printf("VkPresentRegionKHR deconstructed!!\n");
  
  
  vpRectangles->clear();
  delete vpRectangles;
  
  pRectangles.Reset();
  
}

void _VkPresentRegionKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPresentRegionKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPresentRegionKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("rectangleCount").ToLocalChecked(), GetrectangleCount, SetrectangleCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pRectangles").ToLocalChecked(), GetpRectangles, SetpRectangles, ctor);
  Nan::Set(target, Nan::New("VkPresentRegionKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPresentRegionKHR::flush() {
  _VkPresentRegionKHR *self = this;
  if (!(self->pRectangles.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pRectangles);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.rectangleCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'rectangleCount' for 'VkPresentRegionKHR.pRectangles'");
      return false;
    }
    std::vector<VkRectLayerKHR>* data = self->vpRectangles;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkRectLayerKHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPresentRegionKHR.pRectangles", "[object VkRectLayerKHR]");
  
        return false;
      }
      _VkRectLayerKHR* result = Nan::ObjectWrap::Unwrap<_VkRectLayerKHR>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pRectangles = data->data();
  }
  return true;
}

NAN_METHOD(_VkPresentRegionKHR::New) {
  if (info.IsConstructCall()) {
    _VkPresentRegionKHR* self = new _VkPresentRegionKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("rectangleCount").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("pRectangles").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPresentRegionKHR constructor cannot be invoked without 'new'");
  }
};

// rectangleCount
NAN_GETTER(_VkPresentRegionKHR::GetrectangleCount) {
  _VkPresentRegionKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.rectangleCount));
}NAN_SETTER(_VkPresentRegionKHR::SetrectangleCount) {
  _VkPresentRegionKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.rectangleCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentRegionKHR.rectangleCount", "Number");
  
    return;
  }
}// pRectangles
NAN_GETTER(_VkPresentRegionKHR::GetpRectangles) {
  _VkPresentRegionKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionKHR>(info.This());
  if (self->pRectangles.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pRectangles);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPresentRegionKHR::SetpRectangles) {
  _VkPresentRegionKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionKHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pRectangles.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pRectangles.Reset();
      self->instance.pRectangles = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPresentRegionKHR.pRectangles", "[object VkRectLayerKHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pRectangles = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentRegionKHR.pRectangles", "[object VkRectLayerKHR]");
  
    return;
  }
}
/** ## END VkPresentRegionKHR ## **/

/** ## BEGIN VkPresentRegionsKHR ## **/

class _VkPresentRegionsKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetswapchainCount);
    static NAN_SETTER(SetswapchainCount);
    
    std::vector<VkPresentRegionKHR>* vpRegions;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pRegions;
    static NAN_GETTER(GetpRegions);
    static NAN_SETTER(SetpRegions);
    

    // real instance
    VkPresentRegionsKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPresentRegionsKHR();
    ~_VkPresentRegionsKHR();

};

/*
#include "index.h"
#include "VkPresentRegionsKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPresentRegionsKHR::constructor;

_VkPresentRegionsKHR::_VkPresentRegionsKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
  vpRegions = new std::vector<VkPresentRegionKHR>;
  
}

_VkPresentRegionsKHR::~_VkPresentRegionsKHR() {
  //printf("VkPresentRegionsKHR deconstructed!!\n");
  
  
  
  vpRegions->clear();
  delete vpRegions;
  
  pRegions.Reset();
  
}

void _VkPresentRegionsKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPresentRegionsKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPresentRegionsKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("swapchainCount").ToLocalChecked(), GetswapchainCount, SetswapchainCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pRegions").ToLocalChecked(), GetpRegions, SetpRegions, ctor);
  Nan::Set(target, Nan::New("VkPresentRegionsKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPresentRegionsKHR::flush() {
  _VkPresentRegionsKHR *self = this;
  if (!(self->pRegions.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pRegions);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.swapchainCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'swapchainCount' for 'VkPresentRegionsKHR.pRegions'");
      return false;
    }
    std::vector<VkPresentRegionKHR>* data = self->vpRegions;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkPresentRegionKHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPresentRegionsKHR.pRegions", "[object VkPresentRegionKHR]");
  
        return false;
      }
      _VkPresentRegionKHR* result = Nan::ObjectWrap::Unwrap<_VkPresentRegionKHR>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pRegions = data->data();
  }
  return true;
}

NAN_METHOD(_VkPresentRegionsKHR::New) {
  if (info.IsConstructCall()) {
    _VkPresentRegionsKHR* self = new _VkPresentRegionsKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("swapchainCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pRegions").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPresentRegionsKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPresentRegionsKHR::GetsType) {
  _VkPresentRegionsKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionsKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPresentRegionsKHR::SetsType) {
  _VkPresentRegionsKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionsKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentRegionsKHR.sType", "Number");
  
    return;
  }
}// swapchainCount
NAN_GETTER(_VkPresentRegionsKHR::GetswapchainCount) {
  _VkPresentRegionsKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionsKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.swapchainCount));
}NAN_SETTER(_VkPresentRegionsKHR::SetswapchainCount) {
  _VkPresentRegionsKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionsKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.swapchainCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentRegionsKHR.swapchainCount", "Number");
  
    return;
  }
}// pRegions
NAN_GETTER(_VkPresentRegionsKHR::GetpRegions) {
  _VkPresentRegionsKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionsKHR>(info.This());
  if (self->pRegions.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pRegions);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPresentRegionsKHR::SetpRegions) {
  _VkPresentRegionsKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentRegionsKHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pRegions.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pRegions.Reset();
      self->instance.pRegions = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPresentRegionsKHR.pRegions", "[object VkPresentRegionKHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pRegions = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentRegionsKHR.pRegions", "[object VkPresentRegionKHR]");
  
    return;
  }
}
/** ## END VkPresentRegionsKHR ## **/

/** ## BEGIN VkConformanceVersionKHR ## **/

class _VkConformanceVersionKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getmajor);
    static NAN_SETTER(Setmajor);
    
    static NAN_GETTER(Getminor);
    static NAN_SETTER(Setminor);
    
    static NAN_GETTER(Getsubminor);
    static NAN_SETTER(Setsubminor);
    
    static NAN_GETTER(Getpatch);
    static NAN_SETTER(Setpatch);
    

    // real instance
    VkConformanceVersionKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkConformanceVersionKHR();
    ~_VkConformanceVersionKHR();

};

/*
#include "index.h"
#include "VkConformanceVersionKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkConformanceVersionKHR::constructor;

_VkConformanceVersionKHR::_VkConformanceVersionKHR() {
  
  
}

_VkConformanceVersionKHR::~_VkConformanceVersionKHR() {
  //printf("VkConformanceVersionKHR deconstructed!!\n");
  
  
  
  
  
}

void _VkConformanceVersionKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkConformanceVersionKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkConformanceVersionKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("major").ToLocalChecked(), Getmajor, Setmajor, ctor);
  SetPrototypeAccessor(proto, Nan::New("minor").ToLocalChecked(), Getminor, Setminor, ctor);
  SetPrototypeAccessor(proto, Nan::New("subminor").ToLocalChecked(), Getsubminor, Setsubminor, ctor);
  SetPrototypeAccessor(proto, Nan::New("patch").ToLocalChecked(), Getpatch, Setpatch, ctor);
  Nan::Set(target, Nan::New("VkConformanceVersionKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkConformanceVersionKHR::flush() {
  _VkConformanceVersionKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkConformanceVersionKHR::New) {
  if (info.IsConstructCall()) {
    _VkConformanceVersionKHR* self = new _VkConformanceVersionKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("major").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("minor").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("subminor").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("patch").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkConformanceVersionKHR constructor cannot be invoked without 'new'");
  }
};

// major
NAN_GETTER(_VkConformanceVersionKHR::Getmajor) {
  _VkConformanceVersionKHR *self = Nan::ObjectWrap::Unwrap<_VkConformanceVersionKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.major));
}NAN_SETTER(_VkConformanceVersionKHR::Setmajor) {
  _VkConformanceVersionKHR *self = Nan::ObjectWrap::Unwrap<_VkConformanceVersionKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.major = static_cast<uint8_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkConformanceVersionKHR.major", "Number");
  
    return;
  }
}// minor
NAN_GETTER(_VkConformanceVersionKHR::Getminor) {
  _VkConformanceVersionKHR *self = Nan::ObjectWrap::Unwrap<_VkConformanceVersionKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minor));
}NAN_SETTER(_VkConformanceVersionKHR::Setminor) {
  _VkConformanceVersionKHR *self = Nan::ObjectWrap::Unwrap<_VkConformanceVersionKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.minor = static_cast<uint8_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkConformanceVersionKHR.minor", "Number");
  
    return;
  }
}// subminor
NAN_GETTER(_VkConformanceVersionKHR::Getsubminor) {
  _VkConformanceVersionKHR *self = Nan::ObjectWrap::Unwrap<_VkConformanceVersionKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subminor));
}NAN_SETTER(_VkConformanceVersionKHR::Setsubminor) {
  _VkConformanceVersionKHR *self = Nan::ObjectWrap::Unwrap<_VkConformanceVersionKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.subminor = static_cast<uint8_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkConformanceVersionKHR.subminor", "Number");
  
    return;
  }
}// patch
NAN_GETTER(_VkConformanceVersionKHR::Getpatch) {
  _VkConformanceVersionKHR *self = Nan::ObjectWrap::Unwrap<_VkConformanceVersionKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.patch));
}NAN_SETTER(_VkConformanceVersionKHR::Setpatch) {
  _VkConformanceVersionKHR *self = Nan::ObjectWrap::Unwrap<_VkConformanceVersionKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.patch = static_cast<uint8_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkConformanceVersionKHR.patch", "Number");
  
    return;
  }
}
/** ## END VkConformanceVersionKHR ## **/

/** ## BEGIN VkPhysicalDeviceDriverPropertiesKHR ## **/

class _VkPhysicalDeviceDriverPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetdriverID);
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> driverName;
    static NAN_GETTER(GetdriverName);
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> driverInfo;
    static NAN_GETTER(GetdriverInfo);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> conformanceVersion;
      static NAN_GETTER(GetconformanceVersion);

    // real instance
    VkPhysicalDeviceDriverPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceDriverPropertiesKHR();
    ~_VkPhysicalDeviceDriverPropertiesKHR();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceDriverPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceDriverPropertiesKHR::constructor;

_VkPhysicalDeviceDriverPropertiesKHR::_VkPhysicalDeviceDriverPropertiesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR;
  
}

_VkPhysicalDeviceDriverPropertiesKHR::~_VkPhysicalDeviceDriverPropertiesKHR() {
  //printf("VkPhysicalDeviceDriverPropertiesKHR deconstructed!!\n");
  
  
  
  
  
  
}

void _VkPhysicalDeviceDriverPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceDriverPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceDriverPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("driverID").ToLocalChecked(), GetdriverID, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("driverName").ToLocalChecked(), GetdriverName, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("driverInfo").ToLocalChecked(), GetdriverInfo, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("conformanceVersion").ToLocalChecked(), GetconformanceVersion, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceDriverPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceDriverPropertiesKHR::flush() {
  _VkPhysicalDeviceDriverPropertiesKHR *self = this;
  if (!(self->conformanceVersion.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->conformanceVersion);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceDriverPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceDriverPropertiesKHR* self = new _VkPhysicalDeviceDriverPropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceDriverPropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceDriverPropertiesKHR::GetsType) {
  _VkPhysicalDeviceDriverPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDriverPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// driverID
NAN_GETTER(_VkPhysicalDeviceDriverPropertiesKHR::GetdriverID) {
  _VkPhysicalDeviceDriverPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDriverPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.driverID));
}// driverName
NAN_GETTER(_VkPhysicalDeviceDriverPropertiesKHR::GetdriverName) {
  _VkPhysicalDeviceDriverPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDriverPropertiesKHR>(info.This());
  if (self->driverName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->driverName));
  }
}// driverInfo
NAN_GETTER(_VkPhysicalDeviceDriverPropertiesKHR::GetdriverInfo) {
  _VkPhysicalDeviceDriverPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDriverPropertiesKHR>(info.This());
  if (self->driverInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->driverInfo));
  }
}// conformanceVersion
NAN_GETTER(_VkPhysicalDeviceDriverPropertiesKHR::GetconformanceVersion) {
  _VkPhysicalDeviceDriverPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceDriverPropertiesKHR>(info.This());
  if (self->conformanceVersion.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->conformanceVersion);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkPhysicalDeviceDriverPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDevicePushDescriptorPropertiesKHR ## **/

class _VkPhysicalDevicePushDescriptorPropertiesKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_GETTER(GetmaxPushDescriptors);

    // real instance
    VkPhysicalDevicePushDescriptorPropertiesKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDevicePushDescriptorPropertiesKHR();
    ~_VkPhysicalDevicePushDescriptorPropertiesKHR();

};

/*
#include "index.h"
#include "VkPhysicalDevicePushDescriptorPropertiesKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDevicePushDescriptorPropertiesKHR::constructor;

_VkPhysicalDevicePushDescriptorPropertiesKHR::_VkPhysicalDevicePushDescriptorPropertiesKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR;
  
}

_VkPhysicalDevicePushDescriptorPropertiesKHR::~_VkPhysicalDevicePushDescriptorPropertiesKHR() {
  //printf("VkPhysicalDevicePushDescriptorPropertiesKHR deconstructed!!\n");
  
  
  
}

void _VkPhysicalDevicePushDescriptorPropertiesKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDevicePushDescriptorPropertiesKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDevicePushDescriptorPropertiesKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPushDescriptors").ToLocalChecked(), GetmaxPushDescriptors, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDevicePushDescriptorPropertiesKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDevicePushDescriptorPropertiesKHR::flush() {
  _VkPhysicalDevicePushDescriptorPropertiesKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDevicePushDescriptorPropertiesKHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDevicePushDescriptorPropertiesKHR* self = new _VkPhysicalDevicePushDescriptorPropertiesKHR();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDevicePushDescriptorPropertiesKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDevicePushDescriptorPropertiesKHR::GetsType) {
  _VkPhysicalDevicePushDescriptorPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePushDescriptorPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// maxPushDescriptors
NAN_GETTER(_VkPhysicalDevicePushDescriptorPropertiesKHR::GetmaxPushDescriptors) {
  _VkPhysicalDevicePushDescriptorPropertiesKHR *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDevicePushDescriptorPropertiesKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPushDescriptors));
}
/** ## END VkPhysicalDevicePushDescriptorPropertiesKHR ## **/

/** ## BEGIN VkPhysicalDeviceSparseImageFormatInfo2KHR ## **/

class _VkPhysicalDeviceSparseImageFormatInfo2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceSparseImageFormatInfo2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSparseImageFormatInfo2KHR();
    ~_VkPhysicalDeviceSparseImageFormatInfo2KHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceSparseImageFormatInfo2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSparseImageFormatInfo2KHR::constructor;

_VkPhysicalDeviceSparseImageFormatInfo2KHR::_VkPhysicalDeviceSparseImageFormatInfo2KHR() {
  
  
}

_VkPhysicalDeviceSparseImageFormatInfo2KHR::~_VkPhysicalDeviceSparseImageFormatInfo2KHR() {
  //printf("VkPhysicalDeviceSparseImageFormatInfo2KHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceSparseImageFormatInfo2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSparseImageFormatInfo2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSparseImageFormatInfo2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceSparseImageFormatInfo2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSparseImageFormatInfo2KHR::flush() {
  _VkPhysicalDeviceSparseImageFormatInfo2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSparseImageFormatInfo2KHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSparseImageFormatInfo2KHR* self = new _VkPhysicalDeviceSparseImageFormatInfo2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSparseImageFormatInfo2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceSparseImageFormatInfo2KHR ## **/

/** ## BEGIN VkPhysicalDeviceSparseImageFormatInfo2 ## **/

class _VkPhysicalDeviceSparseImageFormatInfo2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Getsamples);
    static NAN_SETTER(Setsamples);
    
    static NAN_GETTER(Getusage);
    static NAN_SETTER(Setusage);
    
    static NAN_GETTER(Gettiling);
    static NAN_SETTER(Settiling);
    

    // real instance
    VkPhysicalDeviceSparseImageFormatInfo2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSparseImageFormatInfo2();
    ~_VkPhysicalDeviceSparseImageFormatInfo2();

};

/*
#include "index.h"
#include "VkPhysicalDeviceSparseImageFormatInfo2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSparseImageFormatInfo2::constructor;

_VkPhysicalDeviceSparseImageFormatInfo2::_VkPhysicalDeviceSparseImageFormatInfo2() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2;
  
}

_VkPhysicalDeviceSparseImageFormatInfo2::~_VkPhysicalDeviceSparseImageFormatInfo2() {
  //printf("VkPhysicalDeviceSparseImageFormatInfo2 deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceSparseImageFormatInfo2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSparseImageFormatInfo2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSparseImageFormatInfo2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("samples").ToLocalChecked(), Getsamples, Setsamples, ctor);
  SetPrototypeAccessor(proto, Nan::New("usage").ToLocalChecked(), Getusage, Setusage, ctor);
  SetPrototypeAccessor(proto, Nan::New("tiling").ToLocalChecked(), Gettiling, Settiling, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceSparseImageFormatInfo2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSparseImageFormatInfo2::flush() {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSparseImageFormatInfo2::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSparseImageFormatInfo2* self = new _VkPhysicalDeviceSparseImageFormatInfo2();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("samples").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("usage").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("tiling").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSparseImageFormatInfo2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceSparseImageFormatInfo2::GetsType) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceSparseImageFormatInfo2::SetsType) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.sType", "Number");
  
    return;
  }
}// format
NAN_GETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Getformat) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Setformat) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.format", "Number");
  
    return;
  }
}// type
NAN_GETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Gettype) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Settype) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkImageType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.type", "Number");
  
    return;
  }
}// samples
NAN_GETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Getsamples) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.samples));
}NAN_SETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Setsamples) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.samples = static_cast<VkSampleCountFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.samples", "Number");
  
    return;
  }
}// usage
NAN_GETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Getusage) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.usage));
}NAN_SETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Setusage) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.usage = static_cast<VkImageUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.usage", "Number");
  
    return;
  }
}// tiling
NAN_GETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Gettiling) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tiling));
}NAN_SETTER(_VkPhysicalDeviceSparseImageFormatInfo2::Settiling) {
  _VkPhysicalDeviceSparseImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.tiling = static_cast<VkImageTiling>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceSparseImageFormatInfo2.tiling", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceSparseImageFormatInfo2 ## **/

/** ## BEGIN VkSparseImageFormatProperties2KHR ## **/

class _VkSparseImageFormatProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkSparseImageFormatProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageFormatProperties2KHR();
    ~_VkSparseImageFormatProperties2KHR();

};

/*
#include "index.h"
#include "VkSparseImageFormatProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageFormatProperties2KHR::constructor;

_VkSparseImageFormatProperties2KHR::_VkSparseImageFormatProperties2KHR() {
  
  
}

_VkSparseImageFormatProperties2KHR::~_VkSparseImageFormatProperties2KHR() {
  //printf("VkSparseImageFormatProperties2KHR deconstructed!!\n");
  
}

void _VkSparseImageFormatProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageFormatProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageFormatProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkSparseImageFormatProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageFormatProperties2KHR::flush() {
  _VkSparseImageFormatProperties2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkSparseImageFormatProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageFormatProperties2KHR* self = new _VkSparseImageFormatProperties2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageFormatProperties2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkSparseImageFormatProperties2KHR ## **/

/** ## BEGIN VkSparseImageFormatProperties2 ## **/

class _VkSparseImageFormatProperties2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> properties;
      static NAN_GETTER(Getproperties);

    // real instance
    VkSparseImageFormatProperties2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageFormatProperties2();
    ~_VkSparseImageFormatProperties2();

};

/*
#include "index.h"
#include "VkSparseImageFormatProperties2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageFormatProperties2::constructor;

_VkSparseImageFormatProperties2::_VkSparseImageFormatProperties2() {
  instance.sType = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2;
  
}

_VkSparseImageFormatProperties2::~_VkSparseImageFormatProperties2() {
  //printf("VkSparseImageFormatProperties2 deconstructed!!\n");
  
  
  
}

void _VkSparseImageFormatProperties2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageFormatProperties2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageFormatProperties2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("properties").ToLocalChecked(), Getproperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkSparseImageFormatProperties2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageFormatProperties2::flush() {
  _VkSparseImageFormatProperties2 *self = this;
  if (!(self->properties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->properties);
    
  }
  return true;
}

NAN_METHOD(_VkSparseImageFormatProperties2::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageFormatProperties2* self = new _VkSparseImageFormatProperties2();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageFormatProperties2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSparseImageFormatProperties2::GetsType) {
  _VkSparseImageFormatProperties2 *self = Nan::ObjectWrap::Unwrap<_VkSparseImageFormatProperties2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// properties
NAN_GETTER(_VkSparseImageFormatProperties2::Getproperties) {
  _VkSparseImageFormatProperties2 *self = Nan::ObjectWrap::Unwrap<_VkSparseImageFormatProperties2>(info.This());
  if (self->properties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->properties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkSparseImageFormatProperties2 ## **/

/** ## BEGIN VkPhysicalDeviceMemoryProperties2KHR ## **/

class _VkPhysicalDeviceMemoryProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceMemoryProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMemoryProperties2KHR();
    ~_VkPhysicalDeviceMemoryProperties2KHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMemoryProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMemoryProperties2KHR::constructor;

_VkPhysicalDeviceMemoryProperties2KHR::_VkPhysicalDeviceMemoryProperties2KHR() {
  
  
}

_VkPhysicalDeviceMemoryProperties2KHR::~_VkPhysicalDeviceMemoryProperties2KHR() {
  //printf("VkPhysicalDeviceMemoryProperties2KHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceMemoryProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMemoryProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMemoryProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceMemoryProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMemoryProperties2KHR::flush() {
  _VkPhysicalDeviceMemoryProperties2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMemoryProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMemoryProperties2KHR* self = new _VkPhysicalDeviceMemoryProperties2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMemoryProperties2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceMemoryProperties2KHR ## **/

/** ## BEGIN VkMemoryHeap ## **/

class _VkMemoryHeap: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getsize);
    static NAN_GETTER(Getflags);

    // real instance
    VkMemoryHeap instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryHeap();
    ~_VkMemoryHeap();

};

/*
#include "index.h"
#include "VkMemoryHeap.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryHeap::constructor;

_VkMemoryHeap::_VkMemoryHeap() {
  
  
}

_VkMemoryHeap::~_VkMemoryHeap() {
  //printf("VkMemoryHeap deconstructed!!\n");
  
  
  
}

void _VkMemoryHeap::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryHeap::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryHeap").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMemoryHeap").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryHeap::flush() {
  _VkMemoryHeap *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryHeap::New) {
  if (info.IsConstructCall()) {
    _VkMemoryHeap* self = new _VkMemoryHeap();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryHeap constructor cannot be invoked without 'new'");
  }
};

// size
NAN_GETTER(_VkMemoryHeap::Getsize) {
  _VkMemoryHeap *self = Nan::ObjectWrap::Unwrap<_VkMemoryHeap>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}// flags
NAN_GETTER(_VkMemoryHeap::Getflags) {
  _VkMemoryHeap *self = Nan::ObjectWrap::Unwrap<_VkMemoryHeap>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}
/** ## END VkMemoryHeap ## **/

/** ## BEGIN VkMemoryType ## **/

class _VkMemoryType: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetpropertyFlags);
    static NAN_GETTER(GetheapIndex);

    // real instance
    VkMemoryType instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryType();
    ~_VkMemoryType();

};

/*
#include "index.h"
#include "VkMemoryType.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryType::constructor;

_VkMemoryType::_VkMemoryType() {
  
  
}

_VkMemoryType::~_VkMemoryType() {
  //printf("VkMemoryType deconstructed!!\n");
  
  
  
}

void _VkMemoryType::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryType::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryType").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("propertyFlags").ToLocalChecked(), GetpropertyFlags, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("heapIndex").ToLocalChecked(), GetheapIndex, nullptr, ctor);
  Nan::Set(target, Nan::New("VkMemoryType").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryType::flush() {
  _VkMemoryType *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryType::New) {
  if (info.IsConstructCall()) {
    _VkMemoryType* self = new _VkMemoryType();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryType constructor cannot be invoked without 'new'");
  }
};

// propertyFlags
NAN_GETTER(_VkMemoryType::GetpropertyFlags) {
  _VkMemoryType *self = Nan::ObjectWrap::Unwrap<_VkMemoryType>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.propertyFlags));
}// heapIndex
NAN_GETTER(_VkMemoryType::GetheapIndex) {
  _VkMemoryType *self = Nan::ObjectWrap::Unwrap<_VkMemoryType>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.heapIndex));
}
/** ## END VkMemoryType ## **/

/** ## BEGIN VkPhysicalDeviceMemoryProperties ## **/

class _VkPhysicalDeviceMemoryProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetmemoryTypeCount);
    std::vector<VkMemoryType>* vmemoryTypes;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> memoryTypes;
    static NAN_GETTER(GetmemoryTypes);
    static NAN_GETTER(GetmemoryHeapCount);
    std::vector<VkMemoryHeap>* vmemoryHeaps;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> memoryHeaps;
    static NAN_GETTER(GetmemoryHeaps);

    // real instance
    VkPhysicalDeviceMemoryProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMemoryProperties();
    ~_VkPhysicalDeviceMemoryProperties();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceMemoryProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMemoryProperties::constructor;

_VkPhysicalDeviceMemoryProperties::_VkPhysicalDeviceMemoryProperties() {
  
  vmemoryTypes = new std::vector<VkMemoryType>;
  vmemoryHeaps = new std::vector<VkMemoryHeap>;
  
}

_VkPhysicalDeviceMemoryProperties::~_VkPhysicalDeviceMemoryProperties() {
  //printf("VkPhysicalDeviceMemoryProperties deconstructed!!\n");
  
  
  vmemoryTypes->clear();
  delete vmemoryTypes;
  
  
  
  vmemoryHeaps->clear();
  delete vmemoryHeaps;
  
  
}

void _VkPhysicalDeviceMemoryProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMemoryProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMemoryProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("memoryTypeCount").ToLocalChecked(), GetmemoryTypeCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryTypes").ToLocalChecked(), GetmemoryTypes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryHeapCount").ToLocalChecked(), GetmemoryHeapCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryHeaps").ToLocalChecked(), GetmemoryHeaps, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMemoryProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMemoryProperties::flush() {
  _VkPhysicalDeviceMemoryProperties *self = this;
  if (!(self->memoryTypes.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->memoryTypes);
    
  }if (!(self->memoryHeaps.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->memoryHeaps);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMemoryProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMemoryProperties* self = new _VkPhysicalDeviceMemoryProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMemoryProperties constructor cannot be invoked without 'new'");
  }
};

// memoryTypeCount
NAN_GETTER(_VkPhysicalDeviceMemoryProperties::GetmemoryTypeCount) {
  _VkPhysicalDeviceMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryTypeCount));
}// memoryTypes
NAN_GETTER(_VkPhysicalDeviceMemoryProperties::GetmemoryTypes) {
  _VkPhysicalDeviceMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties>(info.This());
  if (self->memoryTypes.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->memoryTypes));
  }
}// memoryHeapCount
NAN_GETTER(_VkPhysicalDeviceMemoryProperties::GetmemoryHeapCount) {
  _VkPhysicalDeviceMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryHeapCount));
}// memoryHeaps
NAN_GETTER(_VkPhysicalDeviceMemoryProperties::GetmemoryHeaps) {
  _VkPhysicalDeviceMemoryProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties>(info.This());
  if (self->memoryHeaps.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->memoryHeaps));
  }
}
/** ## END VkPhysicalDeviceMemoryProperties ## **/

/** ## BEGIN VkPhysicalDeviceMemoryProperties2 ## **/

class _VkPhysicalDeviceMemoryProperties2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memoryProperties;
      static NAN_GETTER(GetmemoryProperties);

    // real instance
    VkPhysicalDeviceMemoryProperties2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceMemoryProperties2();
    ~_VkPhysicalDeviceMemoryProperties2();

};

/*
#include "index.h"
#include "VkPhysicalDeviceMemoryProperties2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceMemoryProperties2::constructor;

_VkPhysicalDeviceMemoryProperties2::_VkPhysicalDeviceMemoryProperties2() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
  
}

_VkPhysicalDeviceMemoryProperties2::~_VkPhysicalDeviceMemoryProperties2() {
  //printf("VkPhysicalDeviceMemoryProperties2 deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceMemoryProperties2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceMemoryProperties2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceMemoryProperties2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryProperties").ToLocalChecked(), GetmemoryProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceMemoryProperties2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceMemoryProperties2::flush() {
  _VkPhysicalDeviceMemoryProperties2 *self = this;
  if (!(self->memoryProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->memoryProperties);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceMemoryProperties2::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceMemoryProperties2* self = new _VkPhysicalDeviceMemoryProperties2();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceMemoryProperties2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceMemoryProperties2::GetsType) {
  _VkPhysicalDeviceMemoryProperties2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// memoryProperties
NAN_GETTER(_VkPhysicalDeviceMemoryProperties2::GetmemoryProperties) {
  _VkPhysicalDeviceMemoryProperties2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties2>(info.This());
  if (self->memoryProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memoryProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkPhysicalDeviceMemoryProperties2 ## **/

/** ## BEGIN VkQueueFamilyProperties2KHR ## **/

class _VkQueueFamilyProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkQueueFamilyProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkQueueFamilyProperties2KHR();
    ~_VkQueueFamilyProperties2KHR();

};

/*
#include "index.h"
#include "VkQueueFamilyProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkQueueFamilyProperties2KHR::constructor;

_VkQueueFamilyProperties2KHR::_VkQueueFamilyProperties2KHR() {
  
  
}

_VkQueueFamilyProperties2KHR::~_VkQueueFamilyProperties2KHR() {
  //printf("VkQueueFamilyProperties2KHR deconstructed!!\n");
  
}

void _VkQueueFamilyProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkQueueFamilyProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkQueueFamilyProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkQueueFamilyProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkQueueFamilyProperties2KHR::flush() {
  _VkQueueFamilyProperties2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkQueueFamilyProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkQueueFamilyProperties2KHR* self = new _VkQueueFamilyProperties2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkQueueFamilyProperties2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkQueueFamilyProperties2KHR ## **/

/** ## BEGIN VkQueueFamilyProperties ## **/

class _VkQueueFamilyProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetqueueFlags);
    static NAN_GETTER(GetqueueCount);
    static NAN_GETTER(GettimestampValidBits);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> minImageTransferGranularity;
      static NAN_GETTER(GetminImageTransferGranularity);

    // real instance
    VkQueueFamilyProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkQueueFamilyProperties();
    ~_VkQueueFamilyProperties();

};

/*
#include "index.h"
#include "VkQueueFamilyProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkQueueFamilyProperties::constructor;

_VkQueueFamilyProperties::_VkQueueFamilyProperties() {
  
  
}

_VkQueueFamilyProperties::~_VkQueueFamilyProperties() {
  //printf("VkQueueFamilyProperties deconstructed!!\n");
  
  
  
  
  
}

void _VkQueueFamilyProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkQueueFamilyProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkQueueFamilyProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("queueFlags").ToLocalChecked(), GetqueueFlags, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueCount").ToLocalChecked(), GetqueueCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("timestampValidBits").ToLocalChecked(), GettimestampValidBits, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minImageTransferGranularity").ToLocalChecked(), GetminImageTransferGranularity, nullptr, ctor);
  Nan::Set(target, Nan::New("VkQueueFamilyProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkQueueFamilyProperties::flush() {
  _VkQueueFamilyProperties *self = this;
  if (!(self->minImageTransferGranularity.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->minImageTransferGranularity);
    
  }
  return true;
}

NAN_METHOD(_VkQueueFamilyProperties::New) {
  if (info.IsConstructCall()) {
    _VkQueueFamilyProperties* self = new _VkQueueFamilyProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkQueueFamilyProperties constructor cannot be invoked without 'new'");
  }
};

// queueFlags
NAN_GETTER(_VkQueueFamilyProperties::GetqueueFlags) {
  _VkQueueFamilyProperties *self = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueFlags));
}// queueCount
NAN_GETTER(_VkQueueFamilyProperties::GetqueueCount) {
  _VkQueueFamilyProperties *self = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueCount));
}// timestampValidBits
NAN_GETTER(_VkQueueFamilyProperties::GettimestampValidBits) {
  _VkQueueFamilyProperties *self = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.timestampValidBits));
}// minImageTransferGranularity
NAN_GETTER(_VkQueueFamilyProperties::GetminImageTransferGranularity) {
  _VkQueueFamilyProperties *self = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(info.This());
  if (self->minImageTransferGranularity.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->minImageTransferGranularity);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkQueueFamilyProperties ## **/

/** ## BEGIN VkQueueFamilyProperties2 ## **/

class _VkQueueFamilyProperties2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> queueFamilyProperties;
      static NAN_GETTER(GetqueueFamilyProperties);

    // real instance
    VkQueueFamilyProperties2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkQueueFamilyProperties2();
    ~_VkQueueFamilyProperties2();

};

/*
#include "index.h"
#include "VkQueueFamilyProperties2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkQueueFamilyProperties2::constructor;

_VkQueueFamilyProperties2::_VkQueueFamilyProperties2() {
  instance.sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
  
}

_VkQueueFamilyProperties2::~_VkQueueFamilyProperties2() {
  //printf("VkQueueFamilyProperties2 deconstructed!!\n");
  
  
  
}

void _VkQueueFamilyProperties2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkQueueFamilyProperties2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkQueueFamilyProperties2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueFamilyProperties").ToLocalChecked(), GetqueueFamilyProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkQueueFamilyProperties2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkQueueFamilyProperties2::flush() {
  _VkQueueFamilyProperties2 *self = this;
  if (!(self->queueFamilyProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->queueFamilyProperties);
    
  }
  return true;
}

NAN_METHOD(_VkQueueFamilyProperties2::New) {
  if (info.IsConstructCall()) {
    _VkQueueFamilyProperties2* self = new _VkQueueFamilyProperties2();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkQueueFamilyProperties2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkQueueFamilyProperties2::GetsType) {
  _VkQueueFamilyProperties2 *self = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// queueFamilyProperties
NAN_GETTER(_VkQueueFamilyProperties2::GetqueueFamilyProperties) {
  _VkQueueFamilyProperties2 *self = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties2>(info.This());
  if (self->queueFamilyProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->queueFamilyProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkQueueFamilyProperties2 ## **/

/** ## BEGIN VkPhysicalDeviceImageFormatInfo2KHR ## **/

class _VkPhysicalDeviceImageFormatInfo2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceImageFormatInfo2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceImageFormatInfo2KHR();
    ~_VkPhysicalDeviceImageFormatInfo2KHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceImageFormatInfo2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceImageFormatInfo2KHR::constructor;

_VkPhysicalDeviceImageFormatInfo2KHR::_VkPhysicalDeviceImageFormatInfo2KHR() {
  
  
}

_VkPhysicalDeviceImageFormatInfo2KHR::~_VkPhysicalDeviceImageFormatInfo2KHR() {
  //printf("VkPhysicalDeviceImageFormatInfo2KHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceImageFormatInfo2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceImageFormatInfo2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceImageFormatInfo2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceImageFormatInfo2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceImageFormatInfo2KHR::flush() {
  _VkPhysicalDeviceImageFormatInfo2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceImageFormatInfo2KHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceImageFormatInfo2KHR* self = new _VkPhysicalDeviceImageFormatInfo2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceImageFormatInfo2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceImageFormatInfo2KHR ## **/

/** ## BEGIN VkPhysicalDeviceImageFormatInfo2 ## **/

class _VkPhysicalDeviceImageFormatInfo2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Gettiling);
    static NAN_SETTER(Settiling);
    
    static NAN_GETTER(Getusage);
    static NAN_SETTER(Setusage);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkPhysicalDeviceImageFormatInfo2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceImageFormatInfo2();
    ~_VkPhysicalDeviceImageFormatInfo2();

};

/*
#include "index.h"
#include "VkPhysicalDeviceImageFormatInfo2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceImageFormatInfo2::constructor;

_VkPhysicalDeviceImageFormatInfo2::_VkPhysicalDeviceImageFormatInfo2() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
  
}

_VkPhysicalDeviceImageFormatInfo2::~_VkPhysicalDeviceImageFormatInfo2() {
  //printf("VkPhysicalDeviceImageFormatInfo2 deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceImageFormatInfo2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceImageFormatInfo2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceImageFormatInfo2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("tiling").ToLocalChecked(), Gettiling, Settiling, ctor);
  SetPrototypeAccessor(proto, Nan::New("usage").ToLocalChecked(), Getusage, Setusage, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceImageFormatInfo2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceImageFormatInfo2::flush() {
  _VkPhysicalDeviceImageFormatInfo2 *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceImageFormatInfo2::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceImageFormatInfo2* self = new _VkPhysicalDeviceImageFormatInfo2();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("tiling").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("usage").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceImageFormatInfo2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceImageFormatInfo2::GetsType) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceImageFormatInfo2::SetsType) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageFormatInfo2.sType", "Number");
  
    return;
  }
}// format
NAN_GETTER(_VkPhysicalDeviceImageFormatInfo2::Getformat) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkPhysicalDeviceImageFormatInfo2::Setformat) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageFormatInfo2.format", "Number");
  
    return;
  }
}// type
NAN_GETTER(_VkPhysicalDeviceImageFormatInfo2::Gettype) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkPhysicalDeviceImageFormatInfo2::Settype) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkImageType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageFormatInfo2.type", "Number");
  
    return;
  }
}// tiling
NAN_GETTER(_VkPhysicalDeviceImageFormatInfo2::Gettiling) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tiling));
}NAN_SETTER(_VkPhysicalDeviceImageFormatInfo2::Settiling) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.tiling = static_cast<VkImageTiling>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageFormatInfo2.tiling", "Number");
  
    return;
  }
}// usage
NAN_GETTER(_VkPhysicalDeviceImageFormatInfo2::Getusage) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.usage));
}NAN_SETTER(_VkPhysicalDeviceImageFormatInfo2::Setusage) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.usage = static_cast<VkImageUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageFormatInfo2.usage", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPhysicalDeviceImageFormatInfo2::Getflags) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPhysicalDeviceImageFormatInfo2::Setflags) {
  _VkPhysicalDeviceImageFormatInfo2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceImageFormatInfo2>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkImageCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceImageFormatInfo2.flags", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceImageFormatInfo2 ## **/

/** ## BEGIN VkImageFormatProperties2KHR ## **/

class _VkImageFormatProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkImageFormatProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageFormatProperties2KHR();
    ~_VkImageFormatProperties2KHR();

};

/*
#include "index.h"
#include "VkImageFormatProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageFormatProperties2KHR::constructor;

_VkImageFormatProperties2KHR::_VkImageFormatProperties2KHR() {
  
  
}

_VkImageFormatProperties2KHR::~_VkImageFormatProperties2KHR() {
  //printf("VkImageFormatProperties2KHR deconstructed!!\n");
  
}

void _VkImageFormatProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageFormatProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageFormatProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkImageFormatProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageFormatProperties2KHR::flush() {
  _VkImageFormatProperties2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkImageFormatProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkImageFormatProperties2KHR* self = new _VkImageFormatProperties2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageFormatProperties2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkImageFormatProperties2KHR ## **/

/** ## BEGIN VkImageFormatProperties ## **/

class _VkImageFormatProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> maxExtent;
      static NAN_GETTER(GetmaxExtent);
    static NAN_GETTER(GetmaxMipLevels);
    static NAN_GETTER(GetmaxArrayLayers);
    static NAN_GETTER(GetsampleCounts);
    static NAN_GETTER(GetmaxResourceSize);

    // real instance
    VkImageFormatProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageFormatProperties();
    ~_VkImageFormatProperties();

};

/*
#include "index.h"
#include "VkImageFormatProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageFormatProperties::constructor;

_VkImageFormatProperties::_VkImageFormatProperties() {
  
  
}

_VkImageFormatProperties::~_VkImageFormatProperties() {
  //printf("VkImageFormatProperties deconstructed!!\n");
  
  
  
  
  
  
}

void _VkImageFormatProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageFormatProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageFormatProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("maxExtent").ToLocalChecked(), GetmaxExtent, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMipLevels").ToLocalChecked(), GetmaxMipLevels, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxArrayLayers").ToLocalChecked(), GetmaxArrayLayers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleCounts").ToLocalChecked(), GetsampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxResourceSize").ToLocalChecked(), GetmaxResourceSize, nullptr, ctor);
  Nan::Set(target, Nan::New("VkImageFormatProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageFormatProperties::flush() {
  _VkImageFormatProperties *self = this;
  if (!(self->maxExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxExtent);
    
  }
  return true;
}

NAN_METHOD(_VkImageFormatProperties::New) {
  if (info.IsConstructCall()) {
    _VkImageFormatProperties* self = new _VkImageFormatProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageFormatProperties constructor cannot be invoked without 'new'");
  }
};

// maxExtent
NAN_GETTER(_VkImageFormatProperties::GetmaxExtent) {
  _VkImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkImageFormatProperties>(info.This());
  if (self->maxExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->maxExtent);
    info.GetReturnValue().Set(obj);
  }
}// maxMipLevels
NAN_GETTER(_VkImageFormatProperties::GetmaxMipLevels) {
  _VkImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMipLevels));
}// maxArrayLayers
NAN_GETTER(_VkImageFormatProperties::GetmaxArrayLayers) {
  _VkImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxArrayLayers));
}// sampleCounts
NAN_GETTER(_VkImageFormatProperties::GetsampleCounts) {
  _VkImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleCounts));
}// maxResourceSize
NAN_GETTER(_VkImageFormatProperties::GetmaxResourceSize) {
  _VkImageFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkImageFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxResourceSize));
}
/** ## END VkImageFormatProperties ## **/

/** ## BEGIN VkImageFormatProperties2 ## **/

class _VkImageFormatProperties2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageFormatProperties;
      static NAN_GETTER(GetimageFormatProperties);

    // real instance
    VkImageFormatProperties2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageFormatProperties2();
    ~_VkImageFormatProperties2();

};

/*
#include "index.h"
#include "VkImageFormatProperties2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageFormatProperties2::constructor;

_VkImageFormatProperties2::_VkImageFormatProperties2() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
  
}

_VkImageFormatProperties2::~_VkImageFormatProperties2() {
  //printf("VkImageFormatProperties2 deconstructed!!\n");
  
  
  
}

void _VkImageFormatProperties2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageFormatProperties2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageFormatProperties2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageFormatProperties").ToLocalChecked(), GetimageFormatProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkImageFormatProperties2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageFormatProperties2::flush() {
  _VkImageFormatProperties2 *self = this;
  if (!(self->imageFormatProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->imageFormatProperties);
    
  }
  return true;
}

NAN_METHOD(_VkImageFormatProperties2::New) {
  if (info.IsConstructCall()) {
    _VkImageFormatProperties2* self = new _VkImageFormatProperties2();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageFormatProperties2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageFormatProperties2::GetsType) {
  _VkImageFormatProperties2 *self = Nan::ObjectWrap::Unwrap<_VkImageFormatProperties2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// imageFormatProperties
NAN_GETTER(_VkImageFormatProperties2::GetimageFormatProperties) {
  _VkImageFormatProperties2 *self = Nan::ObjectWrap::Unwrap<_VkImageFormatProperties2>(info.This());
  if (self->imageFormatProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageFormatProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkImageFormatProperties2 ## **/

/** ## BEGIN VkFormatProperties2KHR ## **/

class _VkFormatProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkFormatProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkFormatProperties2KHR();
    ~_VkFormatProperties2KHR();

};

/*
#include "index.h"
#include "VkFormatProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkFormatProperties2KHR::constructor;

_VkFormatProperties2KHR::_VkFormatProperties2KHR() {
  
  
}

_VkFormatProperties2KHR::~_VkFormatProperties2KHR() {
  //printf("VkFormatProperties2KHR deconstructed!!\n");
  
}

void _VkFormatProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFormatProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFormatProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkFormatProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkFormatProperties2KHR::flush() {
  _VkFormatProperties2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkFormatProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkFormatProperties2KHR* self = new _VkFormatProperties2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkFormatProperties2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkFormatProperties2KHR ## **/

/** ## BEGIN VkFormatProperties ## **/

class _VkFormatProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetlinearTilingFeatures);
    static NAN_GETTER(GetoptimalTilingFeatures);
    static NAN_GETTER(GetbufferFeatures);

    // real instance
    VkFormatProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkFormatProperties();
    ~_VkFormatProperties();

};

/*
#include "index.h"
#include "VkFormatProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkFormatProperties::constructor;

_VkFormatProperties::_VkFormatProperties() {
  
  
}

_VkFormatProperties::~_VkFormatProperties() {
  //printf("VkFormatProperties deconstructed!!\n");
  
  
  
  
}

void _VkFormatProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFormatProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFormatProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("linearTilingFeatures").ToLocalChecked(), GetlinearTilingFeatures, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("optimalTilingFeatures").ToLocalChecked(), GetoptimalTilingFeatures, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("bufferFeatures").ToLocalChecked(), GetbufferFeatures, nullptr, ctor);
  Nan::Set(target, Nan::New("VkFormatProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkFormatProperties::flush() {
  _VkFormatProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkFormatProperties::New) {
  if (info.IsConstructCall()) {
    _VkFormatProperties* self = new _VkFormatProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkFormatProperties constructor cannot be invoked without 'new'");
  }
};

// linearTilingFeatures
NAN_GETTER(_VkFormatProperties::GetlinearTilingFeatures) {
  _VkFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.linearTilingFeatures));
}// optimalTilingFeatures
NAN_GETTER(_VkFormatProperties::GetoptimalTilingFeatures) {
  _VkFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.optimalTilingFeatures));
}// bufferFeatures
NAN_GETTER(_VkFormatProperties::GetbufferFeatures) {
  _VkFormatProperties *self = Nan::ObjectWrap::Unwrap<_VkFormatProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferFeatures));
}
/** ## END VkFormatProperties ## **/

/** ## BEGIN VkFormatProperties2 ## **/

class _VkFormatProperties2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> formatProperties;
      static NAN_GETTER(GetformatProperties);

    // real instance
    VkFormatProperties2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkFormatProperties2();
    ~_VkFormatProperties2();

};

/*
#include "index.h"
#include "VkFormatProperties2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkFormatProperties2::constructor;

_VkFormatProperties2::_VkFormatProperties2() {
  instance.sType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2;
  
}

_VkFormatProperties2::~_VkFormatProperties2() {
  //printf("VkFormatProperties2 deconstructed!!\n");
  
  
  
}

void _VkFormatProperties2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFormatProperties2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFormatProperties2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("formatProperties").ToLocalChecked(), GetformatProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkFormatProperties2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkFormatProperties2::flush() {
  _VkFormatProperties2 *self = this;
  if (!(self->formatProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->formatProperties);
    
  }
  return true;
}

NAN_METHOD(_VkFormatProperties2::New) {
  if (info.IsConstructCall()) {
    _VkFormatProperties2* self = new _VkFormatProperties2();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkFormatProperties2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkFormatProperties2::GetsType) {
  _VkFormatProperties2 *self = Nan::ObjectWrap::Unwrap<_VkFormatProperties2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// formatProperties
NAN_GETTER(_VkFormatProperties2::GetformatProperties) {
  _VkFormatProperties2 *self = Nan::ObjectWrap::Unwrap<_VkFormatProperties2>(info.This());
  if (self->formatProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->formatProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkFormatProperties2 ## **/

/** ## BEGIN VkPhysicalDeviceProperties2KHR ## **/

class _VkPhysicalDeviceProperties2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceProperties2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceProperties2KHR();
    ~_VkPhysicalDeviceProperties2KHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceProperties2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceProperties2KHR::constructor;

_VkPhysicalDeviceProperties2KHR::_VkPhysicalDeviceProperties2KHR() {
  
  
}

_VkPhysicalDeviceProperties2KHR::~_VkPhysicalDeviceProperties2KHR() {
  //printf("VkPhysicalDeviceProperties2KHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceProperties2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceProperties2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceProperties2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceProperties2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceProperties2KHR::flush() {
  _VkPhysicalDeviceProperties2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceProperties2KHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceProperties2KHR* self = new _VkPhysicalDeviceProperties2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceProperties2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceProperties2KHR ## **/

/** ## BEGIN VkPhysicalDeviceSparseProperties ## **/

class _VkPhysicalDeviceSparseProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetresidencyStandard2DBlockShape);
    static NAN_GETTER(GetresidencyStandard2DMultisampleBlockShape);
    static NAN_GETTER(GetresidencyStandard3DBlockShape);
    static NAN_GETTER(GetresidencyAlignedMipSize);
    static NAN_GETTER(GetresidencyNonResidentStrict);

    // real instance
    VkPhysicalDeviceSparseProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceSparseProperties();
    ~_VkPhysicalDeviceSparseProperties();

};

/*
#include "index.h"
#include "VkPhysicalDeviceSparseProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceSparseProperties::constructor;

_VkPhysicalDeviceSparseProperties::_VkPhysicalDeviceSparseProperties() {
  
  
}

_VkPhysicalDeviceSparseProperties::~_VkPhysicalDeviceSparseProperties() {
  //printf("VkPhysicalDeviceSparseProperties deconstructed!!\n");
  
  
  
  
  
  
}

void _VkPhysicalDeviceSparseProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceSparseProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceSparseProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("residencyStandard2DBlockShape").ToLocalChecked(), GetresidencyStandard2DBlockShape, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("residencyStandard2DMultisampleBlockShape").ToLocalChecked(), GetresidencyStandard2DMultisampleBlockShape, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("residencyStandard3DBlockShape").ToLocalChecked(), GetresidencyStandard3DBlockShape, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("residencyAlignedMipSize").ToLocalChecked(), GetresidencyAlignedMipSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("residencyNonResidentStrict").ToLocalChecked(), GetresidencyNonResidentStrict, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceSparseProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceSparseProperties::flush() {
  _VkPhysicalDeviceSparseProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceSparseProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceSparseProperties* self = new _VkPhysicalDeviceSparseProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceSparseProperties constructor cannot be invoked without 'new'");
  }
};

// residencyStandard2DBlockShape
NAN_GETTER(_VkPhysicalDeviceSparseProperties::GetresidencyStandard2DBlockShape) {
  _VkPhysicalDeviceSparseProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.residencyStandard2DBlockShape));
}// residencyStandard2DMultisampleBlockShape
NAN_GETTER(_VkPhysicalDeviceSparseProperties::GetresidencyStandard2DMultisampleBlockShape) {
  _VkPhysicalDeviceSparseProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.residencyStandard2DMultisampleBlockShape));
}// residencyStandard3DBlockShape
NAN_GETTER(_VkPhysicalDeviceSparseProperties::GetresidencyStandard3DBlockShape) {
  _VkPhysicalDeviceSparseProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.residencyStandard3DBlockShape));
}// residencyAlignedMipSize
NAN_GETTER(_VkPhysicalDeviceSparseProperties::GetresidencyAlignedMipSize) {
  _VkPhysicalDeviceSparseProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.residencyAlignedMipSize));
}// residencyNonResidentStrict
NAN_GETTER(_VkPhysicalDeviceSparseProperties::GetresidencyNonResidentStrict) {
  _VkPhysicalDeviceSparseProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.residencyNonResidentStrict));
}
/** ## END VkPhysicalDeviceSparseProperties ## **/

/** ## BEGIN VkPhysicalDeviceLimits ## **/

class _VkPhysicalDeviceLimits: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetmaxImageDimension1D);
    static NAN_GETTER(GetmaxImageDimension2D);
    static NAN_GETTER(GetmaxImageDimension3D);
    static NAN_GETTER(GetmaxImageDimensionCube);
    static NAN_GETTER(GetmaxImageArrayLayers);
    static NAN_GETTER(GetmaxTexelBufferElements);
    static NAN_GETTER(GetmaxUniformBufferRange);
    static NAN_GETTER(GetmaxStorageBufferRange);
    static NAN_GETTER(GetmaxPushConstantsSize);
    static NAN_GETTER(GetmaxMemoryAllocationCount);
    static NAN_GETTER(GetmaxSamplerAllocationCount);
    static NAN_GETTER(GetbufferImageGranularity);
    static NAN_GETTER(GetsparseAddressSpaceSize);
    static NAN_GETTER(GetmaxBoundDescriptorSets);
    static NAN_GETTER(GetmaxPerStageDescriptorSamplers);
    static NAN_GETTER(GetmaxPerStageDescriptorUniformBuffers);
    static NAN_GETTER(GetmaxPerStageDescriptorStorageBuffers);
    static NAN_GETTER(GetmaxPerStageDescriptorSampledImages);
    static NAN_GETTER(GetmaxPerStageDescriptorStorageImages);
    static NAN_GETTER(GetmaxPerStageDescriptorInputAttachments);
    static NAN_GETTER(GetmaxPerStageResources);
    static NAN_GETTER(GetmaxDescriptorSetSamplers);
    static NAN_GETTER(GetmaxDescriptorSetUniformBuffers);
    static NAN_GETTER(GetmaxDescriptorSetUniformBuffersDynamic);
    static NAN_GETTER(GetmaxDescriptorSetStorageBuffers);
    static NAN_GETTER(GetmaxDescriptorSetStorageBuffersDynamic);
    static NAN_GETTER(GetmaxDescriptorSetSampledImages);
    static NAN_GETTER(GetmaxDescriptorSetStorageImages);
    static NAN_GETTER(GetmaxDescriptorSetInputAttachments);
    static NAN_GETTER(GetmaxVertexInputAttributes);
    static NAN_GETTER(GetmaxVertexInputBindings);
    static NAN_GETTER(GetmaxVertexInputAttributeOffset);
    static NAN_GETTER(GetmaxVertexInputBindingStride);
    static NAN_GETTER(GetmaxVertexOutputComponents);
    static NAN_GETTER(GetmaxTessellationGenerationLevel);
    static NAN_GETTER(GetmaxTessellationPatchSize);
    static NAN_GETTER(GetmaxTessellationControlPerVertexInputComponents);
    static NAN_GETTER(GetmaxTessellationControlPerVertexOutputComponents);
    static NAN_GETTER(GetmaxTessellationControlPerPatchOutputComponents);
    static NAN_GETTER(GetmaxTessellationControlTotalOutputComponents);
    static NAN_GETTER(GetmaxTessellationEvaluationInputComponents);
    static NAN_GETTER(GetmaxTessellationEvaluationOutputComponents);
    static NAN_GETTER(GetmaxGeometryShaderInvocations);
    static NAN_GETTER(GetmaxGeometryInputComponents);
    static NAN_GETTER(GetmaxGeometryOutputComponents);
    static NAN_GETTER(GetmaxGeometryOutputVertices);
    static NAN_GETTER(GetmaxGeometryTotalOutputComponents);
    static NAN_GETTER(GetmaxFragmentInputComponents);
    static NAN_GETTER(GetmaxFragmentOutputAttachments);
    static NAN_GETTER(GetmaxFragmentDualSrcAttachments);
    static NAN_GETTER(GetmaxFragmentCombinedOutputResources);
    static NAN_GETTER(GetmaxComputeSharedMemorySize);
    std::vector<uint32_t>* vmaxComputeWorkGroupCount;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> maxComputeWorkGroupCount;
    static NAN_GETTER(GetmaxComputeWorkGroupCount);
    static NAN_GETTER(GetmaxComputeWorkGroupInvocations);
    std::vector<uint32_t>* vmaxComputeWorkGroupSize;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> maxComputeWorkGroupSize;
    static NAN_GETTER(GetmaxComputeWorkGroupSize);
    static NAN_GETTER(GetsubPixelPrecisionBits);
    static NAN_GETTER(GetsubTexelPrecisionBits);
    static NAN_GETTER(GetmipmapPrecisionBits);
    static NAN_GETTER(GetmaxDrawIndexedIndexValue);
    static NAN_GETTER(GetmaxDrawIndirectCount);
    static NAN_GETTER(GetmaxSamplerLodBias);
    static NAN_GETTER(GetmaxSamplerAnisotropy);
    static NAN_GETTER(GetmaxViewports);
    std::vector<uint32_t>* vmaxViewportDimensions;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> maxViewportDimensions;
    static NAN_GETTER(GetmaxViewportDimensions);
    std::vector<float>* vviewportBoundsRange;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> viewportBoundsRange;
    static NAN_GETTER(GetviewportBoundsRange);
    static NAN_GETTER(GetviewportSubPixelBits);
    static NAN_GETTER(GetminMemoryMapAlignment);
    static NAN_GETTER(GetminTexelBufferOffsetAlignment);
    static NAN_GETTER(GetminUniformBufferOffsetAlignment);
    static NAN_GETTER(GetminStorageBufferOffsetAlignment);
    static NAN_GETTER(GetminTexelOffset);
    static NAN_GETTER(GetmaxTexelOffset);
    static NAN_GETTER(GetminTexelGatherOffset);
    static NAN_GETTER(GetmaxTexelGatherOffset);
    static NAN_GETTER(GetminInterpolationOffset);
    static NAN_GETTER(GetmaxInterpolationOffset);
    static NAN_GETTER(GetsubPixelInterpolationOffsetBits);
    static NAN_GETTER(GetmaxFramebufferWidth);
    static NAN_GETTER(GetmaxFramebufferHeight);
    static NAN_GETTER(GetmaxFramebufferLayers);
    static NAN_GETTER(GetframebufferColorSampleCounts);
    static NAN_GETTER(GetframebufferDepthSampleCounts);
    static NAN_GETTER(GetframebufferStencilSampleCounts);
    static NAN_GETTER(GetframebufferNoAttachmentsSampleCounts);
    static NAN_GETTER(GetmaxColorAttachments);
    static NAN_GETTER(GetsampledImageColorSampleCounts);
    static NAN_GETTER(GetsampledImageIntegerSampleCounts);
    static NAN_GETTER(GetsampledImageDepthSampleCounts);
    static NAN_GETTER(GetsampledImageStencilSampleCounts);
    static NAN_GETTER(GetstorageImageSampleCounts);
    static NAN_GETTER(GetmaxSampleMaskWords);
    static NAN_GETTER(GettimestampComputeAndGraphics);
    static NAN_GETTER(GettimestampPeriod);
    static NAN_GETTER(GetmaxClipDistances);
    static NAN_GETTER(GetmaxCullDistances);
    static NAN_GETTER(GetmaxCombinedClipAndCullDistances);
    static NAN_GETTER(GetdiscreteQueuePriorities);
    std::vector<float>* vpointSizeRange;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pointSizeRange;
    static NAN_GETTER(GetpointSizeRange);
    std::vector<float>* vlineWidthRange;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> lineWidthRange;
    static NAN_GETTER(GetlineWidthRange);
    static NAN_GETTER(GetpointSizeGranularity);
    static NAN_GETTER(GetlineWidthGranularity);
    static NAN_GETTER(GetstrictLines);
    static NAN_GETTER(GetstandardSampleLocations);
    static NAN_GETTER(GetoptimalBufferCopyOffsetAlignment);
    static NAN_GETTER(GetoptimalBufferCopyRowPitchAlignment);
    static NAN_GETTER(GetnonCoherentAtomSize);

    // real instance
    VkPhysicalDeviceLimits instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceLimits();
    ~_VkPhysicalDeviceLimits();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceLimits.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceLimits::constructor;

_VkPhysicalDeviceLimits::_VkPhysicalDeviceLimits() {
  
  vmaxComputeWorkGroupCount = new std::vector<uint32_t>;
  vmaxComputeWorkGroupSize = new std::vector<uint32_t>;
  vmaxViewportDimensions = new std::vector<uint32_t>;
  vviewportBoundsRange = new std::vector<float>;
  vpointSizeRange = new std::vector<float>;
  vlineWidthRange = new std::vector<float>;
  
}

_VkPhysicalDeviceLimits::~_VkPhysicalDeviceLimits() {
  //printf("VkPhysicalDeviceLimits deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  vmaxComputeWorkGroupCount->clear();
  delete vmaxComputeWorkGroupCount;
  
  
  
  vmaxComputeWorkGroupSize->clear();
  delete vmaxComputeWorkGroupSize;
  
  
  
  
  
  
  
  
  
  
  vmaxViewportDimensions->clear();
  delete vmaxViewportDimensions;
  
  
  vviewportBoundsRange->clear();
  delete vviewportBoundsRange;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  vpointSizeRange->clear();
  delete vpointSizeRange;
  
  
  vlineWidthRange->clear();
  delete vlineWidthRange;
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceLimits::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceLimits::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceLimits").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("maxImageDimension1D").ToLocalChecked(), GetmaxImageDimension1D, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageDimension2D").ToLocalChecked(), GetmaxImageDimension2D, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageDimension3D").ToLocalChecked(), GetmaxImageDimension3D, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageDimensionCube").ToLocalChecked(), GetmaxImageDimensionCube, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxImageArrayLayers").ToLocalChecked(), GetmaxImageArrayLayers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTexelBufferElements").ToLocalChecked(), GetmaxTexelBufferElements, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxUniformBufferRange").ToLocalChecked(), GetmaxUniformBufferRange, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxStorageBufferRange").ToLocalChecked(), GetmaxStorageBufferRange, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPushConstantsSize").ToLocalChecked(), GetmaxPushConstantsSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxMemoryAllocationCount").ToLocalChecked(), GetmaxMemoryAllocationCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSamplerAllocationCount").ToLocalChecked(), GetmaxSamplerAllocationCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("bufferImageGranularity").ToLocalChecked(), GetbufferImageGranularity, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseAddressSpaceSize").ToLocalChecked(), GetsparseAddressSpaceSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxBoundDescriptorSets").ToLocalChecked(), GetmaxBoundDescriptorSets, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorSamplers").ToLocalChecked(), GetmaxPerStageDescriptorSamplers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorUniformBuffers").ToLocalChecked(), GetmaxPerStageDescriptorUniformBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorStorageBuffers").ToLocalChecked(), GetmaxPerStageDescriptorStorageBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorSampledImages").ToLocalChecked(), GetmaxPerStageDescriptorSampledImages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorStorageImages").ToLocalChecked(), GetmaxPerStageDescriptorStorageImages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageDescriptorInputAttachments").ToLocalChecked(), GetmaxPerStageDescriptorInputAttachments, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPerStageResources").ToLocalChecked(), GetmaxPerStageResources, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetSamplers").ToLocalChecked(), GetmaxDescriptorSetSamplers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUniformBuffers").ToLocalChecked(), GetmaxDescriptorSetUniformBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetUniformBuffersDynamic").ToLocalChecked(), GetmaxDescriptorSetUniformBuffersDynamic, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetStorageBuffers").ToLocalChecked(), GetmaxDescriptorSetStorageBuffers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetStorageBuffersDynamic").ToLocalChecked(), GetmaxDescriptorSetStorageBuffersDynamic, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetSampledImages").ToLocalChecked(), GetmaxDescriptorSetSampledImages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetStorageImages").ToLocalChecked(), GetmaxDescriptorSetStorageImages, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDescriptorSetInputAttachments").ToLocalChecked(), GetmaxDescriptorSetInputAttachments, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxVertexInputAttributes").ToLocalChecked(), GetmaxVertexInputAttributes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxVertexInputBindings").ToLocalChecked(), GetmaxVertexInputBindings, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxVertexInputAttributeOffset").ToLocalChecked(), GetmaxVertexInputAttributeOffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxVertexInputBindingStride").ToLocalChecked(), GetmaxVertexInputBindingStride, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxVertexOutputComponents").ToLocalChecked(), GetmaxVertexOutputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTessellationGenerationLevel").ToLocalChecked(), GetmaxTessellationGenerationLevel, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTessellationPatchSize").ToLocalChecked(), GetmaxTessellationPatchSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTessellationControlPerVertexInputComponents").ToLocalChecked(), GetmaxTessellationControlPerVertexInputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTessellationControlPerVertexOutputComponents").ToLocalChecked(), GetmaxTessellationControlPerVertexOutputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTessellationControlPerPatchOutputComponents").ToLocalChecked(), GetmaxTessellationControlPerPatchOutputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTessellationControlTotalOutputComponents").ToLocalChecked(), GetmaxTessellationControlTotalOutputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTessellationEvaluationInputComponents").ToLocalChecked(), GetmaxTessellationEvaluationInputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTessellationEvaluationOutputComponents").ToLocalChecked(), GetmaxTessellationEvaluationOutputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxGeometryShaderInvocations").ToLocalChecked(), GetmaxGeometryShaderInvocations, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxGeometryInputComponents").ToLocalChecked(), GetmaxGeometryInputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxGeometryOutputComponents").ToLocalChecked(), GetmaxGeometryOutputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxGeometryOutputVertices").ToLocalChecked(), GetmaxGeometryOutputVertices, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxGeometryTotalOutputComponents").ToLocalChecked(), GetmaxGeometryTotalOutputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFragmentInputComponents").ToLocalChecked(), GetmaxFragmentInputComponents, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFragmentOutputAttachments").ToLocalChecked(), GetmaxFragmentOutputAttachments, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFragmentDualSrcAttachments").ToLocalChecked(), GetmaxFragmentDualSrcAttachments, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFragmentCombinedOutputResources").ToLocalChecked(), GetmaxFragmentCombinedOutputResources, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxComputeSharedMemorySize").ToLocalChecked(), GetmaxComputeSharedMemorySize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxComputeWorkGroupCount").ToLocalChecked(), GetmaxComputeWorkGroupCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxComputeWorkGroupInvocations").ToLocalChecked(), GetmaxComputeWorkGroupInvocations, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxComputeWorkGroupSize").ToLocalChecked(), GetmaxComputeWorkGroupSize, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("subPixelPrecisionBits").ToLocalChecked(), GetsubPixelPrecisionBits, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("subTexelPrecisionBits").ToLocalChecked(), GetsubTexelPrecisionBits, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("mipmapPrecisionBits").ToLocalChecked(), GetmipmapPrecisionBits, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDrawIndexedIndexValue").ToLocalChecked(), GetmaxDrawIndexedIndexValue, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDrawIndirectCount").ToLocalChecked(), GetmaxDrawIndirectCount, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSamplerLodBias").ToLocalChecked(), GetmaxSamplerLodBias, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSamplerAnisotropy").ToLocalChecked(), GetmaxSamplerAnisotropy, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxViewports").ToLocalChecked(), GetmaxViewports, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxViewportDimensions").ToLocalChecked(), GetmaxViewportDimensions, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewportBoundsRange").ToLocalChecked(), GetviewportBoundsRange, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewportSubPixelBits").ToLocalChecked(), GetviewportSubPixelBits, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minMemoryMapAlignment").ToLocalChecked(), GetminMemoryMapAlignment, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minTexelBufferOffsetAlignment").ToLocalChecked(), GetminTexelBufferOffsetAlignment, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minUniformBufferOffsetAlignment").ToLocalChecked(), GetminUniformBufferOffsetAlignment, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minStorageBufferOffsetAlignment").ToLocalChecked(), GetminStorageBufferOffsetAlignment, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minTexelOffset").ToLocalChecked(), GetminTexelOffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTexelOffset").ToLocalChecked(), GetmaxTexelOffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minTexelGatherOffset").ToLocalChecked(), GetminTexelGatherOffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxTexelGatherOffset").ToLocalChecked(), GetmaxTexelGatherOffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("minInterpolationOffset").ToLocalChecked(), GetminInterpolationOffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxInterpolationOffset").ToLocalChecked(), GetmaxInterpolationOffset, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("subPixelInterpolationOffsetBits").ToLocalChecked(), GetsubPixelInterpolationOffsetBits, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFramebufferWidth").ToLocalChecked(), GetmaxFramebufferWidth, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFramebufferHeight").ToLocalChecked(), GetmaxFramebufferHeight, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxFramebufferLayers").ToLocalChecked(), GetmaxFramebufferLayers, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("framebufferColorSampleCounts").ToLocalChecked(), GetframebufferColorSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("framebufferDepthSampleCounts").ToLocalChecked(), GetframebufferDepthSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("framebufferStencilSampleCounts").ToLocalChecked(), GetframebufferStencilSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("framebufferNoAttachmentsSampleCounts").ToLocalChecked(), GetframebufferNoAttachmentsSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxColorAttachments").ToLocalChecked(), GetmaxColorAttachments, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampledImageColorSampleCounts").ToLocalChecked(), GetsampledImageColorSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampledImageIntegerSampleCounts").ToLocalChecked(), GetsampledImageIntegerSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampledImageDepthSampleCounts").ToLocalChecked(), GetsampledImageDepthSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampledImageStencilSampleCounts").ToLocalChecked(), GetsampledImageStencilSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("storageImageSampleCounts").ToLocalChecked(), GetstorageImageSampleCounts, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSampleMaskWords").ToLocalChecked(), GetmaxSampleMaskWords, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("timestampComputeAndGraphics").ToLocalChecked(), GettimestampComputeAndGraphics, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("timestampPeriod").ToLocalChecked(), GettimestampPeriod, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxClipDistances").ToLocalChecked(), GetmaxClipDistances, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxCullDistances").ToLocalChecked(), GetmaxCullDistances, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxCombinedClipAndCullDistances").ToLocalChecked(), GetmaxCombinedClipAndCullDistances, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("discreteQueuePriorities").ToLocalChecked(), GetdiscreteQueuePriorities, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pointSizeRange").ToLocalChecked(), GetpointSizeRange, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("lineWidthRange").ToLocalChecked(), GetlineWidthRange, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pointSizeGranularity").ToLocalChecked(), GetpointSizeGranularity, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("lineWidthGranularity").ToLocalChecked(), GetlineWidthGranularity, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("strictLines").ToLocalChecked(), GetstrictLines, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("standardSampleLocations").ToLocalChecked(), GetstandardSampleLocations, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("optimalBufferCopyOffsetAlignment").ToLocalChecked(), GetoptimalBufferCopyOffsetAlignment, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("optimalBufferCopyRowPitchAlignment").ToLocalChecked(), GetoptimalBufferCopyRowPitchAlignment, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("nonCoherentAtomSize").ToLocalChecked(), GetnonCoherentAtomSize, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceLimits").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceLimits::flush() {
  _VkPhysicalDeviceLimits *self = this;
  if (!(self->maxComputeWorkGroupCount.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxComputeWorkGroupCount);
    
  }if (!(self->maxComputeWorkGroupSize.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxComputeWorkGroupSize);
    
  }if (!(self->maxViewportDimensions.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->maxViewportDimensions);
    
  }if (!(self->viewportBoundsRange.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->viewportBoundsRange);
    
  }if (!(self->pointSizeRange.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pointSizeRange);
    
  }if (!(self->lineWidthRange.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->lineWidthRange);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceLimits::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceLimits* self = new _VkPhysicalDeviceLimits();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceLimits constructor cannot be invoked without 'new'");
  }
};

// maxImageDimension1D
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxImageDimension1D) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageDimension1D));
}// maxImageDimension2D
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxImageDimension2D) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageDimension2D));
}// maxImageDimension3D
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxImageDimension3D) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageDimension3D));
}// maxImageDimensionCube
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxImageDimensionCube) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageDimensionCube));
}// maxImageArrayLayers
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxImageArrayLayers) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxImageArrayLayers));
}// maxTexelBufferElements
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTexelBufferElements) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTexelBufferElements));
}// maxUniformBufferRange
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxUniformBufferRange) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxUniformBufferRange));
}// maxStorageBufferRange
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxStorageBufferRange) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxStorageBufferRange));
}// maxPushConstantsSize
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxPushConstantsSize) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPushConstantsSize));
}// maxMemoryAllocationCount
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxMemoryAllocationCount) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxMemoryAllocationCount));
}// maxSamplerAllocationCount
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxSamplerAllocationCount) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSamplerAllocationCount));
}// bufferImageGranularity
NAN_GETTER(_VkPhysicalDeviceLimits::GetbufferImageGranularity) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferImageGranularity));
}// sparseAddressSpaceSize
NAN_GETTER(_VkPhysicalDeviceLimits::GetsparseAddressSpaceSize) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseAddressSpaceSize));
}// maxBoundDescriptorSets
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxBoundDescriptorSets) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxBoundDescriptorSets));
}// maxPerStageDescriptorSamplers
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorSamplers) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorSamplers));
}// maxPerStageDescriptorUniformBuffers
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorUniformBuffers) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorUniformBuffers));
}// maxPerStageDescriptorStorageBuffers
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorStorageBuffers) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorStorageBuffers));
}// maxPerStageDescriptorSampledImages
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorSampledImages) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorSampledImages));
}// maxPerStageDescriptorStorageImages
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorStorageImages) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorStorageImages));
}// maxPerStageDescriptorInputAttachments
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxPerStageDescriptorInputAttachments) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageDescriptorInputAttachments));
}// maxPerStageResources
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxPerStageResources) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPerStageResources));
}// maxDescriptorSetSamplers
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDescriptorSetSamplers) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetSamplers));
}// maxDescriptorSetUniformBuffers
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDescriptorSetUniformBuffers) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUniformBuffers));
}// maxDescriptorSetUniformBuffersDynamic
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDescriptorSetUniformBuffersDynamic) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetUniformBuffersDynamic));
}// maxDescriptorSetStorageBuffers
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageBuffers) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetStorageBuffers));
}// maxDescriptorSetStorageBuffersDynamic
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageBuffersDynamic) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetStorageBuffersDynamic));
}// maxDescriptorSetSampledImages
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDescriptorSetSampledImages) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetSampledImages));
}// maxDescriptorSetStorageImages
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDescriptorSetStorageImages) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetStorageImages));
}// maxDescriptorSetInputAttachments
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDescriptorSetInputAttachments) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDescriptorSetInputAttachments));
}// maxVertexInputAttributes
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxVertexInputAttributes) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxVertexInputAttributes));
}// maxVertexInputBindings
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxVertexInputBindings) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxVertexInputBindings));
}// maxVertexInputAttributeOffset
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxVertexInputAttributeOffset) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxVertexInputAttributeOffset));
}// maxVertexInputBindingStride
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxVertexInputBindingStride) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxVertexInputBindingStride));
}// maxVertexOutputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxVertexOutputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxVertexOutputComponents));
}// maxTessellationGenerationLevel
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTessellationGenerationLevel) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTessellationGenerationLevel));
}// maxTessellationPatchSize
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTessellationPatchSize) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTessellationPatchSize));
}// maxTessellationControlPerVertexInputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTessellationControlPerVertexInputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTessellationControlPerVertexInputComponents));
}// maxTessellationControlPerVertexOutputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTessellationControlPerVertexOutputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTessellationControlPerVertexOutputComponents));
}// maxTessellationControlPerPatchOutputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTessellationControlPerPatchOutputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTessellationControlPerPatchOutputComponents));
}// maxTessellationControlTotalOutputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTessellationControlTotalOutputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTessellationControlTotalOutputComponents));
}// maxTessellationEvaluationInputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTessellationEvaluationInputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTessellationEvaluationInputComponents));
}// maxTessellationEvaluationOutputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTessellationEvaluationOutputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTessellationEvaluationOutputComponents));
}// maxGeometryShaderInvocations
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxGeometryShaderInvocations) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxGeometryShaderInvocations));
}// maxGeometryInputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxGeometryInputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxGeometryInputComponents));
}// maxGeometryOutputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxGeometryOutputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxGeometryOutputComponents));
}// maxGeometryOutputVertices
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxGeometryOutputVertices) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxGeometryOutputVertices));
}// maxGeometryTotalOutputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxGeometryTotalOutputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxGeometryTotalOutputComponents));
}// maxFragmentInputComponents
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxFragmentInputComponents) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxFragmentInputComponents));
}// maxFragmentOutputAttachments
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxFragmentOutputAttachments) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxFragmentOutputAttachments));
}// maxFragmentDualSrcAttachments
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxFragmentDualSrcAttachments) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxFragmentDualSrcAttachments));
}// maxFragmentCombinedOutputResources
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxFragmentCombinedOutputResources) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxFragmentCombinedOutputResources));
}// maxComputeSharedMemorySize
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxComputeSharedMemorySize) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxComputeSharedMemorySize));
}// maxComputeWorkGroupCount
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxComputeWorkGroupCount) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  if (self->maxComputeWorkGroupCount.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->maxComputeWorkGroupCount));
  }
}// maxComputeWorkGroupInvocations
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxComputeWorkGroupInvocations) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxComputeWorkGroupInvocations));
}// maxComputeWorkGroupSize
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxComputeWorkGroupSize) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  if (self->maxComputeWorkGroupSize.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->maxComputeWorkGroupSize));
  }
}// subPixelPrecisionBits
NAN_GETTER(_VkPhysicalDeviceLimits::GetsubPixelPrecisionBits) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subPixelPrecisionBits));
}// subTexelPrecisionBits
NAN_GETTER(_VkPhysicalDeviceLimits::GetsubTexelPrecisionBits) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subTexelPrecisionBits));
}// mipmapPrecisionBits
NAN_GETTER(_VkPhysicalDeviceLimits::GetmipmapPrecisionBits) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.mipmapPrecisionBits));
}// maxDrawIndexedIndexValue
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDrawIndexedIndexValue) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDrawIndexedIndexValue));
}// maxDrawIndirectCount
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxDrawIndirectCount) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDrawIndirectCount));
}// maxSamplerLodBias
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxSamplerLodBias) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSamplerLodBias));
}// maxSamplerAnisotropy
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxSamplerAnisotropy) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSamplerAnisotropy));
}// maxViewports
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxViewports) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxViewports));
}// maxViewportDimensions
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxViewportDimensions) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  if (self->maxViewportDimensions.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->maxViewportDimensions));
  }
}// viewportBoundsRange
NAN_GETTER(_VkPhysicalDeviceLimits::GetviewportBoundsRange) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  if (self->viewportBoundsRange.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->viewportBoundsRange));
  }
}// viewportSubPixelBits
NAN_GETTER(_VkPhysicalDeviceLimits::GetviewportSubPixelBits) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewportSubPixelBits));
}// minMemoryMapAlignment
NAN_GETTER(_VkPhysicalDeviceLimits::GetminMemoryMapAlignment) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minMemoryMapAlignment));
}// minTexelBufferOffsetAlignment
NAN_GETTER(_VkPhysicalDeviceLimits::GetminTexelBufferOffsetAlignment) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minTexelBufferOffsetAlignment));
}// minUniformBufferOffsetAlignment
NAN_GETTER(_VkPhysicalDeviceLimits::GetminUniformBufferOffsetAlignment) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minUniformBufferOffsetAlignment));
}// minStorageBufferOffsetAlignment
NAN_GETTER(_VkPhysicalDeviceLimits::GetminStorageBufferOffsetAlignment) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minStorageBufferOffsetAlignment));
}// minTexelOffset
NAN_GETTER(_VkPhysicalDeviceLimits::GetminTexelOffset) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minTexelOffset));
}// maxTexelOffset
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTexelOffset) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTexelOffset));
}// minTexelGatherOffset
NAN_GETTER(_VkPhysicalDeviceLimits::GetminTexelGatherOffset) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minTexelGatherOffset));
}// maxTexelGatherOffset
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxTexelGatherOffset) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxTexelGatherOffset));
}// minInterpolationOffset
NAN_GETTER(_VkPhysicalDeviceLimits::GetminInterpolationOffset) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minInterpolationOffset));
}// maxInterpolationOffset
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxInterpolationOffset) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxInterpolationOffset));
}// subPixelInterpolationOffsetBits
NAN_GETTER(_VkPhysicalDeviceLimits::GetsubPixelInterpolationOffsetBits) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subPixelInterpolationOffsetBits));
}// maxFramebufferWidth
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxFramebufferWidth) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxFramebufferWidth));
}// maxFramebufferHeight
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxFramebufferHeight) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxFramebufferHeight));
}// maxFramebufferLayers
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxFramebufferLayers) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxFramebufferLayers));
}// framebufferColorSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetframebufferColorSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.framebufferColorSampleCounts));
}// framebufferDepthSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetframebufferDepthSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.framebufferDepthSampleCounts));
}// framebufferStencilSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetframebufferStencilSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.framebufferStencilSampleCounts));
}// framebufferNoAttachmentsSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetframebufferNoAttachmentsSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.framebufferNoAttachmentsSampleCounts));
}// maxColorAttachments
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxColorAttachments) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxColorAttachments));
}// sampledImageColorSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetsampledImageColorSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampledImageColorSampleCounts));
}// sampledImageIntegerSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetsampledImageIntegerSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampledImageIntegerSampleCounts));
}// sampledImageDepthSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetsampledImageDepthSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampledImageDepthSampleCounts));
}// sampledImageStencilSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetsampledImageStencilSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampledImageStencilSampleCounts));
}// storageImageSampleCounts
NAN_GETTER(_VkPhysicalDeviceLimits::GetstorageImageSampleCounts) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.storageImageSampleCounts));
}// maxSampleMaskWords
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxSampleMaskWords) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSampleMaskWords));
}// timestampComputeAndGraphics
NAN_GETTER(_VkPhysicalDeviceLimits::GettimestampComputeAndGraphics) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.timestampComputeAndGraphics));
}// timestampPeriod
NAN_GETTER(_VkPhysicalDeviceLimits::GettimestampPeriod) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.timestampPeriod));
}// maxClipDistances
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxClipDistances) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxClipDistances));
}// maxCullDistances
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxCullDistances) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxCullDistances));
}// maxCombinedClipAndCullDistances
NAN_GETTER(_VkPhysicalDeviceLimits::GetmaxCombinedClipAndCullDistances) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxCombinedClipAndCullDistances));
}// discreteQueuePriorities
NAN_GETTER(_VkPhysicalDeviceLimits::GetdiscreteQueuePriorities) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.discreteQueuePriorities));
}// pointSizeRange
NAN_GETTER(_VkPhysicalDeviceLimits::GetpointSizeRange) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  if (self->pointSizeRange.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->pointSizeRange));
  }
}// lineWidthRange
NAN_GETTER(_VkPhysicalDeviceLimits::GetlineWidthRange) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  if (self->lineWidthRange.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->lineWidthRange));
  }
}// pointSizeGranularity
NAN_GETTER(_VkPhysicalDeviceLimits::GetpointSizeGranularity) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pointSizeGranularity));
}// lineWidthGranularity
NAN_GETTER(_VkPhysicalDeviceLimits::GetlineWidthGranularity) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.lineWidthGranularity));
}// strictLines
NAN_GETTER(_VkPhysicalDeviceLimits::GetstrictLines) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.strictLines));
}// standardSampleLocations
NAN_GETTER(_VkPhysicalDeviceLimits::GetstandardSampleLocations) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.standardSampleLocations));
}// optimalBufferCopyOffsetAlignment
NAN_GETTER(_VkPhysicalDeviceLimits::GetoptimalBufferCopyOffsetAlignment) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.optimalBufferCopyOffsetAlignment));
}// optimalBufferCopyRowPitchAlignment
NAN_GETTER(_VkPhysicalDeviceLimits::GetoptimalBufferCopyRowPitchAlignment) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.optimalBufferCopyRowPitchAlignment));
}// nonCoherentAtomSize
NAN_GETTER(_VkPhysicalDeviceLimits::GetnonCoherentAtomSize) {
  _VkPhysicalDeviceLimits *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.nonCoherentAtomSize));
}
/** ## END VkPhysicalDeviceLimits ## **/

/** ## BEGIN VkPhysicalDeviceProperties ## **/

class _VkPhysicalDeviceProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetapiVersion);
    static NAN_GETTER(GetdriverVersion);
    static NAN_GETTER(GetvendorID);
    static NAN_GETTER(GetdeviceID);
    static NAN_GETTER(GetdeviceType);
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> deviceName;
    static NAN_GETTER(GetdeviceName);
    std::vector<uint8_t>* vpipelineCacheUUID;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pipelineCacheUUID;
    static NAN_GETTER(GetpipelineCacheUUID);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> limits;
      static NAN_GETTER(Getlimits);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> sparseProperties;
      static NAN_GETTER(GetsparseProperties);

    // real instance
    VkPhysicalDeviceProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceProperties();
    ~_VkPhysicalDeviceProperties();

};

/*
#include <string.h>
#include "index.h"
#include "VkPhysicalDeviceProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceProperties::constructor;

_VkPhysicalDeviceProperties::_VkPhysicalDeviceProperties() {
  
  vpipelineCacheUUID = new std::vector<uint8_t>;
  
}

_VkPhysicalDeviceProperties::~_VkPhysicalDeviceProperties() {
  //printf("VkPhysicalDeviceProperties deconstructed!!\n");
  
  
  
  
  
  
  
  vpipelineCacheUUID->clear();
  delete vpipelineCacheUUID;
  
  
  
  
}

void _VkPhysicalDeviceProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("apiVersion").ToLocalChecked(), GetapiVersion, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("driverVersion").ToLocalChecked(), GetdriverVersion, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("vendorID").ToLocalChecked(), GetvendorID, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceID").ToLocalChecked(), GetdeviceID, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceType").ToLocalChecked(), GetdeviceType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("deviceName").ToLocalChecked(), GetdeviceName, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineCacheUUID").ToLocalChecked(), GetpipelineCacheUUID, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("limits").ToLocalChecked(), Getlimits, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseProperties").ToLocalChecked(), GetsparseProperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceProperties::flush() {
  _VkPhysicalDeviceProperties *self = this;
  if (!(self->pipelineCacheUUID.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pipelineCacheUUID);
    
  }if (!(self->limits.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->limits);
    
  }if (!(self->sparseProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->sparseProperties);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceProperties::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceProperties* self = new _VkPhysicalDeviceProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceProperties constructor cannot be invoked without 'new'");
  }
};

// apiVersion
NAN_GETTER(_VkPhysicalDeviceProperties::GetapiVersion) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.apiVersion));
}// driverVersion
NAN_GETTER(_VkPhysicalDeviceProperties::GetdriverVersion) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.driverVersion));
}// vendorID
NAN_GETTER(_VkPhysicalDeviceProperties::GetvendorID) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vendorID));
}// deviceID
NAN_GETTER(_VkPhysicalDeviceProperties::GetdeviceID) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceID));
}// deviceType
NAN_GETTER(_VkPhysicalDeviceProperties::GetdeviceType) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.deviceType));
}// deviceName
NAN_GETTER(_VkPhysicalDeviceProperties::GetdeviceName) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  if (self->deviceName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->deviceName));
  }
}// pipelineCacheUUID
NAN_GETTER(_VkPhysicalDeviceProperties::GetpipelineCacheUUID) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  if (self->pipelineCacheUUID.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->pipelineCacheUUID));
  }
}// limits
NAN_GETTER(_VkPhysicalDeviceProperties::Getlimits) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  if (self->limits.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->limits);
    info.GetReturnValue().Set(obj);
  }
}// sparseProperties
NAN_GETTER(_VkPhysicalDeviceProperties::GetsparseProperties) {
  _VkPhysicalDeviceProperties *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(info.This());
  if (self->sparseProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->sparseProperties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkPhysicalDeviceProperties ## **/

/** ## BEGIN VkPhysicalDeviceProperties2 ## **/

class _VkPhysicalDeviceProperties2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> properties;
      static NAN_GETTER(Getproperties);

    // real instance
    VkPhysicalDeviceProperties2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceProperties2();
    ~_VkPhysicalDeviceProperties2();

};

/*
#include "index.h"
#include "VkPhysicalDeviceProperties2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceProperties2::constructor;

_VkPhysicalDeviceProperties2::_VkPhysicalDeviceProperties2() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
  
}

_VkPhysicalDeviceProperties2::~_VkPhysicalDeviceProperties2() {
  //printf("VkPhysicalDeviceProperties2 deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceProperties2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceProperties2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceProperties2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("properties").ToLocalChecked(), Getproperties, nullptr, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceProperties2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceProperties2::flush() {
  _VkPhysicalDeviceProperties2 *self = this;
  if (!(self->properties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->properties);
    
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceProperties2::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceProperties2* self = new _VkPhysicalDeviceProperties2();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceProperties2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceProperties2::GetsType) {
  _VkPhysicalDeviceProperties2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}// properties
NAN_GETTER(_VkPhysicalDeviceProperties2::Getproperties) {
  _VkPhysicalDeviceProperties2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties2>(info.This());
  if (self->properties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->properties);
    info.GetReturnValue().Set(obj);
  }
}
/** ## END VkPhysicalDeviceProperties2 ## **/

/** ## BEGIN VkPhysicalDeviceFeatures2KHR ## **/

class _VkPhysicalDeviceFeatures2KHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkPhysicalDeviceFeatures2KHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceFeatures2KHR();
    ~_VkPhysicalDeviceFeatures2KHR();

};

/*
#include "index.h"
#include "VkPhysicalDeviceFeatures2KHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceFeatures2KHR::constructor;

_VkPhysicalDeviceFeatures2KHR::_VkPhysicalDeviceFeatures2KHR() {
  
  
}

_VkPhysicalDeviceFeatures2KHR::~_VkPhysicalDeviceFeatures2KHR() {
  //printf("VkPhysicalDeviceFeatures2KHR deconstructed!!\n");
  
}

void _VkPhysicalDeviceFeatures2KHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceFeatures2KHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceFeatures2KHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkPhysicalDeviceFeatures2KHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceFeatures2KHR::flush() {
  _VkPhysicalDeviceFeatures2KHR *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceFeatures2KHR::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceFeatures2KHR* self = new _VkPhysicalDeviceFeatures2KHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceFeatures2KHR constructor cannot be invoked without 'new'");
  }
};


/** ## END VkPhysicalDeviceFeatures2KHR ## **/

/** ## BEGIN VkPhysicalDeviceFeatures ## **/

class _VkPhysicalDeviceFeatures: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetrobustBufferAccess);
    static NAN_SETTER(SetrobustBufferAccess);
    
    static NAN_GETTER(GetfullDrawIndexUint32);
    static NAN_SETTER(SetfullDrawIndexUint32);
    
    static NAN_GETTER(GetimageCubeArray);
    static NAN_SETTER(SetimageCubeArray);
    
    static NAN_GETTER(GetindependentBlend);
    static NAN_SETTER(SetindependentBlend);
    
    static NAN_GETTER(GetgeometryShader);
    static NAN_SETTER(SetgeometryShader);
    
    static NAN_GETTER(GettessellationShader);
    static NAN_SETTER(SettessellationShader);
    
    static NAN_GETTER(GetsampleRateShading);
    static NAN_SETTER(SetsampleRateShading);
    
    static NAN_GETTER(GetdualSrcBlend);
    static NAN_SETTER(SetdualSrcBlend);
    
    static NAN_GETTER(GetlogicOp);
    static NAN_SETTER(SetlogicOp);
    
    static NAN_GETTER(GetmultiDrawIndirect);
    static NAN_SETTER(SetmultiDrawIndirect);
    
    static NAN_GETTER(GetdrawIndirectFirstInstance);
    static NAN_SETTER(SetdrawIndirectFirstInstance);
    
    static NAN_GETTER(GetdepthClamp);
    static NAN_SETTER(SetdepthClamp);
    
    static NAN_GETTER(GetdepthBiasClamp);
    static NAN_SETTER(SetdepthBiasClamp);
    
    static NAN_GETTER(GetfillModeNonSolid);
    static NAN_SETTER(SetfillModeNonSolid);
    
    static NAN_GETTER(GetdepthBounds);
    static NAN_SETTER(SetdepthBounds);
    
    static NAN_GETTER(GetwideLines);
    static NAN_SETTER(SetwideLines);
    
    static NAN_GETTER(GetlargePoints);
    static NAN_SETTER(SetlargePoints);
    
    static NAN_GETTER(GetalphaToOne);
    static NAN_SETTER(SetalphaToOne);
    
    static NAN_GETTER(GetmultiViewport);
    static NAN_SETTER(SetmultiViewport);
    
    static NAN_GETTER(GetsamplerAnisotropy);
    static NAN_SETTER(SetsamplerAnisotropy);
    
    static NAN_GETTER(GettextureCompressionETC2);
    static NAN_SETTER(SettextureCompressionETC2);
    
    static NAN_GETTER(GettextureCompressionASTC_LDR);
    static NAN_SETTER(SettextureCompressionASTC_LDR);
    
    static NAN_GETTER(GettextureCompressionBC);
    static NAN_SETTER(SettextureCompressionBC);
    
    static NAN_GETTER(GetocclusionQueryPrecise);
    static NAN_SETTER(SetocclusionQueryPrecise);
    
    static NAN_GETTER(GetpipelineStatisticsQuery);
    static NAN_SETTER(SetpipelineStatisticsQuery);
    
    static NAN_GETTER(GetvertexPipelineStoresAndAtomics);
    static NAN_SETTER(SetvertexPipelineStoresAndAtomics);
    
    static NAN_GETTER(GetfragmentStoresAndAtomics);
    static NAN_SETTER(SetfragmentStoresAndAtomics);
    
    static NAN_GETTER(GetshaderTessellationAndGeometryPointSize);
    static NAN_SETTER(SetshaderTessellationAndGeometryPointSize);
    
    static NAN_GETTER(GetshaderImageGatherExtended);
    static NAN_SETTER(SetshaderImageGatherExtended);
    
    static NAN_GETTER(GetshaderStorageImageExtendedFormats);
    static NAN_SETTER(SetshaderStorageImageExtendedFormats);
    
    static NAN_GETTER(GetshaderStorageImageMultisample);
    static NAN_SETTER(SetshaderStorageImageMultisample);
    
    static NAN_GETTER(GetshaderStorageImageReadWithoutFormat);
    static NAN_SETTER(SetshaderStorageImageReadWithoutFormat);
    
    static NAN_GETTER(GetshaderStorageImageWriteWithoutFormat);
    static NAN_SETTER(SetshaderStorageImageWriteWithoutFormat);
    
    static NAN_GETTER(GetshaderUniformBufferArrayDynamicIndexing);
    static NAN_SETTER(SetshaderUniformBufferArrayDynamicIndexing);
    
    static NAN_GETTER(GetshaderSampledImageArrayDynamicIndexing);
    static NAN_SETTER(SetshaderSampledImageArrayDynamicIndexing);
    
    static NAN_GETTER(GetshaderStorageBufferArrayDynamicIndexing);
    static NAN_SETTER(SetshaderStorageBufferArrayDynamicIndexing);
    
    static NAN_GETTER(GetshaderStorageImageArrayDynamicIndexing);
    static NAN_SETTER(SetshaderStorageImageArrayDynamicIndexing);
    
    static NAN_GETTER(GetshaderClipDistance);
    static NAN_SETTER(SetshaderClipDistance);
    
    static NAN_GETTER(GetshaderCullDistance);
    static NAN_SETTER(SetshaderCullDistance);
    
    static NAN_GETTER(GetshaderFloat64);
    static NAN_SETTER(SetshaderFloat64);
    
    static NAN_GETTER(GetshaderInt64);
    static NAN_SETTER(SetshaderInt64);
    
    static NAN_GETTER(GetshaderInt16);
    static NAN_SETTER(SetshaderInt16);
    
    static NAN_GETTER(GetshaderResourceResidency);
    static NAN_SETTER(SetshaderResourceResidency);
    
    static NAN_GETTER(GetshaderResourceMinLod);
    static NAN_SETTER(SetshaderResourceMinLod);
    
    static NAN_GETTER(GetsparseBinding);
    static NAN_SETTER(SetsparseBinding);
    
    static NAN_GETTER(GetsparseResidencyBuffer);
    static NAN_SETTER(SetsparseResidencyBuffer);
    
    static NAN_GETTER(GetsparseResidencyImage2D);
    static NAN_SETTER(SetsparseResidencyImage2D);
    
    static NAN_GETTER(GetsparseResidencyImage3D);
    static NAN_SETTER(SetsparseResidencyImage3D);
    
    static NAN_GETTER(GetsparseResidency2Samples);
    static NAN_SETTER(SetsparseResidency2Samples);
    
    static NAN_GETTER(GetsparseResidency4Samples);
    static NAN_SETTER(SetsparseResidency4Samples);
    
    static NAN_GETTER(GetsparseResidency8Samples);
    static NAN_SETTER(SetsparseResidency8Samples);
    
    static NAN_GETTER(GetsparseResidency16Samples);
    static NAN_SETTER(SetsparseResidency16Samples);
    
    static NAN_GETTER(GetsparseResidencyAliased);
    static NAN_SETTER(SetsparseResidencyAliased);
    
    static NAN_GETTER(GetvariableMultisampleRate);
    static NAN_SETTER(SetvariableMultisampleRate);
    
    static NAN_GETTER(GetinheritedQueries);
    static NAN_SETTER(SetinheritedQueries);
    

    // real instance
    VkPhysicalDeviceFeatures instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceFeatures();
    ~_VkPhysicalDeviceFeatures();

};

/*
#include "index.h"
#include "VkPhysicalDeviceFeatures.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceFeatures::constructor;

_VkPhysicalDeviceFeatures::_VkPhysicalDeviceFeatures() {
  
  
}

_VkPhysicalDeviceFeatures::~_VkPhysicalDeviceFeatures() {
  //printf("VkPhysicalDeviceFeatures deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPhysicalDeviceFeatures::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceFeatures::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceFeatures").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("robustBufferAccess").ToLocalChecked(), GetrobustBufferAccess, SetrobustBufferAccess, ctor);
  SetPrototypeAccessor(proto, Nan::New("fullDrawIndexUint32").ToLocalChecked(), GetfullDrawIndexUint32, SetfullDrawIndexUint32, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageCubeArray").ToLocalChecked(), GetimageCubeArray, SetimageCubeArray, ctor);
  SetPrototypeAccessor(proto, Nan::New("independentBlend").ToLocalChecked(), GetindependentBlend, SetindependentBlend, ctor);
  SetPrototypeAccessor(proto, Nan::New("geometryShader").ToLocalChecked(), GetgeometryShader, SetgeometryShader, ctor);
  SetPrototypeAccessor(proto, Nan::New("tessellationShader").ToLocalChecked(), GettessellationShader, SettessellationShader, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleRateShading").ToLocalChecked(), GetsampleRateShading, SetsampleRateShading, ctor);
  SetPrototypeAccessor(proto, Nan::New("dualSrcBlend").ToLocalChecked(), GetdualSrcBlend, SetdualSrcBlend, ctor);
  SetPrototypeAccessor(proto, Nan::New("logicOp").ToLocalChecked(), GetlogicOp, SetlogicOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("multiDrawIndirect").ToLocalChecked(), GetmultiDrawIndirect, SetmultiDrawIndirect, ctor);
  SetPrototypeAccessor(proto, Nan::New("drawIndirectFirstInstance").ToLocalChecked(), GetdrawIndirectFirstInstance, SetdrawIndirectFirstInstance, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthClamp").ToLocalChecked(), GetdepthClamp, SetdepthClamp, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthBiasClamp").ToLocalChecked(), GetdepthBiasClamp, SetdepthBiasClamp, ctor);
  SetPrototypeAccessor(proto, Nan::New("fillModeNonSolid").ToLocalChecked(), GetfillModeNonSolid, SetfillModeNonSolid, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthBounds").ToLocalChecked(), GetdepthBounds, SetdepthBounds, ctor);
  SetPrototypeAccessor(proto, Nan::New("wideLines").ToLocalChecked(), GetwideLines, SetwideLines, ctor);
  SetPrototypeAccessor(proto, Nan::New("largePoints").ToLocalChecked(), GetlargePoints, SetlargePoints, ctor);
  SetPrototypeAccessor(proto, Nan::New("alphaToOne").ToLocalChecked(), GetalphaToOne, SetalphaToOne, ctor);
  SetPrototypeAccessor(proto, Nan::New("multiViewport").ToLocalChecked(), GetmultiViewport, SetmultiViewport, ctor);
  SetPrototypeAccessor(proto, Nan::New("samplerAnisotropy").ToLocalChecked(), GetsamplerAnisotropy, SetsamplerAnisotropy, ctor);
  SetPrototypeAccessor(proto, Nan::New("textureCompressionETC2").ToLocalChecked(), GettextureCompressionETC2, SettextureCompressionETC2, ctor);
  SetPrototypeAccessor(proto, Nan::New("textureCompressionASTC_LDR").ToLocalChecked(), GettextureCompressionASTC_LDR, SettextureCompressionASTC_LDR, ctor);
  SetPrototypeAccessor(proto, Nan::New("textureCompressionBC").ToLocalChecked(), GettextureCompressionBC, SettextureCompressionBC, ctor);
  SetPrototypeAccessor(proto, Nan::New("occlusionQueryPrecise").ToLocalChecked(), GetocclusionQueryPrecise, SetocclusionQueryPrecise, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineStatisticsQuery").ToLocalChecked(), GetpipelineStatisticsQuery, SetpipelineStatisticsQuery, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexPipelineStoresAndAtomics").ToLocalChecked(), GetvertexPipelineStoresAndAtomics, SetvertexPipelineStoresAndAtomics, ctor);
  SetPrototypeAccessor(proto, Nan::New("fragmentStoresAndAtomics").ToLocalChecked(), GetfragmentStoresAndAtomics, SetfragmentStoresAndAtomics, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderTessellationAndGeometryPointSize").ToLocalChecked(), GetshaderTessellationAndGeometryPointSize, SetshaderTessellationAndGeometryPointSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderImageGatherExtended").ToLocalChecked(), GetshaderImageGatherExtended, SetshaderImageGatherExtended, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageImageExtendedFormats").ToLocalChecked(), GetshaderStorageImageExtendedFormats, SetshaderStorageImageExtendedFormats, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageImageMultisample").ToLocalChecked(), GetshaderStorageImageMultisample, SetshaderStorageImageMultisample, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageImageReadWithoutFormat").ToLocalChecked(), GetshaderStorageImageReadWithoutFormat, SetshaderStorageImageReadWithoutFormat, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageImageWriteWithoutFormat").ToLocalChecked(), GetshaderStorageImageWriteWithoutFormat, SetshaderStorageImageWriteWithoutFormat, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderUniformBufferArrayDynamicIndexing").ToLocalChecked(), GetshaderUniformBufferArrayDynamicIndexing, SetshaderUniformBufferArrayDynamicIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderSampledImageArrayDynamicIndexing").ToLocalChecked(), GetshaderSampledImageArrayDynamicIndexing, SetshaderSampledImageArrayDynamicIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageBufferArrayDynamicIndexing").ToLocalChecked(), GetshaderStorageBufferArrayDynamicIndexing, SetshaderStorageBufferArrayDynamicIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderStorageImageArrayDynamicIndexing").ToLocalChecked(), GetshaderStorageImageArrayDynamicIndexing, SetshaderStorageImageArrayDynamicIndexing, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderClipDistance").ToLocalChecked(), GetshaderClipDistance, SetshaderClipDistance, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderCullDistance").ToLocalChecked(), GetshaderCullDistance, SetshaderCullDistance, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderFloat64").ToLocalChecked(), GetshaderFloat64, SetshaderFloat64, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderInt64").ToLocalChecked(), GetshaderInt64, SetshaderInt64, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderInt16").ToLocalChecked(), GetshaderInt16, SetshaderInt16, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderResourceResidency").ToLocalChecked(), GetshaderResourceResidency, SetshaderResourceResidency, ctor);
  SetPrototypeAccessor(proto, Nan::New("shaderResourceMinLod").ToLocalChecked(), GetshaderResourceMinLod, SetshaderResourceMinLod, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseBinding").ToLocalChecked(), GetsparseBinding, SetsparseBinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseResidencyBuffer").ToLocalChecked(), GetsparseResidencyBuffer, SetsparseResidencyBuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseResidencyImage2D").ToLocalChecked(), GetsparseResidencyImage2D, SetsparseResidencyImage2D, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseResidencyImage3D").ToLocalChecked(), GetsparseResidencyImage3D, SetsparseResidencyImage3D, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseResidency2Samples").ToLocalChecked(), GetsparseResidency2Samples, SetsparseResidency2Samples, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseResidency4Samples").ToLocalChecked(), GetsparseResidency4Samples, SetsparseResidency4Samples, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseResidency8Samples").ToLocalChecked(), GetsparseResidency8Samples, SetsparseResidency8Samples, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseResidency16Samples").ToLocalChecked(), GetsparseResidency16Samples, SetsparseResidency16Samples, ctor);
  SetPrototypeAccessor(proto, Nan::New("sparseResidencyAliased").ToLocalChecked(), GetsparseResidencyAliased, SetsparseResidencyAliased, ctor);
  SetPrototypeAccessor(proto, Nan::New("variableMultisampleRate").ToLocalChecked(), GetvariableMultisampleRate, SetvariableMultisampleRate, ctor);
  SetPrototypeAccessor(proto, Nan::New("inheritedQueries").ToLocalChecked(), GetinheritedQueries, SetinheritedQueries, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceFeatures").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceFeatures::flush() {
  _VkPhysicalDeviceFeatures *self = this;
  
  return true;
}

NAN_METHOD(_VkPhysicalDeviceFeatures::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceFeatures* self = new _VkPhysicalDeviceFeatures();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("robustBufferAccess").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("fullDrawIndexUint32").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("imageCubeArray").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("independentBlend").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("geometryShader").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("tessellationShader").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("sampleRateShading").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("dualSrcBlend").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("logicOp").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("multiDrawIndirect").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("drawIndirectFirstInstance").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("depthClamp").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("depthBiasClamp").ToLocalChecked();
      v8::Local<v8::String> sAccess13 = Nan::New("fillModeNonSolid").ToLocalChecked();
      v8::Local<v8::String> sAccess14 = Nan::New("depthBounds").ToLocalChecked();
      v8::Local<v8::String> sAccess15 = Nan::New("wideLines").ToLocalChecked();
      v8::Local<v8::String> sAccess16 = Nan::New("largePoints").ToLocalChecked();
      v8::Local<v8::String> sAccess17 = Nan::New("alphaToOne").ToLocalChecked();
      v8::Local<v8::String> sAccess18 = Nan::New("multiViewport").ToLocalChecked();
      v8::Local<v8::String> sAccess19 = Nan::New("samplerAnisotropy").ToLocalChecked();
      v8::Local<v8::String> sAccess20 = Nan::New("textureCompressionETC2").ToLocalChecked();
      v8::Local<v8::String> sAccess21 = Nan::New("textureCompressionASTC_LDR").ToLocalChecked();
      v8::Local<v8::String> sAccess22 = Nan::New("textureCompressionBC").ToLocalChecked();
      v8::Local<v8::String> sAccess23 = Nan::New("occlusionQueryPrecise").ToLocalChecked();
      v8::Local<v8::String> sAccess24 = Nan::New("pipelineStatisticsQuery").ToLocalChecked();
      v8::Local<v8::String> sAccess25 = Nan::New("vertexPipelineStoresAndAtomics").ToLocalChecked();
      v8::Local<v8::String> sAccess26 = Nan::New("fragmentStoresAndAtomics").ToLocalChecked();
      v8::Local<v8::String> sAccess27 = Nan::New("shaderTessellationAndGeometryPointSize").ToLocalChecked();
      v8::Local<v8::String> sAccess28 = Nan::New("shaderImageGatherExtended").ToLocalChecked();
      v8::Local<v8::String> sAccess29 = Nan::New("shaderStorageImageExtendedFormats").ToLocalChecked();
      v8::Local<v8::String> sAccess30 = Nan::New("shaderStorageImageMultisample").ToLocalChecked();
      v8::Local<v8::String> sAccess31 = Nan::New("shaderStorageImageReadWithoutFormat").ToLocalChecked();
      v8::Local<v8::String> sAccess32 = Nan::New("shaderStorageImageWriteWithoutFormat").ToLocalChecked();
      v8::Local<v8::String> sAccess33 = Nan::New("shaderUniformBufferArrayDynamicIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess34 = Nan::New("shaderSampledImageArrayDynamicIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess35 = Nan::New("shaderStorageBufferArrayDynamicIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess36 = Nan::New("shaderStorageImageArrayDynamicIndexing").ToLocalChecked();
      v8::Local<v8::String> sAccess37 = Nan::New("shaderClipDistance").ToLocalChecked();
      v8::Local<v8::String> sAccess38 = Nan::New("shaderCullDistance").ToLocalChecked();
      v8::Local<v8::String> sAccess39 = Nan::New("shaderFloat64").ToLocalChecked();
      v8::Local<v8::String> sAccess40 = Nan::New("shaderInt64").ToLocalChecked();
      v8::Local<v8::String> sAccess41 = Nan::New("shaderInt16").ToLocalChecked();
      v8::Local<v8::String> sAccess42 = Nan::New("shaderResourceResidency").ToLocalChecked();
      v8::Local<v8::String> sAccess43 = Nan::New("shaderResourceMinLod").ToLocalChecked();
      v8::Local<v8::String> sAccess44 = Nan::New("sparseBinding").ToLocalChecked();
      v8::Local<v8::String> sAccess45 = Nan::New("sparseResidencyBuffer").ToLocalChecked();
      v8::Local<v8::String> sAccess46 = Nan::New("sparseResidencyImage2D").ToLocalChecked();
      v8::Local<v8::String> sAccess47 = Nan::New("sparseResidencyImage3D").ToLocalChecked();
      v8::Local<v8::String> sAccess48 = Nan::New("sparseResidency2Samples").ToLocalChecked();
      v8::Local<v8::String> sAccess49 = Nan::New("sparseResidency4Samples").ToLocalChecked();
      v8::Local<v8::String> sAccess50 = Nan::New("sparseResidency8Samples").ToLocalChecked();
      v8::Local<v8::String> sAccess51 = Nan::New("sparseResidency16Samples").ToLocalChecked();
      v8::Local<v8::String> sAccess52 = Nan::New("sparseResidencyAliased").ToLocalChecked();
      v8::Local<v8::String> sAccess53 = Nan::New("variableMultisampleRate").ToLocalChecked();
      v8::Local<v8::String> sAccess54 = Nan::New("inheritedQueries").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      if (obj->Has(sAccess13)) info.This()->Set(sAccess13, obj->Get(sAccess13));
      if (obj->Has(sAccess14)) info.This()->Set(sAccess14, obj->Get(sAccess14));
      if (obj->Has(sAccess15)) info.This()->Set(sAccess15, obj->Get(sAccess15));
      if (obj->Has(sAccess16)) info.This()->Set(sAccess16, obj->Get(sAccess16));
      if (obj->Has(sAccess17)) info.This()->Set(sAccess17, obj->Get(sAccess17));
      if (obj->Has(sAccess18)) info.This()->Set(sAccess18, obj->Get(sAccess18));
      if (obj->Has(sAccess19)) info.This()->Set(sAccess19, obj->Get(sAccess19));
      if (obj->Has(sAccess20)) info.This()->Set(sAccess20, obj->Get(sAccess20));
      if (obj->Has(sAccess21)) info.This()->Set(sAccess21, obj->Get(sAccess21));
      if (obj->Has(sAccess22)) info.This()->Set(sAccess22, obj->Get(sAccess22));
      if (obj->Has(sAccess23)) info.This()->Set(sAccess23, obj->Get(sAccess23));
      if (obj->Has(sAccess24)) info.This()->Set(sAccess24, obj->Get(sAccess24));
      if (obj->Has(sAccess25)) info.This()->Set(sAccess25, obj->Get(sAccess25));
      if (obj->Has(sAccess26)) info.This()->Set(sAccess26, obj->Get(sAccess26));
      if (obj->Has(sAccess27)) info.This()->Set(sAccess27, obj->Get(sAccess27));
      if (obj->Has(sAccess28)) info.This()->Set(sAccess28, obj->Get(sAccess28));
      if (obj->Has(sAccess29)) info.This()->Set(sAccess29, obj->Get(sAccess29));
      if (obj->Has(sAccess30)) info.This()->Set(sAccess30, obj->Get(sAccess30));
      if (obj->Has(sAccess31)) info.This()->Set(sAccess31, obj->Get(sAccess31));
      if (obj->Has(sAccess32)) info.This()->Set(sAccess32, obj->Get(sAccess32));
      if (obj->Has(sAccess33)) info.This()->Set(sAccess33, obj->Get(sAccess33));
      if (obj->Has(sAccess34)) info.This()->Set(sAccess34, obj->Get(sAccess34));
      if (obj->Has(sAccess35)) info.This()->Set(sAccess35, obj->Get(sAccess35));
      if (obj->Has(sAccess36)) info.This()->Set(sAccess36, obj->Get(sAccess36));
      if (obj->Has(sAccess37)) info.This()->Set(sAccess37, obj->Get(sAccess37));
      if (obj->Has(sAccess38)) info.This()->Set(sAccess38, obj->Get(sAccess38));
      if (obj->Has(sAccess39)) info.This()->Set(sAccess39, obj->Get(sAccess39));
      if (obj->Has(sAccess40)) info.This()->Set(sAccess40, obj->Get(sAccess40));
      if (obj->Has(sAccess41)) info.This()->Set(sAccess41, obj->Get(sAccess41));
      if (obj->Has(sAccess42)) info.This()->Set(sAccess42, obj->Get(sAccess42));
      if (obj->Has(sAccess43)) info.This()->Set(sAccess43, obj->Get(sAccess43));
      if (obj->Has(sAccess44)) info.This()->Set(sAccess44, obj->Get(sAccess44));
      if (obj->Has(sAccess45)) info.This()->Set(sAccess45, obj->Get(sAccess45));
      if (obj->Has(sAccess46)) info.This()->Set(sAccess46, obj->Get(sAccess46));
      if (obj->Has(sAccess47)) info.This()->Set(sAccess47, obj->Get(sAccess47));
      if (obj->Has(sAccess48)) info.This()->Set(sAccess48, obj->Get(sAccess48));
      if (obj->Has(sAccess49)) info.This()->Set(sAccess49, obj->Get(sAccess49));
      if (obj->Has(sAccess50)) info.This()->Set(sAccess50, obj->Get(sAccess50));
      if (obj->Has(sAccess51)) info.This()->Set(sAccess51, obj->Get(sAccess51));
      if (obj->Has(sAccess52)) info.This()->Set(sAccess52, obj->Get(sAccess52));
      if (obj->Has(sAccess53)) info.This()->Set(sAccess53, obj->Get(sAccess53));
      if (obj->Has(sAccess54)) info.This()->Set(sAccess54, obj->Get(sAccess54));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceFeatures constructor cannot be invoked without 'new'");
  }
};

// robustBufferAccess
NAN_GETTER(_VkPhysicalDeviceFeatures::GetrobustBufferAccess) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.robustBufferAccess));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetrobustBufferAccess) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.robustBufferAccess = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.robustBufferAccess", "Number");
  
    return;
  }
}// fullDrawIndexUint32
NAN_GETTER(_VkPhysicalDeviceFeatures::GetfullDrawIndexUint32) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fullDrawIndexUint32));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetfullDrawIndexUint32) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.fullDrawIndexUint32 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.fullDrawIndexUint32", "Number");
  
    return;
  }
}// imageCubeArray
NAN_GETTER(_VkPhysicalDeviceFeatures::GetimageCubeArray) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageCubeArray));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetimageCubeArray) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.imageCubeArray = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.imageCubeArray", "Number");
  
    return;
  }
}// independentBlend
NAN_GETTER(_VkPhysicalDeviceFeatures::GetindependentBlend) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.independentBlend));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetindependentBlend) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.independentBlend = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.independentBlend", "Number");
  
    return;
  }
}// geometryShader
NAN_GETTER(_VkPhysicalDeviceFeatures::GetgeometryShader) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.geometryShader));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetgeometryShader) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.geometryShader = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.geometryShader", "Number");
  
    return;
  }
}// tessellationShader
NAN_GETTER(_VkPhysicalDeviceFeatures::GettessellationShader) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tessellationShader));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SettessellationShader) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.tessellationShader = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.tessellationShader", "Number");
  
    return;
  }
}// sampleRateShading
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsampleRateShading) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleRateShading));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsampleRateShading) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sampleRateShading = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sampleRateShading", "Number");
  
    return;
  }
}// dualSrcBlend
NAN_GETTER(_VkPhysicalDeviceFeatures::GetdualSrcBlend) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dualSrcBlend));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetdualSrcBlend) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.dualSrcBlend = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.dualSrcBlend", "Number");
  
    return;
  }
}// logicOp
NAN_GETTER(_VkPhysicalDeviceFeatures::GetlogicOp) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.logicOp));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetlogicOp) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.logicOp = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.logicOp", "Number");
  
    return;
  }
}// multiDrawIndirect
NAN_GETTER(_VkPhysicalDeviceFeatures::GetmultiDrawIndirect) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.multiDrawIndirect));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetmultiDrawIndirect) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.multiDrawIndirect = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.multiDrawIndirect", "Number");
  
    return;
  }
}// drawIndirectFirstInstance
NAN_GETTER(_VkPhysicalDeviceFeatures::GetdrawIndirectFirstInstance) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.drawIndirectFirstInstance));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetdrawIndirectFirstInstance) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.drawIndirectFirstInstance = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.drawIndirectFirstInstance", "Number");
  
    return;
  }
}// depthClamp
NAN_GETTER(_VkPhysicalDeviceFeatures::GetdepthClamp) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthClamp));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetdepthClamp) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.depthClamp = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.depthClamp", "Number");
  
    return;
  }
}// depthBiasClamp
NAN_GETTER(_VkPhysicalDeviceFeatures::GetdepthBiasClamp) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthBiasClamp));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetdepthBiasClamp) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.depthBiasClamp = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.depthBiasClamp", "Number");
  
    return;
  }
}// fillModeNonSolid
NAN_GETTER(_VkPhysicalDeviceFeatures::GetfillModeNonSolid) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fillModeNonSolid));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetfillModeNonSolid) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.fillModeNonSolid = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.fillModeNonSolid", "Number");
  
    return;
  }
}// depthBounds
NAN_GETTER(_VkPhysicalDeviceFeatures::GetdepthBounds) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthBounds));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetdepthBounds) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.depthBounds = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.depthBounds", "Number");
  
    return;
  }
}// wideLines
NAN_GETTER(_VkPhysicalDeviceFeatures::GetwideLines) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.wideLines));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetwideLines) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.wideLines = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.wideLines", "Number");
  
    return;
  }
}// largePoints
NAN_GETTER(_VkPhysicalDeviceFeatures::GetlargePoints) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.largePoints));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetlargePoints) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.largePoints = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.largePoints", "Number");
  
    return;
  }
}// alphaToOne
NAN_GETTER(_VkPhysicalDeviceFeatures::GetalphaToOne) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.alphaToOne));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetalphaToOne) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.alphaToOne = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.alphaToOne", "Number");
  
    return;
  }
}// multiViewport
NAN_GETTER(_VkPhysicalDeviceFeatures::GetmultiViewport) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.multiViewport));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetmultiViewport) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.multiViewport = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.multiViewport", "Number");
  
    return;
  }
}// samplerAnisotropy
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsamplerAnisotropy) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.samplerAnisotropy));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsamplerAnisotropy) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.samplerAnisotropy = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.samplerAnisotropy", "Number");
  
    return;
  }
}// textureCompressionETC2
NAN_GETTER(_VkPhysicalDeviceFeatures::GettextureCompressionETC2) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.textureCompressionETC2));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SettextureCompressionETC2) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.textureCompressionETC2 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.textureCompressionETC2", "Number");
  
    return;
  }
}// textureCompressionASTC_LDR
NAN_GETTER(_VkPhysicalDeviceFeatures::GettextureCompressionASTC_LDR) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.textureCompressionASTC_LDR));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SettextureCompressionASTC_LDR) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.textureCompressionASTC_LDR = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.textureCompressionASTC_LDR", "Number");
  
    return;
  }
}// textureCompressionBC
NAN_GETTER(_VkPhysicalDeviceFeatures::GettextureCompressionBC) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.textureCompressionBC));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SettextureCompressionBC) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.textureCompressionBC = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.textureCompressionBC", "Number");
  
    return;
  }
}// occlusionQueryPrecise
NAN_GETTER(_VkPhysicalDeviceFeatures::GetocclusionQueryPrecise) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.occlusionQueryPrecise));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetocclusionQueryPrecise) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.occlusionQueryPrecise = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.occlusionQueryPrecise", "Number");
  
    return;
  }
}// pipelineStatisticsQuery
NAN_GETTER(_VkPhysicalDeviceFeatures::GetpipelineStatisticsQuery) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pipelineStatisticsQuery));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetpipelineStatisticsQuery) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.pipelineStatisticsQuery = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.pipelineStatisticsQuery", "Number");
  
    return;
  }
}// vertexPipelineStoresAndAtomics
NAN_GETTER(_VkPhysicalDeviceFeatures::GetvertexPipelineStoresAndAtomics) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexPipelineStoresAndAtomics));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetvertexPipelineStoresAndAtomics) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.vertexPipelineStoresAndAtomics = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.vertexPipelineStoresAndAtomics", "Number");
  
    return;
  }
}// fragmentStoresAndAtomics
NAN_GETTER(_VkPhysicalDeviceFeatures::GetfragmentStoresAndAtomics) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.fragmentStoresAndAtomics));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetfragmentStoresAndAtomics) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.fragmentStoresAndAtomics = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.fragmentStoresAndAtomics", "Number");
  
    return;
  }
}// shaderTessellationAndGeometryPointSize
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderTessellationAndGeometryPointSize) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderTessellationAndGeometryPointSize));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderTessellationAndGeometryPointSize) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderTessellationAndGeometryPointSize = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderTessellationAndGeometryPointSize", "Number");
  
    return;
  }
}// shaderImageGatherExtended
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderImageGatherExtended) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderImageGatherExtended));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderImageGatherExtended) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderImageGatherExtended = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderImageGatherExtended", "Number");
  
    return;
  }
}// shaderStorageImageExtendedFormats
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderStorageImageExtendedFormats) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageImageExtendedFormats));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderStorageImageExtendedFormats) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageImageExtendedFormats = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageExtendedFormats", "Number");
  
    return;
  }
}// shaderStorageImageMultisample
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderStorageImageMultisample) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageImageMultisample));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderStorageImageMultisample) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageImageMultisample = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageMultisample", "Number");
  
    return;
  }
}// shaderStorageImageReadWithoutFormat
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderStorageImageReadWithoutFormat) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageImageReadWithoutFormat));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderStorageImageReadWithoutFormat) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageImageReadWithoutFormat = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageReadWithoutFormat", "Number");
  
    return;
  }
}// shaderStorageImageWriteWithoutFormat
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderStorageImageWriteWithoutFormat) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageImageWriteWithoutFormat));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderStorageImageWriteWithoutFormat) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageImageWriteWithoutFormat = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageWriteWithoutFormat", "Number");
  
    return;
  }
}// shaderUniformBufferArrayDynamicIndexing
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderUniformBufferArrayDynamicIndexing) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderUniformBufferArrayDynamicIndexing));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderUniformBufferArrayDynamicIndexing) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderUniformBufferArrayDynamicIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderUniformBufferArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderSampledImageArrayDynamicIndexing
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderSampledImageArrayDynamicIndexing) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderSampledImageArrayDynamicIndexing));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderSampledImageArrayDynamicIndexing) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderSampledImageArrayDynamicIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderSampledImageArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderStorageBufferArrayDynamicIndexing
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderStorageBufferArrayDynamicIndexing) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageBufferArrayDynamicIndexing));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderStorageBufferArrayDynamicIndexing) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageBufferArrayDynamicIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageBufferArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderStorageImageArrayDynamicIndexing
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderStorageImageArrayDynamicIndexing) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderStorageImageArrayDynamicIndexing));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderStorageImageArrayDynamicIndexing) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderStorageImageArrayDynamicIndexing = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderStorageImageArrayDynamicIndexing", "Number");
  
    return;
  }
}// shaderClipDistance
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderClipDistance) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderClipDistance));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderClipDistance) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderClipDistance = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderClipDistance", "Number");
  
    return;
  }
}// shaderCullDistance
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderCullDistance) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderCullDistance));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderCullDistance) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderCullDistance = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderCullDistance", "Number");
  
    return;
  }
}// shaderFloat64
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderFloat64) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderFloat64));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderFloat64) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderFloat64 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderFloat64", "Number");
  
    return;
  }
}// shaderInt64
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderInt64) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderInt64));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderInt64) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderInt64 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderInt64", "Number");
  
    return;
  }
}// shaderInt16
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderInt16) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderInt16));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderInt16) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderInt16 = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderInt16", "Number");
  
    return;
  }
}// shaderResourceResidency
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderResourceResidency) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderResourceResidency));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderResourceResidency) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderResourceResidency = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderResourceResidency", "Number");
  
    return;
  }
}// shaderResourceMinLod
NAN_GETTER(_VkPhysicalDeviceFeatures::GetshaderResourceMinLod) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.shaderResourceMinLod));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetshaderResourceMinLod) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.shaderResourceMinLod = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.shaderResourceMinLod", "Number");
  
    return;
  }
}// sparseBinding
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseBinding) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseBinding));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseBinding) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseBinding = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseBinding", "Number");
  
    return;
  }
}// sparseResidencyBuffer
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseResidencyBuffer) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseResidencyBuffer));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseResidencyBuffer) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseResidencyBuffer = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseResidencyBuffer", "Number");
  
    return;
  }
}// sparseResidencyImage2D
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseResidencyImage2D) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseResidencyImage2D));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseResidencyImage2D) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseResidencyImage2D = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseResidencyImage2D", "Number");
  
    return;
  }
}// sparseResidencyImage3D
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseResidencyImage3D) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseResidencyImage3D));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseResidencyImage3D) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseResidencyImage3D = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseResidencyImage3D", "Number");
  
    return;
  }
}// sparseResidency2Samples
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseResidency2Samples) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseResidency2Samples));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseResidency2Samples) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseResidency2Samples = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseResidency2Samples", "Number");
  
    return;
  }
}// sparseResidency4Samples
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseResidency4Samples) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseResidency4Samples));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseResidency4Samples) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseResidency4Samples = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseResidency4Samples", "Number");
  
    return;
  }
}// sparseResidency8Samples
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseResidency8Samples) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseResidency8Samples));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseResidency8Samples) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseResidency8Samples = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseResidency8Samples", "Number");
  
    return;
  }
}// sparseResidency16Samples
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseResidency16Samples) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseResidency16Samples));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseResidency16Samples) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseResidency16Samples = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseResidency16Samples", "Number");
  
    return;
  }
}// sparseResidencyAliased
NAN_GETTER(_VkPhysicalDeviceFeatures::GetsparseResidencyAliased) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sparseResidencyAliased));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetsparseResidencyAliased) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sparseResidencyAliased = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.sparseResidencyAliased", "Number");
  
    return;
  }
}// variableMultisampleRate
NAN_GETTER(_VkPhysicalDeviceFeatures::GetvariableMultisampleRate) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.variableMultisampleRate));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetvariableMultisampleRate) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.variableMultisampleRate = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.variableMultisampleRate", "Number");
  
    return;
  }
}// inheritedQueries
NAN_GETTER(_VkPhysicalDeviceFeatures::GetinheritedQueries) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.inheritedQueries));
}NAN_SETTER(_VkPhysicalDeviceFeatures::SetinheritedQueries) {
  _VkPhysicalDeviceFeatures *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.inheritedQueries = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures.inheritedQueries", "Number");
  
    return;
  }
}
/** ## END VkPhysicalDeviceFeatures ## **/

/** ## BEGIN VkPhysicalDeviceFeatures2 ## **/

class _VkPhysicalDeviceFeatures2: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> features;
      static NAN_GETTER(Getfeatures);
    static NAN_SETTER(Setfeatures);
    

    // real instance
    VkPhysicalDeviceFeatures2 instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPhysicalDeviceFeatures2();
    ~_VkPhysicalDeviceFeatures2();

};

/*
#include "index.h"
#include "VkPhysicalDeviceFeatures2.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPhysicalDeviceFeatures2::constructor;

_VkPhysicalDeviceFeatures2::_VkPhysicalDeviceFeatures2() {
  instance.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
  
}

_VkPhysicalDeviceFeatures2::~_VkPhysicalDeviceFeatures2() {
  //printf("VkPhysicalDeviceFeatures2 deconstructed!!\n");
  
  
  
}

void _VkPhysicalDeviceFeatures2::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPhysicalDeviceFeatures2::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPhysicalDeviceFeatures2").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("features").ToLocalChecked(), Getfeatures, Setfeatures, ctor);
  Nan::Set(target, Nan::New("VkPhysicalDeviceFeatures2").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPhysicalDeviceFeatures2::flush() {
  _VkPhysicalDeviceFeatures2 *self = this;
  if (!(self->features.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->features);
    
    _VkPhysicalDeviceFeatures* result = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.features = result->instance;
  }
  return true;
}

NAN_METHOD(_VkPhysicalDeviceFeatures2::New) {
  if (info.IsConstructCall()) {
    _VkPhysicalDeviceFeatures2* self = new _VkPhysicalDeviceFeatures2();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("features").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPhysicalDeviceFeatures2 constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPhysicalDeviceFeatures2::GetsType) {
  _VkPhysicalDeviceFeatures2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures2>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPhysicalDeviceFeatures2::SetsType) {
  _VkPhysicalDeviceFeatures2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures2>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures2.sType", "Number");
  
    return;
  }
}// features
NAN_GETTER(_VkPhysicalDeviceFeatures2::Getfeatures) {
  _VkPhysicalDeviceFeatures2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures2>(info.This());
  if (self->features.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->features);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPhysicalDeviceFeatures2::Setfeatures) {
  _VkPhysicalDeviceFeatures2 *self = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures2>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPhysicalDeviceFeatures::constructor)->HasInstance(obj)) {
      self->features.Reset<v8::Object>(value.As<v8::Object>());
      _VkPhysicalDeviceFeatures* inst = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(obj);
      inst->flush();
      self->instance.features = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures2.features", "[object VkPhysicalDeviceFeatures]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->features.Reset();
    memset(&self->instance.features, 0, sizeof(VkPhysicalDeviceFeatures));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPhysicalDeviceFeatures2.features", "[object VkPhysicalDeviceFeatures]");
  
    return;
  }
}
/** ## END VkPhysicalDeviceFeatures2 ## **/

/** ## BEGIN VkObjectTablePushConstantEntryNVX ## **/

class _VkObjectTablePushConstantEntryNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pipelineLayout;
      static NAN_GETTER(GetpipelineLayout);
    static NAN_SETTER(SetpipelineLayout);
    
    static NAN_GETTER(GetstageFlags);
    static NAN_SETTER(SetstageFlags);
    

    // real instance
    VkObjectTablePushConstantEntryNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkObjectTablePushConstantEntryNVX();
    ~_VkObjectTablePushConstantEntryNVX();

};

/*
#include "index.h"
#include "VkObjectTablePushConstantEntryNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkObjectTablePushConstantEntryNVX::constructor;

_VkObjectTablePushConstantEntryNVX::_VkObjectTablePushConstantEntryNVX() {
  
  
}

_VkObjectTablePushConstantEntryNVX::~_VkObjectTablePushConstantEntryNVX() {
  //printf("VkObjectTablePushConstantEntryNVX deconstructed!!\n");
  
  
  
  
  
}

void _VkObjectTablePushConstantEntryNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkObjectTablePushConstantEntryNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkObjectTablePushConstantEntryNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineLayout").ToLocalChecked(), GetpipelineLayout, SetpipelineLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("stageFlags").ToLocalChecked(), GetstageFlags, SetstageFlags, ctor);
  Nan::Set(target, Nan::New("VkObjectTablePushConstantEntryNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkObjectTablePushConstantEntryNVX::flush() {
  _VkObjectTablePushConstantEntryNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkObjectTablePushConstantEntryNVX::New) {
  if (info.IsConstructCall()) {
    _VkObjectTablePushConstantEntryNVX* self = new _VkObjectTablePushConstantEntryNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pipelineLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("stageFlags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkObjectTablePushConstantEntryNVX constructor cannot be invoked without 'new'");
  }
};

// type
NAN_GETTER(_VkObjectTablePushConstantEntryNVX::Gettype) {
  _VkObjectTablePushConstantEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePushConstantEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkObjectTablePushConstantEntryNVX::Settype) {
  _VkObjectTablePushConstantEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePushConstantEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkObjectEntryTypeNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTablePushConstantEntryNVX.type", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkObjectTablePushConstantEntryNVX::Getflags) {
  _VkObjectTablePushConstantEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePushConstantEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkObjectTablePushConstantEntryNVX::Setflags) {
  _VkObjectTablePushConstantEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePushConstantEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTablePushConstantEntryNVX.flags", "Number");
  
    return;
  }
}// pipelineLayout
NAN_GETTER(_VkObjectTablePushConstantEntryNVX::GetpipelineLayout) {
  _VkObjectTablePushConstantEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePushConstantEntryNVX>(info.This());
  if (self->pipelineLayout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pipelineLayout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTablePushConstantEntryNVX::SetpipelineLayout) {
  _VkObjectTablePushConstantEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePushConstantEntryNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineLayout::constructor)->HasInstance(obj)) {
      self->pipelineLayout.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineLayout* inst = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(obj);
      ;
      self->instance.pipelineLayout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTablePushConstantEntryNVX.pipelineLayout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pipelineLayout.Reset();
    self->instance.pipelineLayout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTablePushConstantEntryNVX.pipelineLayout", "[object VkPipelineLayout]");
  
    return;
  }
}// stageFlags
NAN_GETTER(_VkObjectTablePushConstantEntryNVX::GetstageFlags) {
  _VkObjectTablePushConstantEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePushConstantEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stageFlags));
}NAN_SETTER(_VkObjectTablePushConstantEntryNVX::SetstageFlags) {
  _VkObjectTablePushConstantEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePushConstantEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.stageFlags = static_cast<VkShaderStageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTablePushConstantEntryNVX.stageFlags", "Number");
  
    return;
  }
}
/** ## END VkObjectTablePushConstantEntryNVX ## **/

/** ## BEGIN VkObjectTableIndexBufferEntryNVX ## **/

class _VkObjectTableIndexBufferEntryNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    
    static NAN_GETTER(GetindexType);
    static NAN_SETTER(SetindexType);
    

    // real instance
    VkObjectTableIndexBufferEntryNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkObjectTableIndexBufferEntryNVX();
    ~_VkObjectTableIndexBufferEntryNVX();

};

/*
#include "index.h"
#include "VkObjectTableIndexBufferEntryNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkObjectTableIndexBufferEntryNVX::constructor;

_VkObjectTableIndexBufferEntryNVX::_VkObjectTableIndexBufferEntryNVX() {
  
  
}

_VkObjectTableIndexBufferEntryNVX::~_VkObjectTableIndexBufferEntryNVX() {
  //printf("VkObjectTableIndexBufferEntryNVX deconstructed!!\n");
  
  
  
  
  
}

void _VkObjectTableIndexBufferEntryNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkObjectTableIndexBufferEntryNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkObjectTableIndexBufferEntryNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("indexType").ToLocalChecked(), GetindexType, SetindexType, ctor);
  Nan::Set(target, Nan::New("VkObjectTableIndexBufferEntryNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkObjectTableIndexBufferEntryNVX::flush() {
  _VkObjectTableIndexBufferEntryNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkObjectTableIndexBufferEntryNVX::New) {
  if (info.IsConstructCall()) {
    _VkObjectTableIndexBufferEntryNVX* self = new _VkObjectTableIndexBufferEntryNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("buffer").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("indexType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkObjectTableIndexBufferEntryNVX constructor cannot be invoked without 'new'");
  }
};

// type
NAN_GETTER(_VkObjectTableIndexBufferEntryNVX::Gettype) {
  _VkObjectTableIndexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableIndexBufferEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkObjectTableIndexBufferEntryNVX::Settype) {
  _VkObjectTableIndexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableIndexBufferEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkObjectEntryTypeNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableIndexBufferEntryNVX.type", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkObjectTableIndexBufferEntryNVX::Getflags) {
  _VkObjectTableIndexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableIndexBufferEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkObjectTableIndexBufferEntryNVX::Setflags) {
  _VkObjectTableIndexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableIndexBufferEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableIndexBufferEntryNVX.flags", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkObjectTableIndexBufferEntryNVX::Getbuffer) {
  _VkObjectTableIndexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableIndexBufferEntryNVX>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTableIndexBufferEntryNVX::Setbuffer) {
  _VkObjectTableIndexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableIndexBufferEntryNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTableIndexBufferEntryNVX.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableIndexBufferEntryNVX.buffer", "[object VkBuffer]");
  
    return;
  }
}// indexType
NAN_GETTER(_VkObjectTableIndexBufferEntryNVX::GetindexType) {
  _VkObjectTableIndexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableIndexBufferEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.indexType));
}NAN_SETTER(_VkObjectTableIndexBufferEntryNVX::SetindexType) {
  _VkObjectTableIndexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableIndexBufferEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.indexType = static_cast<VkIndexType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableIndexBufferEntryNVX.indexType", "Number");
  
    return;
  }
}
/** ## END VkObjectTableIndexBufferEntryNVX ## **/

/** ## BEGIN VkObjectTableVertexBufferEntryNVX ## **/

class _VkObjectTableVertexBufferEntryNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    

    // real instance
    VkObjectTableVertexBufferEntryNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkObjectTableVertexBufferEntryNVX();
    ~_VkObjectTableVertexBufferEntryNVX();

};

/*
#include "index.h"
#include "VkObjectTableVertexBufferEntryNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkObjectTableVertexBufferEntryNVX::constructor;

_VkObjectTableVertexBufferEntryNVX::_VkObjectTableVertexBufferEntryNVX() {
  
  
}

_VkObjectTableVertexBufferEntryNVX::~_VkObjectTableVertexBufferEntryNVX() {
  //printf("VkObjectTableVertexBufferEntryNVX deconstructed!!\n");
  
  
  
  
}

void _VkObjectTableVertexBufferEntryNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkObjectTableVertexBufferEntryNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkObjectTableVertexBufferEntryNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  Nan::Set(target, Nan::New("VkObjectTableVertexBufferEntryNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkObjectTableVertexBufferEntryNVX::flush() {
  _VkObjectTableVertexBufferEntryNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkObjectTableVertexBufferEntryNVX::New) {
  if (info.IsConstructCall()) {
    _VkObjectTableVertexBufferEntryNVX* self = new _VkObjectTableVertexBufferEntryNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("buffer").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkObjectTableVertexBufferEntryNVX constructor cannot be invoked without 'new'");
  }
};

// type
NAN_GETTER(_VkObjectTableVertexBufferEntryNVX::Gettype) {
  _VkObjectTableVertexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableVertexBufferEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkObjectTableVertexBufferEntryNVX::Settype) {
  _VkObjectTableVertexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableVertexBufferEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkObjectEntryTypeNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableVertexBufferEntryNVX.type", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkObjectTableVertexBufferEntryNVX::Getflags) {
  _VkObjectTableVertexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableVertexBufferEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkObjectTableVertexBufferEntryNVX::Setflags) {
  _VkObjectTableVertexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableVertexBufferEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableVertexBufferEntryNVX.flags", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkObjectTableVertexBufferEntryNVX::Getbuffer) {
  _VkObjectTableVertexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableVertexBufferEntryNVX>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTableVertexBufferEntryNVX::Setbuffer) {
  _VkObjectTableVertexBufferEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableVertexBufferEntryNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTableVertexBufferEntryNVX.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableVertexBufferEntryNVX.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkObjectTableVertexBufferEntryNVX ## **/

/** ## BEGIN VkObjectTableDescriptorSetEntryNVX ## **/

class _VkObjectTableDescriptorSetEntryNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pipelineLayout;
      static NAN_GETTER(GetpipelineLayout);
    static NAN_SETTER(SetpipelineLayout);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> descriptorSet;
      static NAN_GETTER(GetdescriptorSet);
    static NAN_SETTER(SetdescriptorSet);
    

    // real instance
    VkObjectTableDescriptorSetEntryNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkObjectTableDescriptorSetEntryNVX();
    ~_VkObjectTableDescriptorSetEntryNVX();

};

/*
#include "index.h"
#include "VkObjectTableDescriptorSetEntryNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkObjectTableDescriptorSetEntryNVX::constructor;

_VkObjectTableDescriptorSetEntryNVX::_VkObjectTableDescriptorSetEntryNVX() {
  
  
}

_VkObjectTableDescriptorSetEntryNVX::~_VkObjectTableDescriptorSetEntryNVX() {
  //printf("VkObjectTableDescriptorSetEntryNVX deconstructed!!\n");
  
  
  
  
  
}

void _VkObjectTableDescriptorSetEntryNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkObjectTableDescriptorSetEntryNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkObjectTableDescriptorSetEntryNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineLayout").ToLocalChecked(), GetpipelineLayout, SetpipelineLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorSet").ToLocalChecked(), GetdescriptorSet, SetdescriptorSet, ctor);
  Nan::Set(target, Nan::New("VkObjectTableDescriptorSetEntryNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkObjectTableDescriptorSetEntryNVX::flush() {
  _VkObjectTableDescriptorSetEntryNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkObjectTableDescriptorSetEntryNVX::New) {
  if (info.IsConstructCall()) {
    _VkObjectTableDescriptorSetEntryNVX* self = new _VkObjectTableDescriptorSetEntryNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pipelineLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("descriptorSet").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkObjectTableDescriptorSetEntryNVX constructor cannot be invoked without 'new'");
  }
};

// type
NAN_GETTER(_VkObjectTableDescriptorSetEntryNVX::Gettype) {
  _VkObjectTableDescriptorSetEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableDescriptorSetEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkObjectTableDescriptorSetEntryNVX::Settype) {
  _VkObjectTableDescriptorSetEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableDescriptorSetEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkObjectEntryTypeNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableDescriptorSetEntryNVX.type", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkObjectTableDescriptorSetEntryNVX::Getflags) {
  _VkObjectTableDescriptorSetEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableDescriptorSetEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkObjectTableDescriptorSetEntryNVX::Setflags) {
  _VkObjectTableDescriptorSetEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableDescriptorSetEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableDescriptorSetEntryNVX.flags", "Number");
  
    return;
  }
}// pipelineLayout
NAN_GETTER(_VkObjectTableDescriptorSetEntryNVX::GetpipelineLayout) {
  _VkObjectTableDescriptorSetEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableDescriptorSetEntryNVX>(info.This());
  if (self->pipelineLayout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pipelineLayout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTableDescriptorSetEntryNVX::SetpipelineLayout) {
  _VkObjectTableDescriptorSetEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableDescriptorSetEntryNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineLayout::constructor)->HasInstance(obj)) {
      self->pipelineLayout.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineLayout* inst = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(obj);
      ;
      self->instance.pipelineLayout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTableDescriptorSetEntryNVX.pipelineLayout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pipelineLayout.Reset();
    self->instance.pipelineLayout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableDescriptorSetEntryNVX.pipelineLayout", "[object VkPipelineLayout]");
  
    return;
  }
}// descriptorSet
NAN_GETTER(_VkObjectTableDescriptorSetEntryNVX::GetdescriptorSet) {
  _VkObjectTableDescriptorSetEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableDescriptorSetEntryNVX>(info.This());
  if (self->descriptorSet.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->descriptorSet);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTableDescriptorSetEntryNVX::SetdescriptorSet) {
  _VkObjectTableDescriptorSetEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableDescriptorSetEntryNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDescriptorSet::constructor)->HasInstance(obj)) {
      self->descriptorSet.Reset<v8::Object>(value.As<v8::Object>());
      _VkDescriptorSet* inst = Nan::ObjectWrap::Unwrap<_VkDescriptorSet>(obj);
      ;
      self->instance.descriptorSet = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTableDescriptorSetEntryNVX.descriptorSet", "[object VkDescriptorSet]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->descriptorSet.Reset();
    self->instance.descriptorSet = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableDescriptorSetEntryNVX.descriptorSet", "[object VkDescriptorSet]");
  
    return;
  }
}
/** ## END VkObjectTableDescriptorSetEntryNVX ## **/

/** ## BEGIN VkObjectTablePipelineEntryNVX ## **/

class _VkObjectTablePipelineEntryNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pipeline;
      static NAN_GETTER(Getpipeline);
    static NAN_SETTER(Setpipeline);
    

    // real instance
    VkObjectTablePipelineEntryNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkObjectTablePipelineEntryNVX();
    ~_VkObjectTablePipelineEntryNVX();

};

/*
#include "index.h"
#include "VkObjectTablePipelineEntryNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkObjectTablePipelineEntryNVX::constructor;

_VkObjectTablePipelineEntryNVX::_VkObjectTablePipelineEntryNVX() {
  
  
}

_VkObjectTablePipelineEntryNVX::~_VkObjectTablePipelineEntryNVX() {
  //printf("VkObjectTablePipelineEntryNVX deconstructed!!\n");
  
  
  
  
}

void _VkObjectTablePipelineEntryNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkObjectTablePipelineEntryNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkObjectTablePipelineEntryNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipeline").ToLocalChecked(), Getpipeline, Setpipeline, ctor);
  Nan::Set(target, Nan::New("VkObjectTablePipelineEntryNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkObjectTablePipelineEntryNVX::flush() {
  _VkObjectTablePipelineEntryNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkObjectTablePipelineEntryNVX::New) {
  if (info.IsConstructCall()) {
    _VkObjectTablePipelineEntryNVX* self = new _VkObjectTablePipelineEntryNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pipeline").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkObjectTablePipelineEntryNVX constructor cannot be invoked without 'new'");
  }
};

// type
NAN_GETTER(_VkObjectTablePipelineEntryNVX::Gettype) {
  _VkObjectTablePipelineEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePipelineEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkObjectTablePipelineEntryNVX::Settype) {
  _VkObjectTablePipelineEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePipelineEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkObjectEntryTypeNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTablePipelineEntryNVX.type", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkObjectTablePipelineEntryNVX::Getflags) {
  _VkObjectTablePipelineEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePipelineEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkObjectTablePipelineEntryNVX::Setflags) {
  _VkObjectTablePipelineEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePipelineEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTablePipelineEntryNVX.flags", "Number");
  
    return;
  }
}// pipeline
NAN_GETTER(_VkObjectTablePipelineEntryNVX::Getpipeline) {
  _VkObjectTablePipelineEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePipelineEntryNVX>(info.This());
  if (self->pipeline.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pipeline);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTablePipelineEntryNVX::Setpipeline) {
  _VkObjectTablePipelineEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTablePipelineEntryNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipeline::constructor)->HasInstance(obj)) {
      self->pipeline.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipeline* inst = Nan::ObjectWrap::Unwrap<_VkPipeline>(obj);
      ;
      self->instance.pipeline = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTablePipelineEntryNVX.pipeline", "[object VkPipeline]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pipeline.Reset();
    self->instance.pipeline = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTablePipelineEntryNVX.pipeline", "[object VkPipeline]");
  
    return;
  }
}
/** ## END VkObjectTablePipelineEntryNVX ## **/

/** ## BEGIN VkObjectTableEntryNVX ## **/

class _VkObjectTableEntryNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkObjectTableEntryNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkObjectTableEntryNVX();
    ~_VkObjectTableEntryNVX();

};

/*
#include "index.h"
#include "VkObjectTableEntryNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkObjectTableEntryNVX::constructor;

_VkObjectTableEntryNVX::_VkObjectTableEntryNVX() {
  
  
}

_VkObjectTableEntryNVX::~_VkObjectTableEntryNVX() {
  //printf("VkObjectTableEntryNVX deconstructed!!\n");
  
  
  
}

void _VkObjectTableEntryNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkObjectTableEntryNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkObjectTableEntryNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkObjectTableEntryNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkObjectTableEntryNVX::flush() {
  _VkObjectTableEntryNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkObjectTableEntryNVX::New) {
  if (info.IsConstructCall()) {
    _VkObjectTableEntryNVX* self = new _VkObjectTableEntryNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkObjectTableEntryNVX constructor cannot be invoked without 'new'");
  }
};

// type
NAN_GETTER(_VkObjectTableEntryNVX::Gettype) {
  _VkObjectTableEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkObjectTableEntryNVX::Settype) {
  _VkObjectTableEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkObjectEntryTypeNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableEntryNVX.type", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkObjectTableEntryNVX::Getflags) {
  _VkObjectTableEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableEntryNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkObjectTableEntryNVX::Setflags) {
  _VkObjectTableEntryNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableEntryNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkObjectEntryUsageFlagsNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableEntryNVX.flags", "Number");
  
    return;
  }
}
/** ## END VkObjectTableEntryNVX ## **/

/** ## BEGIN VkObjectTableCreateInfoNVX ## **/

class _VkObjectTableCreateInfoNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetobjectCount);
    static NAN_SETTER(SetobjectCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pObjectEntryTypes;
    static NAN_GETTER(GetpObjectEntryTypes);
    static NAN_SETTER(SetpObjectEntryTypes);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pObjectEntryCounts;
    static NAN_GETTER(GetpObjectEntryCounts);
    static NAN_SETTER(SetpObjectEntryCounts);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pObjectEntryUsageFlags;
    static NAN_GETTER(GetpObjectEntryUsageFlags);
    static NAN_SETTER(SetpObjectEntryUsageFlags);
    
    static NAN_GETTER(GetmaxUniformBuffersPerDescriptor);
    static NAN_SETTER(SetmaxUniformBuffersPerDescriptor);
    
    static NAN_GETTER(GetmaxStorageBuffersPerDescriptor);
    static NAN_SETTER(SetmaxStorageBuffersPerDescriptor);
    
    static NAN_GETTER(GetmaxStorageImagesPerDescriptor);
    static NAN_SETTER(SetmaxStorageImagesPerDescriptor);
    
    static NAN_GETTER(GetmaxSampledImagesPerDescriptor);
    static NAN_SETTER(SetmaxSampledImagesPerDescriptor);
    
    static NAN_GETTER(GetmaxPipelineLayouts);
    static NAN_SETTER(SetmaxPipelineLayouts);
    

    // real instance
    VkObjectTableCreateInfoNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkObjectTableCreateInfoNVX();
    ~_VkObjectTableCreateInfoNVX();

};

/*
#include "index.h"
#include "VkObjectTableCreateInfoNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkObjectTableCreateInfoNVX::constructor;

_VkObjectTableCreateInfoNVX::_VkObjectTableCreateInfoNVX() {
  instance.sType = VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX;
  
}

_VkObjectTableCreateInfoNVX::~_VkObjectTableCreateInfoNVX() {
  //printf("VkObjectTableCreateInfoNVX deconstructed!!\n");
  
  
  
  pObjectEntryTypes.Reset();
  
  pObjectEntryCounts.Reset();
  
  pObjectEntryUsageFlags.Reset();
  
  
  
  
  
  
}

void _VkObjectTableCreateInfoNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkObjectTableCreateInfoNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkObjectTableCreateInfoNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectCount").ToLocalChecked(), GetobjectCount, SetobjectCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pObjectEntryTypes").ToLocalChecked(), GetpObjectEntryTypes, SetpObjectEntryTypes, ctor);
  SetPrototypeAccessor(proto, Nan::New("pObjectEntryCounts").ToLocalChecked(), GetpObjectEntryCounts, SetpObjectEntryCounts, ctor);
  SetPrototypeAccessor(proto, Nan::New("pObjectEntryUsageFlags").ToLocalChecked(), GetpObjectEntryUsageFlags, SetpObjectEntryUsageFlags, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxUniformBuffersPerDescriptor").ToLocalChecked(), GetmaxUniformBuffersPerDescriptor, SetmaxUniformBuffersPerDescriptor, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxStorageBuffersPerDescriptor").ToLocalChecked(), GetmaxStorageBuffersPerDescriptor, SetmaxStorageBuffersPerDescriptor, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxStorageImagesPerDescriptor").ToLocalChecked(), GetmaxStorageImagesPerDescriptor, SetmaxStorageImagesPerDescriptor, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSampledImagesPerDescriptor").ToLocalChecked(), GetmaxSampledImagesPerDescriptor, SetmaxSampledImagesPerDescriptor, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxPipelineLayouts").ToLocalChecked(), GetmaxPipelineLayouts, SetmaxPipelineLayouts, ctor);
  Nan::Set(target, Nan::New("VkObjectTableCreateInfoNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkObjectTableCreateInfoNVX::flush() {
  _VkObjectTableCreateInfoNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkObjectTableCreateInfoNVX::New) {
  if (info.IsConstructCall()) {
    _VkObjectTableCreateInfoNVX* self = new _VkObjectTableCreateInfoNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("objectCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pObjectEntryTypes").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pObjectEntryCounts").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pObjectEntryUsageFlags").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("maxUniformBuffersPerDescriptor").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("maxStorageBuffersPerDescriptor").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("maxStorageImagesPerDescriptor").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("maxSampledImagesPerDescriptor").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("maxPipelineLayouts").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkObjectTableCreateInfoNVX constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetsType) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetsType) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.sType", "Number");
  
    return;
  }
}// objectCount
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetobjectCount) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.objectCount));
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetobjectCount) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.objectCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.objectCount", "Number");
  
    return;
  }
}// pObjectEntryTypes
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetpObjectEntryTypes) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (self->pObjectEntryTypes.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pObjectEntryTypes);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetpObjectEntryTypes) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pObjectEntryTypes.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryTypes", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pObjectEntryTypes.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryTypes", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pObjectEntryTypes = reinterpret_cast<const VkObjectEntryTypeNVX *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pObjectEntryTypes = nullptr;
  }
}// pObjectEntryCounts
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetpObjectEntryCounts) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (self->pObjectEntryCounts.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pObjectEntryCounts);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetpObjectEntryCounts) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pObjectEntryCounts.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryCounts", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pObjectEntryCounts.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryCounts", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pObjectEntryCounts = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pObjectEntryCounts = nullptr;
  }
}// pObjectEntryUsageFlags
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetpObjectEntryUsageFlags) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (self->pObjectEntryUsageFlags.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pObjectEntryUsageFlags);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetpObjectEntryUsageFlags) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pObjectEntryUsageFlags.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryUsageFlags", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pObjectEntryUsageFlags.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.pObjectEntryUsageFlags", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pObjectEntryUsageFlags = reinterpret_cast<const VkObjectEntryUsageFlagsNVX *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pObjectEntryUsageFlags = nullptr;
  }
}// maxUniformBuffersPerDescriptor
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetmaxUniformBuffersPerDescriptor) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxUniformBuffersPerDescriptor));
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetmaxUniformBuffersPerDescriptor) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxUniformBuffersPerDescriptor = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.maxUniformBuffersPerDescriptor", "Number");
  
    return;
  }
}// maxStorageBuffersPerDescriptor
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetmaxStorageBuffersPerDescriptor) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxStorageBuffersPerDescriptor));
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetmaxStorageBuffersPerDescriptor) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxStorageBuffersPerDescriptor = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.maxStorageBuffersPerDescriptor", "Number");
  
    return;
  }
}// maxStorageImagesPerDescriptor
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetmaxStorageImagesPerDescriptor) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxStorageImagesPerDescriptor));
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetmaxStorageImagesPerDescriptor) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxStorageImagesPerDescriptor = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.maxStorageImagesPerDescriptor", "Number");
  
    return;
  }
}// maxSampledImagesPerDescriptor
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetmaxSampledImagesPerDescriptor) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSampledImagesPerDescriptor));
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetmaxSampledImagesPerDescriptor) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxSampledImagesPerDescriptor = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.maxSampledImagesPerDescriptor", "Number");
  
    return;
  }
}// maxPipelineLayouts
NAN_GETTER(_VkObjectTableCreateInfoNVX::GetmaxPipelineLayouts) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxPipelineLayouts));
}NAN_SETTER(_VkObjectTableCreateInfoNVX::SetmaxPipelineLayouts) {
  _VkObjectTableCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkObjectTableCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxPipelineLayouts = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkObjectTableCreateInfoNVX.maxPipelineLayouts", "Number");
  
    return;
  }
}
/** ## END VkObjectTableCreateInfoNVX ## **/

/** ## BEGIN VkCmdReserveSpaceForCommandsInfoNVX ## **/

class _VkCmdReserveSpaceForCommandsInfoNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> objectTable;
      static NAN_GETTER(GetobjectTable);
    static NAN_SETTER(SetobjectTable);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> indirectCommandsLayout;
      static NAN_GETTER(GetindirectCommandsLayout);
    static NAN_SETTER(SetindirectCommandsLayout);
    
    static NAN_GETTER(GetmaxSequencesCount);
    static NAN_SETTER(SetmaxSequencesCount);
    

    // real instance
    VkCmdReserveSpaceForCommandsInfoNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCmdReserveSpaceForCommandsInfoNVX();
    ~_VkCmdReserveSpaceForCommandsInfoNVX();

};

/*
#include "index.h"
#include "VkCmdReserveSpaceForCommandsInfoNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCmdReserveSpaceForCommandsInfoNVX::constructor;

_VkCmdReserveSpaceForCommandsInfoNVX::_VkCmdReserveSpaceForCommandsInfoNVX() {
  instance.sType = VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX;
  
}

_VkCmdReserveSpaceForCommandsInfoNVX::~_VkCmdReserveSpaceForCommandsInfoNVX() {
  //printf("VkCmdReserveSpaceForCommandsInfoNVX deconstructed!!\n");
  
  
  
  
  
}

void _VkCmdReserveSpaceForCommandsInfoNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCmdReserveSpaceForCommandsInfoNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCmdReserveSpaceForCommandsInfoNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectTable").ToLocalChecked(), GetobjectTable, SetobjectTable, ctor);
  SetPrototypeAccessor(proto, Nan::New("indirectCommandsLayout").ToLocalChecked(), GetindirectCommandsLayout, SetindirectCommandsLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSequencesCount").ToLocalChecked(), GetmaxSequencesCount, SetmaxSequencesCount, ctor);
  Nan::Set(target, Nan::New("VkCmdReserveSpaceForCommandsInfoNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCmdReserveSpaceForCommandsInfoNVX::flush() {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkCmdReserveSpaceForCommandsInfoNVX::New) {
  if (info.IsConstructCall()) {
    _VkCmdReserveSpaceForCommandsInfoNVX* self = new _VkCmdReserveSpaceForCommandsInfoNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("objectTable").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("indirectCommandsLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("maxSequencesCount").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCmdReserveSpaceForCommandsInfoNVX constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCmdReserveSpaceForCommandsInfoNVX::GetsType) {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCmdReserveSpaceForCommandsInfoNVX::SetsType) {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.sType", "Number");
  
    return;
  }
}// objectTable
NAN_GETTER(_VkCmdReserveSpaceForCommandsInfoNVX::GetobjectTable) {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info.This());
  if (self->objectTable.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->objectTable);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCmdReserveSpaceForCommandsInfoNVX::SetobjectTable) {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkObjectTableNVX::constructor)->HasInstance(obj)) {
      self->objectTable.Reset<v8::Object>(value.As<v8::Object>());
      _VkObjectTableNVX* inst = Nan::ObjectWrap::Unwrap<_VkObjectTableNVX>(obj);
      ;
      self->instance.objectTable = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.objectTable", "[object VkObjectTableNVX]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->objectTable.Reset();
    self->instance.objectTable = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.objectTable", "[object VkObjectTableNVX]");
  
    return;
  }
}// indirectCommandsLayout
NAN_GETTER(_VkCmdReserveSpaceForCommandsInfoNVX::GetindirectCommandsLayout) {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info.This());
  if (self->indirectCommandsLayout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->indirectCommandsLayout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCmdReserveSpaceForCommandsInfoNVX::SetindirectCommandsLayout) {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkIndirectCommandsLayoutNVX::constructor)->HasInstance(obj)) {
      self->indirectCommandsLayout.Reset<v8::Object>(value.As<v8::Object>());
      _VkIndirectCommandsLayoutNVX* inst = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutNVX>(obj);
      ;
      self->instance.indirectCommandsLayout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.indirectCommandsLayout", "[object VkIndirectCommandsLayoutNVX]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->indirectCommandsLayout.Reset();
    self->instance.indirectCommandsLayout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.indirectCommandsLayout", "[object VkIndirectCommandsLayoutNVX]");
  
    return;
  }
}// maxSequencesCount
NAN_GETTER(_VkCmdReserveSpaceForCommandsInfoNVX::GetmaxSequencesCount) {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSequencesCount));
}NAN_SETTER(_VkCmdReserveSpaceForCommandsInfoNVX::SetmaxSequencesCount) {
  _VkCmdReserveSpaceForCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdReserveSpaceForCommandsInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxSequencesCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdReserveSpaceForCommandsInfoNVX.maxSequencesCount", "Number");
  
    return;
  }
}
/** ## END VkCmdReserveSpaceForCommandsInfoNVX ## **/

/** ## BEGIN VkIndirectCommandsTokenNVX ## **/

class _VkIndirectCommandsTokenNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GettokenType);
    static NAN_SETTER(SettokenType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    

    // real instance
    VkIndirectCommandsTokenNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkIndirectCommandsTokenNVX();
    ~_VkIndirectCommandsTokenNVX();

};

/*
#include "index.h"
#include "VkIndirectCommandsTokenNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkIndirectCommandsTokenNVX::constructor;

_VkIndirectCommandsTokenNVX::_VkIndirectCommandsTokenNVX() {
  
  
}

_VkIndirectCommandsTokenNVX::~_VkIndirectCommandsTokenNVX() {
  //printf("VkIndirectCommandsTokenNVX deconstructed!!\n");
  
  
  
  
}

void _VkIndirectCommandsTokenNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkIndirectCommandsTokenNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkIndirectCommandsTokenNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("tokenType").ToLocalChecked(), GettokenType, SettokenType, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  Nan::Set(target, Nan::New("VkIndirectCommandsTokenNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkIndirectCommandsTokenNVX::flush() {
  _VkIndirectCommandsTokenNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkIndirectCommandsTokenNVX::New) {
  if (info.IsConstructCall()) {
    _VkIndirectCommandsTokenNVX* self = new _VkIndirectCommandsTokenNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("tokenType").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("buffer").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("offset").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkIndirectCommandsTokenNVX constructor cannot be invoked without 'new'");
  }
};

// tokenType
NAN_GETTER(_VkIndirectCommandsTokenNVX::GettokenType) {
  _VkIndirectCommandsTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsTokenNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tokenType));
}NAN_SETTER(_VkIndirectCommandsTokenNVX::SettokenType) {
  _VkIndirectCommandsTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsTokenNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.tokenType = static_cast<VkIndirectCommandsTokenTypeNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsTokenNVX.tokenType", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkIndirectCommandsTokenNVX::Getbuffer) {
  _VkIndirectCommandsTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsTokenNVX>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkIndirectCommandsTokenNVX::Setbuffer) {
  _VkIndirectCommandsTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsTokenNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsTokenNVX.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsTokenNVX.buffer", "[object VkBuffer]");
  
    return;
  }
}// offset
NAN_GETTER(_VkIndirectCommandsTokenNVX::Getoffset) {
  _VkIndirectCommandsTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsTokenNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkIndirectCommandsTokenNVX::Setoffset) {
  _VkIndirectCommandsTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsTokenNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsTokenNVX.offset", "Number");
  
    return;
  }
}
/** ## END VkIndirectCommandsTokenNVX ## **/

/** ## BEGIN VkCmdProcessCommandsInfoNVX ## **/

class _VkCmdProcessCommandsInfoNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> objectTable;
      static NAN_GETTER(GetobjectTable);
    static NAN_SETTER(SetobjectTable);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> indirectCommandsLayout;
      static NAN_GETTER(GetindirectCommandsLayout);
    static NAN_SETTER(SetindirectCommandsLayout);
    
    static NAN_GETTER(GetindirectCommandsTokenCount);
    static NAN_SETTER(SetindirectCommandsTokenCount);
    
    std::vector<VkIndirectCommandsTokenNVX>* vpIndirectCommandsTokens;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pIndirectCommandsTokens;
    static NAN_GETTER(GetpIndirectCommandsTokens);
    static NAN_SETTER(SetpIndirectCommandsTokens);
    
    static NAN_GETTER(GetmaxSequencesCount);
    static NAN_SETTER(SetmaxSequencesCount);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> targetCommandBuffer;
      static NAN_GETTER(GettargetCommandBuffer);
    static NAN_SETTER(SettargetCommandBuffer);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> sequencesCountBuffer;
      static NAN_GETTER(GetsequencesCountBuffer);
    static NAN_SETTER(SetsequencesCountBuffer);
    
    static NAN_GETTER(GetsequencesCountOffset);
    static NAN_SETTER(SetsequencesCountOffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> sequencesIndexBuffer;
      static NAN_GETTER(GetsequencesIndexBuffer);
    static NAN_SETTER(SetsequencesIndexBuffer);
    
    static NAN_GETTER(GetsequencesIndexOffset);
    static NAN_SETTER(SetsequencesIndexOffset);
    

    // real instance
    VkCmdProcessCommandsInfoNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCmdProcessCommandsInfoNVX();
    ~_VkCmdProcessCommandsInfoNVX();

};

/*
#include "index.h"
#include "VkCmdProcessCommandsInfoNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCmdProcessCommandsInfoNVX::constructor;

_VkCmdProcessCommandsInfoNVX::_VkCmdProcessCommandsInfoNVX() {
  instance.sType = VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX;
  vpIndirectCommandsTokens = new std::vector<VkIndirectCommandsTokenNVX>;
  
}

_VkCmdProcessCommandsInfoNVX::~_VkCmdProcessCommandsInfoNVX() {
  //printf("VkCmdProcessCommandsInfoNVX deconstructed!!\n");
  
  
  
  
  
  vpIndirectCommandsTokens->clear();
  delete vpIndirectCommandsTokens;
  
  pIndirectCommandsTokens.Reset();
  
  
  
  
  
  
  
}

void _VkCmdProcessCommandsInfoNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCmdProcessCommandsInfoNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCmdProcessCommandsInfoNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectTable").ToLocalChecked(), GetobjectTable, SetobjectTable, ctor);
  SetPrototypeAccessor(proto, Nan::New("indirectCommandsLayout").ToLocalChecked(), GetindirectCommandsLayout, SetindirectCommandsLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("indirectCommandsTokenCount").ToLocalChecked(), GetindirectCommandsTokenCount, SetindirectCommandsTokenCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pIndirectCommandsTokens").ToLocalChecked(), GetpIndirectCommandsTokens, SetpIndirectCommandsTokens, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSequencesCount").ToLocalChecked(), GetmaxSequencesCount, SetmaxSequencesCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("targetCommandBuffer").ToLocalChecked(), GettargetCommandBuffer, SettargetCommandBuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("sequencesCountBuffer").ToLocalChecked(), GetsequencesCountBuffer, SetsequencesCountBuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("sequencesCountOffset").ToLocalChecked(), GetsequencesCountOffset, SetsequencesCountOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("sequencesIndexBuffer").ToLocalChecked(), GetsequencesIndexBuffer, SetsequencesIndexBuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("sequencesIndexOffset").ToLocalChecked(), GetsequencesIndexOffset, SetsequencesIndexOffset, ctor);
  Nan::Set(target, Nan::New("VkCmdProcessCommandsInfoNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCmdProcessCommandsInfoNVX::flush() {
  _VkCmdProcessCommandsInfoNVX *self = this;
  if (!(self->pIndirectCommandsTokens.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pIndirectCommandsTokens);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.indirectCommandsTokenCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'indirectCommandsTokenCount' for 'VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens'");
      return false;
    }
    std::vector<VkIndirectCommandsTokenNVX>* data = self->vpIndirectCommandsTokens;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkIndirectCommandsTokenNVX::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens", "[object VkIndirectCommandsTokenNVX]");
  
        return false;
      }
      _VkIndirectCommandsTokenNVX* result = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsTokenNVX>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pIndirectCommandsTokens = data->data();
  }
  return true;
}

NAN_METHOD(_VkCmdProcessCommandsInfoNVX::New) {
  if (info.IsConstructCall()) {
    _VkCmdProcessCommandsInfoNVX* self = new _VkCmdProcessCommandsInfoNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("objectTable").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("indirectCommandsLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("indirectCommandsTokenCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pIndirectCommandsTokens").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("maxSequencesCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("targetCommandBuffer").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("sequencesCountBuffer").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("sequencesCountOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("sequencesIndexBuffer").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("sequencesIndexOffset").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCmdProcessCommandsInfoNVX constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetsType) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetsType) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.sType", "Number");
  
    return;
  }
}// objectTable
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetobjectTable) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (self->objectTable.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->objectTable);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetobjectTable) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkObjectTableNVX::constructor)->HasInstance(obj)) {
      self->objectTable.Reset<v8::Object>(value.As<v8::Object>());
      _VkObjectTableNVX* inst = Nan::ObjectWrap::Unwrap<_VkObjectTableNVX>(obj);
      ;
      self->instance.objectTable = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.objectTable", "[object VkObjectTableNVX]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->objectTable.Reset();
    self->instance.objectTable = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.objectTable", "[object VkObjectTableNVX]");
  
    return;
  }
}// indirectCommandsLayout
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetindirectCommandsLayout) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (self->indirectCommandsLayout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->indirectCommandsLayout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetindirectCommandsLayout) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkIndirectCommandsLayoutNVX::constructor)->HasInstance(obj)) {
      self->indirectCommandsLayout.Reset<v8::Object>(value.As<v8::Object>());
      _VkIndirectCommandsLayoutNVX* inst = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutNVX>(obj);
      ;
      self->instance.indirectCommandsLayout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.indirectCommandsLayout", "[object VkIndirectCommandsLayoutNVX]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->indirectCommandsLayout.Reset();
    self->instance.indirectCommandsLayout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.indirectCommandsLayout", "[object VkIndirectCommandsLayoutNVX]");
  
    return;
  }
}// indirectCommandsTokenCount
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetindirectCommandsTokenCount) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.indirectCommandsTokenCount));
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetindirectCommandsTokenCount) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.indirectCommandsTokenCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.indirectCommandsTokenCount", "Number");
  
    return;
  }
}// pIndirectCommandsTokens
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetpIndirectCommandsTokens) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (self->pIndirectCommandsTokens.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pIndirectCommandsTokens);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetpIndirectCommandsTokens) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pIndirectCommandsTokens.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pIndirectCommandsTokens.Reset();
      self->instance.pIndirectCommandsTokens = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens", "[object VkIndirectCommandsTokenNVX]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pIndirectCommandsTokens = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens", "[object VkIndirectCommandsTokenNVX]");
  
    return;
  }
}// maxSequencesCount
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetmaxSequencesCount) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSequencesCount));
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetmaxSequencesCount) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxSequencesCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.maxSequencesCount", "Number");
  
    return;
  }
}// targetCommandBuffer
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GettargetCommandBuffer) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (self->targetCommandBuffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->targetCommandBuffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SettargetCommandBuffer) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkCommandBuffer::constructor)->HasInstance(obj)) {
      self->targetCommandBuffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkCommandBuffer* inst = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(obj);
      ;
      self->instance.targetCommandBuffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.targetCommandBuffer", "[object VkCommandBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->targetCommandBuffer.Reset();
    self->instance.targetCommandBuffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.targetCommandBuffer", "[object VkCommandBuffer]");
  
    return;
  }
}// sequencesCountBuffer
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetsequencesCountBuffer) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (self->sequencesCountBuffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->sequencesCountBuffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetsequencesCountBuffer) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->sequencesCountBuffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.sequencesCountBuffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesCountBuffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->sequencesCountBuffer.Reset();
    self->instance.sequencesCountBuffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesCountBuffer", "[object VkBuffer]");
  
    return;
  }
}// sequencesCountOffset
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetsequencesCountOffset) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sequencesCountOffset));
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetsequencesCountOffset) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.sequencesCountOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesCountOffset", "Number");
  
    return;
  }
}// sequencesIndexBuffer
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetsequencesIndexBuffer) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (self->sequencesIndexBuffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->sequencesIndexBuffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetsequencesIndexBuffer) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->sequencesIndexBuffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.sequencesIndexBuffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesIndexBuffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->sequencesIndexBuffer.Reset();
    self->instance.sequencesIndexBuffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesIndexBuffer", "[object VkBuffer]");
  
    return;
  }
}// sequencesIndexOffset
NAN_GETTER(_VkCmdProcessCommandsInfoNVX::GetsequencesIndexOffset) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sequencesIndexOffset));
}NAN_SETTER(_VkCmdProcessCommandsInfoNVX::SetsequencesIndexOffset) {
  _VkCmdProcessCommandsInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkCmdProcessCommandsInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.sequencesIndexOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCmdProcessCommandsInfoNVX.sequencesIndexOffset", "Number");
  
    return;
  }
}
/** ## END VkCmdProcessCommandsInfoNVX ## **/

/** ## BEGIN VkIndirectCommandsLayoutTokenNVX ## **/

class _VkIndirectCommandsLayoutTokenNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GettokenType);
    static NAN_SETTER(SettokenType);
    
    static NAN_GETTER(GetbindingUnit);
    static NAN_SETTER(SetbindingUnit);
    
    static NAN_GETTER(GetdynamicCount);
    static NAN_SETTER(SetdynamicCount);
    
    static NAN_GETTER(Getdivisor);
    static NAN_SETTER(Setdivisor);
    

    // real instance
    VkIndirectCommandsLayoutTokenNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkIndirectCommandsLayoutTokenNVX();
    ~_VkIndirectCommandsLayoutTokenNVX();

};

/*
#include "index.h"
#include "VkIndirectCommandsLayoutTokenNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkIndirectCommandsLayoutTokenNVX::constructor;

_VkIndirectCommandsLayoutTokenNVX::_VkIndirectCommandsLayoutTokenNVX() {
  
  
}

_VkIndirectCommandsLayoutTokenNVX::~_VkIndirectCommandsLayoutTokenNVX() {
  //printf("VkIndirectCommandsLayoutTokenNVX deconstructed!!\n");
  
  
  
  
  
}

void _VkIndirectCommandsLayoutTokenNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkIndirectCommandsLayoutTokenNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkIndirectCommandsLayoutTokenNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("tokenType").ToLocalChecked(), GettokenType, SettokenType, ctor);
  SetPrototypeAccessor(proto, Nan::New("bindingUnit").ToLocalChecked(), GetbindingUnit, SetbindingUnit, ctor);
  SetPrototypeAccessor(proto, Nan::New("dynamicCount").ToLocalChecked(), GetdynamicCount, SetdynamicCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("divisor").ToLocalChecked(), Getdivisor, Setdivisor, ctor);
  Nan::Set(target, Nan::New("VkIndirectCommandsLayoutTokenNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkIndirectCommandsLayoutTokenNVX::flush() {
  _VkIndirectCommandsLayoutTokenNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkIndirectCommandsLayoutTokenNVX::New) {
  if (info.IsConstructCall()) {
    _VkIndirectCommandsLayoutTokenNVX* self = new _VkIndirectCommandsLayoutTokenNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("tokenType").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("bindingUnit").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dynamicCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("divisor").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkIndirectCommandsLayoutTokenNVX constructor cannot be invoked without 'new'");
  }
};

// tokenType
NAN_GETTER(_VkIndirectCommandsLayoutTokenNVX::GettokenType) {
  _VkIndirectCommandsLayoutTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tokenType));
}NAN_SETTER(_VkIndirectCommandsLayoutTokenNVX::SettokenType) {
  _VkIndirectCommandsLayoutTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.tokenType = static_cast<VkIndirectCommandsTokenTypeNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutTokenNVX.tokenType", "Number");
  
    return;
  }
}// bindingUnit
NAN_GETTER(_VkIndirectCommandsLayoutTokenNVX::GetbindingUnit) {
  _VkIndirectCommandsLayoutTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bindingUnit));
}NAN_SETTER(_VkIndirectCommandsLayoutTokenNVX::SetbindingUnit) {
  _VkIndirectCommandsLayoutTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.bindingUnit = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutTokenNVX.bindingUnit", "Number");
  
    return;
  }
}// dynamicCount
NAN_GETTER(_VkIndirectCommandsLayoutTokenNVX::GetdynamicCount) {
  _VkIndirectCommandsLayoutTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dynamicCount));
}NAN_SETTER(_VkIndirectCommandsLayoutTokenNVX::SetdynamicCount) {
  _VkIndirectCommandsLayoutTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.dynamicCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutTokenNVX.dynamicCount", "Number");
  
    return;
  }
}// divisor
NAN_GETTER(_VkIndirectCommandsLayoutTokenNVX::Getdivisor) {
  _VkIndirectCommandsLayoutTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.divisor));
}NAN_SETTER(_VkIndirectCommandsLayoutTokenNVX::Setdivisor) {
  _VkIndirectCommandsLayoutTokenNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.divisor = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutTokenNVX.divisor", "Number");
  
    return;
  }
}
/** ## END VkIndirectCommandsLayoutTokenNVX ## **/

/** ## BEGIN VkIndirectCommandsLayoutCreateInfoNVX ## **/

class _VkIndirectCommandsLayoutCreateInfoNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetpipelineBindPoint);
    static NAN_SETTER(SetpipelineBindPoint);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GettokenCount);
    static NAN_SETTER(SettokenCount);
    
    std::vector<VkIndirectCommandsLayoutTokenNVX>* vpTokens;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pTokens;
    static NAN_GETTER(GetpTokens);
    static NAN_SETTER(SetpTokens);
    

    // real instance
    VkIndirectCommandsLayoutCreateInfoNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkIndirectCommandsLayoutCreateInfoNVX();
    ~_VkIndirectCommandsLayoutCreateInfoNVX();

};

/*
#include "index.h"
#include "VkIndirectCommandsLayoutCreateInfoNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkIndirectCommandsLayoutCreateInfoNVX::constructor;

_VkIndirectCommandsLayoutCreateInfoNVX::_VkIndirectCommandsLayoutCreateInfoNVX() {
  instance.sType = VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX;
  vpTokens = new std::vector<VkIndirectCommandsLayoutTokenNVX>;
  
}

_VkIndirectCommandsLayoutCreateInfoNVX::~_VkIndirectCommandsLayoutCreateInfoNVX() {
  //printf("VkIndirectCommandsLayoutCreateInfoNVX deconstructed!!\n");
  
  
  
  
  
  vpTokens->clear();
  delete vpTokens;
  
  pTokens.Reset();
  
}

void _VkIndirectCommandsLayoutCreateInfoNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkIndirectCommandsLayoutCreateInfoNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkIndirectCommandsLayoutCreateInfoNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineBindPoint").ToLocalChecked(), GetpipelineBindPoint, SetpipelineBindPoint, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("tokenCount").ToLocalChecked(), GettokenCount, SettokenCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pTokens").ToLocalChecked(), GetpTokens, SetpTokens, ctor);
  Nan::Set(target, Nan::New("VkIndirectCommandsLayoutCreateInfoNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkIndirectCommandsLayoutCreateInfoNVX::flush() {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = this;
  if (!(self->pTokens.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pTokens);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.tokenCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'tokenCount' for 'VkIndirectCommandsLayoutCreateInfoNVX.pTokens'");
      return false;
    }
    std::vector<VkIndirectCommandsLayoutTokenNVX>* data = self->vpTokens;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkIndirectCommandsLayoutTokenNVX::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pTokens", "[object VkIndirectCommandsLayoutTokenNVX]");
  
        return false;
      }
      _VkIndirectCommandsLayoutTokenNVX* result = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutTokenNVX>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pTokens = data->data();
  }
  return true;
}

NAN_METHOD(_VkIndirectCommandsLayoutCreateInfoNVX::New) {
  if (info.IsConstructCall()) {
    _VkIndirectCommandsLayoutCreateInfoNVX* self = new _VkIndirectCommandsLayoutCreateInfoNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pipelineBindPoint").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("tokenCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pTokens").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkIndirectCommandsLayoutCreateInfoNVX constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkIndirectCommandsLayoutCreateInfoNVX::GetsType) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkIndirectCommandsLayoutCreateInfoNVX::SetsType) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.sType", "Number");
  
    return;
  }
}// pipelineBindPoint
NAN_GETTER(_VkIndirectCommandsLayoutCreateInfoNVX::GetpipelineBindPoint) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pipelineBindPoint));
}NAN_SETTER(_VkIndirectCommandsLayoutCreateInfoNVX::SetpipelineBindPoint) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pipelineBindPoint", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkIndirectCommandsLayoutCreateInfoNVX::Getflags) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkIndirectCommandsLayoutCreateInfoNVX::Setflags) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkIndirectCommandsLayoutUsageFlagsNVX>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.flags", "Number");
  
    return;
  }
}// tokenCount
NAN_GETTER(_VkIndirectCommandsLayoutCreateInfoNVX::GettokenCount) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tokenCount));
}NAN_SETTER(_VkIndirectCommandsLayoutCreateInfoNVX::SettokenCount) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.tokenCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.tokenCount", "Number");
  
    return;
  }
}// pTokens
NAN_GETTER(_VkIndirectCommandsLayoutCreateInfoNVX::GetpTokens) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  if (self->pTokens.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pTokens);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkIndirectCommandsLayoutCreateInfoNVX::SetpTokens) {
  _VkIndirectCommandsLayoutCreateInfoNVX *self = Nan::ObjectWrap::Unwrap<_VkIndirectCommandsLayoutCreateInfoNVX>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pTokens.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pTokens.Reset();
      self->instance.pTokens = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pTokens", "[object VkIndirectCommandsLayoutTokenNVX]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pTokens = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkIndirectCommandsLayoutCreateInfoNVX.pTokens", "[object VkIndirectCommandsLayoutTokenNVX]");
  
    return;
  }
}
/** ## END VkIndirectCommandsLayoutCreateInfoNVX ## **/

/** ## BEGIN VkDeviceGeneratedCommandsLimitsNVX ## **/

class _VkDeviceGeneratedCommandsLimitsNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetmaxIndirectCommandsLayoutTokenCount);
    static NAN_SETTER(SetmaxIndirectCommandsLayoutTokenCount);
    
    static NAN_GETTER(GetmaxObjectEntryCounts);
    static NAN_SETTER(SetmaxObjectEntryCounts);
    
    static NAN_GETTER(GetminSequenceCountBufferOffsetAlignment);
    static NAN_SETTER(SetminSequenceCountBufferOffsetAlignment);
    
    static NAN_GETTER(GetminSequenceIndexBufferOffsetAlignment);
    static NAN_SETTER(SetminSequenceIndexBufferOffsetAlignment);
    
    static NAN_GETTER(GetminCommandsTokenBufferOffsetAlignment);
    static NAN_SETTER(SetminCommandsTokenBufferOffsetAlignment);
    

    // real instance
    VkDeviceGeneratedCommandsLimitsNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGeneratedCommandsLimitsNVX();
    ~_VkDeviceGeneratedCommandsLimitsNVX();

};

/*
#include "index.h"
#include "VkDeviceGeneratedCommandsLimitsNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGeneratedCommandsLimitsNVX::constructor;

_VkDeviceGeneratedCommandsLimitsNVX::_VkDeviceGeneratedCommandsLimitsNVX() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX;
  
}

_VkDeviceGeneratedCommandsLimitsNVX::~_VkDeviceGeneratedCommandsLimitsNVX() {
  //printf("VkDeviceGeneratedCommandsLimitsNVX deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkDeviceGeneratedCommandsLimitsNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGeneratedCommandsLimitsNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGeneratedCommandsLimitsNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxIndirectCommandsLayoutTokenCount").ToLocalChecked(), GetmaxIndirectCommandsLayoutTokenCount, SetmaxIndirectCommandsLayoutTokenCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxObjectEntryCounts").ToLocalChecked(), GetmaxObjectEntryCounts, SetmaxObjectEntryCounts, ctor);
  SetPrototypeAccessor(proto, Nan::New("minSequenceCountBufferOffsetAlignment").ToLocalChecked(), GetminSequenceCountBufferOffsetAlignment, SetminSequenceCountBufferOffsetAlignment, ctor);
  SetPrototypeAccessor(proto, Nan::New("minSequenceIndexBufferOffsetAlignment").ToLocalChecked(), GetminSequenceIndexBufferOffsetAlignment, SetminSequenceIndexBufferOffsetAlignment, ctor);
  SetPrototypeAccessor(proto, Nan::New("minCommandsTokenBufferOffsetAlignment").ToLocalChecked(), GetminCommandsTokenBufferOffsetAlignment, SetminCommandsTokenBufferOffsetAlignment, ctor);
  Nan::Set(target, Nan::New("VkDeviceGeneratedCommandsLimitsNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGeneratedCommandsLimitsNVX::flush() {
  _VkDeviceGeneratedCommandsLimitsNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGeneratedCommandsLimitsNVX::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGeneratedCommandsLimitsNVX* self = new _VkDeviceGeneratedCommandsLimitsNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("maxIndirectCommandsLayoutTokenCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("maxObjectEntryCounts").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("minSequenceCountBufferOffsetAlignment").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("minSequenceIndexBufferOffsetAlignment").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("minCommandsTokenBufferOffsetAlignment").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGeneratedCommandsLimitsNVX constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGeneratedCommandsLimitsNVX::GetsType) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGeneratedCommandsLimitsNVX::SetsType) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.sType", "Number");
  
    return;
  }
}// maxIndirectCommandsLayoutTokenCount
NAN_GETTER(_VkDeviceGeneratedCommandsLimitsNVX::GetmaxIndirectCommandsLayoutTokenCount) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxIndirectCommandsLayoutTokenCount));
}NAN_SETTER(_VkDeviceGeneratedCommandsLimitsNVX::SetmaxIndirectCommandsLayoutTokenCount) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxIndirectCommandsLayoutTokenCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.maxIndirectCommandsLayoutTokenCount", "Number");
  
    return;
  }
}// maxObjectEntryCounts
NAN_GETTER(_VkDeviceGeneratedCommandsLimitsNVX::GetmaxObjectEntryCounts) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxObjectEntryCounts));
}NAN_SETTER(_VkDeviceGeneratedCommandsLimitsNVX::SetmaxObjectEntryCounts) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.maxObjectEntryCounts = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.maxObjectEntryCounts", "Number");
  
    return;
  }
}// minSequenceCountBufferOffsetAlignment
NAN_GETTER(_VkDeviceGeneratedCommandsLimitsNVX::GetminSequenceCountBufferOffsetAlignment) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minSequenceCountBufferOffsetAlignment));
}NAN_SETTER(_VkDeviceGeneratedCommandsLimitsNVX::SetminSequenceCountBufferOffsetAlignment) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.minSequenceCountBufferOffsetAlignment = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.minSequenceCountBufferOffsetAlignment", "Number");
  
    return;
  }
}// minSequenceIndexBufferOffsetAlignment
NAN_GETTER(_VkDeviceGeneratedCommandsLimitsNVX::GetminSequenceIndexBufferOffsetAlignment) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minSequenceIndexBufferOffsetAlignment));
}NAN_SETTER(_VkDeviceGeneratedCommandsLimitsNVX::SetminSequenceIndexBufferOffsetAlignment) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.minSequenceIndexBufferOffsetAlignment = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.minSequenceIndexBufferOffsetAlignment", "Number");
  
    return;
  }
}// minCommandsTokenBufferOffsetAlignment
NAN_GETTER(_VkDeviceGeneratedCommandsLimitsNVX::GetminCommandsTokenBufferOffsetAlignment) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minCommandsTokenBufferOffsetAlignment));
}NAN_SETTER(_VkDeviceGeneratedCommandsLimitsNVX::SetminCommandsTokenBufferOffsetAlignment) {
  _VkDeviceGeneratedCommandsLimitsNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsLimitsNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.minCommandsTokenBufferOffsetAlignment = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGeneratedCommandsLimitsNVX.minCommandsTokenBufferOffsetAlignment", "Number");
  
    return;
  }
}
/** ## END VkDeviceGeneratedCommandsLimitsNVX ## **/

/** ## BEGIN VkDeviceGeneratedCommandsFeaturesNVX ## **/

class _VkDeviceGeneratedCommandsFeaturesNVX: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetcomputeBindingPointSupport);
    static NAN_SETTER(SetcomputeBindingPointSupport);
    

    // real instance
    VkDeviceGeneratedCommandsFeaturesNVX instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceGeneratedCommandsFeaturesNVX();
    ~_VkDeviceGeneratedCommandsFeaturesNVX();

};

/*
#include "index.h"
#include "VkDeviceGeneratedCommandsFeaturesNVX.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceGeneratedCommandsFeaturesNVX::constructor;

_VkDeviceGeneratedCommandsFeaturesNVX::_VkDeviceGeneratedCommandsFeaturesNVX() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX;
  
}

_VkDeviceGeneratedCommandsFeaturesNVX::~_VkDeviceGeneratedCommandsFeaturesNVX() {
  //printf("VkDeviceGeneratedCommandsFeaturesNVX deconstructed!!\n");
  
  
  
}

void _VkDeviceGeneratedCommandsFeaturesNVX::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceGeneratedCommandsFeaturesNVX::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceGeneratedCommandsFeaturesNVX").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("computeBindingPointSupport").ToLocalChecked(), GetcomputeBindingPointSupport, SetcomputeBindingPointSupport, ctor);
  Nan::Set(target, Nan::New("VkDeviceGeneratedCommandsFeaturesNVX").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceGeneratedCommandsFeaturesNVX::flush() {
  _VkDeviceGeneratedCommandsFeaturesNVX *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceGeneratedCommandsFeaturesNVX::New) {
  if (info.IsConstructCall()) {
    _VkDeviceGeneratedCommandsFeaturesNVX* self = new _VkDeviceGeneratedCommandsFeaturesNVX();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("computeBindingPointSupport").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceGeneratedCommandsFeaturesNVX constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceGeneratedCommandsFeaturesNVX::GetsType) {
  _VkDeviceGeneratedCommandsFeaturesNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsFeaturesNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceGeneratedCommandsFeaturesNVX::SetsType) {
  _VkDeviceGeneratedCommandsFeaturesNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsFeaturesNVX>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGeneratedCommandsFeaturesNVX.sType", "Number");
  
    return;
  }
}// computeBindingPointSupport
NAN_GETTER(_VkDeviceGeneratedCommandsFeaturesNVX::GetcomputeBindingPointSupport) {
  _VkDeviceGeneratedCommandsFeaturesNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsFeaturesNVX>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.computeBindingPointSupport));
}NAN_SETTER(_VkDeviceGeneratedCommandsFeaturesNVX::SetcomputeBindingPointSupport) {
  _VkDeviceGeneratedCommandsFeaturesNVX *self = Nan::ObjectWrap::Unwrap<_VkDeviceGeneratedCommandsFeaturesNVX>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.computeBindingPointSupport = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceGeneratedCommandsFeaturesNVX.computeBindingPointSupport", "Number");
  
    return;
  }
}
/** ## END VkDeviceGeneratedCommandsFeaturesNVX ## **/

/** ## BEGIN VkWin32KeyedMutexAcquireReleaseInfoNV ## **/

class _VkWin32KeyedMutexAcquireReleaseInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetacquireCount);
    static NAN_SETTER(SetacquireCount);
    
    std::vector<VkDeviceMemory>* vpAcquireSyncs;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAcquireSyncs;
    static NAN_GETTER(GetpAcquireSyncs);
    static NAN_SETTER(SetpAcquireSyncs);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAcquireKeys;
    static NAN_GETTER(GetpAcquireKeys);
    static NAN_SETTER(SetpAcquireKeys);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAcquireTimeoutMilliseconds;
    static NAN_GETTER(GetpAcquireTimeoutMilliseconds);
    static NAN_SETTER(SetpAcquireTimeoutMilliseconds);
    
    static NAN_GETTER(GetreleaseCount);
    static NAN_SETTER(SetreleaseCount);
    
    std::vector<VkDeviceMemory>* vpReleaseSyncs;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pReleaseSyncs;
    static NAN_GETTER(GetpReleaseSyncs);
    static NAN_SETTER(SetpReleaseSyncs);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pReleaseKeys;
    static NAN_GETTER(GetpReleaseKeys);
    static NAN_SETTER(SetpReleaseKeys);
    

    // real instance
    VkWin32KeyedMutexAcquireReleaseInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkWin32KeyedMutexAcquireReleaseInfoNV();
    ~_VkWin32KeyedMutexAcquireReleaseInfoNV();

};

/*
#include "index.h"
#include "VkWin32KeyedMutexAcquireReleaseInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkWin32KeyedMutexAcquireReleaseInfoNV::constructor;

_VkWin32KeyedMutexAcquireReleaseInfoNV::_VkWin32KeyedMutexAcquireReleaseInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV;
  vpAcquireSyncs = new std::vector<VkDeviceMemory>;
  vpReleaseSyncs = new std::vector<VkDeviceMemory>;
  
}

_VkWin32KeyedMutexAcquireReleaseInfoNV::~_VkWin32KeyedMutexAcquireReleaseInfoNV() {
  //printf("VkWin32KeyedMutexAcquireReleaseInfoNV deconstructed!!\n");
  
  
  
  vpAcquireSyncs->clear();
  delete vpAcquireSyncs;
  
  pAcquireSyncs.Reset();
  
  pAcquireKeys.Reset();
  
  pAcquireTimeoutMilliseconds.Reset();
  
  
  vpReleaseSyncs->clear();
  delete vpReleaseSyncs;
  
  pReleaseSyncs.Reset();
  
  pReleaseKeys.Reset();
  
}

void _VkWin32KeyedMutexAcquireReleaseInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkWin32KeyedMutexAcquireReleaseInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkWin32KeyedMutexAcquireReleaseInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("acquireCount").ToLocalChecked(), GetacquireCount, SetacquireCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAcquireSyncs").ToLocalChecked(), GetpAcquireSyncs, SetpAcquireSyncs, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAcquireKeys").ToLocalChecked(), GetpAcquireKeys, SetpAcquireKeys, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAcquireTimeoutMilliseconds").ToLocalChecked(), GetpAcquireTimeoutMilliseconds, SetpAcquireTimeoutMilliseconds, ctor);
  SetPrototypeAccessor(proto, Nan::New("releaseCount").ToLocalChecked(), GetreleaseCount, SetreleaseCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pReleaseSyncs").ToLocalChecked(), GetpReleaseSyncs, SetpReleaseSyncs, ctor);
  SetPrototypeAccessor(proto, Nan::New("pReleaseKeys").ToLocalChecked(), GetpReleaseKeys, SetpReleaseKeys, ctor);
  Nan::Set(target, Nan::New("VkWin32KeyedMutexAcquireReleaseInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkWin32KeyedMutexAcquireReleaseInfoNV::flush() {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = this;
  if (!(self->pAcquireSyncs.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAcquireSyncs);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.acquireCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'acquireCount' for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs'");
      return false;
    }
    std::vector<VkDeviceMemory>* data = self->vpAcquireSyncs;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs", "[object VkDeviceMemory]");
  
        return false;
      }
      _VkDeviceMemory* result = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pAcquireSyncs = data->data();
  }if (!(self->pReleaseSyncs.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pReleaseSyncs);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.releaseCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'releaseCount' for 'VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs'");
      return false;
    }
    std::vector<VkDeviceMemory>* data = self->vpReleaseSyncs;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs", "[object VkDeviceMemory]");
  
        return false;
      }
      _VkDeviceMemory* result = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pReleaseSyncs = data->data();
  }
  return true;
}

NAN_METHOD(_VkWin32KeyedMutexAcquireReleaseInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkWin32KeyedMutexAcquireReleaseInfoNV* self = new _VkWin32KeyedMutexAcquireReleaseInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("acquireCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pAcquireSyncs").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pAcquireKeys").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pAcquireTimeoutMilliseconds").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("releaseCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pReleaseSyncs").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pReleaseKeys").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkWin32KeyedMutexAcquireReleaseInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::GetsType) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::SetsType) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.sType", "Number");
  
    return;
  }
}// acquireCount
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::GetacquireCount) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.acquireCount));
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::SetacquireCount) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.acquireCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.acquireCount", "Number");
  
    return;
  }
}// pAcquireSyncs
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireSyncs) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  if (self->pAcquireSyncs.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAcquireSyncs);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireSyncs) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAcquireSyncs.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAcquireSyncs.Reset();
      self->instance.pAcquireSyncs = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs", "[object VkDeviceMemory]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAcquireSyncs = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireSyncs", "[object VkDeviceMemory]");
  
    return;
  }
}// pAcquireKeys
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireKeys) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  if (self->pAcquireKeys.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAcquireKeys);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireKeys) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsBigUint64Array()) {
        self->pAcquireKeys.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireKeys", "BigUint64Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pAcquireKeys.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireKeys", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pAcquireKeys = getTypedArrayData<uint64_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pAcquireKeys = nullptr;
  }
}// pAcquireTimeoutMilliseconds
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpAcquireTimeoutMilliseconds) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  if (self->pAcquireTimeoutMilliseconds.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAcquireTimeoutMilliseconds);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpAcquireTimeoutMilliseconds) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pAcquireTimeoutMilliseconds.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireTimeoutMilliseconds", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pAcquireTimeoutMilliseconds.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pAcquireTimeoutMilliseconds", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pAcquireTimeoutMilliseconds = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pAcquireTimeoutMilliseconds = nullptr;
  }
}// releaseCount
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::GetreleaseCount) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.releaseCount));
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::SetreleaseCount) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.releaseCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.releaseCount", "Number");
  
    return;
  }
}// pReleaseSyncs
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpReleaseSyncs) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  if (self->pReleaseSyncs.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pReleaseSyncs);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpReleaseSyncs) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pReleaseSyncs.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pReleaseSyncs.Reset();
      self->instance.pReleaseSyncs = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs", "[object VkDeviceMemory]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pReleaseSyncs = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseSyncs", "[object VkDeviceMemory]");
  
    return;
  }
}// pReleaseKeys
NAN_GETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::GetpReleaseKeys) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  if (self->pReleaseKeys.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pReleaseKeys);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWin32KeyedMutexAcquireReleaseInfoNV::SetpReleaseKeys) {
  _VkWin32KeyedMutexAcquireReleaseInfoNV *self = Nan::ObjectWrap::Unwrap<_VkWin32KeyedMutexAcquireReleaseInfoNV>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsBigUint64Array()) {
        self->pReleaseKeys.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseKeys", "BigUint64Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pReleaseKeys.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWin32KeyedMutexAcquireReleaseInfoNV.pReleaseKeys", "BigUint64Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pReleaseKeys = getTypedArrayData<uint64_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pReleaseKeys = nullptr;
  }
}
/** ## END VkWin32KeyedMutexAcquireReleaseInfoNV ## **/

/** ## BEGIN VkExportMemoryWin32HandleInfoNV ## **/

class _VkExportMemoryWin32HandleInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    

    // real instance
    VkExportMemoryWin32HandleInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportMemoryWin32HandleInfoNV();
    ~_VkExportMemoryWin32HandleInfoNV();

};

/*
#include "index.h"
#include "VkExportMemoryWin32HandleInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportMemoryWin32HandleInfoNV::constructor;

_VkExportMemoryWin32HandleInfoNV::_VkExportMemoryWin32HandleInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV;
  
}

_VkExportMemoryWin32HandleInfoNV::~_VkExportMemoryWin32HandleInfoNV() {
  //printf("VkExportMemoryWin32HandleInfoNV deconstructed!!\n");
  
  
}

void _VkExportMemoryWin32HandleInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportMemoryWin32HandleInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportMemoryWin32HandleInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  Nan::Set(target, Nan::New("VkExportMemoryWin32HandleInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportMemoryWin32HandleInfoNV::flush() {
  _VkExportMemoryWin32HandleInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkExportMemoryWin32HandleInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkExportMemoryWin32HandleInfoNV* self = new _VkExportMemoryWin32HandleInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportMemoryWin32HandleInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExportMemoryWin32HandleInfoNV::GetsType) {
  _VkExportMemoryWin32HandleInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryWin32HandleInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExportMemoryWin32HandleInfoNV::SetsType) {
  _VkExportMemoryWin32HandleInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryWin32HandleInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportMemoryWin32HandleInfoNV.sType", "Number");
  
    return;
  }
}
/** ## END VkExportMemoryWin32HandleInfoNV ## **/

/** ## BEGIN VkImportMemoryWin32HandleInfoNV ## **/

class _VkImportMemoryWin32HandleInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleType);
    static NAN_SETTER(SethandleType);
    

    // real instance
    VkImportMemoryWin32HandleInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImportMemoryWin32HandleInfoNV();
    ~_VkImportMemoryWin32HandleInfoNV();

};

/*
#include "index.h"
#include "VkImportMemoryWin32HandleInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImportMemoryWin32HandleInfoNV::constructor;

_VkImportMemoryWin32HandleInfoNV::_VkImportMemoryWin32HandleInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV;
  
}

_VkImportMemoryWin32HandleInfoNV::~_VkImportMemoryWin32HandleInfoNV() {
  //printf("VkImportMemoryWin32HandleInfoNV deconstructed!!\n");
  
  
  
}

void _VkImportMemoryWin32HandleInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImportMemoryWin32HandleInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImportMemoryWin32HandleInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleType").ToLocalChecked(), GethandleType, SethandleType, ctor);
  Nan::Set(target, Nan::New("VkImportMemoryWin32HandleInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImportMemoryWin32HandleInfoNV::flush() {
  _VkImportMemoryWin32HandleInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkImportMemoryWin32HandleInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkImportMemoryWin32HandleInfoNV* self = new _VkImportMemoryWin32HandleInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleType").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImportMemoryWin32HandleInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImportMemoryWin32HandleInfoNV::GetsType) {
  _VkImportMemoryWin32HandleInfoNV *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryWin32HandleInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImportMemoryWin32HandleInfoNV::SetsType) {
  _VkImportMemoryWin32HandleInfoNV *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryWin32HandleInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryWin32HandleInfoNV.sType", "Number");
  
    return;
  }
}// handleType
NAN_GETTER(_VkImportMemoryWin32HandleInfoNV::GethandleType) {
  _VkImportMemoryWin32HandleInfoNV *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryWin32HandleInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleType));
}NAN_SETTER(_VkImportMemoryWin32HandleInfoNV::SethandleType) {
  _VkImportMemoryWin32HandleInfoNV *self = Nan::ObjectWrap::Unwrap<_VkImportMemoryWin32HandleInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.handleType = static_cast<VkExternalMemoryHandleTypeFlagsNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImportMemoryWin32HandleInfoNV.handleType", "Number");
  
    return;
  }
}
/** ## END VkImportMemoryWin32HandleInfoNV ## **/

/** ## BEGIN VkExportMemoryAllocateInfoNV ## **/

class _VkExportMemoryAllocateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleTypes);
    static NAN_SETTER(SethandleTypes);
    

    // real instance
    VkExportMemoryAllocateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExportMemoryAllocateInfoNV();
    ~_VkExportMemoryAllocateInfoNV();

};

/*
#include "index.h"
#include "VkExportMemoryAllocateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExportMemoryAllocateInfoNV::constructor;

_VkExportMemoryAllocateInfoNV::_VkExportMemoryAllocateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV;
  
}

_VkExportMemoryAllocateInfoNV::~_VkExportMemoryAllocateInfoNV() {
  //printf("VkExportMemoryAllocateInfoNV deconstructed!!\n");
  
  
  
}

void _VkExportMemoryAllocateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExportMemoryAllocateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExportMemoryAllocateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleTypes").ToLocalChecked(), GethandleTypes, SethandleTypes, ctor);
  Nan::Set(target, Nan::New("VkExportMemoryAllocateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExportMemoryAllocateInfoNV::flush() {
  _VkExportMemoryAllocateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkExportMemoryAllocateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkExportMemoryAllocateInfoNV* self = new _VkExportMemoryAllocateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleTypes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExportMemoryAllocateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExportMemoryAllocateInfoNV::GetsType) {
  _VkExportMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryAllocateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExportMemoryAllocateInfoNV::SetsType) {
  _VkExportMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryAllocateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportMemoryAllocateInfoNV.sType", "Number");
  
    return;
  }
}// handleTypes
NAN_GETTER(_VkExportMemoryAllocateInfoNV::GethandleTypes) {
  _VkExportMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryAllocateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleTypes));
}NAN_SETTER(_VkExportMemoryAllocateInfoNV::SethandleTypes) {
  _VkExportMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExportMemoryAllocateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlagsNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExportMemoryAllocateInfoNV.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExportMemoryAllocateInfoNV ## **/

/** ## BEGIN VkExternalMemoryImageCreateInfoNV ## **/

class _VkExternalMemoryImageCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GethandleTypes);
    static NAN_SETTER(SethandleTypes);
    

    // real instance
    VkExternalMemoryImageCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalMemoryImageCreateInfoNV();
    ~_VkExternalMemoryImageCreateInfoNV();

};

/*
#include "index.h"
#include "VkExternalMemoryImageCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalMemoryImageCreateInfoNV::constructor;

_VkExternalMemoryImageCreateInfoNV::_VkExternalMemoryImageCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
  
}

_VkExternalMemoryImageCreateInfoNV::~_VkExternalMemoryImageCreateInfoNV() {
  //printf("VkExternalMemoryImageCreateInfoNV deconstructed!!\n");
  
  
  
}

void _VkExternalMemoryImageCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalMemoryImageCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalMemoryImageCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("handleTypes").ToLocalChecked(), GethandleTypes, SethandleTypes, ctor);
  Nan::Set(target, Nan::New("VkExternalMemoryImageCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalMemoryImageCreateInfoNV::flush() {
  _VkExternalMemoryImageCreateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkExternalMemoryImageCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkExternalMemoryImageCreateInfoNV* self = new _VkExternalMemoryImageCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("handleTypes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalMemoryImageCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkExternalMemoryImageCreateInfoNV::GetsType) {
  _VkExternalMemoryImageCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryImageCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkExternalMemoryImageCreateInfoNV::SetsType) {
  _VkExternalMemoryImageCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryImageCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExternalMemoryImageCreateInfoNV.sType", "Number");
  
    return;
  }
}// handleTypes
NAN_GETTER(_VkExternalMemoryImageCreateInfoNV::GethandleTypes) {
  _VkExternalMemoryImageCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryImageCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.handleTypes));
}NAN_SETTER(_VkExternalMemoryImageCreateInfoNV::SethandleTypes) {
  _VkExternalMemoryImageCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkExternalMemoryImageCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.handleTypes = static_cast<VkExternalMemoryHandleTypeFlagsNV>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkExternalMemoryImageCreateInfoNV.handleTypes", "Number");
  
    return;
  }
}
/** ## END VkExternalMemoryImageCreateInfoNV ## **/

/** ## BEGIN VkExternalImageFormatPropertiesNV ## **/

class _VkExternalImageFormatPropertiesNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageFormatProperties;
      static NAN_GETTER(GetimageFormatProperties);
    static NAN_GETTER(GetexternalMemoryFeatures);
    static NAN_GETTER(GetexportFromImportedHandleTypes);
    static NAN_GETTER(GetcompatibleHandleTypes);

    // real instance
    VkExternalImageFormatPropertiesNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExternalImageFormatPropertiesNV();
    ~_VkExternalImageFormatPropertiesNV();

};

/*
#include "index.h"
#include "VkExternalImageFormatPropertiesNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExternalImageFormatPropertiesNV::constructor;

_VkExternalImageFormatPropertiesNV::_VkExternalImageFormatPropertiesNV() {
  
  
}

_VkExternalImageFormatPropertiesNV::~_VkExternalImageFormatPropertiesNV() {
  //printf("VkExternalImageFormatPropertiesNV deconstructed!!\n");
  
  
  
  
  
}

void _VkExternalImageFormatPropertiesNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExternalImageFormatPropertiesNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExternalImageFormatPropertiesNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("imageFormatProperties").ToLocalChecked(), GetimageFormatProperties, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("externalMemoryFeatures").ToLocalChecked(), GetexternalMemoryFeatures, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("exportFromImportedHandleTypes").ToLocalChecked(), GetexportFromImportedHandleTypes, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("compatibleHandleTypes").ToLocalChecked(), GetcompatibleHandleTypes, nullptr, ctor);
  Nan::Set(target, Nan::New("VkExternalImageFormatPropertiesNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExternalImageFormatPropertiesNV::flush() {
  _VkExternalImageFormatPropertiesNV *self = this;
  if (!(self->imageFormatProperties.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->imageFormatProperties);
    
  }
  return true;
}

NAN_METHOD(_VkExternalImageFormatPropertiesNV::New) {
  if (info.IsConstructCall()) {
    _VkExternalImageFormatPropertiesNV* self = new _VkExternalImageFormatPropertiesNV();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExternalImageFormatPropertiesNV constructor cannot be invoked without 'new'");
  }
};

// imageFormatProperties
NAN_GETTER(_VkExternalImageFormatPropertiesNV::GetimageFormatProperties) {
  _VkExternalImageFormatPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkExternalImageFormatPropertiesNV>(info.This());
  if (self->imageFormatProperties.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageFormatProperties);
    info.GetReturnValue().Set(obj);
  }
}// externalMemoryFeatures
NAN_GETTER(_VkExternalImageFormatPropertiesNV::GetexternalMemoryFeatures) {
  _VkExternalImageFormatPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkExternalImageFormatPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.externalMemoryFeatures));
}// exportFromImportedHandleTypes
NAN_GETTER(_VkExternalImageFormatPropertiesNV::GetexportFromImportedHandleTypes) {
  _VkExternalImageFormatPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkExternalImageFormatPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.exportFromImportedHandleTypes));
}// compatibleHandleTypes
NAN_GETTER(_VkExternalImageFormatPropertiesNV::GetcompatibleHandleTypes) {
  _VkExternalImageFormatPropertiesNV *self = Nan::ObjectWrap::Unwrap<_VkExternalImageFormatPropertiesNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compatibleHandleTypes));
}
/** ## END VkExternalImageFormatPropertiesNV ## **/

/** ## BEGIN VkDedicatedAllocationMemoryAllocateInfoNV ## **/

class _VkDedicatedAllocationMemoryAllocateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    

    // real instance
    VkDedicatedAllocationMemoryAllocateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDedicatedAllocationMemoryAllocateInfoNV();
    ~_VkDedicatedAllocationMemoryAllocateInfoNV();

};

/*
#include "index.h"
#include "VkDedicatedAllocationMemoryAllocateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDedicatedAllocationMemoryAllocateInfoNV::constructor;

_VkDedicatedAllocationMemoryAllocateInfoNV::_VkDedicatedAllocationMemoryAllocateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV;
  
}

_VkDedicatedAllocationMemoryAllocateInfoNV::~_VkDedicatedAllocationMemoryAllocateInfoNV() {
  //printf("VkDedicatedAllocationMemoryAllocateInfoNV deconstructed!!\n");
  
  
  
  
}

void _VkDedicatedAllocationMemoryAllocateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDedicatedAllocationMemoryAllocateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDedicatedAllocationMemoryAllocateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  Nan::Set(target, Nan::New("VkDedicatedAllocationMemoryAllocateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDedicatedAllocationMemoryAllocateInfoNV::flush() {
  _VkDedicatedAllocationMemoryAllocateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkDedicatedAllocationMemoryAllocateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkDedicatedAllocationMemoryAllocateInfoNV* self = new _VkDedicatedAllocationMemoryAllocateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("image").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("buffer").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDedicatedAllocationMemoryAllocateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDedicatedAllocationMemoryAllocateInfoNV::GetsType) {
  _VkDedicatedAllocationMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationMemoryAllocateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDedicatedAllocationMemoryAllocateInfoNV::SetsType) {
  _VkDedicatedAllocationMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationMemoryAllocateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.sType", "Number");
  
    return;
  }
}// image
NAN_GETTER(_VkDedicatedAllocationMemoryAllocateInfoNV::Getimage) {
  _VkDedicatedAllocationMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationMemoryAllocateInfoNV>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDedicatedAllocationMemoryAllocateInfoNV::Setimage) {
  _VkDedicatedAllocationMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationMemoryAllocateInfoNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.image", "[object VkImage]");
  
    return;
  }
}// buffer
NAN_GETTER(_VkDedicatedAllocationMemoryAllocateInfoNV::Getbuffer) {
  _VkDedicatedAllocationMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationMemoryAllocateInfoNV>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDedicatedAllocationMemoryAllocateInfoNV::Setbuffer) {
  _VkDedicatedAllocationMemoryAllocateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationMemoryAllocateInfoNV>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationMemoryAllocateInfoNV.buffer", "[object VkBuffer]");
  
    return;
  }
}
/** ## END VkDedicatedAllocationMemoryAllocateInfoNV ## **/

/** ## BEGIN VkDedicatedAllocationBufferCreateInfoNV ## **/

class _VkDedicatedAllocationBufferCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdedicatedAllocation);
    static NAN_SETTER(SetdedicatedAllocation);
    

    // real instance
    VkDedicatedAllocationBufferCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDedicatedAllocationBufferCreateInfoNV();
    ~_VkDedicatedAllocationBufferCreateInfoNV();

};

/*
#include "index.h"
#include "VkDedicatedAllocationBufferCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDedicatedAllocationBufferCreateInfoNV::constructor;

_VkDedicatedAllocationBufferCreateInfoNV::_VkDedicatedAllocationBufferCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV;
  
}

_VkDedicatedAllocationBufferCreateInfoNV::~_VkDedicatedAllocationBufferCreateInfoNV() {
  //printf("VkDedicatedAllocationBufferCreateInfoNV deconstructed!!\n");
  
  
  
}

void _VkDedicatedAllocationBufferCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDedicatedAllocationBufferCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDedicatedAllocationBufferCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("dedicatedAllocation").ToLocalChecked(), GetdedicatedAllocation, SetdedicatedAllocation, ctor);
  Nan::Set(target, Nan::New("VkDedicatedAllocationBufferCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDedicatedAllocationBufferCreateInfoNV::flush() {
  _VkDedicatedAllocationBufferCreateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkDedicatedAllocationBufferCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkDedicatedAllocationBufferCreateInfoNV* self = new _VkDedicatedAllocationBufferCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dedicatedAllocation").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDedicatedAllocationBufferCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDedicatedAllocationBufferCreateInfoNV::GetsType) {
  _VkDedicatedAllocationBufferCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationBufferCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDedicatedAllocationBufferCreateInfoNV::SetsType) {
  _VkDedicatedAllocationBufferCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationBufferCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationBufferCreateInfoNV.sType", "Number");
  
    return;
  }
}// dedicatedAllocation
NAN_GETTER(_VkDedicatedAllocationBufferCreateInfoNV::GetdedicatedAllocation) {
  _VkDedicatedAllocationBufferCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationBufferCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dedicatedAllocation));
}NAN_SETTER(_VkDedicatedAllocationBufferCreateInfoNV::SetdedicatedAllocation) {
  _VkDedicatedAllocationBufferCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationBufferCreateInfoNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.dedicatedAllocation = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationBufferCreateInfoNV.dedicatedAllocation", "Number");
  
    return;
  }
}
/** ## END VkDedicatedAllocationBufferCreateInfoNV ## **/

/** ## BEGIN VkDedicatedAllocationImageCreateInfoNV ## **/

class _VkDedicatedAllocationImageCreateInfoNV: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdedicatedAllocation);
    static NAN_SETTER(SetdedicatedAllocation);
    

    // real instance
    VkDedicatedAllocationImageCreateInfoNV instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDedicatedAllocationImageCreateInfoNV();
    ~_VkDedicatedAllocationImageCreateInfoNV();

};

/*
#include "index.h"
#include "VkDedicatedAllocationImageCreateInfoNV.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDedicatedAllocationImageCreateInfoNV::constructor;

_VkDedicatedAllocationImageCreateInfoNV::_VkDedicatedAllocationImageCreateInfoNV() {
  instance.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
  
}

_VkDedicatedAllocationImageCreateInfoNV::~_VkDedicatedAllocationImageCreateInfoNV() {
  //printf("VkDedicatedAllocationImageCreateInfoNV deconstructed!!\n");
  
  
  
}

void _VkDedicatedAllocationImageCreateInfoNV::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDedicatedAllocationImageCreateInfoNV::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDedicatedAllocationImageCreateInfoNV").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("dedicatedAllocation").ToLocalChecked(), GetdedicatedAllocation, SetdedicatedAllocation, ctor);
  Nan::Set(target, Nan::New("VkDedicatedAllocationImageCreateInfoNV").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDedicatedAllocationImageCreateInfoNV::flush() {
  _VkDedicatedAllocationImageCreateInfoNV *self = this;
  
  return true;
}

NAN_METHOD(_VkDedicatedAllocationImageCreateInfoNV::New) {
  if (info.IsConstructCall()) {
    _VkDedicatedAllocationImageCreateInfoNV* self = new _VkDedicatedAllocationImageCreateInfoNV();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dedicatedAllocation").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDedicatedAllocationImageCreateInfoNV constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDedicatedAllocationImageCreateInfoNV::GetsType) {
  _VkDedicatedAllocationImageCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationImageCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDedicatedAllocationImageCreateInfoNV::SetsType) {
  _VkDedicatedAllocationImageCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationImageCreateInfoNV>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationImageCreateInfoNV.sType", "Number");
  
    return;
  }
}// dedicatedAllocation
NAN_GETTER(_VkDedicatedAllocationImageCreateInfoNV::GetdedicatedAllocation) {
  _VkDedicatedAllocationImageCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationImageCreateInfoNV>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dedicatedAllocation));
}NAN_SETTER(_VkDedicatedAllocationImageCreateInfoNV::SetdedicatedAllocation) {
  _VkDedicatedAllocationImageCreateInfoNV *self = Nan::ObjectWrap::Unwrap<_VkDedicatedAllocationImageCreateInfoNV>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.dedicatedAllocation = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDedicatedAllocationImageCreateInfoNV.dedicatedAllocation", "Number");
  
    return;
  }
}
/** ## END VkDedicatedAllocationImageCreateInfoNV ## **/

/** ## BEGIN VkDebugMarkerMarkerInfoEXT ## **/

class _VkDebugMarkerMarkerInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pMarkerName;
    static NAN_GETTER(GetpMarkerName);
    static NAN_SETTER(SetpMarkerName);
    
    std::vector<float>* vcolor;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> color;
    static NAN_GETTER(Getcolor);
    static NAN_SETTER(Setcolor);
    

    // real instance
    VkDebugMarkerMarkerInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugMarkerMarkerInfoEXT();
    ~_VkDebugMarkerMarkerInfoEXT();

};

/*
#include <string.h>
#include "index.h"
#include "VkDebugMarkerMarkerInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugMarkerMarkerInfoEXT::constructor;

_VkDebugMarkerMarkerInfoEXT::_VkDebugMarkerMarkerInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT;
  vcolor = new std::vector<float>;
  
}

_VkDebugMarkerMarkerInfoEXT::~_VkDebugMarkerMarkerInfoEXT() {
  //printf("VkDebugMarkerMarkerInfoEXT deconstructed!!\n");
  
  
  pMarkerName.Reset();
  
  vcolor->clear();
  delete vcolor;
  
  
}

void _VkDebugMarkerMarkerInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugMarkerMarkerInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugMarkerMarkerInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("pMarkerName").ToLocalChecked(), GetpMarkerName, SetpMarkerName, ctor);
  SetPrototypeAccessor(proto, Nan::New("color").ToLocalChecked(), Getcolor, Setcolor, ctor);
  Nan::Set(target, Nan::New("VkDebugMarkerMarkerInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugMarkerMarkerInfoEXT::flush() {
  _VkDebugMarkerMarkerInfoEXT *self = this;
  if (!(self->color.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->color);
    
    if (value->IsArray()) {
      // validate length
      if (v8::Local<v8::Array>::Cast(value)->Length() != 4) {
        Nan::ThrowRangeError("Invalid array length, expected array length of '4' for 'VkDebugMarkerMarkerInfoEXT.color'");
        return false;
      }
      std::vector<float> array = createArrayOfV8Numbers<float>(value);
      memcpy(self->instance.color, array.data(), sizeof(float) * 4);
    } else if (value->IsNull()) {
      memset(&self->instance.color, 0, sizeof(float));
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerMarkerInfoEXT.color", "Array");
  
      return false;
    }
  }
  return true;
}

NAN_METHOD(_VkDebugMarkerMarkerInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugMarkerMarkerInfoEXT* self = new _VkDebugMarkerMarkerInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pMarkerName").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("color").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugMarkerMarkerInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugMarkerMarkerInfoEXT::GetsType) {
  _VkDebugMarkerMarkerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerMarkerInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugMarkerMarkerInfoEXT::SetsType) {
  _VkDebugMarkerMarkerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerMarkerInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerMarkerInfoEXT.sType", "Number");
  
    return;
  }
}// pMarkerName
NAN_GETTER(_VkDebugMarkerMarkerInfoEXT::GetpMarkerName) {
  _VkDebugMarkerMarkerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerMarkerInfoEXT>(info.This());
  if (self->pMarkerName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pMarkerName);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkDebugMarkerMarkerInfoEXT::SetpMarkerName) {
  _VkDebugMarkerMarkerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerMarkerInfoEXT>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pMarkerName = str;
    // free previous
    if (self->instance.pMarkerName) {
      delete[] self->instance.pMarkerName;
    }
    self->instance.pMarkerName = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pMarkerName = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerMarkerInfoEXT.pMarkerName", "String");
  
    return;
  }
}// color
NAN_GETTER(_VkDebugMarkerMarkerInfoEXT::Getcolor) {
  _VkDebugMarkerMarkerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerMarkerInfoEXT>(info.This());
  if (self->color.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->color));
  }
}NAN_SETTER(_VkDebugMarkerMarkerInfoEXT::Setcolor) {
  _VkDebugMarkerMarkerInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerMarkerInfoEXT>(info.This());
  // js
  if (value->IsArray()) {
    self->color.Reset<v8::Array>(value.As<v8::Array>());
  } else if (value->IsNull()) {
    self->color.Reset();
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerMarkerInfoEXT.color", "Array");
  
    return;
  }
}
/** ## END VkDebugMarkerMarkerInfoEXT ## **/

/** ## BEGIN VkDebugMarkerObjectTagInfoEXT ## **/

class _VkDebugMarkerObjectTagInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetobjectType);
    static NAN_SETTER(SetobjectType);
    
    static NAN_GETTER(Getobject);
    static NAN_SETTER(Setobject);
    
    static NAN_GETTER(GettagName);
    static NAN_SETTER(SettagName);
    
    static NAN_GETTER(GettagSize);
    static NAN_SETTER(SettagSize);
    
    Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pTag;
    static NAN_GETTER(GetpTag);
    static NAN_SETTER(SetpTag);
    

    // real instance
    VkDebugMarkerObjectTagInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugMarkerObjectTagInfoEXT();
    ~_VkDebugMarkerObjectTagInfoEXT();

};

/*
#include "index.h"
#include "VkDebugMarkerObjectTagInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugMarkerObjectTagInfoEXT::constructor;

_VkDebugMarkerObjectTagInfoEXT::_VkDebugMarkerObjectTagInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT;
  
}

_VkDebugMarkerObjectTagInfoEXT::~_VkDebugMarkerObjectTagInfoEXT() {
  //printf("VkDebugMarkerObjectTagInfoEXT deconstructed!!\n");
  
  
  
  
  
  
  pTag.Reset();
  
}

void _VkDebugMarkerObjectTagInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugMarkerObjectTagInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugMarkerObjectTagInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectType").ToLocalChecked(), GetobjectType, SetobjectType, ctor);
  SetPrototypeAccessor(proto, Nan::New("object").ToLocalChecked(), Getobject, Setobject, ctor);
  SetPrototypeAccessor(proto, Nan::New("tagName").ToLocalChecked(), GettagName, SettagName, ctor);
  SetPrototypeAccessor(proto, Nan::New("tagSize").ToLocalChecked(), GettagSize, SettagSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("pTag").ToLocalChecked(), GetpTag, SetpTag, ctor);
  Nan::Set(target, Nan::New("VkDebugMarkerObjectTagInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugMarkerObjectTagInfoEXT::flush() {
  _VkDebugMarkerObjectTagInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDebugMarkerObjectTagInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugMarkerObjectTagInfoEXT* self = new _VkDebugMarkerObjectTagInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("objectType").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("object").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("tagName").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("tagSize").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pTag").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugMarkerObjectTagInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugMarkerObjectTagInfoEXT::GetsType) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugMarkerObjectTagInfoEXT::SetsType) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectTagInfoEXT.sType", "Number");
  
    return;
  }
}// objectType
NAN_GETTER(_VkDebugMarkerObjectTagInfoEXT::GetobjectType) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.objectType));
}NAN_SETTER(_VkDebugMarkerObjectTagInfoEXT::SetobjectType) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.objectType = static_cast<VkDebugReportObjectTypeEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectTagInfoEXT.objectType", "Number");
  
    return;
  }
}// object
NAN_GETTER(_VkDebugMarkerObjectTagInfoEXT::Getobject) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.object));
}NAN_SETTER(_VkDebugMarkerObjectTagInfoEXT::Setobject) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.object = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectTagInfoEXT.object", "Number");
  
    return;
  }
}// tagName
NAN_GETTER(_VkDebugMarkerObjectTagInfoEXT::GettagName) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tagName));
}NAN_SETTER(_VkDebugMarkerObjectTagInfoEXT::SettagName) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.tagName = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectTagInfoEXT.tagName", "Number");
  
    return;
  }
}// tagSize
NAN_GETTER(_VkDebugMarkerObjectTagInfoEXT::GettagSize) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tagSize));
}NAN_SETTER(_VkDebugMarkerObjectTagInfoEXT::SettagSize) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.tagSize = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectTagInfoEXT.tagSize", "Number");
  
    return;
  }
}// pTag
NAN_GETTER(_VkDebugMarkerObjectTagInfoEXT::GetpTag) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
}NAN_SETTER(_VkDebugMarkerObjectTagInfoEXT::SetpTag) {
  _VkDebugMarkerObjectTagInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectTagInfoEXT>(info.This());
}
/** ## END VkDebugMarkerObjectTagInfoEXT ## **/

/** ## BEGIN VkDebugMarkerObjectNameInfoEXT ## **/

class _VkDebugMarkerObjectNameInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetobjectType);
    static NAN_SETTER(SetobjectType);
    
    static NAN_GETTER(Getobject);
    static NAN_SETTER(Setobject);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pObjectName;
    static NAN_GETTER(GetpObjectName);
    static NAN_SETTER(SetpObjectName);
    

    // real instance
    VkDebugMarkerObjectNameInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugMarkerObjectNameInfoEXT();
    ~_VkDebugMarkerObjectNameInfoEXT();

};

/*
#include "index.h"
#include "VkDebugMarkerObjectNameInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugMarkerObjectNameInfoEXT::constructor;

_VkDebugMarkerObjectNameInfoEXT::_VkDebugMarkerObjectNameInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT;
  
}

_VkDebugMarkerObjectNameInfoEXT::~_VkDebugMarkerObjectNameInfoEXT() {
  //printf("VkDebugMarkerObjectNameInfoEXT deconstructed!!\n");
  
  
  
  
  pObjectName.Reset();
  
}

void _VkDebugMarkerObjectNameInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugMarkerObjectNameInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugMarkerObjectNameInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("objectType").ToLocalChecked(), GetobjectType, SetobjectType, ctor);
  SetPrototypeAccessor(proto, Nan::New("object").ToLocalChecked(), Getobject, Setobject, ctor);
  SetPrototypeAccessor(proto, Nan::New("pObjectName").ToLocalChecked(), GetpObjectName, SetpObjectName, ctor);
  Nan::Set(target, Nan::New("VkDebugMarkerObjectNameInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugMarkerObjectNameInfoEXT::flush() {
  _VkDebugMarkerObjectNameInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDebugMarkerObjectNameInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugMarkerObjectNameInfoEXT* self = new _VkDebugMarkerObjectNameInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("objectType").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("object").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pObjectName").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugMarkerObjectNameInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugMarkerObjectNameInfoEXT::GetsType) {
  _VkDebugMarkerObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectNameInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugMarkerObjectNameInfoEXT::SetsType) {
  _VkDebugMarkerObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectNameInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectNameInfoEXT.sType", "Number");
  
    return;
  }
}// objectType
NAN_GETTER(_VkDebugMarkerObjectNameInfoEXT::GetobjectType) {
  _VkDebugMarkerObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectNameInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.objectType));
}NAN_SETTER(_VkDebugMarkerObjectNameInfoEXT::SetobjectType) {
  _VkDebugMarkerObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectNameInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.objectType = static_cast<VkDebugReportObjectTypeEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectNameInfoEXT.objectType", "Number");
  
    return;
  }
}// object
NAN_GETTER(_VkDebugMarkerObjectNameInfoEXT::Getobject) {
  _VkDebugMarkerObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectNameInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.object));
}NAN_SETTER(_VkDebugMarkerObjectNameInfoEXT::Setobject) {
  _VkDebugMarkerObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectNameInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.object = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectNameInfoEXT.object", "Number");
  
    return;
  }
}// pObjectName
NAN_GETTER(_VkDebugMarkerObjectNameInfoEXT::GetpObjectName) {
  _VkDebugMarkerObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectNameInfoEXT>(info.This());
  if (self->pObjectName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pObjectName);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkDebugMarkerObjectNameInfoEXT::SetpObjectName) {
  _VkDebugMarkerObjectNameInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugMarkerObjectNameInfoEXT>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pObjectName = str;
    // free previous
    if (self->instance.pObjectName) {
      delete[] self->instance.pObjectName;
    }
    self->instance.pObjectName = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pObjectName = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugMarkerObjectNameInfoEXT.pObjectName", "String");
  
    return;
  }
}
/** ## END VkDebugMarkerObjectNameInfoEXT ## **/

/** ## BEGIN VkPipelineRasterizationStateRasterizationOrderAMD ## **/

class _VkPipelineRasterizationStateRasterizationOrderAMD: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetrasterizationOrder);
    static NAN_SETTER(SetrasterizationOrder);
    

    // real instance
    VkPipelineRasterizationStateRasterizationOrderAMD instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineRasterizationStateRasterizationOrderAMD();
    ~_VkPipelineRasterizationStateRasterizationOrderAMD();

};

/*
#include "index.h"
#include "VkPipelineRasterizationStateRasterizationOrderAMD.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineRasterizationStateRasterizationOrderAMD::constructor;

_VkPipelineRasterizationStateRasterizationOrderAMD::_VkPipelineRasterizationStateRasterizationOrderAMD() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD;
  
}

_VkPipelineRasterizationStateRasterizationOrderAMD::~_VkPipelineRasterizationStateRasterizationOrderAMD() {
  //printf("VkPipelineRasterizationStateRasterizationOrderAMD deconstructed!!\n");
  
  
  
}

void _VkPipelineRasterizationStateRasterizationOrderAMD::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineRasterizationStateRasterizationOrderAMD::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineRasterizationStateRasterizationOrderAMD").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("rasterizationOrder").ToLocalChecked(), GetrasterizationOrder, SetrasterizationOrder, ctor);
  Nan::Set(target, Nan::New("VkPipelineRasterizationStateRasterizationOrderAMD").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineRasterizationStateRasterizationOrderAMD::flush() {
  _VkPipelineRasterizationStateRasterizationOrderAMD *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineRasterizationStateRasterizationOrderAMD::New) {
  if (info.IsConstructCall()) {
    _VkPipelineRasterizationStateRasterizationOrderAMD* self = new _VkPipelineRasterizationStateRasterizationOrderAMD();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("rasterizationOrder").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineRasterizationStateRasterizationOrderAMD constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineRasterizationStateRasterizationOrderAMD::GetsType) {
  _VkPipelineRasterizationStateRasterizationOrderAMD *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateRasterizationOrderAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineRasterizationStateRasterizationOrderAMD::SetsType) {
  _VkPipelineRasterizationStateRasterizationOrderAMD *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateRasterizationOrderAMD>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateRasterizationOrderAMD.sType", "Number");
  
    return;
  }
}// rasterizationOrder
NAN_GETTER(_VkPipelineRasterizationStateRasterizationOrderAMD::GetrasterizationOrder) {
  _VkPipelineRasterizationStateRasterizationOrderAMD *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateRasterizationOrderAMD>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.rasterizationOrder));
}NAN_SETTER(_VkPipelineRasterizationStateRasterizationOrderAMD::SetrasterizationOrder) {
  _VkPipelineRasterizationStateRasterizationOrderAMD *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateRasterizationOrderAMD>(info.This());
  if (value->IsNumber()) {
    self->instance.rasterizationOrder = static_cast<VkRasterizationOrderAMD>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateRasterizationOrderAMD.rasterizationOrder", "Number");
  
    return;
  }
}
/** ## END VkPipelineRasterizationStateRasterizationOrderAMD ## **/

/** ## BEGIN VkValidationFeaturesEXT ## **/

class _VkValidationFeaturesEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetenabledValidationFeatureCount);
    static NAN_SETTER(SetenabledValidationFeatureCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pEnabledValidationFeatures;
    static NAN_GETTER(GetpEnabledValidationFeatures);
    static NAN_SETTER(SetpEnabledValidationFeatures);
    
    static NAN_GETTER(GetdisabledValidationFeatureCount);
    static NAN_SETTER(SetdisabledValidationFeatureCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDisabledValidationFeatures;
    static NAN_GETTER(GetpDisabledValidationFeatures);
    static NAN_SETTER(SetpDisabledValidationFeatures);
    

    // real instance
    VkValidationFeaturesEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkValidationFeaturesEXT();
    ~_VkValidationFeaturesEXT();

};

/*
#include "index.h"
#include "VkValidationFeaturesEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkValidationFeaturesEXT::constructor;

_VkValidationFeaturesEXT::_VkValidationFeaturesEXT() {
  instance.sType = VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT;
  
}

_VkValidationFeaturesEXT::~_VkValidationFeaturesEXT() {
  //printf("VkValidationFeaturesEXT deconstructed!!\n");
  
  
  
  pEnabledValidationFeatures.Reset();
  
  
  pDisabledValidationFeatures.Reset();
  
}

void _VkValidationFeaturesEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkValidationFeaturesEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkValidationFeaturesEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("enabledValidationFeatureCount").ToLocalChecked(), GetenabledValidationFeatureCount, SetenabledValidationFeatureCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pEnabledValidationFeatures").ToLocalChecked(), GetpEnabledValidationFeatures, SetpEnabledValidationFeatures, ctor);
  SetPrototypeAccessor(proto, Nan::New("disabledValidationFeatureCount").ToLocalChecked(), GetdisabledValidationFeatureCount, SetdisabledValidationFeatureCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDisabledValidationFeatures").ToLocalChecked(), GetpDisabledValidationFeatures, SetpDisabledValidationFeatures, ctor);
  Nan::Set(target, Nan::New("VkValidationFeaturesEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkValidationFeaturesEXT::flush() {
  _VkValidationFeaturesEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkValidationFeaturesEXT::New) {
  if (info.IsConstructCall()) {
    _VkValidationFeaturesEXT* self = new _VkValidationFeaturesEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("enabledValidationFeatureCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pEnabledValidationFeatures").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("disabledValidationFeatureCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pDisabledValidationFeatures").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkValidationFeaturesEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkValidationFeaturesEXT::GetsType) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkValidationFeaturesEXT::SetsType) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkValidationFeaturesEXT.sType", "Number");
  
    return;
  }
}// enabledValidationFeatureCount
NAN_GETTER(_VkValidationFeaturesEXT::GetenabledValidationFeatureCount) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.enabledValidationFeatureCount));
}NAN_SETTER(_VkValidationFeaturesEXT::SetenabledValidationFeatureCount) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.enabledValidationFeatureCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkValidationFeaturesEXT.enabledValidationFeatureCount", "Number");
  
    return;
  }
}// pEnabledValidationFeatures
NAN_GETTER(_VkValidationFeaturesEXT::GetpEnabledValidationFeatures) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  if (self->pEnabledValidationFeatures.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pEnabledValidationFeatures);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkValidationFeaturesEXT::SetpEnabledValidationFeatures) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pEnabledValidationFeatures.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkValidationFeaturesEXT.pEnabledValidationFeatures", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pEnabledValidationFeatures.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkValidationFeaturesEXT.pEnabledValidationFeatures", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pEnabledValidationFeatures = reinterpret_cast<const VkValidationFeatureEnableEXT *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pEnabledValidationFeatures = nullptr;
  }
}// disabledValidationFeatureCount
NAN_GETTER(_VkValidationFeaturesEXT::GetdisabledValidationFeatureCount) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.disabledValidationFeatureCount));
}NAN_SETTER(_VkValidationFeaturesEXT::SetdisabledValidationFeatureCount) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.disabledValidationFeatureCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkValidationFeaturesEXT.disabledValidationFeatureCount", "Number");
  
    return;
  }
}// pDisabledValidationFeatures
NAN_GETTER(_VkValidationFeaturesEXT::GetpDisabledValidationFeatures) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  if (self->pDisabledValidationFeatures.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDisabledValidationFeatures);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkValidationFeaturesEXT::SetpDisabledValidationFeatures) {
  _VkValidationFeaturesEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFeaturesEXT>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pDisabledValidationFeatures.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkValidationFeaturesEXT.pDisabledValidationFeatures", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDisabledValidationFeatures.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkValidationFeaturesEXT.pDisabledValidationFeatures", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDisabledValidationFeatures = reinterpret_cast<const VkValidationFeatureDisableEXT *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pDisabledValidationFeatures = nullptr;
  }
}
/** ## END VkValidationFeaturesEXT ## **/

/** ## BEGIN VkValidationFlagsEXT ## **/

class _VkValidationFlagsEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetdisabledValidationCheckCount);
    static NAN_SETTER(SetdisabledValidationCheckCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDisabledValidationChecks;
    static NAN_GETTER(GetpDisabledValidationChecks);
    static NAN_SETTER(SetpDisabledValidationChecks);
    

    // real instance
    VkValidationFlagsEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkValidationFlagsEXT();
    ~_VkValidationFlagsEXT();

};

/*
#include "index.h"
#include "VkValidationFlagsEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkValidationFlagsEXT::constructor;

_VkValidationFlagsEXT::_VkValidationFlagsEXT() {
  instance.sType = VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT;
  
}

_VkValidationFlagsEXT::~_VkValidationFlagsEXT() {
  //printf("VkValidationFlagsEXT deconstructed!!\n");
  
  
  
  pDisabledValidationChecks.Reset();
  
}

void _VkValidationFlagsEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkValidationFlagsEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkValidationFlagsEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("disabledValidationCheckCount").ToLocalChecked(), GetdisabledValidationCheckCount, SetdisabledValidationCheckCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDisabledValidationChecks").ToLocalChecked(), GetpDisabledValidationChecks, SetpDisabledValidationChecks, ctor);
  Nan::Set(target, Nan::New("VkValidationFlagsEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkValidationFlagsEXT::flush() {
  _VkValidationFlagsEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkValidationFlagsEXT::New) {
  if (info.IsConstructCall()) {
    _VkValidationFlagsEXT* self = new _VkValidationFlagsEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("disabledValidationCheckCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pDisabledValidationChecks").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkValidationFlagsEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkValidationFlagsEXT::GetsType) {
  _VkValidationFlagsEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFlagsEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkValidationFlagsEXT::SetsType) {
  _VkValidationFlagsEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFlagsEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkValidationFlagsEXT.sType", "Number");
  
    return;
  }
}// disabledValidationCheckCount
NAN_GETTER(_VkValidationFlagsEXT::GetdisabledValidationCheckCount) {
  _VkValidationFlagsEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFlagsEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.disabledValidationCheckCount));
}NAN_SETTER(_VkValidationFlagsEXT::SetdisabledValidationCheckCount) {
  _VkValidationFlagsEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFlagsEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.disabledValidationCheckCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkValidationFlagsEXT.disabledValidationCheckCount", "Number");
  
    return;
  }
}// pDisabledValidationChecks
NAN_GETTER(_VkValidationFlagsEXT::GetpDisabledValidationChecks) {
  _VkValidationFlagsEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFlagsEXT>(info.This());
  if (self->pDisabledValidationChecks.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDisabledValidationChecks);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkValidationFlagsEXT::SetpDisabledValidationChecks) {
  _VkValidationFlagsEXT *self = Nan::ObjectWrap::Unwrap<_VkValidationFlagsEXT>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pDisabledValidationChecks.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkValidationFlagsEXT.pDisabledValidationChecks", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDisabledValidationChecks.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkValidationFlagsEXT.pDisabledValidationChecks", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDisabledValidationChecks = reinterpret_cast<const VkValidationCheckEXT *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pDisabledValidationChecks = nullptr;
  }
}
/** ## END VkValidationFlagsEXT ## **/

/** ## BEGIN VkDebugReportCallbackCreateInfoEXT ## **/

class _VkDebugReportCallbackCreateInfoEXT: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkDebugReportCallbackCreateInfoEXT instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDebugReportCallbackCreateInfoEXT();
    ~_VkDebugReportCallbackCreateInfoEXT();

};

/*
#include "index.h"
#include "VkDebugReportCallbackCreateInfoEXT.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDebugReportCallbackCreateInfoEXT::constructor;

_VkDebugReportCallbackCreateInfoEXT::_VkDebugReportCallbackCreateInfoEXT() {
  instance.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
  
}

_VkDebugReportCallbackCreateInfoEXT::~_VkDebugReportCallbackCreateInfoEXT() {
  //printf("VkDebugReportCallbackCreateInfoEXT deconstructed!!\n");
  
  
  
}

void _VkDebugReportCallbackCreateInfoEXT::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDebugReportCallbackCreateInfoEXT::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDebugReportCallbackCreateInfoEXT").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkDebugReportCallbackCreateInfoEXT").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDebugReportCallbackCreateInfoEXT::flush() {
  _VkDebugReportCallbackCreateInfoEXT *self = this;
  
  return true;
}

NAN_METHOD(_VkDebugReportCallbackCreateInfoEXT::New) {
  if (info.IsConstructCall()) {
    _VkDebugReportCallbackCreateInfoEXT* self = new _VkDebugReportCallbackCreateInfoEXT();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDebugReportCallbackCreateInfoEXT constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDebugReportCallbackCreateInfoEXT::GetsType) {
  _VkDebugReportCallbackCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugReportCallbackCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDebugReportCallbackCreateInfoEXT::SetsType) {
  _VkDebugReportCallbackCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugReportCallbackCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugReportCallbackCreateInfoEXT.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDebugReportCallbackCreateInfoEXT::Getflags) {
  _VkDebugReportCallbackCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugReportCallbackCreateInfoEXT>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDebugReportCallbackCreateInfoEXT::Setflags) {
  _VkDebugReportCallbackCreateInfoEXT *self = Nan::ObjectWrap::Unwrap<_VkDebugReportCallbackCreateInfoEXT>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDebugReportFlagsEXT>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDebugReportCallbackCreateInfoEXT.flags", "Number");
  
    return;
  }
}
/** ## END VkDebugReportCallbackCreateInfoEXT ## **/

/** ## BEGIN VkPresentInfoKHR ## **/

class _VkPresentInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetwaitSemaphoreCount);
    static NAN_SETTER(SetwaitSemaphoreCount);
    
    std::vector<VkSemaphore>* vpWaitSemaphores;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pWaitSemaphores;
    static NAN_GETTER(GetpWaitSemaphores);
    static NAN_SETTER(SetpWaitSemaphores);
    
    static NAN_GETTER(GetswapchainCount);
    static NAN_SETTER(SetswapchainCount);
    
    std::vector<VkSwapchainKHR>* vpSwapchains;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSwapchains;
    static NAN_GETTER(GetpSwapchains);
    static NAN_SETTER(SetpSwapchains);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pImageIndices;
    static NAN_GETTER(GetpImageIndices);
    static NAN_SETTER(SetpImageIndices);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pResults;
    static NAN_GETTER(GetpResults);
    static NAN_SETTER(SetpResults);
    

    // real instance
    VkPresentInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPresentInfoKHR();
    ~_VkPresentInfoKHR();

};

/*
#include "index.h"
#include "VkPresentInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPresentInfoKHR::constructor;

_VkPresentInfoKHR::_VkPresentInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
  vpWaitSemaphores = new std::vector<VkSemaphore>;
  vpSwapchains = new std::vector<VkSwapchainKHR>;
  
}

_VkPresentInfoKHR::~_VkPresentInfoKHR() {
  //printf("VkPresentInfoKHR deconstructed!!\n");
  
  
  
  vpWaitSemaphores->clear();
  delete vpWaitSemaphores;
  
  pWaitSemaphores.Reset();
  
  
  vpSwapchains->clear();
  delete vpSwapchains;
  
  pSwapchains.Reset();
  
  pImageIndices.Reset();
  
  pResults.Reset();
  
}

void _VkPresentInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPresentInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPresentInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("waitSemaphoreCount").ToLocalChecked(), GetwaitSemaphoreCount, SetwaitSemaphoreCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pWaitSemaphores").ToLocalChecked(), GetpWaitSemaphores, SetpWaitSemaphores, ctor);
  SetPrototypeAccessor(proto, Nan::New("swapchainCount").ToLocalChecked(), GetswapchainCount, SetswapchainCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSwapchains").ToLocalChecked(), GetpSwapchains, SetpSwapchains, ctor);
  SetPrototypeAccessor(proto, Nan::New("pImageIndices").ToLocalChecked(), GetpImageIndices, SetpImageIndices, ctor);
  SetPrototypeAccessor(proto, Nan::New("pResults").ToLocalChecked(), GetpResults, SetpResults, ctor);
  Nan::Set(target, Nan::New("VkPresentInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPresentInfoKHR::flush() {
  _VkPresentInfoKHR *self = this;
  if (!(self->pWaitSemaphores.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pWaitSemaphores);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.waitSemaphoreCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'waitSemaphoreCount' for 'VkPresentInfoKHR.pWaitSemaphores'");
      return false;
    }
    std::vector<VkSemaphore>* data = self->vpWaitSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSemaphore::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pWaitSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pWaitSemaphores = data->data();
  }if (!(self->pSwapchains.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSwapchains);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.swapchainCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'swapchainCount' for 'VkPresentInfoKHR.pSwapchains'");
      return false;
    }
    std::vector<VkSwapchainKHR>* data = self->vpSwapchains;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSwapchainKHR::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pSwapchains", "[object VkSwapchainKHR]");
  
        return false;
      }
      _VkSwapchainKHR* result = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSwapchains = data->data();
  }
  return true;
}

NAN_METHOD(_VkPresentInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkPresentInfoKHR* self = new _VkPresentInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("waitSemaphoreCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pWaitSemaphores").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("swapchainCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pSwapchains").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pImageIndices").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pResults").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPresentInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPresentInfoKHR::GetsType) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPresentInfoKHR::SetsType) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.sType", "Number");
  
    return;
  }
}// waitSemaphoreCount
NAN_GETTER(_VkPresentInfoKHR::GetwaitSemaphoreCount) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.waitSemaphoreCount));
}NAN_SETTER(_VkPresentInfoKHR::SetwaitSemaphoreCount) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.waitSemaphoreCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphores
NAN_GETTER(_VkPresentInfoKHR::GetpWaitSemaphores) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  if (self->pWaitSemaphores.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pWaitSemaphores);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPresentInfoKHR::SetpWaitSemaphores) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pWaitSemaphores.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pWaitSemaphores.Reset();
      self->instance.pWaitSemaphores = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pWaitSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pWaitSemaphores = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pWaitSemaphores", "[object VkSemaphore]");
  
    return;
  }
}// swapchainCount
NAN_GETTER(_VkPresentInfoKHR::GetswapchainCount) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.swapchainCount));
}NAN_SETTER(_VkPresentInfoKHR::SetswapchainCount) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.swapchainCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.swapchainCount", "Number");
  
    return;
  }
}// pSwapchains
NAN_GETTER(_VkPresentInfoKHR::GetpSwapchains) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  if (self->pSwapchains.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSwapchains);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPresentInfoKHR::SetpSwapchains) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSwapchains.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSwapchains.Reset();
      self->instance.pSwapchains = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pSwapchains", "[object VkSwapchainKHR]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSwapchains = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pSwapchains", "[object VkSwapchainKHR]");
  
    return;
  }
}// pImageIndices
NAN_GETTER(_VkPresentInfoKHR::GetpImageIndices) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  if (self->pImageIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pImageIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPresentInfoKHR::SetpImageIndices) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pImageIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pImageIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pImageIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pImageIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pImageIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pImageIndices = nullptr;
  }
}// pResults
NAN_GETTER(_VkPresentInfoKHR::GetpResults) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  if (self->pResults.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pResults);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPresentInfoKHR::SetpResults) {
  _VkPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pResults.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pResults", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pResults.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPresentInfoKHR.pResults", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pResults = reinterpret_cast<VkResult *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pResults = nullptr;
  }
}
/** ## END VkPresentInfoKHR ## **/

/** ## BEGIN VkSwapchainCreateInfoKHR ## **/

class _VkSwapchainCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> surface;
      static NAN_GETTER(Getsurface);
    static NAN_SETTER(Setsurface);
    
    static NAN_GETTER(GetminImageCount);
    static NAN_SETTER(SetminImageCount);
    
    static NAN_GETTER(GetimageFormat);
    static NAN_SETTER(SetimageFormat);
    
    static NAN_GETTER(GetimageColorSpace);
    static NAN_SETTER(SetimageColorSpace);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageExtent;
      static NAN_GETTER(GetimageExtent);
    static NAN_SETTER(SetimageExtent);
    
    static NAN_GETTER(GetimageArrayLayers);
    static NAN_SETTER(SetimageArrayLayers);
    
    static NAN_GETTER(GetimageUsage);
    static NAN_SETTER(SetimageUsage);
    
    static NAN_GETTER(GetimageSharingMode);
    static NAN_SETTER(SetimageSharingMode);
    
    static NAN_GETTER(GetqueueFamilyIndexCount);
    static NAN_SETTER(SetqueueFamilyIndexCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pQueueFamilyIndices;
    static NAN_GETTER(GetpQueueFamilyIndices);
    static NAN_SETTER(SetpQueueFamilyIndices);
    
    static NAN_GETTER(GetpreTransform);
    static NAN_SETTER(SetpreTransform);
    
    static NAN_GETTER(GetcompositeAlpha);
    static NAN_SETTER(SetcompositeAlpha);
    
    static NAN_GETTER(GetpresentMode);
    static NAN_SETTER(SetpresentMode);
    
    static NAN_GETTER(Getclipped);
    static NAN_SETTER(Setclipped);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> oldSwapchain;
      static NAN_GETTER(GetoldSwapchain);
    static NAN_SETTER(SetoldSwapchain);
    

    // real instance
    VkSwapchainCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSwapchainCreateInfoKHR();
    ~_VkSwapchainCreateInfoKHR();

};

/*
#include "index.h"
#include "VkSwapchainCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSwapchainCreateInfoKHR::constructor;

_VkSwapchainCreateInfoKHR::_VkSwapchainCreateInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
  
}

_VkSwapchainCreateInfoKHR::~_VkSwapchainCreateInfoKHR() {
  //printf("VkSwapchainCreateInfoKHR deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  pQueueFamilyIndices.Reset();
  
  
  
  
  
  
}

void _VkSwapchainCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSwapchainCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSwapchainCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("surface").ToLocalChecked(), Getsurface, Setsurface, ctor);
  SetPrototypeAccessor(proto, Nan::New("minImageCount").ToLocalChecked(), GetminImageCount, SetminImageCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageFormat").ToLocalChecked(), GetimageFormat, SetimageFormat, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageColorSpace").ToLocalChecked(), GetimageColorSpace, SetimageColorSpace, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageExtent").ToLocalChecked(), GetimageExtent, SetimageExtent, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageArrayLayers").ToLocalChecked(), GetimageArrayLayers, SetimageArrayLayers, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageUsage").ToLocalChecked(), GetimageUsage, SetimageUsage, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageSharingMode").ToLocalChecked(), GetimageSharingMode, SetimageSharingMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueFamilyIndexCount").ToLocalChecked(), GetqueueFamilyIndexCount, SetqueueFamilyIndexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pQueueFamilyIndices").ToLocalChecked(), GetpQueueFamilyIndices, SetpQueueFamilyIndices, ctor);
  SetPrototypeAccessor(proto, Nan::New("preTransform").ToLocalChecked(), GetpreTransform, SetpreTransform, ctor);
  SetPrototypeAccessor(proto, Nan::New("compositeAlpha").ToLocalChecked(), GetcompositeAlpha, SetcompositeAlpha, ctor);
  SetPrototypeAccessor(proto, Nan::New("presentMode").ToLocalChecked(), GetpresentMode, SetpresentMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("clipped").ToLocalChecked(), Getclipped, Setclipped, ctor);
  SetPrototypeAccessor(proto, Nan::New("oldSwapchain").ToLocalChecked(), GetoldSwapchain, SetoldSwapchain, ctor);
  Nan::Set(target, Nan::New("VkSwapchainCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSwapchainCreateInfoKHR::flush() {
  _VkSwapchainCreateInfoKHR *self = this;
  if (!(self->imageExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->imageExtent);
    
    _VkExtent2D* result = Nan::ObjectWrap::Unwrap<_VkExtent2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.imageExtent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkSwapchainCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkSwapchainCreateInfoKHR* self = new _VkSwapchainCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("surface").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("minImageCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("imageFormat").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("imageColorSpace").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("imageExtent").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("imageArrayLayers").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("imageUsage").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("imageSharingMode").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("queueFamilyIndexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("pQueueFamilyIndices").ToLocalChecked();
      v8::Local<v8::String> sAccess13 = Nan::New("preTransform").ToLocalChecked();
      v8::Local<v8::String> sAccess14 = Nan::New("compositeAlpha").ToLocalChecked();
      v8::Local<v8::String> sAccess15 = Nan::New("presentMode").ToLocalChecked();
      v8::Local<v8::String> sAccess16 = Nan::New("clipped").ToLocalChecked();
      v8::Local<v8::String> sAccess17 = Nan::New("oldSwapchain").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      if (obj->Has(sAccess13)) info.This()->Set(sAccess13, obj->Get(sAccess13));
      if (obj->Has(sAccess14)) info.This()->Set(sAccess14, obj->Get(sAccess14));
      if (obj->Has(sAccess15)) info.This()->Set(sAccess15, obj->Get(sAccess15));
      if (obj->Has(sAccess16)) info.This()->Set(sAccess16, obj->Get(sAccess16));
      if (obj->Has(sAccess17)) info.This()->Set(sAccess17, obj->Get(sAccess17));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSwapchainCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetsType) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetsType) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkSwapchainCreateInfoKHR::Getflags) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::Setflags) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSwapchainCreateFlagsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.flags", "Number");
  
    return;
  }
}// surface
NAN_GETTER(_VkSwapchainCreateInfoKHR::Getsurface) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (self->surface.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->surface);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSwapchainCreateInfoKHR::Setsurface) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSurfaceKHR::constructor)->HasInstance(obj)) {
      self->surface.Reset<v8::Object>(value.As<v8::Object>());
      _VkSurfaceKHR* inst = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(obj);
      ;
      self->instance.surface = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.surface", "[object VkSurfaceKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->surface.Reset();
    self->instance.surface = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.surface", "[object VkSurfaceKHR]");
  
    return;
  }
}// minImageCount
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetminImageCount) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minImageCount));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetminImageCount) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.minImageCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.minImageCount", "Number");
  
    return;
  }
}// imageFormat
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetimageFormat) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageFormat));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetimageFormat) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.imageFormat = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.imageFormat", "Number");
  
    return;
  }
}// imageColorSpace
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetimageColorSpace) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageColorSpace));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetimageColorSpace) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.imageColorSpace = static_cast<VkColorSpaceKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.imageColorSpace", "Number");
  
    return;
  }
}// imageExtent
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetimageExtent) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (self->imageExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageExtent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetimageExtent) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent2D::constructor)->HasInstance(obj)) {
      self->imageExtent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent2D* inst = Nan::ObjectWrap::Unwrap<_VkExtent2D>(obj);
      inst->flush();
      self->instance.imageExtent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.imageExtent", "[object VkExtent2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->imageExtent.Reset();
    memset(&self->instance.imageExtent, 0, sizeof(VkExtent2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.imageExtent", "[object VkExtent2D]");
  
    return;
  }
}// imageArrayLayers
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetimageArrayLayers) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageArrayLayers));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetimageArrayLayers) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.imageArrayLayers = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.imageArrayLayers", "Number");
  
    return;
  }
}// imageUsage
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetimageUsage) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageUsage));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetimageUsage) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.imageUsage = static_cast<VkImageUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.imageUsage", "Number");
  
    return;
  }
}// imageSharingMode
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetimageSharingMode) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageSharingMode));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetimageSharingMode) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.imageSharingMode = static_cast<VkSharingMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.imageSharingMode", "Number");
  
    return;
  }
}// queueFamilyIndexCount
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetqueueFamilyIndexCount) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueFamilyIndexCount));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetqueueFamilyIndexCount) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.queueFamilyIndexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.queueFamilyIndexCount", "Number");
  
    return;
  }
}// pQueueFamilyIndices
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetpQueueFamilyIndices) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (self->pQueueFamilyIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pQueueFamilyIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetpQueueFamilyIndices) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pQueueFamilyIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.pQueueFamilyIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pQueueFamilyIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.pQueueFamilyIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pQueueFamilyIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pQueueFamilyIndices = nullptr;
  }
}// preTransform
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetpreTransform) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.preTransform));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetpreTransform) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.preTransform = static_cast<VkSurfaceTransformFlagBitsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.preTransform", "Number");
  
    return;
  }
}// compositeAlpha
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetcompositeAlpha) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compositeAlpha));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetcompositeAlpha) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.compositeAlpha = static_cast<VkCompositeAlphaFlagBitsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.compositeAlpha", "Number");
  
    return;
  }
}// presentMode
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetpresentMode) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.presentMode));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetpresentMode) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.presentMode = static_cast<VkPresentModeKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.presentMode", "Number");
  
    return;
  }
}// clipped
NAN_GETTER(_VkSwapchainCreateInfoKHR::Getclipped) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.clipped));
}NAN_SETTER(_VkSwapchainCreateInfoKHR::Setclipped) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.clipped = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.clipped", "Number");
  
    return;
  }
}// oldSwapchain
NAN_GETTER(_VkSwapchainCreateInfoKHR::GetoldSwapchain) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  if (self->oldSwapchain.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->oldSwapchain);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSwapchainCreateInfoKHR::SetoldSwapchain) {
  _VkSwapchainCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSwapchainKHR::constructor)->HasInstance(obj)) {
      self->oldSwapchain.Reset<v8::Object>(value.As<v8::Object>());
      _VkSwapchainKHR* inst = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(obj);
      ;
      self->instance.oldSwapchain = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.oldSwapchain", "[object VkSwapchainKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->oldSwapchain.Reset();
    self->instance.oldSwapchain = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSwapchainCreateInfoKHR.oldSwapchain", "[object VkSwapchainKHR]");
  
    return;
  }
}
/** ## END VkSwapchainCreateInfoKHR ## **/

/** ## BEGIN VkWin32SurfaceCreateInfoKHR ## **/

class _VkWin32SurfaceCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkWin32SurfaceCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkWin32SurfaceCreateInfoKHR();
    ~_VkWin32SurfaceCreateInfoKHR();

};

/*
#include "index.h"
#include "VkWin32SurfaceCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkWin32SurfaceCreateInfoKHR::constructor;

_VkWin32SurfaceCreateInfoKHR::_VkWin32SurfaceCreateInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
  
}

_VkWin32SurfaceCreateInfoKHR::~_VkWin32SurfaceCreateInfoKHR() {
  //printf("VkWin32SurfaceCreateInfoKHR deconstructed!!\n");
  
  
  
}

void _VkWin32SurfaceCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkWin32SurfaceCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkWin32SurfaceCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkWin32SurfaceCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkWin32SurfaceCreateInfoKHR::flush() {
  _VkWin32SurfaceCreateInfoKHR *self = this;
  
  return true;
}

NAN_METHOD(_VkWin32SurfaceCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkWin32SurfaceCreateInfoKHR* self = new _VkWin32SurfaceCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkWin32SurfaceCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkWin32SurfaceCreateInfoKHR::GetsType) {
  _VkWin32SurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32SurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkWin32SurfaceCreateInfoKHR::SetsType) {
  _VkWin32SurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32SurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32SurfaceCreateInfoKHR.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkWin32SurfaceCreateInfoKHR::Getflags) {
  _VkWin32SurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32SurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkWin32SurfaceCreateInfoKHR::Setflags) {
  _VkWin32SurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkWin32SurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkWin32SurfaceCreateFlagsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWin32SurfaceCreateInfoKHR.flags", "Number");
  
    return;
  }
}
/** ## END VkWin32SurfaceCreateInfoKHR ## **/

/** ## BEGIN VkDisplayPresentInfoKHR ## **/

class _VkDisplayPresentInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> srcRect;
      static NAN_GETTER(GetsrcRect);
    static NAN_SETTER(SetsrcRect);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> dstRect;
      static NAN_GETTER(GetdstRect);
    static NAN_SETTER(SetdstRect);
    
    static NAN_GETTER(Getpersistent);
    static NAN_SETTER(Setpersistent);
    

    // real instance
    VkDisplayPresentInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayPresentInfoKHR();
    ~_VkDisplayPresentInfoKHR();

};

/*
#include "index.h"
#include "VkDisplayPresentInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayPresentInfoKHR::constructor;

_VkDisplayPresentInfoKHR::_VkDisplayPresentInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
  
}

_VkDisplayPresentInfoKHR::~_VkDisplayPresentInfoKHR() {
  //printf("VkDisplayPresentInfoKHR deconstructed!!\n");
  
  
  
  
  
}

void _VkDisplayPresentInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayPresentInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayPresentInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcRect").ToLocalChecked(), GetsrcRect, SetsrcRect, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstRect").ToLocalChecked(), GetdstRect, SetdstRect, ctor);
  SetPrototypeAccessor(proto, Nan::New("persistent").ToLocalChecked(), Getpersistent, Setpersistent, ctor);
  Nan::Set(target, Nan::New("VkDisplayPresentInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayPresentInfoKHR::flush() {
  _VkDisplayPresentInfoKHR *self = this;
  if (!(self->srcRect.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->srcRect);
    
    _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.srcRect = result->instance;
  }if (!(self->dstRect.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->dstRect);
    
    _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.dstRect = result->instance;
  }
  return true;
}

NAN_METHOD(_VkDisplayPresentInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayPresentInfoKHR* self = new _VkDisplayPresentInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("srcRect").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstRect").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("persistent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayPresentInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayPresentInfoKHR::GetsType) {
  _VkDisplayPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPresentInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDisplayPresentInfoKHR::SetsType) {
  _VkDisplayPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPresentInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPresentInfoKHR.sType", "Number");
  
    return;
  }
}// srcRect
NAN_GETTER(_VkDisplayPresentInfoKHR::GetsrcRect) {
  _VkDisplayPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPresentInfoKHR>(info.This());
  if (self->srcRect.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->srcRect);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDisplayPresentInfoKHR::SetsrcRect) {
  _VkDisplayPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPresentInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkRect2D::constructor)->HasInstance(obj)) {
      self->srcRect.Reset<v8::Object>(value.As<v8::Object>());
      _VkRect2D* inst = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      inst->flush();
      self->instance.srcRect = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDisplayPresentInfoKHR.srcRect", "[object VkRect2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->srcRect.Reset();
    memset(&self->instance.srcRect, 0, sizeof(VkRect2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPresentInfoKHR.srcRect", "[object VkRect2D]");
  
    return;
  }
}// dstRect
NAN_GETTER(_VkDisplayPresentInfoKHR::GetdstRect) {
  _VkDisplayPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPresentInfoKHR>(info.This());
  if (self->dstRect.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->dstRect);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDisplayPresentInfoKHR::SetdstRect) {
  _VkDisplayPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPresentInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkRect2D::constructor)->HasInstance(obj)) {
      self->dstRect.Reset<v8::Object>(value.As<v8::Object>());
      _VkRect2D* inst = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      inst->flush();
      self->instance.dstRect = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDisplayPresentInfoKHR.dstRect", "[object VkRect2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->dstRect.Reset();
    memset(&self->instance.dstRect, 0, sizeof(VkRect2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPresentInfoKHR.dstRect", "[object VkRect2D]");
  
    return;
  }
}// persistent
NAN_GETTER(_VkDisplayPresentInfoKHR::Getpersistent) {
  _VkDisplayPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPresentInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.persistent));
}NAN_SETTER(_VkDisplayPresentInfoKHR::Setpersistent) {
  _VkDisplayPresentInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayPresentInfoKHR>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.persistent = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayPresentInfoKHR.persistent", "Number");
  
    return;
  }
}
/** ## END VkDisplayPresentInfoKHR ## **/

/** ## BEGIN VkDisplaySurfaceCreateInfoKHR ## **/

class _VkDisplaySurfaceCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> displayMode;
      static NAN_GETTER(GetdisplayMode);
    static NAN_SETTER(SetdisplayMode);
    
    static NAN_GETTER(GetplaneIndex);
    static NAN_SETTER(SetplaneIndex);
    
    static NAN_GETTER(GetplaneStackIndex);
    static NAN_SETTER(SetplaneStackIndex);
    
    static NAN_GETTER(Gettransform);
    static NAN_SETTER(Settransform);
    
    static NAN_GETTER(GetglobalAlpha);
    static NAN_SETTER(SetglobalAlpha);
    
    static NAN_GETTER(GetalphaMode);
    static NAN_SETTER(SetalphaMode);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageExtent;
      static NAN_GETTER(GetimageExtent);
    static NAN_SETTER(SetimageExtent);
    

    // real instance
    VkDisplaySurfaceCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplaySurfaceCreateInfoKHR();
    ~_VkDisplaySurfaceCreateInfoKHR();

};

/*
#include "index.h"
#include "VkDisplaySurfaceCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplaySurfaceCreateInfoKHR::constructor;

_VkDisplaySurfaceCreateInfoKHR::_VkDisplaySurfaceCreateInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
  
}

_VkDisplaySurfaceCreateInfoKHR::~_VkDisplaySurfaceCreateInfoKHR() {
  //printf("VkDisplaySurfaceCreateInfoKHR deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
}

void _VkDisplaySurfaceCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplaySurfaceCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplaySurfaceCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("displayMode").ToLocalChecked(), GetdisplayMode, SetdisplayMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("planeIndex").ToLocalChecked(), GetplaneIndex, SetplaneIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("planeStackIndex").ToLocalChecked(), GetplaneStackIndex, SetplaneStackIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("transform").ToLocalChecked(), Gettransform, Settransform, ctor);
  SetPrototypeAccessor(proto, Nan::New("globalAlpha").ToLocalChecked(), GetglobalAlpha, SetglobalAlpha, ctor);
  SetPrototypeAccessor(proto, Nan::New("alphaMode").ToLocalChecked(), GetalphaMode, SetalphaMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageExtent").ToLocalChecked(), GetimageExtent, SetimageExtent, ctor);
  Nan::Set(target, Nan::New("VkDisplaySurfaceCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplaySurfaceCreateInfoKHR::flush() {
  _VkDisplaySurfaceCreateInfoKHR *self = this;
  if (!(self->imageExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->imageExtent);
    
    _VkExtent2D* result = Nan::ObjectWrap::Unwrap<_VkExtent2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.imageExtent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkDisplaySurfaceCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplaySurfaceCreateInfoKHR* self = new _VkDisplaySurfaceCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("displayMode").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("planeIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("planeStackIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("transform").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("globalAlpha").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("alphaMode").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("imageExtent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplaySurfaceCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::GetsType) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::SetsType) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::Getflags) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::Setflags) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDisplaySurfaceCreateFlagsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.flags", "Number");
  
    return;
  }
}// displayMode
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::GetdisplayMode) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (self->displayMode.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->displayMode);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::SetdisplayMode) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDisplayModeKHR::constructor)->HasInstance(obj)) {
      self->displayMode.Reset<v8::Object>(value.As<v8::Object>());
      _VkDisplayModeKHR* inst = Nan::ObjectWrap::Unwrap<_VkDisplayModeKHR>(obj);
      ;
      self->instance.displayMode = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.displayMode", "[object VkDisplayModeKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->displayMode.Reset();
    self->instance.displayMode = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.displayMode", "[object VkDisplayModeKHR]");
  
    return;
  }
}// planeIndex
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::GetplaneIndex) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.planeIndex));
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::SetplaneIndex) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.planeIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.planeIndex", "Number");
  
    return;
  }
}// planeStackIndex
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::GetplaneStackIndex) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.planeStackIndex));
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::SetplaneStackIndex) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.planeStackIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.planeStackIndex", "Number");
  
    return;
  }
}// transform
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::Gettransform) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.transform));
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::Settransform) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.transform = static_cast<VkSurfaceTransformFlagBitsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.transform", "Number");
  
    return;
  }
}// globalAlpha
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::GetglobalAlpha) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.globalAlpha));
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::SetglobalAlpha) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.globalAlpha = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.globalAlpha", "Number");
  
    return;
  }
}// alphaMode
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::GetalphaMode) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.alphaMode));
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::SetalphaMode) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.alphaMode = static_cast<VkDisplayPlaneAlphaFlagBitsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.alphaMode", "Number");
  
    return;
  }
}// imageExtent
NAN_GETTER(_VkDisplaySurfaceCreateInfoKHR::GetimageExtent) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  if (self->imageExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageExtent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDisplaySurfaceCreateInfoKHR::SetimageExtent) {
  _VkDisplaySurfaceCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplaySurfaceCreateInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent2D::constructor)->HasInstance(obj)) {
      self->imageExtent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent2D* inst = Nan::ObjectWrap::Unwrap<_VkExtent2D>(obj);
      inst->flush();
      self->instance.imageExtent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.imageExtent", "[object VkExtent2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->imageExtent.Reset();
    memset(&self->instance.imageExtent, 0, sizeof(VkExtent2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplaySurfaceCreateInfoKHR.imageExtent", "[object VkExtent2D]");
  
    return;
  }
}
/** ## END VkDisplaySurfaceCreateInfoKHR ## **/

/** ## BEGIN VkDisplayModeCreateInfoKHR ## **/

class _VkDisplayModeCreateInfoKHR: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> parameters;
      static NAN_GETTER(Getparameters);
    static NAN_SETTER(Setparameters);
    

    // real instance
    VkDisplayModeCreateInfoKHR instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDisplayModeCreateInfoKHR();
    ~_VkDisplayModeCreateInfoKHR();

};

/*
#include "index.h"
#include "VkDisplayModeCreateInfoKHR.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDisplayModeCreateInfoKHR::constructor;

_VkDisplayModeCreateInfoKHR::_VkDisplayModeCreateInfoKHR() {
  instance.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
  
}

_VkDisplayModeCreateInfoKHR::~_VkDisplayModeCreateInfoKHR() {
  //printf("VkDisplayModeCreateInfoKHR deconstructed!!\n");
  
  
  
  
}

void _VkDisplayModeCreateInfoKHR::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDisplayModeCreateInfoKHR::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDisplayModeCreateInfoKHR").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("parameters").ToLocalChecked(), Getparameters, Setparameters, ctor);
  Nan::Set(target, Nan::New("VkDisplayModeCreateInfoKHR").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDisplayModeCreateInfoKHR::flush() {
  _VkDisplayModeCreateInfoKHR *self = this;
  if (!(self->parameters.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->parameters);
    
    _VkDisplayModeParametersKHR* result = Nan::ObjectWrap::Unwrap<_VkDisplayModeParametersKHR>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.parameters = result->instance;
  }
  return true;
}

NAN_METHOD(_VkDisplayModeCreateInfoKHR::New) {
  if (info.IsConstructCall()) {
    _VkDisplayModeCreateInfoKHR* self = new _VkDisplayModeCreateInfoKHR();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("parameters").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDisplayModeCreateInfoKHR constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDisplayModeCreateInfoKHR::GetsType) {
  _VkDisplayModeCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDisplayModeCreateInfoKHR::SetsType) {
  _VkDisplayModeCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayModeCreateInfoKHR.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDisplayModeCreateInfoKHR::Getflags) {
  _VkDisplayModeCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeCreateInfoKHR>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDisplayModeCreateInfoKHR::Setflags) {
  _VkDisplayModeCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeCreateInfoKHR>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDisplayModeCreateFlagsKHR>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayModeCreateInfoKHR.flags", "Number");
  
    return;
  }
}// parameters
NAN_GETTER(_VkDisplayModeCreateInfoKHR::Getparameters) {
  _VkDisplayModeCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeCreateInfoKHR>(info.This());
  if (self->parameters.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->parameters);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDisplayModeCreateInfoKHR::Setparameters) {
  _VkDisplayModeCreateInfoKHR *self = Nan::ObjectWrap::Unwrap<_VkDisplayModeCreateInfoKHR>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDisplayModeParametersKHR::constructor)->HasInstance(obj)) {
      self->parameters.Reset<v8::Object>(value.As<v8::Object>());
      _VkDisplayModeParametersKHR* inst = Nan::ObjectWrap::Unwrap<_VkDisplayModeParametersKHR>(obj);
      inst->flush();
      self->instance.parameters = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDisplayModeCreateInfoKHR.parameters", "[object VkDisplayModeParametersKHR]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->parameters.Reset();
    memset(&self->instance.parameters, 0, sizeof(VkDisplayModeParametersKHR));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDisplayModeCreateInfoKHR.parameters", "[object VkDisplayModeParametersKHR]");
  
    return;
  }
}
/** ## END VkDisplayModeCreateInfoKHR ## **/

/** ## BEGIN VkSubmitInfo ## **/

class _VkSubmitInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetwaitSemaphoreCount);
    static NAN_SETTER(SetwaitSemaphoreCount);
    
    std::vector<VkSemaphore>* vpWaitSemaphores;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pWaitSemaphores;
    static NAN_GETTER(GetpWaitSemaphores);
    static NAN_SETTER(SetpWaitSemaphores);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pWaitDstStageMask;
    static NAN_GETTER(GetpWaitDstStageMask);
    static NAN_SETTER(SetpWaitDstStageMask);
    
    static NAN_GETTER(GetcommandBufferCount);
    static NAN_SETTER(SetcommandBufferCount);
    
    std::vector<VkCommandBuffer>* vpCommandBuffers;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pCommandBuffers;
    static NAN_GETTER(GetpCommandBuffers);
    static NAN_SETTER(SetpCommandBuffers);
    
    static NAN_GETTER(GetsignalSemaphoreCount);
    static NAN_SETTER(SetsignalSemaphoreCount);
    
    std::vector<VkSemaphore>* vpSignalSemaphores;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSignalSemaphores;
    static NAN_GETTER(GetpSignalSemaphores);
    static NAN_SETTER(SetpSignalSemaphores);
    

    // real instance
    VkSubmitInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubmitInfo();
    ~_VkSubmitInfo();

};

/*
#include "index.h"
#include "VkSubmitInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubmitInfo::constructor;

_VkSubmitInfo::_VkSubmitInfo() {
  instance.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
  vpWaitSemaphores = new std::vector<VkSemaphore>;
  vpCommandBuffers = new std::vector<VkCommandBuffer>;
  vpSignalSemaphores = new std::vector<VkSemaphore>;
  
}

_VkSubmitInfo::~_VkSubmitInfo() {
  //printf("VkSubmitInfo deconstructed!!\n");
  
  
  
  vpWaitSemaphores->clear();
  delete vpWaitSemaphores;
  
  pWaitSemaphores.Reset();
  
  pWaitDstStageMask.Reset();
  
  
  vpCommandBuffers->clear();
  delete vpCommandBuffers;
  
  pCommandBuffers.Reset();
  
  
  vpSignalSemaphores->clear();
  delete vpSignalSemaphores;
  
  pSignalSemaphores.Reset();
  
}

void _VkSubmitInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubmitInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubmitInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("waitSemaphoreCount").ToLocalChecked(), GetwaitSemaphoreCount, SetwaitSemaphoreCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pWaitSemaphores").ToLocalChecked(), GetpWaitSemaphores, SetpWaitSemaphores, ctor);
  SetPrototypeAccessor(proto, Nan::New("pWaitDstStageMask").ToLocalChecked(), GetpWaitDstStageMask, SetpWaitDstStageMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("commandBufferCount").ToLocalChecked(), GetcommandBufferCount, SetcommandBufferCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pCommandBuffers").ToLocalChecked(), GetpCommandBuffers, SetpCommandBuffers, ctor);
  SetPrototypeAccessor(proto, Nan::New("signalSemaphoreCount").ToLocalChecked(), GetsignalSemaphoreCount, SetsignalSemaphoreCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSignalSemaphores").ToLocalChecked(), GetpSignalSemaphores, SetpSignalSemaphores, ctor);
  Nan::Set(target, Nan::New("VkSubmitInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubmitInfo::flush() {
  _VkSubmitInfo *self = this;
  if (!(self->pWaitSemaphores.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pWaitSemaphores);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.waitSemaphoreCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'waitSemaphoreCount' for 'VkSubmitInfo.pWaitSemaphores'");
      return false;
    }
    std::vector<VkSemaphore>* data = self->vpWaitSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSemaphore::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pWaitSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pWaitSemaphores = data->data();
  }if (!(self->pCommandBuffers.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pCommandBuffers);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.commandBufferCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'commandBufferCount' for 'VkSubmitInfo.pCommandBuffers'");
      return false;
    }
    std::vector<VkCommandBuffer>* data = self->vpCommandBuffers;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkCommandBuffer::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pCommandBuffers", "[object VkCommandBuffer]");
  
        return false;
      }
      _VkCommandBuffer* result = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pCommandBuffers = data->data();
  }if (!(self->pSignalSemaphores.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSignalSemaphores);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.signalSemaphoreCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'signalSemaphoreCount' for 'VkSubmitInfo.pSignalSemaphores'");
      return false;
    }
    std::vector<VkSemaphore>* data = self->vpSignalSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSemaphore::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pSignalSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSignalSemaphores = data->data();
  }
  return true;
}

NAN_METHOD(_VkSubmitInfo::New) {
  if (info.IsConstructCall()) {
    _VkSubmitInfo* self = new _VkSubmitInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("waitSemaphoreCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pWaitSemaphores").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pWaitDstStageMask").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("commandBufferCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pCommandBuffers").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("signalSemaphoreCount").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pSignalSemaphores").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubmitInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSubmitInfo::GetsType) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSubmitInfo::SetsType) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.sType", "Number");
  
    return;
  }
}// waitSemaphoreCount
NAN_GETTER(_VkSubmitInfo::GetwaitSemaphoreCount) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.waitSemaphoreCount));
}NAN_SETTER(_VkSubmitInfo::SetwaitSemaphoreCount) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.waitSemaphoreCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphores
NAN_GETTER(_VkSubmitInfo::GetpWaitSemaphores) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  if (self->pWaitSemaphores.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pWaitSemaphores);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubmitInfo::SetpWaitSemaphores) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pWaitSemaphores.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pWaitSemaphores.Reset();
      self->instance.pWaitSemaphores = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pWaitSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pWaitSemaphores = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pWaitSemaphores", "[object VkSemaphore]");
  
    return;
  }
}// pWaitDstStageMask
NAN_GETTER(_VkSubmitInfo::GetpWaitDstStageMask) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  if (self->pWaitDstStageMask.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pWaitDstStageMask);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubmitInfo::SetpWaitDstStageMask) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pWaitDstStageMask.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pWaitDstStageMask", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pWaitDstStageMask.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pWaitDstStageMask", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pWaitDstStageMask = reinterpret_cast<const VkPipelineStageFlags *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pWaitDstStageMask = nullptr;
  }
}// commandBufferCount
NAN_GETTER(_VkSubmitInfo::GetcommandBufferCount) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.commandBufferCount));
}NAN_SETTER(_VkSubmitInfo::SetcommandBufferCount) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.commandBufferCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.commandBufferCount", "Number");
  
    return;
  }
}// pCommandBuffers
NAN_GETTER(_VkSubmitInfo::GetpCommandBuffers) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  if (self->pCommandBuffers.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pCommandBuffers);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubmitInfo::SetpCommandBuffers) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pCommandBuffers.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pCommandBuffers.Reset();
      self->instance.pCommandBuffers = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pCommandBuffers", "[object VkCommandBuffer]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pCommandBuffers = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pCommandBuffers", "[object VkCommandBuffer]");
  
    return;
  }
}// signalSemaphoreCount
NAN_GETTER(_VkSubmitInfo::GetsignalSemaphoreCount) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.signalSemaphoreCount));
}NAN_SETTER(_VkSubmitInfo::SetsignalSemaphoreCount) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.signalSemaphoreCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.signalSemaphoreCount", "Number");
  
    return;
  }
}// pSignalSemaphores
NAN_GETTER(_VkSubmitInfo::GetpSignalSemaphores) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  if (self->pSignalSemaphores.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSignalSemaphores);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubmitInfo::SetpSignalSemaphores) {
  _VkSubmitInfo *self = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSignalSemaphores.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSignalSemaphores.Reset();
      self->instance.pSignalSemaphores = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pSignalSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSignalSemaphores = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubmitInfo.pSignalSemaphores", "[object VkSemaphore]");
  
    return;
  }
}
/** ## END VkSubmitInfo ## **/

/** ## BEGIN VkDispatchIndirectCommand ## **/

class _VkDispatchIndirectCommand: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getx);
    static NAN_SETTER(Setx);
    
    static NAN_GETTER(Gety);
    static NAN_SETTER(Sety);
    
    static NAN_GETTER(Getz);
    static NAN_SETTER(Setz);
    

    // real instance
    VkDispatchIndirectCommand instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDispatchIndirectCommand();
    ~_VkDispatchIndirectCommand();

};

/*
#include "index.h"
#include "VkDispatchIndirectCommand.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDispatchIndirectCommand::constructor;

_VkDispatchIndirectCommand::_VkDispatchIndirectCommand() {
  
  
}

_VkDispatchIndirectCommand::~_VkDispatchIndirectCommand() {
  //printf("VkDispatchIndirectCommand deconstructed!!\n");
  
  
  
  
}

void _VkDispatchIndirectCommand::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDispatchIndirectCommand::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDispatchIndirectCommand").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("x").ToLocalChecked(), Getx, Setx, ctor);
  SetPrototypeAccessor(proto, Nan::New("y").ToLocalChecked(), Gety, Sety, ctor);
  SetPrototypeAccessor(proto, Nan::New("z").ToLocalChecked(), Getz, Setz, ctor);
  Nan::Set(target, Nan::New("VkDispatchIndirectCommand").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDispatchIndirectCommand::flush() {
  _VkDispatchIndirectCommand *self = this;
  
  return true;
}

NAN_METHOD(_VkDispatchIndirectCommand::New) {
  if (info.IsConstructCall()) {
    _VkDispatchIndirectCommand* self = new _VkDispatchIndirectCommand();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("x").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("y").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("z").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDispatchIndirectCommand constructor cannot be invoked without 'new'");
  }
};

// x
NAN_GETTER(_VkDispatchIndirectCommand::Getx) {
  _VkDispatchIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDispatchIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.x));
}NAN_SETTER(_VkDispatchIndirectCommand::Setx) {
  _VkDispatchIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDispatchIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.x = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDispatchIndirectCommand.x", "Number");
  
    return;
  }
}// y
NAN_GETTER(_VkDispatchIndirectCommand::Gety) {
  _VkDispatchIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDispatchIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.y));
}NAN_SETTER(_VkDispatchIndirectCommand::Sety) {
  _VkDispatchIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDispatchIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.y = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDispatchIndirectCommand.y", "Number");
  
    return;
  }
}// z
NAN_GETTER(_VkDispatchIndirectCommand::Getz) {
  _VkDispatchIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDispatchIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.z));
}NAN_SETTER(_VkDispatchIndirectCommand::Setz) {
  _VkDispatchIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDispatchIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.z = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDispatchIndirectCommand.z", "Number");
  
    return;
  }
}
/** ## END VkDispatchIndirectCommand ## **/

/** ## BEGIN VkDrawIndexedIndirectCommand ## **/

class _VkDrawIndexedIndirectCommand: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetindexCount);
    static NAN_SETTER(SetindexCount);
    
    static NAN_GETTER(GetinstanceCount);
    static NAN_SETTER(SetinstanceCount);
    
    static NAN_GETTER(GetfirstIndex);
    static NAN_SETTER(SetfirstIndex);
    
    static NAN_GETTER(GetvertexOffset);
    static NAN_SETTER(SetvertexOffset);
    
    static NAN_GETTER(GetfirstInstance);
    static NAN_SETTER(SetfirstInstance);
    

    // real instance
    VkDrawIndexedIndirectCommand instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDrawIndexedIndirectCommand();
    ~_VkDrawIndexedIndirectCommand();

};

/*
#include "index.h"
#include "VkDrawIndexedIndirectCommand.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDrawIndexedIndirectCommand::constructor;

_VkDrawIndexedIndirectCommand::_VkDrawIndexedIndirectCommand() {
  
  
}

_VkDrawIndexedIndirectCommand::~_VkDrawIndexedIndirectCommand() {
  //printf("VkDrawIndexedIndirectCommand deconstructed!!\n");
  
  
  
  
  
  
}

void _VkDrawIndexedIndirectCommand::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDrawIndexedIndirectCommand::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDrawIndexedIndirectCommand").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("indexCount").ToLocalChecked(), GetindexCount, SetindexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("instanceCount").ToLocalChecked(), GetinstanceCount, SetinstanceCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("firstIndex").ToLocalChecked(), GetfirstIndex, SetfirstIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexOffset").ToLocalChecked(), GetvertexOffset, SetvertexOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("firstInstance").ToLocalChecked(), GetfirstInstance, SetfirstInstance, ctor);
  Nan::Set(target, Nan::New("VkDrawIndexedIndirectCommand").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDrawIndexedIndirectCommand::flush() {
  _VkDrawIndexedIndirectCommand *self = this;
  
  return true;
}

NAN_METHOD(_VkDrawIndexedIndirectCommand::New) {
  if (info.IsConstructCall()) {
    _VkDrawIndexedIndirectCommand* self = new _VkDrawIndexedIndirectCommand();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("indexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("instanceCount").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("firstIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("vertexOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("firstInstance").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDrawIndexedIndirectCommand constructor cannot be invoked without 'new'");
  }
};

// indexCount
NAN_GETTER(_VkDrawIndexedIndirectCommand::GetindexCount) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.indexCount));
}NAN_SETTER(_VkDrawIndexedIndirectCommand::SetindexCount) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.indexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndexedIndirectCommand.indexCount", "Number");
  
    return;
  }
}// instanceCount
NAN_GETTER(_VkDrawIndexedIndirectCommand::GetinstanceCount) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.instanceCount));
}NAN_SETTER(_VkDrawIndexedIndirectCommand::SetinstanceCount) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.instanceCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndexedIndirectCommand.instanceCount", "Number");
  
    return;
  }
}// firstIndex
NAN_GETTER(_VkDrawIndexedIndirectCommand::GetfirstIndex) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.firstIndex));
}NAN_SETTER(_VkDrawIndexedIndirectCommand::SetfirstIndex) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.firstIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndexedIndirectCommand.firstIndex", "Number");
  
    return;
  }
}// vertexOffset
NAN_GETTER(_VkDrawIndexedIndirectCommand::GetvertexOffset) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexOffset));
}NAN_SETTER(_VkDrawIndexedIndirectCommand::SetvertexOffset) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexOffset = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndexedIndirectCommand.vertexOffset", "Number");
  
    return;
  }
}// firstInstance
NAN_GETTER(_VkDrawIndexedIndirectCommand::GetfirstInstance) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.firstInstance));
}NAN_SETTER(_VkDrawIndexedIndirectCommand::SetfirstInstance) {
  _VkDrawIndexedIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndexedIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.firstInstance = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndexedIndirectCommand.firstInstance", "Number");
  
    return;
  }
}
/** ## END VkDrawIndexedIndirectCommand ## **/

/** ## BEGIN VkDrawIndirectCommand ## **/

class _VkDrawIndirectCommand: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetvertexCount);
    static NAN_SETTER(SetvertexCount);
    
    static NAN_GETTER(GetinstanceCount);
    static NAN_SETTER(SetinstanceCount);
    
    static NAN_GETTER(GetfirstVertex);
    static NAN_SETTER(SetfirstVertex);
    
    static NAN_GETTER(GetfirstInstance);
    static NAN_SETTER(SetfirstInstance);
    

    // real instance
    VkDrawIndirectCommand instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDrawIndirectCommand();
    ~_VkDrawIndirectCommand();

};

/*
#include "index.h"
#include "VkDrawIndirectCommand.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDrawIndirectCommand::constructor;

_VkDrawIndirectCommand::_VkDrawIndirectCommand() {
  
  
}

_VkDrawIndirectCommand::~_VkDrawIndirectCommand() {
  //printf("VkDrawIndirectCommand deconstructed!!\n");
  
  
  
  
  
}

void _VkDrawIndirectCommand::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDrawIndirectCommand::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDrawIndirectCommand").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("vertexCount").ToLocalChecked(), GetvertexCount, SetvertexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("instanceCount").ToLocalChecked(), GetinstanceCount, SetinstanceCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("firstVertex").ToLocalChecked(), GetfirstVertex, SetfirstVertex, ctor);
  SetPrototypeAccessor(proto, Nan::New("firstInstance").ToLocalChecked(), GetfirstInstance, SetfirstInstance, ctor);
  Nan::Set(target, Nan::New("VkDrawIndirectCommand").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDrawIndirectCommand::flush() {
  _VkDrawIndirectCommand *self = this;
  
  return true;
}

NAN_METHOD(_VkDrawIndirectCommand::New) {
  if (info.IsConstructCall()) {
    _VkDrawIndirectCommand* self = new _VkDrawIndirectCommand();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("vertexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("instanceCount").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("firstVertex").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("firstInstance").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDrawIndirectCommand constructor cannot be invoked without 'new'");
  }
};

// vertexCount
NAN_GETTER(_VkDrawIndirectCommand::GetvertexCount) {
  _VkDrawIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexCount));
}NAN_SETTER(_VkDrawIndirectCommand::SetvertexCount) {
  _VkDrawIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndirectCommand.vertexCount", "Number");
  
    return;
  }
}// instanceCount
NAN_GETTER(_VkDrawIndirectCommand::GetinstanceCount) {
  _VkDrawIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.instanceCount));
}NAN_SETTER(_VkDrawIndirectCommand::SetinstanceCount) {
  _VkDrawIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.instanceCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndirectCommand.instanceCount", "Number");
  
    return;
  }
}// firstVertex
NAN_GETTER(_VkDrawIndirectCommand::GetfirstVertex) {
  _VkDrawIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.firstVertex));
}NAN_SETTER(_VkDrawIndirectCommand::SetfirstVertex) {
  _VkDrawIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.firstVertex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndirectCommand.firstVertex", "Number");
  
    return;
  }
}// firstInstance
NAN_GETTER(_VkDrawIndirectCommand::GetfirstInstance) {
  _VkDrawIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndirectCommand>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.firstInstance));
}NAN_SETTER(_VkDrawIndirectCommand::SetfirstInstance) {
  _VkDrawIndirectCommand *self = Nan::ObjectWrap::Unwrap<_VkDrawIndirectCommand>(info.This());
  if (value->IsNumber()) {
    self->instance.firstInstance = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDrawIndirectCommand.firstInstance", "Number");
  
    return;
  }
}
/** ## END VkDrawIndirectCommand ## **/

/** ## BEGIN VkFramebufferCreateInfo ## **/

class _VkFramebufferCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> renderPass;
      static NAN_GETTER(GetrenderPass);
    static NAN_SETTER(SetrenderPass);
    
    static NAN_GETTER(GetattachmentCount);
    static NAN_SETTER(SetattachmentCount);
    
    std::vector<VkImageView>* vpAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAttachments;
    static NAN_GETTER(GetpAttachments);
    static NAN_SETTER(SetpAttachments);
    
    static NAN_GETTER(Getwidth);
    static NAN_SETTER(Setwidth);
    
    static NAN_GETTER(Getheight);
    static NAN_SETTER(Setheight);
    
    static NAN_GETTER(Getlayers);
    static NAN_SETTER(Setlayers);
    

    // real instance
    VkFramebufferCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkFramebufferCreateInfo();
    ~_VkFramebufferCreateInfo();

};

/*
#include "index.h"
#include "VkFramebufferCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkFramebufferCreateInfo::constructor;

_VkFramebufferCreateInfo::_VkFramebufferCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
  vpAttachments = new std::vector<VkImageView>;
  
}

_VkFramebufferCreateInfo::~_VkFramebufferCreateInfo() {
  //printf("VkFramebufferCreateInfo deconstructed!!\n");
  
  
  
  
  
  vpAttachments->clear();
  delete vpAttachments;
  
  pAttachments.Reset();
  
  
  
  
}

void _VkFramebufferCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFramebufferCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFramebufferCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("renderPass").ToLocalChecked(), GetrenderPass, SetrenderPass, ctor);
  SetPrototypeAccessor(proto, Nan::New("attachmentCount").ToLocalChecked(), GetattachmentCount, SetattachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAttachments").ToLocalChecked(), GetpAttachments, SetpAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("width").ToLocalChecked(), Getwidth, Setwidth, ctor);
  SetPrototypeAccessor(proto, Nan::New("height").ToLocalChecked(), Getheight, Setheight, ctor);
  SetPrototypeAccessor(proto, Nan::New("layers").ToLocalChecked(), Getlayers, Setlayers, ctor);
  Nan::Set(target, Nan::New("VkFramebufferCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkFramebufferCreateInfo::flush() {
  _VkFramebufferCreateInfo *self = this;
  if (!(self->pAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.attachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'attachmentCount' for 'VkFramebufferCreateInfo.pAttachments'");
      return false;
    }
    std::vector<VkImageView>* data = self->vpAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkImageView::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.pAttachments", "[object VkImageView]");
  
        return false;
      }
      _VkImageView* result = Nan::ObjectWrap::Unwrap<_VkImageView>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pAttachments = data->data();
  }
  return true;
}

NAN_METHOD(_VkFramebufferCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkFramebufferCreateInfo* self = new _VkFramebufferCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("renderPass").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("attachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("width").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("height").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("layers").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkFramebufferCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkFramebufferCreateInfo::GetsType) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkFramebufferCreateInfo::SetsType) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkFramebufferCreateInfo::Getflags) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkFramebufferCreateInfo::Setflags) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkFramebufferCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.flags", "Number");
  
    return;
  }
}// renderPass
NAN_GETTER(_VkFramebufferCreateInfo::GetrenderPass) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  if (self->renderPass.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->renderPass);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkFramebufferCreateInfo::SetrenderPass) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkRenderPass::constructor)->HasInstance(obj)) {
      self->renderPass.Reset<v8::Object>(value.As<v8::Object>());
      _VkRenderPass* inst = Nan::ObjectWrap::Unwrap<_VkRenderPass>(obj);
      ;
      self->instance.renderPass = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.renderPass", "[object VkRenderPass]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->renderPass.Reset();
    self->instance.renderPass = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.renderPass", "[object VkRenderPass]");
  
    return;
  }
}// attachmentCount
NAN_GETTER(_VkFramebufferCreateInfo::GetattachmentCount) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.attachmentCount));
}NAN_SETTER(_VkFramebufferCreateInfo::SetattachmentCount) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.attachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.attachmentCount", "Number");
  
    return;
  }
}// pAttachments
NAN_GETTER(_VkFramebufferCreateInfo::GetpAttachments) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  if (self->pAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkFramebufferCreateInfo::SetpAttachments) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAttachments.Reset();
      self->instance.pAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.pAttachments", "[object VkImageView]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAttachments = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.pAttachments", "[object VkImageView]");
  
    return;
  }
}// width
NAN_GETTER(_VkFramebufferCreateInfo::Getwidth) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.width));
}NAN_SETTER(_VkFramebufferCreateInfo::Setwidth) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.width = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.width", "Number");
  
    return;
  }
}// height
NAN_GETTER(_VkFramebufferCreateInfo::Getheight) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.height));
}NAN_SETTER(_VkFramebufferCreateInfo::Setheight) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.height = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.height", "Number");
  
    return;
  }
}// layers
NAN_GETTER(_VkFramebufferCreateInfo::Getlayers) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.layers));
}NAN_SETTER(_VkFramebufferCreateInfo::Setlayers) {
  _VkFramebufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.layers = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFramebufferCreateInfo.layers", "Number");
  
    return;
  }
}
/** ## END VkFramebufferCreateInfo ## **/

/** ## BEGIN VkQueryPoolCreateInfo ## **/

class _VkQueryPoolCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetqueryType);
    static NAN_SETTER(SetqueryType);
    
    static NAN_GETTER(GetqueryCount);
    static NAN_SETTER(SetqueryCount);
    
    static NAN_GETTER(GetpipelineStatistics);
    static NAN_SETTER(SetpipelineStatistics);
    

    // real instance
    VkQueryPoolCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkQueryPoolCreateInfo();
    ~_VkQueryPoolCreateInfo();

};

/*
#include "index.h"
#include "VkQueryPoolCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkQueryPoolCreateInfo::constructor;

_VkQueryPoolCreateInfo::_VkQueryPoolCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
  
}

_VkQueryPoolCreateInfo::~_VkQueryPoolCreateInfo() {
  //printf("VkQueryPoolCreateInfo deconstructed!!\n");
  
  
  
  
  
  
}

void _VkQueryPoolCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkQueryPoolCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkQueryPoolCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("queryType").ToLocalChecked(), GetqueryType, SetqueryType, ctor);
  SetPrototypeAccessor(proto, Nan::New("queryCount").ToLocalChecked(), GetqueryCount, SetqueryCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineStatistics").ToLocalChecked(), GetpipelineStatistics, SetpipelineStatistics, ctor);
  Nan::Set(target, Nan::New("VkQueryPoolCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkQueryPoolCreateInfo::flush() {
  _VkQueryPoolCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkQueryPoolCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkQueryPoolCreateInfo* self = new _VkQueryPoolCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("queryType").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("queryCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pipelineStatistics").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkQueryPoolCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkQueryPoolCreateInfo::GetsType) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkQueryPoolCreateInfo::SetsType) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkQueryPoolCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkQueryPoolCreateInfo::Getflags) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkQueryPoolCreateInfo::Setflags) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkQueryPoolCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkQueryPoolCreateInfo.flags", "Number");
  
    return;
  }
}// queryType
NAN_GETTER(_VkQueryPoolCreateInfo::GetqueryType) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queryType));
}NAN_SETTER(_VkQueryPoolCreateInfo::SetqueryType) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queryType = static_cast<VkQueryType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkQueryPoolCreateInfo.queryType", "Number");
  
    return;
  }
}// queryCount
NAN_GETTER(_VkQueryPoolCreateInfo::GetqueryCount) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queryCount));
}NAN_SETTER(_VkQueryPoolCreateInfo::SetqueryCount) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queryCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkQueryPoolCreateInfo.queryCount", "Number");
  
    return;
  }
}// pipelineStatistics
NAN_GETTER(_VkQueryPoolCreateInfo::GetpipelineStatistics) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pipelineStatistics));
}NAN_SETTER(_VkQueryPoolCreateInfo::SetpipelineStatistics) {
  _VkQueryPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkQueryPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.pipelineStatistics = static_cast<VkQueryPipelineStatisticFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkQueryPoolCreateInfo.pipelineStatistics", "Number");
  
    return;
  }
}
/** ## END VkQueryPoolCreateInfo ## **/

/** ## BEGIN VkSemaphoreCreateInfo ## **/

class _VkSemaphoreCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkSemaphoreCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSemaphoreCreateInfo();
    ~_VkSemaphoreCreateInfo();

};

/*
#include "index.h"
#include "VkSemaphoreCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSemaphoreCreateInfo::constructor;

_VkSemaphoreCreateInfo::_VkSemaphoreCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
  
}

_VkSemaphoreCreateInfo::~_VkSemaphoreCreateInfo() {
  //printf("VkSemaphoreCreateInfo deconstructed!!\n");
  
  
  
}

void _VkSemaphoreCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSemaphoreCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSemaphoreCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkSemaphoreCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSemaphoreCreateInfo::flush() {
  _VkSemaphoreCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkSemaphoreCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkSemaphoreCreateInfo* self = new _VkSemaphoreCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSemaphoreCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSemaphoreCreateInfo::GetsType) {
  _VkSemaphoreCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSemaphoreCreateInfo::SetsType) {
  _VkSemaphoreCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSemaphoreCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkSemaphoreCreateInfo::Getflags) {
  _VkSemaphoreCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkSemaphoreCreateInfo::Setflags) {
  _VkSemaphoreCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSemaphoreCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSemaphoreCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSemaphoreCreateInfo.flags", "Number");
  
    return;
  }
}
/** ## END VkSemaphoreCreateInfo ## **/

/** ## BEGIN VkFenceCreateInfo ## **/

class _VkFenceCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkFenceCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkFenceCreateInfo();
    ~_VkFenceCreateInfo();

};

/*
#include "index.h"
#include "VkFenceCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkFenceCreateInfo::constructor;

_VkFenceCreateInfo::_VkFenceCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
  
}

_VkFenceCreateInfo::~_VkFenceCreateInfo() {
  //printf("VkFenceCreateInfo deconstructed!!\n");
  
  
  
}

void _VkFenceCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkFenceCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkFenceCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkFenceCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkFenceCreateInfo::flush() {
  _VkFenceCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkFenceCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkFenceCreateInfo* self = new _VkFenceCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkFenceCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkFenceCreateInfo::GetsType) {
  _VkFenceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFenceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkFenceCreateInfo::SetsType) {
  _VkFenceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFenceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFenceCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkFenceCreateInfo::Getflags) {
  _VkFenceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFenceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkFenceCreateInfo::Setflags) {
  _VkFenceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkFenceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkFenceCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkFenceCreateInfo.flags", "Number");
  
    return;
  }
}
/** ## END VkFenceCreateInfo ## **/

/** ## BEGIN VkEventCreateInfo ## **/

class _VkEventCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkEventCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkEventCreateInfo();
    ~_VkEventCreateInfo();

};

/*
#include "index.h"
#include "VkEventCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkEventCreateInfo::constructor;

_VkEventCreateInfo::_VkEventCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
  
}

_VkEventCreateInfo::~_VkEventCreateInfo() {
  //printf("VkEventCreateInfo deconstructed!!\n");
  
  
  
}

void _VkEventCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkEventCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkEventCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkEventCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkEventCreateInfo::flush() {
  _VkEventCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkEventCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkEventCreateInfo* self = new _VkEventCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkEventCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkEventCreateInfo::GetsType) {
  _VkEventCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkEventCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkEventCreateInfo::SetsType) {
  _VkEventCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkEventCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkEventCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkEventCreateInfo::Getflags) {
  _VkEventCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkEventCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkEventCreateInfo::Setflags) {
  _VkEventCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkEventCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkEventCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkEventCreateInfo.flags", "Number");
  
    return;
  }
}
/** ## END VkEventCreateInfo ## **/

/** ## BEGIN VkSubpassDependency ## **/

class _VkSubpassDependency: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsrcSubpass);
    static NAN_SETTER(SetsrcSubpass);
    
    static NAN_GETTER(GetdstSubpass);
    static NAN_SETTER(SetdstSubpass);
    
    static NAN_GETTER(GetsrcStageMask);
    static NAN_SETTER(SetsrcStageMask);
    
    static NAN_GETTER(GetdstStageMask);
    static NAN_SETTER(SetdstStageMask);
    
    static NAN_GETTER(GetsrcAccessMask);
    static NAN_SETTER(SetsrcAccessMask);
    
    static NAN_GETTER(GetdstAccessMask);
    static NAN_SETTER(SetdstAccessMask);
    
    static NAN_GETTER(GetdependencyFlags);
    static NAN_SETTER(SetdependencyFlags);
    

    // real instance
    VkSubpassDependency instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubpassDependency();
    ~_VkSubpassDependency();

};

/*
#include "index.h"
#include "VkSubpassDependency.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubpassDependency::constructor;

_VkSubpassDependency::_VkSubpassDependency() {
  
  
}

_VkSubpassDependency::~_VkSubpassDependency() {
  //printf("VkSubpassDependency deconstructed!!\n");
  
  
  
  
  
  
  
  
}

void _VkSubpassDependency::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubpassDependency::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubpassDependency").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("srcSubpass").ToLocalChecked(), GetsrcSubpass, SetsrcSubpass, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstSubpass").ToLocalChecked(), GetdstSubpass, SetdstSubpass, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcStageMask").ToLocalChecked(), GetsrcStageMask, SetsrcStageMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstStageMask").ToLocalChecked(), GetdstStageMask, SetdstStageMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcAccessMask").ToLocalChecked(), GetsrcAccessMask, SetsrcAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstAccessMask").ToLocalChecked(), GetdstAccessMask, SetdstAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dependencyFlags").ToLocalChecked(), GetdependencyFlags, SetdependencyFlags, ctor);
  Nan::Set(target, Nan::New("VkSubpassDependency").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubpassDependency::flush() {
  _VkSubpassDependency *self = this;
  
  return true;
}

NAN_METHOD(_VkSubpassDependency::New) {
  if (info.IsConstructCall()) {
    _VkSubpassDependency* self = new _VkSubpassDependency();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("srcSubpass").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("dstSubpass").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("srcStageMask").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstStageMask").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("srcAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("dstAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("dependencyFlags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubpassDependency constructor cannot be invoked without 'new'");
  }
};

// srcSubpass
NAN_GETTER(_VkSubpassDependency::GetsrcSubpass) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcSubpass));
}NAN_SETTER(_VkSubpassDependency::SetsrcSubpass) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  if (value->IsNumber()) {
    self->instance.srcSubpass = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency.srcSubpass", "Number");
  
    return;
  }
}// dstSubpass
NAN_GETTER(_VkSubpassDependency::GetdstSubpass) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstSubpass));
}NAN_SETTER(_VkSubpassDependency::SetdstSubpass) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  if (value->IsNumber()) {
    self->instance.dstSubpass = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency.dstSubpass", "Number");
  
    return;
  }
}// srcStageMask
NAN_GETTER(_VkSubpassDependency::GetsrcStageMask) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcStageMask));
}NAN_SETTER(_VkSubpassDependency::SetsrcStageMask) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  if (value->IsNumber()) {
    self->instance.srcStageMask = static_cast<VkPipelineStageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency.srcStageMask", "Number");
  
    return;
  }
}// dstStageMask
NAN_GETTER(_VkSubpassDependency::GetdstStageMask) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstStageMask));
}NAN_SETTER(_VkSubpassDependency::SetdstStageMask) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  if (value->IsNumber()) {
    self->instance.dstStageMask = static_cast<VkPipelineStageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency.dstStageMask", "Number");
  
    return;
  }
}// srcAccessMask
NAN_GETTER(_VkSubpassDependency::GetsrcAccessMask) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcAccessMask));
}NAN_SETTER(_VkSubpassDependency::SetsrcAccessMask) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  if (value->IsNumber()) {
    self->instance.srcAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
NAN_GETTER(_VkSubpassDependency::GetdstAccessMask) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstAccessMask));
}NAN_SETTER(_VkSubpassDependency::SetdstAccessMask) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  if (value->IsNumber()) {
    self->instance.dstAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency.dstAccessMask", "Number");
  
    return;
  }
}// dependencyFlags
NAN_GETTER(_VkSubpassDependency::GetdependencyFlags) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dependencyFlags));
}NAN_SETTER(_VkSubpassDependency::SetdependencyFlags) {
  _VkSubpassDependency *self = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(info.This());
  if (value->IsNumber()) {
    self->instance.dependencyFlags = static_cast<VkDependencyFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDependency.dependencyFlags", "Number");
  
    return;
  }
}
/** ## END VkSubpassDependency ## **/

/** ## BEGIN VkSubpassDescription ## **/

class _VkSubpassDescription: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetpipelineBindPoint);
    static NAN_SETTER(SetpipelineBindPoint);
    
    static NAN_GETTER(GetinputAttachmentCount);
    static NAN_SETTER(SetinputAttachmentCount);
    
    std::vector<VkAttachmentReference>* vpInputAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pInputAttachments;
    static NAN_GETTER(GetpInputAttachments);
    static NAN_SETTER(SetpInputAttachments);
    
    static NAN_GETTER(GetcolorAttachmentCount);
    static NAN_SETTER(SetcolorAttachmentCount);
    
    std::vector<VkAttachmentReference>* vpColorAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pColorAttachments;
    static NAN_GETTER(GetpColorAttachments);
    static NAN_SETTER(SetpColorAttachments);
    
    std::vector<VkAttachmentReference>* vpResolveAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pResolveAttachments;
    static NAN_GETTER(GetpResolveAttachments);
    static NAN_SETTER(SetpResolveAttachments);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pDepthStencilAttachment;
      static NAN_GETTER(GetpDepthStencilAttachment);
    static NAN_SETTER(SetpDepthStencilAttachment);
    
    static NAN_GETTER(GetpreserveAttachmentCount);
    static NAN_SETTER(SetpreserveAttachmentCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pPreserveAttachments;
    static NAN_GETTER(GetpPreserveAttachments);
    static NAN_SETTER(SetpPreserveAttachments);
    

    // real instance
    VkSubpassDescription instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSubpassDescription();
    ~_VkSubpassDescription();

};

/*
#include "index.h"
#include "VkSubpassDescription.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSubpassDescription::constructor;

_VkSubpassDescription::_VkSubpassDescription() {
  
  vpInputAttachments = new std::vector<VkAttachmentReference>;
  vpColorAttachments = new std::vector<VkAttachmentReference>;
  vpResolveAttachments = new std::vector<VkAttachmentReference>;
  
}

_VkSubpassDescription::~_VkSubpassDescription() {
  //printf("VkSubpassDescription deconstructed!!\n");
  
  
  
  
  vpInputAttachments->clear();
  delete vpInputAttachments;
  
  pInputAttachments.Reset();
  
  
  vpColorAttachments->clear();
  delete vpColorAttachments;
  
  pColorAttachments.Reset();
  
  vpResolveAttachments->clear();
  delete vpResolveAttachments;
  
  pResolveAttachments.Reset();
  
  pDepthStencilAttachment.Reset();
  
  
  pPreserveAttachments.Reset();
  
}

void _VkSubpassDescription::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSubpassDescription::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSubpassDescription").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineBindPoint").ToLocalChecked(), GetpipelineBindPoint, SetpipelineBindPoint, ctor);
  SetPrototypeAccessor(proto, Nan::New("inputAttachmentCount").ToLocalChecked(), GetinputAttachmentCount, SetinputAttachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pInputAttachments").ToLocalChecked(), GetpInputAttachments, SetpInputAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("colorAttachmentCount").ToLocalChecked(), GetcolorAttachmentCount, SetcolorAttachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pColorAttachments").ToLocalChecked(), GetpColorAttachments, SetpColorAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("pResolveAttachments").ToLocalChecked(), GetpResolveAttachments, SetpResolveAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDepthStencilAttachment").ToLocalChecked(), GetpDepthStencilAttachment, SetpDepthStencilAttachment, ctor);
  SetPrototypeAccessor(proto, Nan::New("preserveAttachmentCount").ToLocalChecked(), GetpreserveAttachmentCount, SetpreserveAttachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pPreserveAttachments").ToLocalChecked(), GetpPreserveAttachments, SetpPreserveAttachments, ctor);
  Nan::Set(target, Nan::New("VkSubpassDescription").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSubpassDescription::flush() {
  _VkSubpassDescription *self = this;
  if (!(self->pInputAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pInputAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.inputAttachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'inputAttachmentCount' for 'VkSubpassDescription.pInputAttachments'");
      return false;
    }
    std::vector<VkAttachmentReference>* data = self->vpInputAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentReference::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pInputAttachments", "[object VkAttachmentReference]");
  
        return false;
      }
      _VkAttachmentReference* result = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pInputAttachments = data->data();
  }if (!(self->pColorAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pColorAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.colorAttachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'colorAttachmentCount' for 'VkSubpassDescription.pColorAttachments'");
      return false;
    }
    std::vector<VkAttachmentReference>* data = self->vpColorAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentReference::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pColorAttachments", "[object VkAttachmentReference]");
  
        return false;
      }
      _VkAttachmentReference* result = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pColorAttachments = data->data();
  }if (!(self->pResolveAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pResolveAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.colorAttachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'colorAttachmentCount' for 'VkSubpassDescription.pResolveAttachments'");
      return false;
    }
    std::vector<VkAttachmentReference>* data = self->vpResolveAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentReference::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pResolveAttachments", "[object VkAttachmentReference]");
  
        return false;
      }
      _VkAttachmentReference* result = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pResolveAttachments = data->data();
  }
  return true;
}

NAN_METHOD(_VkSubpassDescription::New) {
  if (info.IsConstructCall()) {
    _VkSubpassDescription* self = new _VkSubpassDescription();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("pipelineBindPoint").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("inputAttachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pInputAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("colorAttachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pColorAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pResolveAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pDepthStencilAttachment").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("preserveAttachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("pPreserveAttachments").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSubpassDescription constructor cannot be invoked without 'new'");
  }
};

// flags
NAN_GETTER(_VkSubpassDescription::Getflags) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkSubpassDescription::Setflags) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSubpassDescriptionFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.flags", "Number");
  
    return;
  }
}// pipelineBindPoint
NAN_GETTER(_VkSubpassDescription::GetpipelineBindPoint) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pipelineBindPoint));
}NAN_SETTER(_VkSubpassDescription::SetpipelineBindPoint) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.pipelineBindPoint = static_cast<VkPipelineBindPoint>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pipelineBindPoint", "Number");
  
    return;
  }
}// inputAttachmentCount
NAN_GETTER(_VkSubpassDescription::GetinputAttachmentCount) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.inputAttachmentCount));
}NAN_SETTER(_VkSubpassDescription::SetinputAttachmentCount) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.inputAttachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.inputAttachmentCount", "Number");
  
    return;
  }
}// pInputAttachments
NAN_GETTER(_VkSubpassDescription::GetpInputAttachments) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (self->pInputAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pInputAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription::SetpInputAttachments) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pInputAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pInputAttachments.Reset();
      self->instance.pInputAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pInputAttachments", "[object VkAttachmentReference]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pInputAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pInputAttachments", "[object VkAttachmentReference]");
  
    return;
  }
}// colorAttachmentCount
NAN_GETTER(_VkSubpassDescription::GetcolorAttachmentCount) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.colorAttachmentCount));
}NAN_SETTER(_VkSubpassDescription::SetcolorAttachmentCount) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.colorAttachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.colorAttachmentCount", "Number");
  
    return;
  }
}// pColorAttachments
NAN_GETTER(_VkSubpassDescription::GetpColorAttachments) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (self->pColorAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pColorAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription::SetpColorAttachments) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pColorAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pColorAttachments.Reset();
      self->instance.pColorAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pColorAttachments", "[object VkAttachmentReference]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pColorAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pColorAttachments", "[object VkAttachmentReference]");
  
    return;
  }
}// pResolveAttachments
NAN_GETTER(_VkSubpassDescription::GetpResolveAttachments) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (self->pResolveAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pResolveAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription::SetpResolveAttachments) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pResolveAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pResolveAttachments.Reset();
      self->instance.pResolveAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pResolveAttachments", "[object VkAttachmentReference]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pResolveAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pResolveAttachments", "[object VkAttachmentReference]");
  
    return;
  }
}// pDepthStencilAttachment
NAN_GETTER(_VkSubpassDescription::GetpDepthStencilAttachment) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (self->pDepthStencilAttachment.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDepthStencilAttachment);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription::SetpDepthStencilAttachment) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkAttachmentReference::constructor)->HasInstance(obj)) {
      self->pDepthStencilAttachment.Reset<v8::Object>(value.As<v8::Object>());
      _VkAttachmentReference* inst = Nan::ObjectWrap::Unwrap<_VkAttachmentReference>(obj);
      inst->flush();
      self->instance.pDepthStencilAttachment = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pDepthStencilAttachment", "[object VkAttachmentReference]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pDepthStencilAttachment.Reset();
    self->instance.pDepthStencilAttachment = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pDepthStencilAttachment", "[object VkAttachmentReference]");
  
    return;
  }
}// preserveAttachmentCount
NAN_GETTER(_VkSubpassDescription::GetpreserveAttachmentCount) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.preserveAttachmentCount));
}NAN_SETTER(_VkSubpassDescription::SetpreserveAttachmentCount) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.preserveAttachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.preserveAttachmentCount", "Number");
  
    return;
  }
}// pPreserveAttachments
NAN_GETTER(_VkSubpassDescription::GetpPreserveAttachments) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  if (self->pPreserveAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pPreserveAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSubpassDescription::SetpPreserveAttachments) {
  _VkSubpassDescription *self = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pPreserveAttachments.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pPreserveAttachments", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pPreserveAttachments.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSubpassDescription.pPreserveAttachments", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pPreserveAttachments = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pPreserveAttachments = nullptr;
  }
}
/** ## END VkSubpassDescription ## **/

/** ## BEGIN VkAttachmentDescription ## **/

class _VkAttachmentDescription: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
    static NAN_GETTER(Getsamples);
    static NAN_SETTER(Setsamples);
    
    static NAN_GETTER(GetloadOp);
    static NAN_SETTER(SetloadOp);
    
    static NAN_GETTER(GetstoreOp);
    static NAN_SETTER(SetstoreOp);
    
    static NAN_GETTER(GetstencilLoadOp);
    static NAN_SETTER(SetstencilLoadOp);
    
    static NAN_GETTER(GetstencilStoreOp);
    static NAN_SETTER(SetstencilStoreOp);
    
    static NAN_GETTER(GetinitialLayout);
    static NAN_SETTER(SetinitialLayout);
    
    static NAN_GETTER(GetfinalLayout);
    static NAN_SETTER(SetfinalLayout);
    

    // real instance
    VkAttachmentDescription instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAttachmentDescription();
    ~_VkAttachmentDescription();

};

/*
#include "index.h"
#include "VkAttachmentDescription.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAttachmentDescription::constructor;

_VkAttachmentDescription::_VkAttachmentDescription() {
  
  
}

_VkAttachmentDescription::~_VkAttachmentDescription() {
  //printf("VkAttachmentDescription deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
}

void _VkAttachmentDescription::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAttachmentDescription::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAttachmentDescription").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("samples").ToLocalChecked(), Getsamples, Setsamples, ctor);
  SetPrototypeAccessor(proto, Nan::New("loadOp").ToLocalChecked(), GetloadOp, SetloadOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("storeOp").ToLocalChecked(), GetstoreOp, SetstoreOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("stencilLoadOp").ToLocalChecked(), GetstencilLoadOp, SetstencilLoadOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("stencilStoreOp").ToLocalChecked(), GetstencilStoreOp, SetstencilStoreOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("initialLayout").ToLocalChecked(), GetinitialLayout, SetinitialLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("finalLayout").ToLocalChecked(), GetfinalLayout, SetfinalLayout, ctor);
  Nan::Set(target, Nan::New("VkAttachmentDescription").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAttachmentDescription::flush() {
  _VkAttachmentDescription *self = this;
  
  return true;
}

NAN_METHOD(_VkAttachmentDescription::New) {
  if (info.IsConstructCall()) {
    _VkAttachmentDescription* self = new _VkAttachmentDescription();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("samples").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("loadOp").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("storeOp").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("stencilLoadOp").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("stencilStoreOp").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("initialLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("finalLayout").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAttachmentDescription constructor cannot be invoked without 'new'");
  }
};

// flags
NAN_GETTER(_VkAttachmentDescription::Getflags) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkAttachmentDescription::Setflags) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkAttachmentDescriptionFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.flags", "Number");
  
    return;
  }
}// format
NAN_GETTER(_VkAttachmentDescription::Getformat) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkAttachmentDescription::Setformat) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.format", "Number");
  
    return;
  }
}// samples
NAN_GETTER(_VkAttachmentDescription::Getsamples) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.samples));
}NAN_SETTER(_VkAttachmentDescription::Setsamples) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.samples = static_cast<VkSampleCountFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.samples", "Number");
  
    return;
  }
}// loadOp
NAN_GETTER(_VkAttachmentDescription::GetloadOp) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.loadOp));
}NAN_SETTER(_VkAttachmentDescription::SetloadOp) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.loadOp = static_cast<VkAttachmentLoadOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.loadOp", "Number");
  
    return;
  }
}// storeOp
NAN_GETTER(_VkAttachmentDescription::GetstoreOp) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.storeOp));
}NAN_SETTER(_VkAttachmentDescription::SetstoreOp) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.storeOp = static_cast<VkAttachmentStoreOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.storeOp", "Number");
  
    return;
  }
}// stencilLoadOp
NAN_GETTER(_VkAttachmentDescription::GetstencilLoadOp) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stencilLoadOp));
}NAN_SETTER(_VkAttachmentDescription::SetstencilLoadOp) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.stencilLoadOp = static_cast<VkAttachmentLoadOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.stencilLoadOp", "Number");
  
    return;
  }
}// stencilStoreOp
NAN_GETTER(_VkAttachmentDescription::GetstencilStoreOp) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stencilStoreOp));
}NAN_SETTER(_VkAttachmentDescription::SetstencilStoreOp) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.stencilStoreOp = static_cast<VkAttachmentStoreOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.stencilStoreOp", "Number");
  
    return;
  }
}// initialLayout
NAN_GETTER(_VkAttachmentDescription::GetinitialLayout) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.initialLayout));
}NAN_SETTER(_VkAttachmentDescription::SetinitialLayout) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.initialLayout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.initialLayout", "Number");
  
    return;
  }
}// finalLayout
NAN_GETTER(_VkAttachmentDescription::GetfinalLayout) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.finalLayout));
}NAN_SETTER(_VkAttachmentDescription::SetfinalLayout) {
  _VkAttachmentDescription *self = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.finalLayout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkAttachmentDescription.finalLayout", "Number");
  
    return;
  }
}
/** ## END VkAttachmentDescription ## **/

/** ## BEGIN VkRenderPassCreateInfo ## **/

class _VkRenderPassCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetattachmentCount);
    static NAN_SETTER(SetattachmentCount);
    
    std::vector<VkAttachmentDescription>* vpAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAttachments;
    static NAN_GETTER(GetpAttachments);
    static NAN_SETTER(SetpAttachments);
    
    static NAN_GETTER(GetsubpassCount);
    static NAN_SETTER(SetsubpassCount);
    
    std::vector<VkSubpassDescription>* vpSubpasses;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSubpasses;
    static NAN_GETTER(GetpSubpasses);
    static NAN_SETTER(SetpSubpasses);
    
    static NAN_GETTER(GetdependencyCount);
    static NAN_SETTER(SetdependencyCount);
    
    std::vector<VkSubpassDependency>* vpDependencies;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDependencies;
    static NAN_GETTER(GetpDependencies);
    static NAN_SETTER(SetpDependencies);
    

    // real instance
    VkRenderPassCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassCreateInfo();
    ~_VkRenderPassCreateInfo();

};

/*
#include "index.h"
#include "VkRenderPassCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassCreateInfo::constructor;

_VkRenderPassCreateInfo::_VkRenderPassCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
  vpAttachments = new std::vector<VkAttachmentDescription>;
  vpSubpasses = new std::vector<VkSubpassDescription>;
  vpDependencies = new std::vector<VkSubpassDependency>;
  
}

_VkRenderPassCreateInfo::~_VkRenderPassCreateInfo() {
  //printf("VkRenderPassCreateInfo deconstructed!!\n");
  
  
  
  
  vpAttachments->clear();
  delete vpAttachments;
  
  pAttachments.Reset();
  
  
  vpSubpasses->clear();
  delete vpSubpasses;
  
  pSubpasses.Reset();
  
  
  vpDependencies->clear();
  delete vpDependencies;
  
  pDependencies.Reset();
  
}

void _VkRenderPassCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("attachmentCount").ToLocalChecked(), GetattachmentCount, SetattachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAttachments").ToLocalChecked(), GetpAttachments, SetpAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("subpassCount").ToLocalChecked(), GetsubpassCount, SetsubpassCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSubpasses").ToLocalChecked(), GetpSubpasses, SetpSubpasses, ctor);
  SetPrototypeAccessor(proto, Nan::New("dependencyCount").ToLocalChecked(), GetdependencyCount, SetdependencyCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDependencies").ToLocalChecked(), GetpDependencies, SetpDependencies, ctor);
  Nan::Set(target, Nan::New("VkRenderPassCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassCreateInfo::flush() {
  _VkRenderPassCreateInfo *self = this;
  if (!(self->pAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.attachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'attachmentCount' for 'VkRenderPassCreateInfo.pAttachments'");
      return false;
    }
    std::vector<VkAttachmentDescription>* data = self->vpAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkAttachmentDescription::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pAttachments", "[object VkAttachmentDescription]");
  
        return false;
      }
      _VkAttachmentDescription* result = Nan::ObjectWrap::Unwrap<_VkAttachmentDescription>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAttachments = data->data();
  }if (!(self->pSubpasses.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSubpasses);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.subpassCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'subpassCount' for 'VkRenderPassCreateInfo.pSubpasses'");
      return false;
    }
    std::vector<VkSubpassDescription>* data = self->vpSubpasses;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSubpassDescription::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pSubpasses", "[object VkSubpassDescription]");
  
        return false;
      }
      _VkSubpassDescription* result = Nan::ObjectWrap::Unwrap<_VkSubpassDescription>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pSubpasses = data->data();
  }if (!(self->pDependencies.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pDependencies);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.dependencyCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'dependencyCount' for 'VkRenderPassCreateInfo.pDependencies'");
      return false;
    }
    std::vector<VkSubpassDependency>* data = self->vpDependencies;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSubpassDependency::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pDependencies", "[object VkSubpassDependency]");
  
        return false;
      }
      _VkSubpassDependency* result = Nan::ObjectWrap::Unwrap<_VkSubpassDependency>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pDependencies = data->data();
  }
  return true;
}

NAN_METHOD(_VkRenderPassCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassCreateInfo* self = new _VkRenderPassCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("attachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("subpassCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pSubpasses").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("dependencyCount").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pDependencies").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRenderPassCreateInfo::GetsType) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRenderPassCreateInfo::SetsType) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkRenderPassCreateInfo::Getflags) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkRenderPassCreateInfo::Setflags) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkRenderPassCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.flags", "Number");
  
    return;
  }
}// attachmentCount
NAN_GETTER(_VkRenderPassCreateInfo::GetattachmentCount) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.attachmentCount));
}NAN_SETTER(_VkRenderPassCreateInfo::SetattachmentCount) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.attachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.attachmentCount", "Number");
  
    return;
  }
}// pAttachments
NAN_GETTER(_VkRenderPassCreateInfo::GetpAttachments) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  if (self->pAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassCreateInfo::SetpAttachments) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAttachments.Reset();
      self->instance.pAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pAttachments", "[object VkAttachmentDescription]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pAttachments", "[object VkAttachmentDescription]");
  
    return;
  }
}// subpassCount
NAN_GETTER(_VkRenderPassCreateInfo::GetsubpassCount) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subpassCount));
}NAN_SETTER(_VkRenderPassCreateInfo::SetsubpassCount) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.subpassCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.subpassCount", "Number");
  
    return;
  }
}// pSubpasses
NAN_GETTER(_VkRenderPassCreateInfo::GetpSubpasses) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  if (self->pSubpasses.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSubpasses);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassCreateInfo::SetpSubpasses) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSubpasses.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSubpasses.Reset();
      self->instance.pSubpasses = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pSubpasses", "[object VkSubpassDescription]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSubpasses = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pSubpasses", "[object VkSubpassDescription]");
  
    return;
  }
}// dependencyCount
NAN_GETTER(_VkRenderPassCreateInfo::GetdependencyCount) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dependencyCount));
}NAN_SETTER(_VkRenderPassCreateInfo::SetdependencyCount) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.dependencyCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.dependencyCount", "Number");
  
    return;
  }
}// pDependencies
NAN_GETTER(_VkRenderPassCreateInfo::GetpDependencies) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  if (self->pDependencies.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDependencies);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassCreateInfo::SetpDependencies) {
  _VkRenderPassCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pDependencies.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pDependencies.Reset();
      self->instance.pDependencies = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pDependencies", "[object VkSubpassDependency]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pDependencies = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassCreateInfo.pDependencies", "[object VkSubpassDependency]");
  
    return;
  }
}
/** ## END VkRenderPassCreateInfo ## **/

/** ## BEGIN VkClearDepthStencilValue ## **/

class _VkClearDepthStencilValue: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getdepth);
    static NAN_SETTER(Setdepth);
    
    static NAN_GETTER(Getstencil);
    static NAN_SETTER(Setstencil);
    

    // real instance
    VkClearDepthStencilValue instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkClearDepthStencilValue();
    ~_VkClearDepthStencilValue();

};

/*
#include "index.h"
#include "VkClearDepthStencilValue.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkClearDepthStencilValue::constructor;

_VkClearDepthStencilValue::_VkClearDepthStencilValue() {
  
  
}

_VkClearDepthStencilValue::~_VkClearDepthStencilValue() {
  //printf("VkClearDepthStencilValue deconstructed!!\n");
  
  
  
}

void _VkClearDepthStencilValue::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkClearDepthStencilValue::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkClearDepthStencilValue").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("depth").ToLocalChecked(), Getdepth, Setdepth, ctor);
  SetPrototypeAccessor(proto, Nan::New("stencil").ToLocalChecked(), Getstencil, Setstencil, ctor);
  Nan::Set(target, Nan::New("VkClearDepthStencilValue").ToLocalChecked(), ctor->GetFunction());
}

bool _VkClearDepthStencilValue::flush() {
  _VkClearDepthStencilValue *self = this;
  
  return true;
}

NAN_METHOD(_VkClearDepthStencilValue::New) {
  if (info.IsConstructCall()) {
    _VkClearDepthStencilValue* self = new _VkClearDepthStencilValue();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("depth").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("stencil").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkClearDepthStencilValue constructor cannot be invoked without 'new'");
  }
};

// depth
NAN_GETTER(_VkClearDepthStencilValue::Getdepth) {
  _VkClearDepthStencilValue *self = Nan::ObjectWrap::Unwrap<_VkClearDepthStencilValue>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depth));
}NAN_SETTER(_VkClearDepthStencilValue::Setdepth) {
  _VkClearDepthStencilValue *self = Nan::ObjectWrap::Unwrap<_VkClearDepthStencilValue>(info.This());
  if (value->IsNumber()) {
    self->instance.depth = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearDepthStencilValue.depth", "Number");
  
    return;
  }
}// stencil
NAN_GETTER(_VkClearDepthStencilValue::Getstencil) {
  _VkClearDepthStencilValue *self = Nan::ObjectWrap::Unwrap<_VkClearDepthStencilValue>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stencil));
}NAN_SETTER(_VkClearDepthStencilValue::Setstencil) {
  _VkClearDepthStencilValue *self = Nan::ObjectWrap::Unwrap<_VkClearDepthStencilValue>(info.This());
  if (value->IsNumber()) {
    self->instance.stencil = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearDepthStencilValue.stencil", "Number");
  
    return;
  }
}
/** ## END VkClearDepthStencilValue ## **/

/** ## BEGIN VkClearValue ## **/

class _VkClearValue: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> color;
      static NAN_GETTER(Getcolor);
    static NAN_SETTER(Setcolor);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> depthStencil;
      static NAN_GETTER(GetdepthStencil);
    static NAN_SETTER(SetdepthStencil);
    

    // real instance
    VkClearValue instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkClearValue();
    ~_VkClearValue();

};

/*
#include "index.h"
#include "VkClearValue.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkClearValue::constructor;

_VkClearValue::_VkClearValue() {
  
  
}

_VkClearValue::~_VkClearValue() {
  //printf("VkClearValue deconstructed!!\n");
  
  
  
}

void _VkClearValue::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkClearValue::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkClearValue").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("color").ToLocalChecked(), Getcolor, Setcolor, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthStencil").ToLocalChecked(), GetdepthStencil, SetdepthStencil, ctor);
  Nan::Set(target, Nan::New("VkClearValue").ToLocalChecked(), ctor->GetFunction());
}

bool _VkClearValue::flush() {
  _VkClearValue *self = this;
  if (!(self->color.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->color);
    
    _VkClearColorValue* result = Nan::ObjectWrap::Unwrap<_VkClearColorValue>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.color = result->instance;
  }if (!(self->depthStencil.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->depthStencil);
    
    _VkClearDepthStencilValue* result = Nan::ObjectWrap::Unwrap<_VkClearDepthStencilValue>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.depthStencil = result->instance;
  }
  return true;
}

NAN_METHOD(_VkClearValue::New) {
  if (info.IsConstructCall()) {
    _VkClearValue* self = new _VkClearValue();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("color").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("depthStencil").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkClearValue constructor cannot be invoked without 'new'");
  }
};

// color
NAN_GETTER(_VkClearValue::Getcolor) {
  _VkClearValue *self = Nan::ObjectWrap::Unwrap<_VkClearValue>(info.This());
  if (self->color.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->color);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkClearValue::Setcolor) {
  _VkClearValue *self = Nan::ObjectWrap::Unwrap<_VkClearValue>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkClearColorValue::constructor)->HasInstance(obj)) {
      self->color.Reset<v8::Object>(value.As<v8::Object>());
      _VkClearColorValue* inst = Nan::ObjectWrap::Unwrap<_VkClearColorValue>(obj);
      inst->flush();
      self->instance.color = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkClearValue.color", "[object VkClearColorValue]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->color.Reset();
    memset(&self->instance.color, 0, sizeof(VkClearColorValue));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearValue.color", "[object VkClearColorValue]");
  
    return;
  }
}// depthStencil
NAN_GETTER(_VkClearValue::GetdepthStencil) {
  _VkClearValue *self = Nan::ObjectWrap::Unwrap<_VkClearValue>(info.This());
  if (self->depthStencil.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->depthStencil);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkClearValue::SetdepthStencil) {
  _VkClearValue *self = Nan::ObjectWrap::Unwrap<_VkClearValue>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkClearDepthStencilValue::constructor)->HasInstance(obj)) {
      self->depthStencil.Reset<v8::Object>(value.As<v8::Object>());
      _VkClearDepthStencilValue* inst = Nan::ObjectWrap::Unwrap<_VkClearDepthStencilValue>(obj);
      inst->flush();
      self->instance.depthStencil = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkClearValue.depthStencil", "[object VkClearDepthStencilValue]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->depthStencil.Reset();
    memset(&self->instance.depthStencil, 0, sizeof(VkClearDepthStencilValue));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearValue.depthStencil", "[object VkClearDepthStencilValue]");
  
    return;
  }
}
/** ## END VkClearValue ## **/

/** ## BEGIN VkClearAttachment ## **/

class _VkClearAttachment: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetaspectMask);
    static NAN_SETTER(SetaspectMask);
    
    static NAN_GETTER(GetcolorAttachment);
    static NAN_SETTER(SetcolorAttachment);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> clearValue;
      static NAN_GETTER(GetclearValue);
    static NAN_SETTER(SetclearValue);
    

    // real instance
    VkClearAttachment instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkClearAttachment();
    ~_VkClearAttachment();

};

/*
#include "index.h"
#include "VkClearAttachment.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkClearAttachment::constructor;

_VkClearAttachment::_VkClearAttachment() {
  
  
}

_VkClearAttachment::~_VkClearAttachment() {
  //printf("VkClearAttachment deconstructed!!\n");
  
  
  
  
}

void _VkClearAttachment::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkClearAttachment::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkClearAttachment").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("aspectMask").ToLocalChecked(), GetaspectMask, SetaspectMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("colorAttachment").ToLocalChecked(), GetcolorAttachment, SetcolorAttachment, ctor);
  SetPrototypeAccessor(proto, Nan::New("clearValue").ToLocalChecked(), GetclearValue, SetclearValue, ctor);
  Nan::Set(target, Nan::New("VkClearAttachment").ToLocalChecked(), ctor->GetFunction());
}

bool _VkClearAttachment::flush() {
  _VkClearAttachment *self = this;
  if (!(self->clearValue.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->clearValue);
    
    _VkClearValue* result = Nan::ObjectWrap::Unwrap<_VkClearValue>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.clearValue = result->instance;
  }
  return true;
}

NAN_METHOD(_VkClearAttachment::New) {
  if (info.IsConstructCall()) {
    _VkClearAttachment* self = new _VkClearAttachment();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("aspectMask").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("colorAttachment").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("clearValue").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkClearAttachment constructor cannot be invoked without 'new'");
  }
};

// aspectMask
NAN_GETTER(_VkClearAttachment::GetaspectMask) {
  _VkClearAttachment *self = Nan::ObjectWrap::Unwrap<_VkClearAttachment>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.aspectMask));
}NAN_SETTER(_VkClearAttachment::SetaspectMask) {
  _VkClearAttachment *self = Nan::ObjectWrap::Unwrap<_VkClearAttachment>(info.This());
  if (value->IsNumber()) {
    self->instance.aspectMask = static_cast<VkImageAspectFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearAttachment.aspectMask", "Number");
  
    return;
  }
}// colorAttachment
NAN_GETTER(_VkClearAttachment::GetcolorAttachment) {
  _VkClearAttachment *self = Nan::ObjectWrap::Unwrap<_VkClearAttachment>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.colorAttachment));
}NAN_SETTER(_VkClearAttachment::SetcolorAttachment) {
  _VkClearAttachment *self = Nan::ObjectWrap::Unwrap<_VkClearAttachment>(info.This());
  if (value->IsNumber()) {
    self->instance.colorAttachment = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearAttachment.colorAttachment", "Number");
  
    return;
  }
}// clearValue
NAN_GETTER(_VkClearAttachment::GetclearValue) {
  _VkClearAttachment *self = Nan::ObjectWrap::Unwrap<_VkClearAttachment>(info.This());
  if (self->clearValue.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->clearValue);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkClearAttachment::SetclearValue) {
  _VkClearAttachment *self = Nan::ObjectWrap::Unwrap<_VkClearAttachment>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkClearValue::constructor)->HasInstance(obj)) {
      self->clearValue.Reset<v8::Object>(value.As<v8::Object>());
      _VkClearValue* inst = Nan::ObjectWrap::Unwrap<_VkClearValue>(obj);
      inst->flush();
      self->instance.clearValue = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkClearAttachment.clearValue", "[object VkClearValue]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->clearValue.Reset();
    memset(&self->instance.clearValue, 0, sizeof(VkClearValue));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearAttachment.clearValue", "[object VkClearValue]");
  
    return;
  }
}
/** ## END VkClearAttachment ## **/

/** ## BEGIN VkRenderPassBeginInfo ## **/

class _VkRenderPassBeginInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> renderPass;
      static NAN_GETTER(GetrenderPass);
    static NAN_SETTER(SetrenderPass);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> framebuffer;
      static NAN_GETTER(Getframebuffer);
    static NAN_SETTER(Setframebuffer);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> renderArea;
      static NAN_GETTER(GetrenderArea);
    static NAN_SETTER(SetrenderArea);
    
    static NAN_GETTER(GetclearValueCount);
    static NAN_SETTER(SetclearValueCount);
    
    std::vector<VkClearValue>* vpClearValues;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pClearValues;
    static NAN_GETTER(GetpClearValues);
    static NAN_SETTER(SetpClearValues);
    

    // real instance
    VkRenderPassBeginInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkRenderPassBeginInfo();
    ~_VkRenderPassBeginInfo();

};

/*
#include "index.h"
#include "VkRenderPassBeginInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkRenderPassBeginInfo::constructor;

_VkRenderPassBeginInfo::_VkRenderPassBeginInfo() {
  instance.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
  vpClearValues = new std::vector<VkClearValue>;
  
}

_VkRenderPassBeginInfo::~_VkRenderPassBeginInfo() {
  //printf("VkRenderPassBeginInfo deconstructed!!\n");
  
  
  
  
  
  
  vpClearValues->clear();
  delete vpClearValues;
  
  pClearValues.Reset();
  
}

void _VkRenderPassBeginInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkRenderPassBeginInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkRenderPassBeginInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("renderPass").ToLocalChecked(), GetrenderPass, SetrenderPass, ctor);
  SetPrototypeAccessor(proto, Nan::New("framebuffer").ToLocalChecked(), Getframebuffer, Setframebuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("renderArea").ToLocalChecked(), GetrenderArea, SetrenderArea, ctor);
  SetPrototypeAccessor(proto, Nan::New("clearValueCount").ToLocalChecked(), GetclearValueCount, SetclearValueCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pClearValues").ToLocalChecked(), GetpClearValues, SetpClearValues, ctor);
  Nan::Set(target, Nan::New("VkRenderPassBeginInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkRenderPassBeginInfo::flush() {
  _VkRenderPassBeginInfo *self = this;
  if (!(self->renderArea.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->renderArea);
    
    _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.renderArea = result->instance;
  }if (!(self->pClearValues.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pClearValues);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.clearValueCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'clearValueCount' for 'VkRenderPassBeginInfo.pClearValues'");
      return false;
    }
    std::vector<VkClearValue>* data = self->vpClearValues;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkClearValue::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.pClearValues", "[object VkClearValue]");
  
        return false;
      }
      _VkClearValue* result = Nan::ObjectWrap::Unwrap<_VkClearValue>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pClearValues = data->data();
  }
  return true;
}

NAN_METHOD(_VkRenderPassBeginInfo::New) {
  if (info.IsConstructCall()) {
    _VkRenderPassBeginInfo* self = new _VkRenderPassBeginInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("renderPass").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("framebuffer").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("renderArea").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("clearValueCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pClearValues").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkRenderPassBeginInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkRenderPassBeginInfo::GetsType) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkRenderPassBeginInfo::SetsType) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.sType", "Number");
  
    return;
  }
}// renderPass
NAN_GETTER(_VkRenderPassBeginInfo::GetrenderPass) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  if (self->renderPass.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->renderPass);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassBeginInfo::SetrenderPass) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkRenderPass::constructor)->HasInstance(obj)) {
      self->renderPass.Reset<v8::Object>(value.As<v8::Object>());
      _VkRenderPass* inst = Nan::ObjectWrap::Unwrap<_VkRenderPass>(obj);
      ;
      self->instance.renderPass = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.renderPass", "[object VkRenderPass]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->renderPass.Reset();
    self->instance.renderPass = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.renderPass", "[object VkRenderPass]");
  
    return;
  }
}// framebuffer
NAN_GETTER(_VkRenderPassBeginInfo::Getframebuffer) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  if (self->framebuffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->framebuffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassBeginInfo::Setframebuffer) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkFramebuffer::constructor)->HasInstance(obj)) {
      self->framebuffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkFramebuffer* inst = Nan::ObjectWrap::Unwrap<_VkFramebuffer>(obj);
      ;
      self->instance.framebuffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.framebuffer", "[object VkFramebuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->framebuffer.Reset();
    self->instance.framebuffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.framebuffer", "[object VkFramebuffer]");
  
    return;
  }
}// renderArea
NAN_GETTER(_VkRenderPassBeginInfo::GetrenderArea) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  if (self->renderArea.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->renderArea);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassBeginInfo::SetrenderArea) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkRect2D::constructor)->HasInstance(obj)) {
      self->renderArea.Reset<v8::Object>(value.As<v8::Object>());
      _VkRect2D* inst = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      inst->flush();
      self->instance.renderArea = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.renderArea", "[object VkRect2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->renderArea.Reset();
    memset(&self->instance.renderArea, 0, sizeof(VkRect2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.renderArea", "[object VkRect2D]");
  
    return;
  }
}// clearValueCount
NAN_GETTER(_VkRenderPassBeginInfo::GetclearValueCount) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.clearValueCount));
}NAN_SETTER(_VkRenderPassBeginInfo::SetclearValueCount) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.clearValueCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.clearValueCount", "Number");
  
    return;
  }
}// pClearValues
NAN_GETTER(_VkRenderPassBeginInfo::GetpClearValues) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  if (self->pClearValues.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pClearValues);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkRenderPassBeginInfo::SetpClearValues) {
  _VkRenderPassBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pClearValues.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pClearValues.Reset();
      self->instance.pClearValues = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.pClearValues", "[object VkClearValue]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pClearValues = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkRenderPassBeginInfo.pClearValues", "[object VkClearValue]");
  
    return;
  }
}
/** ## END VkRenderPassBeginInfo ## **/

/** ## BEGIN VkCommandBufferInheritanceInfo ## **/

class _VkCommandBufferInheritanceInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> renderPass;
      static NAN_GETTER(GetrenderPass);
    static NAN_SETTER(SetrenderPass);
    
    static NAN_GETTER(Getsubpass);
    static NAN_SETTER(Setsubpass);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> framebuffer;
      static NAN_GETTER(Getframebuffer);
    static NAN_SETTER(Setframebuffer);
    
    static NAN_GETTER(GetocclusionQueryEnable);
    static NAN_SETTER(SetocclusionQueryEnable);
    
    static NAN_GETTER(GetqueryFlags);
    static NAN_SETTER(SetqueryFlags);
    
    static NAN_GETTER(GetpipelineStatistics);
    static NAN_SETTER(SetpipelineStatistics);
    

    // real instance
    VkCommandBufferInheritanceInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCommandBufferInheritanceInfo();
    ~_VkCommandBufferInheritanceInfo();

};

/*
#include "index.h"
#include "VkCommandBufferInheritanceInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCommandBufferInheritanceInfo::constructor;

_VkCommandBufferInheritanceInfo::_VkCommandBufferInheritanceInfo() {
  instance.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
  
}

_VkCommandBufferInheritanceInfo::~_VkCommandBufferInheritanceInfo() {
  //printf("VkCommandBufferInheritanceInfo deconstructed!!\n");
  
  
  
  
  
  
  
  
}

void _VkCommandBufferInheritanceInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCommandBufferInheritanceInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCommandBufferInheritanceInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("renderPass").ToLocalChecked(), GetrenderPass, SetrenderPass, ctor);
  SetPrototypeAccessor(proto, Nan::New("subpass").ToLocalChecked(), Getsubpass, Setsubpass, ctor);
  SetPrototypeAccessor(proto, Nan::New("framebuffer").ToLocalChecked(), Getframebuffer, Setframebuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("occlusionQueryEnable").ToLocalChecked(), GetocclusionQueryEnable, SetocclusionQueryEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("queryFlags").ToLocalChecked(), GetqueryFlags, SetqueryFlags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pipelineStatistics").ToLocalChecked(), GetpipelineStatistics, SetpipelineStatistics, ctor);
  Nan::Set(target, Nan::New("VkCommandBufferInheritanceInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCommandBufferInheritanceInfo::flush() {
  _VkCommandBufferInheritanceInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkCommandBufferInheritanceInfo::New) {
  if (info.IsConstructCall()) {
    _VkCommandBufferInheritanceInfo* self = new _VkCommandBufferInheritanceInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("renderPass").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("subpass").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("framebuffer").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("occlusionQueryEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("queryFlags").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pipelineStatistics").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCommandBufferInheritanceInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCommandBufferInheritanceInfo::GetsType) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCommandBufferInheritanceInfo::SetsType) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.sType", "Number");
  
    return;
  }
}// renderPass
NAN_GETTER(_VkCommandBufferInheritanceInfo::GetrenderPass) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  if (self->renderPass.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->renderPass);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCommandBufferInheritanceInfo::SetrenderPass) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkRenderPass::constructor)->HasInstance(obj)) {
      self->renderPass.Reset<v8::Object>(value.As<v8::Object>());
      _VkRenderPass* inst = Nan::ObjectWrap::Unwrap<_VkRenderPass>(obj);
      ;
      self->instance.renderPass = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.renderPass", "[object VkRenderPass]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->renderPass.Reset();
    self->instance.renderPass = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.renderPass", "[object VkRenderPass]");
  
    return;
  }
}// subpass
NAN_GETTER(_VkCommandBufferInheritanceInfo::Getsubpass) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subpass));
}NAN_SETTER(_VkCommandBufferInheritanceInfo::Setsubpass) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.subpass = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.subpass", "Number");
  
    return;
  }
}// framebuffer
NAN_GETTER(_VkCommandBufferInheritanceInfo::Getframebuffer) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  if (self->framebuffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->framebuffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCommandBufferInheritanceInfo::Setframebuffer) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkFramebuffer::constructor)->HasInstance(obj)) {
      self->framebuffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkFramebuffer* inst = Nan::ObjectWrap::Unwrap<_VkFramebuffer>(obj);
      ;
      self->instance.framebuffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.framebuffer", "[object VkFramebuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->framebuffer.Reset();
    self->instance.framebuffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.framebuffer", "[object VkFramebuffer]");
  
    return;
  }
}// occlusionQueryEnable
NAN_GETTER(_VkCommandBufferInheritanceInfo::GetocclusionQueryEnable) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.occlusionQueryEnable));
}NAN_SETTER(_VkCommandBufferInheritanceInfo::SetocclusionQueryEnable) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.occlusionQueryEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.occlusionQueryEnable", "Number");
  
    return;
  }
}// queryFlags
NAN_GETTER(_VkCommandBufferInheritanceInfo::GetqueryFlags) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queryFlags));
}NAN_SETTER(_VkCommandBufferInheritanceInfo::SetqueryFlags) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queryFlags = static_cast<VkQueryControlFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.queryFlags", "Number");
  
    return;
  }
}// pipelineStatistics
NAN_GETTER(_VkCommandBufferInheritanceInfo::GetpipelineStatistics) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pipelineStatistics));
}NAN_SETTER(_VkCommandBufferInheritanceInfo::SetpipelineStatistics) {
  _VkCommandBufferInheritanceInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.pipelineStatistics = static_cast<VkQueryPipelineStatisticFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferInheritanceInfo.pipelineStatistics", "Number");
  
    return;
  }
}
/** ## END VkCommandBufferInheritanceInfo ## **/

/** ## BEGIN VkCommandBufferBeginInfo ## **/

class _VkCommandBufferBeginInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pInheritanceInfo;
      static NAN_GETTER(GetpInheritanceInfo);
    static NAN_SETTER(SetpInheritanceInfo);
    

    // real instance
    VkCommandBufferBeginInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCommandBufferBeginInfo();
    ~_VkCommandBufferBeginInfo();

};

/*
#include "index.h"
#include "VkCommandBufferBeginInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCommandBufferBeginInfo::constructor;

_VkCommandBufferBeginInfo::_VkCommandBufferBeginInfo() {
  instance.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
  
}

_VkCommandBufferBeginInfo::~_VkCommandBufferBeginInfo() {
  //printf("VkCommandBufferBeginInfo deconstructed!!\n");
  
  
  
  pInheritanceInfo.Reset();
  
}

void _VkCommandBufferBeginInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCommandBufferBeginInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCommandBufferBeginInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pInheritanceInfo").ToLocalChecked(), GetpInheritanceInfo, SetpInheritanceInfo, ctor);
  Nan::Set(target, Nan::New("VkCommandBufferBeginInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCommandBufferBeginInfo::flush() {
  _VkCommandBufferBeginInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkCommandBufferBeginInfo::New) {
  if (info.IsConstructCall()) {
    _VkCommandBufferBeginInfo* self = new _VkCommandBufferBeginInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pInheritanceInfo").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCommandBufferBeginInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCommandBufferBeginInfo::GetsType) {
  _VkCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCommandBufferBeginInfo::SetsType) {
  _VkCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferBeginInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkCommandBufferBeginInfo::Getflags) {
  _VkCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkCommandBufferBeginInfo::Setflags) {
  _VkCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkCommandBufferUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferBeginInfo.flags", "Number");
  
    return;
  }
}// pInheritanceInfo
NAN_GETTER(_VkCommandBufferBeginInfo::GetpInheritanceInfo) {
  _VkCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(info.This());
  if (self->pInheritanceInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pInheritanceInfo);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCommandBufferBeginInfo::SetpInheritanceInfo) {
  _VkCommandBufferBeginInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkCommandBufferInheritanceInfo::constructor)->HasInstance(obj)) {
      self->pInheritanceInfo.Reset<v8::Object>(value.As<v8::Object>());
      _VkCommandBufferInheritanceInfo* inst = Nan::ObjectWrap::Unwrap<_VkCommandBufferInheritanceInfo>(obj);
      inst->flush();
      self->instance.pInheritanceInfo = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCommandBufferBeginInfo.pInheritanceInfo", "[object VkCommandBufferInheritanceInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pInheritanceInfo.Reset();
    self->instance.pInheritanceInfo = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferBeginInfo.pInheritanceInfo", "[object VkCommandBufferInheritanceInfo]");
  
    return;
  }
}
/** ## END VkCommandBufferBeginInfo ## **/

/** ## BEGIN VkCommandBufferAllocateInfo ## **/

class _VkCommandBufferAllocateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> commandPool;
      static NAN_GETTER(GetcommandPool);
    static NAN_SETTER(SetcommandPool);
    
    static NAN_GETTER(Getlevel);
    static NAN_SETTER(Setlevel);
    
    static NAN_GETTER(GetcommandBufferCount);
    static NAN_SETTER(SetcommandBufferCount);
    

    // real instance
    VkCommandBufferAllocateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCommandBufferAllocateInfo();
    ~_VkCommandBufferAllocateInfo();

};

/*
#include "index.h"
#include "VkCommandBufferAllocateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCommandBufferAllocateInfo::constructor;

_VkCommandBufferAllocateInfo::_VkCommandBufferAllocateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
  
}

_VkCommandBufferAllocateInfo::~_VkCommandBufferAllocateInfo() {
  //printf("VkCommandBufferAllocateInfo deconstructed!!\n");
  
  
  
  
  
}

void _VkCommandBufferAllocateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCommandBufferAllocateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCommandBufferAllocateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("commandPool").ToLocalChecked(), GetcommandPool, SetcommandPool, ctor);
  SetPrototypeAccessor(proto, Nan::New("level").ToLocalChecked(), Getlevel, Setlevel, ctor);
  SetPrototypeAccessor(proto, Nan::New("commandBufferCount").ToLocalChecked(), GetcommandBufferCount, SetcommandBufferCount, ctor);
  Nan::Set(target, Nan::New("VkCommandBufferAllocateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCommandBufferAllocateInfo::flush() {
  _VkCommandBufferAllocateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkCommandBufferAllocateInfo::New) {
  if (info.IsConstructCall()) {
    _VkCommandBufferAllocateInfo* self = new _VkCommandBufferAllocateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("commandPool").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("level").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("commandBufferCount").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCommandBufferAllocateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCommandBufferAllocateInfo::GetsType) {
  _VkCommandBufferAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCommandBufferAllocateInfo::SetsType) {
  _VkCommandBufferAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferAllocateInfo.sType", "Number");
  
    return;
  }
}// commandPool
NAN_GETTER(_VkCommandBufferAllocateInfo::GetcommandPool) {
  _VkCommandBufferAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info.This());
  if (self->commandPool.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->commandPool);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCommandBufferAllocateInfo::SetcommandPool) {
  _VkCommandBufferAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkCommandPool::constructor)->HasInstance(obj)) {
      self->commandPool.Reset<v8::Object>(value.As<v8::Object>());
      _VkCommandPool* inst = Nan::ObjectWrap::Unwrap<_VkCommandPool>(obj);
      ;
      self->instance.commandPool = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCommandBufferAllocateInfo.commandPool", "[object VkCommandPool]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->commandPool.Reset();
    self->instance.commandPool = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferAllocateInfo.commandPool", "[object VkCommandPool]");
  
    return;
  }
}// level
NAN_GETTER(_VkCommandBufferAllocateInfo::Getlevel) {
  _VkCommandBufferAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.level));
}NAN_SETTER(_VkCommandBufferAllocateInfo::Setlevel) {
  _VkCommandBufferAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.level = static_cast<VkCommandBufferLevel>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferAllocateInfo.level", "Number");
  
    return;
  }
}// commandBufferCount
NAN_GETTER(_VkCommandBufferAllocateInfo::GetcommandBufferCount) {
  _VkCommandBufferAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.commandBufferCount));
}NAN_SETTER(_VkCommandBufferAllocateInfo::SetcommandBufferCount) {
  _VkCommandBufferAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.commandBufferCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandBufferAllocateInfo.commandBufferCount", "Number");
  
    return;
  }
}
/** ## END VkCommandBufferAllocateInfo ## **/

/** ## BEGIN VkCommandPoolCreateInfo ## **/

class _VkCommandPoolCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetqueueFamilyIndex);
    static NAN_SETTER(SetqueueFamilyIndex);
    

    // real instance
    VkCommandPoolCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCommandPoolCreateInfo();
    ~_VkCommandPoolCreateInfo();

};

/*
#include "index.h"
#include "VkCommandPoolCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCommandPoolCreateInfo::constructor;

_VkCommandPoolCreateInfo::_VkCommandPoolCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
  
}

_VkCommandPoolCreateInfo::~_VkCommandPoolCreateInfo() {
  //printf("VkCommandPoolCreateInfo deconstructed!!\n");
  
  
  
  
}

void _VkCommandPoolCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCommandPoolCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCommandPoolCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueFamilyIndex").ToLocalChecked(), GetqueueFamilyIndex, SetqueueFamilyIndex, ctor);
  Nan::Set(target, Nan::New("VkCommandPoolCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCommandPoolCreateInfo::flush() {
  _VkCommandPoolCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkCommandPoolCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkCommandPoolCreateInfo* self = new _VkCommandPoolCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("queueFamilyIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCommandPoolCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCommandPoolCreateInfo::GetsType) {
  _VkCommandPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCommandPoolCreateInfo::SetsType) {
  _VkCommandPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandPoolCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkCommandPoolCreateInfo::Getflags) {
  _VkCommandPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkCommandPoolCreateInfo::Setflags) {
  _VkCommandPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkCommandPoolCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandPoolCreateInfo.flags", "Number");
  
    return;
  }
}// queueFamilyIndex
NAN_GETTER(_VkCommandPoolCreateInfo::GetqueueFamilyIndex) {
  _VkCommandPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueFamilyIndex));
}NAN_SETTER(_VkCommandPoolCreateInfo::SetqueueFamilyIndex) {
  _VkCommandPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queueFamilyIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCommandPoolCreateInfo.queueFamilyIndex", "Number");
  
    return;
  }
}
/** ## END VkCommandPoolCreateInfo ## **/

/** ## BEGIN VkSamplerCreateInfo ## **/

class _VkSamplerCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetmagFilter);
    static NAN_SETTER(SetmagFilter);
    
    static NAN_GETTER(GetminFilter);
    static NAN_SETTER(SetminFilter);
    
    static NAN_GETTER(GetmipmapMode);
    static NAN_SETTER(SetmipmapMode);
    
    static NAN_GETTER(GetaddressModeU);
    static NAN_SETTER(SetaddressModeU);
    
    static NAN_GETTER(GetaddressModeV);
    static NAN_SETTER(SetaddressModeV);
    
    static NAN_GETTER(GetaddressModeW);
    static NAN_SETTER(SetaddressModeW);
    
    static NAN_GETTER(GetmipLodBias);
    static NAN_SETTER(SetmipLodBias);
    
    static NAN_GETTER(GetanisotropyEnable);
    static NAN_SETTER(SetanisotropyEnable);
    
    static NAN_GETTER(GetmaxAnisotropy);
    static NAN_SETTER(SetmaxAnisotropy);
    
    static NAN_GETTER(GetcompareEnable);
    static NAN_SETTER(SetcompareEnable);
    
    static NAN_GETTER(GetcompareOp);
    static NAN_SETTER(SetcompareOp);
    
    static NAN_GETTER(GetminLod);
    static NAN_SETTER(SetminLod);
    
    static NAN_GETTER(GetmaxLod);
    static NAN_SETTER(SetmaxLod);
    
    static NAN_GETTER(GetborderColor);
    static NAN_SETTER(SetborderColor);
    
    static NAN_GETTER(GetunnormalizedCoordinates);
    static NAN_SETTER(SetunnormalizedCoordinates);
    

    // real instance
    VkSamplerCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSamplerCreateInfo();
    ~_VkSamplerCreateInfo();

};

/*
#include "index.h"
#include "VkSamplerCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSamplerCreateInfo::constructor;

_VkSamplerCreateInfo::_VkSamplerCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
  
}

_VkSamplerCreateInfo::~_VkSamplerCreateInfo() {
  //printf("VkSamplerCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkSamplerCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSamplerCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSamplerCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("magFilter").ToLocalChecked(), GetmagFilter, SetmagFilter, ctor);
  SetPrototypeAccessor(proto, Nan::New("minFilter").ToLocalChecked(), GetminFilter, SetminFilter, ctor);
  SetPrototypeAccessor(proto, Nan::New("mipmapMode").ToLocalChecked(), GetmipmapMode, SetmipmapMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("addressModeU").ToLocalChecked(), GetaddressModeU, SetaddressModeU, ctor);
  SetPrototypeAccessor(proto, Nan::New("addressModeV").ToLocalChecked(), GetaddressModeV, SetaddressModeV, ctor);
  SetPrototypeAccessor(proto, Nan::New("addressModeW").ToLocalChecked(), GetaddressModeW, SetaddressModeW, ctor);
  SetPrototypeAccessor(proto, Nan::New("mipLodBias").ToLocalChecked(), GetmipLodBias, SetmipLodBias, ctor);
  SetPrototypeAccessor(proto, Nan::New("anisotropyEnable").ToLocalChecked(), GetanisotropyEnable, SetanisotropyEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxAnisotropy").ToLocalChecked(), GetmaxAnisotropy, SetmaxAnisotropy, ctor);
  SetPrototypeAccessor(proto, Nan::New("compareEnable").ToLocalChecked(), GetcompareEnable, SetcompareEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("compareOp").ToLocalChecked(), GetcompareOp, SetcompareOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("minLod").ToLocalChecked(), GetminLod, SetminLod, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxLod").ToLocalChecked(), GetmaxLod, SetmaxLod, ctor);
  SetPrototypeAccessor(proto, Nan::New("borderColor").ToLocalChecked(), GetborderColor, SetborderColor, ctor);
  SetPrototypeAccessor(proto, Nan::New("unnormalizedCoordinates").ToLocalChecked(), GetunnormalizedCoordinates, SetunnormalizedCoordinates, ctor);
  Nan::Set(target, Nan::New("VkSamplerCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSamplerCreateInfo::flush() {
  _VkSamplerCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkSamplerCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkSamplerCreateInfo* self = new _VkSamplerCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("magFilter").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("minFilter").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("mipmapMode").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("addressModeU").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("addressModeV").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("addressModeW").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("mipLodBias").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("anisotropyEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("maxAnisotropy").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("compareEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess13 = Nan::New("compareOp").ToLocalChecked();
      v8::Local<v8::String> sAccess14 = Nan::New("minLod").ToLocalChecked();
      v8::Local<v8::String> sAccess15 = Nan::New("maxLod").ToLocalChecked();
      v8::Local<v8::String> sAccess16 = Nan::New("borderColor").ToLocalChecked();
      v8::Local<v8::String> sAccess17 = Nan::New("unnormalizedCoordinates").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      if (obj->Has(sAccess13)) info.This()->Set(sAccess13, obj->Get(sAccess13));
      if (obj->Has(sAccess14)) info.This()->Set(sAccess14, obj->Get(sAccess14));
      if (obj->Has(sAccess15)) info.This()->Set(sAccess15, obj->Get(sAccess15));
      if (obj->Has(sAccess16)) info.This()->Set(sAccess16, obj->Get(sAccess16));
      if (obj->Has(sAccess17)) info.This()->Set(sAccess17, obj->Get(sAccess17));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSamplerCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkSamplerCreateInfo::GetsType) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkSamplerCreateInfo::SetsType) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkSamplerCreateInfo::Getflags) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkSamplerCreateInfo::Setflags) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSamplerCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.flags", "Number");
  
    return;
  }
}// magFilter
NAN_GETTER(_VkSamplerCreateInfo::GetmagFilter) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.magFilter));
}NAN_SETTER(_VkSamplerCreateInfo::SetmagFilter) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.magFilter = static_cast<VkFilter>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.magFilter", "Number");
  
    return;
  }
}// minFilter
NAN_GETTER(_VkSamplerCreateInfo::GetminFilter) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minFilter));
}NAN_SETTER(_VkSamplerCreateInfo::SetminFilter) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.minFilter = static_cast<VkFilter>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.minFilter", "Number");
  
    return;
  }
}// mipmapMode
NAN_GETTER(_VkSamplerCreateInfo::GetmipmapMode) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.mipmapMode));
}NAN_SETTER(_VkSamplerCreateInfo::SetmipmapMode) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.mipmapMode = static_cast<VkSamplerMipmapMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.mipmapMode", "Number");
  
    return;
  }
}// addressModeU
NAN_GETTER(_VkSamplerCreateInfo::GetaddressModeU) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.addressModeU));
}NAN_SETTER(_VkSamplerCreateInfo::SetaddressModeU) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.addressModeU = static_cast<VkSamplerAddressMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.addressModeU", "Number");
  
    return;
  }
}// addressModeV
NAN_GETTER(_VkSamplerCreateInfo::GetaddressModeV) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.addressModeV));
}NAN_SETTER(_VkSamplerCreateInfo::SetaddressModeV) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.addressModeV = static_cast<VkSamplerAddressMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.addressModeV", "Number");
  
    return;
  }
}// addressModeW
NAN_GETTER(_VkSamplerCreateInfo::GetaddressModeW) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.addressModeW));
}NAN_SETTER(_VkSamplerCreateInfo::SetaddressModeW) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.addressModeW = static_cast<VkSamplerAddressMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.addressModeW", "Number");
  
    return;
  }
}// mipLodBias
NAN_GETTER(_VkSamplerCreateInfo::GetmipLodBias) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.mipLodBias));
}NAN_SETTER(_VkSamplerCreateInfo::SetmipLodBias) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.mipLodBias = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.mipLodBias", "Number");
  
    return;
  }
}// anisotropyEnable
NAN_GETTER(_VkSamplerCreateInfo::GetanisotropyEnable) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.anisotropyEnable));
}NAN_SETTER(_VkSamplerCreateInfo::SetanisotropyEnable) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.anisotropyEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.anisotropyEnable", "Number");
  
    return;
  }
}// maxAnisotropy
NAN_GETTER(_VkSamplerCreateInfo::GetmaxAnisotropy) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxAnisotropy));
}NAN_SETTER(_VkSamplerCreateInfo::SetmaxAnisotropy) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.maxAnisotropy = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.maxAnisotropy", "Number");
  
    return;
  }
}// compareEnable
NAN_GETTER(_VkSamplerCreateInfo::GetcompareEnable) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compareEnable));
}NAN_SETTER(_VkSamplerCreateInfo::SetcompareEnable) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.compareEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.compareEnable", "Number");
  
    return;
  }
}// compareOp
NAN_GETTER(_VkSamplerCreateInfo::GetcompareOp) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compareOp));
}NAN_SETTER(_VkSamplerCreateInfo::SetcompareOp) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.compareOp = static_cast<VkCompareOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.compareOp", "Number");
  
    return;
  }
}// minLod
NAN_GETTER(_VkSamplerCreateInfo::GetminLod) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minLod));
}NAN_SETTER(_VkSamplerCreateInfo::SetminLod) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.minLod = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.minLod", "Number");
  
    return;
  }
}// maxLod
NAN_GETTER(_VkSamplerCreateInfo::GetmaxLod) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxLod));
}NAN_SETTER(_VkSamplerCreateInfo::SetmaxLod) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.maxLod = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.maxLod", "Number");
  
    return;
  }
}// borderColor
NAN_GETTER(_VkSamplerCreateInfo::GetborderColor) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.borderColor));
}NAN_SETTER(_VkSamplerCreateInfo::SetborderColor) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.borderColor = static_cast<VkBorderColor>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.borderColor", "Number");
  
    return;
  }
}// unnormalizedCoordinates
NAN_GETTER(_VkSamplerCreateInfo::GetunnormalizedCoordinates) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.unnormalizedCoordinates));
}NAN_SETTER(_VkSamplerCreateInfo::SetunnormalizedCoordinates) {
  _VkSamplerCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.unnormalizedCoordinates = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSamplerCreateInfo.unnormalizedCoordinates", "Number");
  
    return;
  }
}
/** ## END VkSamplerCreateInfo ## **/

/** ## BEGIN VkPushConstantRange ## **/

class _VkPushConstantRange: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetstageFlags);
    static NAN_SETTER(SetstageFlags);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
    static NAN_GETTER(Getsize);
    static NAN_SETTER(Setsize);
    

    // real instance
    VkPushConstantRange instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPushConstantRange();
    ~_VkPushConstantRange();

};

/*
#include "index.h"
#include "VkPushConstantRange.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPushConstantRange::constructor;

_VkPushConstantRange::_VkPushConstantRange() {
  
  
}

_VkPushConstantRange::~_VkPushConstantRange() {
  //printf("VkPushConstantRange deconstructed!!\n");
  
  
  
  
}

void _VkPushConstantRange::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPushConstantRange::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPushConstantRange").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("stageFlags").ToLocalChecked(), GetstageFlags, SetstageFlags, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, Setsize, ctor);
  Nan::Set(target, Nan::New("VkPushConstantRange").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPushConstantRange::flush() {
  _VkPushConstantRange *self = this;
  
  return true;
}

NAN_METHOD(_VkPushConstantRange::New) {
  if (info.IsConstructCall()) {
    _VkPushConstantRange* self = new _VkPushConstantRange();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("stageFlags").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("size").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPushConstantRange constructor cannot be invoked without 'new'");
  }
};

// stageFlags
NAN_GETTER(_VkPushConstantRange::GetstageFlags) {
  _VkPushConstantRange *self = Nan::ObjectWrap::Unwrap<_VkPushConstantRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stageFlags));
}NAN_SETTER(_VkPushConstantRange::SetstageFlags) {
  _VkPushConstantRange *self = Nan::ObjectWrap::Unwrap<_VkPushConstantRange>(info.This());
  if (value->IsNumber()) {
    self->instance.stageFlags = static_cast<VkShaderStageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPushConstantRange.stageFlags", "Number");
  
    return;
  }
}// offset
NAN_GETTER(_VkPushConstantRange::Getoffset) {
  _VkPushConstantRange *self = Nan::ObjectWrap::Unwrap<_VkPushConstantRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkPushConstantRange::Setoffset) {
  _VkPushConstantRange *self = Nan::ObjectWrap::Unwrap<_VkPushConstantRange>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPushConstantRange.offset", "Number");
  
    return;
  }
}// size
NAN_GETTER(_VkPushConstantRange::Getsize) {
  _VkPushConstantRange *self = Nan::ObjectWrap::Unwrap<_VkPushConstantRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}NAN_SETTER(_VkPushConstantRange::Setsize) {
  _VkPushConstantRange *self = Nan::ObjectWrap::Unwrap<_VkPushConstantRange>(info.This());
  if (value->IsNumber()) {
    self->instance.size = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPushConstantRange.size", "Number");
  
    return;
  }
}
/** ## END VkPushConstantRange ## **/

/** ## BEGIN VkPipelineLayoutCreateInfo ## **/

class _VkPipelineLayoutCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetsetLayoutCount);
    static NAN_SETTER(SetsetLayoutCount);
    
    std::vector<VkDescriptorSetLayout>* vpSetLayouts;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSetLayouts;
    static NAN_GETTER(GetpSetLayouts);
    static NAN_SETTER(SetpSetLayouts);
    
    static NAN_GETTER(GetpushConstantRangeCount);
    static NAN_SETTER(SetpushConstantRangeCount);
    
    std::vector<VkPushConstantRange>* vpPushConstantRanges;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pPushConstantRanges;
    static NAN_GETTER(GetpPushConstantRanges);
    static NAN_SETTER(SetpPushConstantRanges);
    

    // real instance
    VkPipelineLayoutCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineLayoutCreateInfo();
    ~_VkPipelineLayoutCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineLayoutCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineLayoutCreateInfo::constructor;

_VkPipelineLayoutCreateInfo::_VkPipelineLayoutCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
  vpSetLayouts = new std::vector<VkDescriptorSetLayout>;
  vpPushConstantRanges = new std::vector<VkPushConstantRange>;
  
}

_VkPipelineLayoutCreateInfo::~_VkPipelineLayoutCreateInfo() {
  //printf("VkPipelineLayoutCreateInfo deconstructed!!\n");
  
  
  
  
  vpSetLayouts->clear();
  delete vpSetLayouts;
  
  pSetLayouts.Reset();
  
  
  vpPushConstantRanges->clear();
  delete vpPushConstantRanges;
  
  pPushConstantRanges.Reset();
  
}

void _VkPipelineLayoutCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineLayoutCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineLayoutCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("setLayoutCount").ToLocalChecked(), GetsetLayoutCount, SetsetLayoutCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSetLayouts").ToLocalChecked(), GetpSetLayouts, SetpSetLayouts, ctor);
  SetPrototypeAccessor(proto, Nan::New("pushConstantRangeCount").ToLocalChecked(), GetpushConstantRangeCount, SetpushConstantRangeCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pPushConstantRanges").ToLocalChecked(), GetpPushConstantRanges, SetpPushConstantRanges, ctor);
  Nan::Set(target, Nan::New("VkPipelineLayoutCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineLayoutCreateInfo::flush() {
  _VkPipelineLayoutCreateInfo *self = this;
  if (!(self->pSetLayouts.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSetLayouts);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.setLayoutCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'setLayoutCount' for 'VkPipelineLayoutCreateInfo.pSetLayouts'");
      return false;
    }
    std::vector<VkDescriptorSetLayout>* data = self->vpSetLayouts;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDescriptorSetLayout::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
        return false;
      }
      _VkDescriptorSetLayout* result = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayout>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSetLayouts = data->data();
  }if (!(self->pPushConstantRanges.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pPushConstantRanges);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.pushConstantRangeCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'pushConstantRangeCount' for 'VkPipelineLayoutCreateInfo.pPushConstantRanges'");
      return false;
    }
    std::vector<VkPushConstantRange>* data = self->vpPushConstantRanges;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkPushConstantRange::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.pPushConstantRanges", "[object VkPushConstantRange]");
  
        return false;
      }
      _VkPushConstantRange* result = Nan::ObjectWrap::Unwrap<_VkPushConstantRange>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pPushConstantRanges = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineLayoutCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineLayoutCreateInfo* self = new _VkPipelineLayoutCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("setLayoutCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pSetLayouts").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pushConstantRangeCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pPushConstantRanges").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineLayoutCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineLayoutCreateInfo::GetsType) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineLayoutCreateInfo::SetsType) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineLayoutCreateInfo::Getflags) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineLayoutCreateInfo::Setflags) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineLayoutCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.flags", "Number");
  
    return;
  }
}// setLayoutCount
NAN_GETTER(_VkPipelineLayoutCreateInfo::GetsetLayoutCount) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.setLayoutCount));
}NAN_SETTER(_VkPipelineLayoutCreateInfo::SetsetLayoutCount) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.setLayoutCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.setLayoutCount", "Number");
  
    return;
  }
}// pSetLayouts
NAN_GETTER(_VkPipelineLayoutCreateInfo::GetpSetLayouts) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  if (self->pSetLayouts.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSetLayouts);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineLayoutCreateInfo::SetpSetLayouts) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSetLayouts.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSetLayouts.Reset();
      self->instance.pSetLayouts = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSetLayouts = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
    return;
  }
}// pushConstantRangeCount
NAN_GETTER(_VkPipelineLayoutCreateInfo::GetpushConstantRangeCount) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.pushConstantRangeCount));
}NAN_SETTER(_VkPipelineLayoutCreateInfo::SetpushConstantRangeCount) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.pushConstantRangeCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.pushConstantRangeCount", "Number");
  
    return;
  }
}// pPushConstantRanges
NAN_GETTER(_VkPipelineLayoutCreateInfo::GetpPushConstantRanges) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  if (self->pPushConstantRanges.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pPushConstantRanges);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineLayoutCreateInfo::SetpPushConstantRanges) {
  _VkPipelineLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pPushConstantRanges.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pPushConstantRanges.Reset();
      self->instance.pPushConstantRanges = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.pPushConstantRanges", "[object VkPushConstantRange]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pPushConstantRanges = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineLayoutCreateInfo.pPushConstantRanges", "[object VkPushConstantRange]");
  
    return;
  }
}
/** ## END VkPipelineLayoutCreateInfo ## **/

/** ## BEGIN VkPipelineCacheCreateInfo ## **/

class _VkPipelineCacheCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetinitialDataSize);
    static NAN_SETTER(SetinitialDataSize);
    
    Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pInitialData;
    static NAN_GETTER(GetpInitialData);
    static NAN_SETTER(SetpInitialData);
    

    // real instance
    VkPipelineCacheCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineCacheCreateInfo();
    ~_VkPipelineCacheCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineCacheCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineCacheCreateInfo::constructor;

_VkPipelineCacheCreateInfo::_VkPipelineCacheCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
  
}

_VkPipelineCacheCreateInfo::~_VkPipelineCacheCreateInfo() {
  //printf("VkPipelineCacheCreateInfo deconstructed!!\n");
  
  
  
  
  pInitialData.Reset();
  
}

void _VkPipelineCacheCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineCacheCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineCacheCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("initialDataSize").ToLocalChecked(), GetinitialDataSize, SetinitialDataSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("pInitialData").ToLocalChecked(), GetpInitialData, SetpInitialData, ctor);
  Nan::Set(target, Nan::New("VkPipelineCacheCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineCacheCreateInfo::flush() {
  _VkPipelineCacheCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineCacheCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineCacheCreateInfo* self = new _VkPipelineCacheCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("initialDataSize").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pInitialData").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineCacheCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineCacheCreateInfo::GetsType) {
  _VkPipelineCacheCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineCacheCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineCacheCreateInfo::SetsType) {
  _VkPipelineCacheCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineCacheCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCacheCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineCacheCreateInfo::Getflags) {
  _VkPipelineCacheCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineCacheCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineCacheCreateInfo::Setflags) {
  _VkPipelineCacheCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineCacheCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineCacheCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCacheCreateInfo.flags", "Number");
  
    return;
  }
}// initialDataSize
NAN_GETTER(_VkPipelineCacheCreateInfo::GetinitialDataSize) {
  _VkPipelineCacheCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineCacheCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.initialDataSize));
}NAN_SETTER(_VkPipelineCacheCreateInfo::SetinitialDataSize) {
  _VkPipelineCacheCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineCacheCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.initialDataSize = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineCacheCreateInfo.initialDataSize", "Number");
  
    return;
  }
}// pInitialData
NAN_GETTER(_VkPipelineCacheCreateInfo::GetpInitialData) {
  _VkPipelineCacheCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineCacheCreateInfo>(info.This());
}NAN_SETTER(_VkPipelineCacheCreateInfo::SetpInitialData) {
  _VkPipelineCacheCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineCacheCreateInfo>(info.This());
}
/** ## END VkPipelineCacheCreateInfo ## **/

/** ## BEGIN VkPipelineDynamicStateCreateInfo ## **/

class _VkPipelineDynamicStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetdynamicStateCount);
    static NAN_SETTER(SetdynamicStateCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pDynamicStates;
    static NAN_GETTER(GetpDynamicStates);
    static NAN_SETTER(SetpDynamicStates);
    

    // real instance
    VkPipelineDynamicStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineDynamicStateCreateInfo();
    ~_VkPipelineDynamicStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineDynamicStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineDynamicStateCreateInfo::constructor;

_VkPipelineDynamicStateCreateInfo::_VkPipelineDynamicStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
  
}

_VkPipelineDynamicStateCreateInfo::~_VkPipelineDynamicStateCreateInfo() {
  //printf("VkPipelineDynamicStateCreateInfo deconstructed!!\n");
  
  
  
  
  pDynamicStates.Reset();
  
}

void _VkPipelineDynamicStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineDynamicStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineDynamicStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("dynamicStateCount").ToLocalChecked(), GetdynamicStateCount, SetdynamicStateCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDynamicStates").ToLocalChecked(), GetpDynamicStates, SetpDynamicStates, ctor);
  Nan::Set(target, Nan::New("VkPipelineDynamicStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineDynamicStateCreateInfo::flush() {
  _VkPipelineDynamicStateCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineDynamicStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineDynamicStateCreateInfo* self = new _VkPipelineDynamicStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dynamicStateCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pDynamicStates").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineDynamicStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineDynamicStateCreateInfo::GetsType) {
  _VkPipelineDynamicStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineDynamicStateCreateInfo::SetsType) {
  _VkPipelineDynamicStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDynamicStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineDynamicStateCreateInfo::Getflags) {
  _VkPipelineDynamicStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineDynamicStateCreateInfo::Setflags) {
  _VkPipelineDynamicStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineDynamicStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDynamicStateCreateInfo.flags", "Number");
  
    return;
  }
}// dynamicStateCount
NAN_GETTER(_VkPipelineDynamicStateCreateInfo::GetdynamicStateCount) {
  _VkPipelineDynamicStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dynamicStateCount));
}NAN_SETTER(_VkPipelineDynamicStateCreateInfo::SetdynamicStateCount) {
  _VkPipelineDynamicStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.dynamicStateCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDynamicStateCreateInfo.dynamicStateCount", "Number");
  
    return;
  }
}// pDynamicStates
NAN_GETTER(_VkPipelineDynamicStateCreateInfo::GetpDynamicStates) {
  _VkPipelineDynamicStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(info.This());
  if (self->pDynamicStates.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDynamicStates);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineDynamicStateCreateInfo::SetpDynamicStates) {
  _VkPipelineDynamicStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsInt32Array()) {
        self->pDynamicStates.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineDynamicStateCreateInfo.pDynamicStates", "Int32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pDynamicStates.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineDynamicStateCreateInfo.pDynamicStates", "Int32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pDynamicStates = reinterpret_cast<const VkDynamicState *>(getTypedArrayData<int32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr));
  } else {
    self->instance.pDynamicStates = nullptr;
  }
}
/** ## END VkPipelineDynamicStateCreateInfo ## **/

/** ## BEGIN VkPipelineColorBlendAttachmentState ## **/

class _VkPipelineColorBlendAttachmentState: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetblendEnable);
    static NAN_SETTER(SetblendEnable);
    
    static NAN_GETTER(GetsrcColorBlendFactor);
    static NAN_SETTER(SetsrcColorBlendFactor);
    
    static NAN_GETTER(GetdstColorBlendFactor);
    static NAN_SETTER(SetdstColorBlendFactor);
    
    static NAN_GETTER(GetcolorBlendOp);
    static NAN_SETTER(SetcolorBlendOp);
    
    static NAN_GETTER(GetsrcAlphaBlendFactor);
    static NAN_SETTER(SetsrcAlphaBlendFactor);
    
    static NAN_GETTER(GetdstAlphaBlendFactor);
    static NAN_SETTER(SetdstAlphaBlendFactor);
    
    static NAN_GETTER(GetalphaBlendOp);
    static NAN_SETTER(SetalphaBlendOp);
    
    static NAN_GETTER(GetcolorWriteMask);
    static NAN_SETTER(SetcolorWriteMask);
    

    // real instance
    VkPipelineColorBlendAttachmentState instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineColorBlendAttachmentState();
    ~_VkPipelineColorBlendAttachmentState();

};

/*
#include "index.h"
#include "VkPipelineColorBlendAttachmentState.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineColorBlendAttachmentState::constructor;

_VkPipelineColorBlendAttachmentState::_VkPipelineColorBlendAttachmentState() {
  
  
}

_VkPipelineColorBlendAttachmentState::~_VkPipelineColorBlendAttachmentState() {
  //printf("VkPipelineColorBlendAttachmentState deconstructed!!\n");
  
  
  
  
  
  
  
  
  
}

void _VkPipelineColorBlendAttachmentState::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineColorBlendAttachmentState::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineColorBlendAttachmentState").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("blendEnable").ToLocalChecked(), GetblendEnable, SetblendEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcColorBlendFactor").ToLocalChecked(), GetsrcColorBlendFactor, SetsrcColorBlendFactor, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstColorBlendFactor").ToLocalChecked(), GetdstColorBlendFactor, SetdstColorBlendFactor, ctor);
  SetPrototypeAccessor(proto, Nan::New("colorBlendOp").ToLocalChecked(), GetcolorBlendOp, SetcolorBlendOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcAlphaBlendFactor").ToLocalChecked(), GetsrcAlphaBlendFactor, SetsrcAlphaBlendFactor, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstAlphaBlendFactor").ToLocalChecked(), GetdstAlphaBlendFactor, SetdstAlphaBlendFactor, ctor);
  SetPrototypeAccessor(proto, Nan::New("alphaBlendOp").ToLocalChecked(), GetalphaBlendOp, SetalphaBlendOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("colorWriteMask").ToLocalChecked(), GetcolorWriteMask, SetcolorWriteMask, ctor);
  Nan::Set(target, Nan::New("VkPipelineColorBlendAttachmentState").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineColorBlendAttachmentState::flush() {
  _VkPipelineColorBlendAttachmentState *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineColorBlendAttachmentState::New) {
  if (info.IsConstructCall()) {
    _VkPipelineColorBlendAttachmentState* self = new _VkPipelineColorBlendAttachmentState();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("blendEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("srcColorBlendFactor").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dstColorBlendFactor").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("colorBlendOp").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("srcAlphaBlendFactor").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("dstAlphaBlendFactor").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("alphaBlendOp").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("colorWriteMask").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineColorBlendAttachmentState constructor cannot be invoked without 'new'");
  }
};

// blendEnable
NAN_GETTER(_VkPipelineColorBlendAttachmentState::GetblendEnable) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.blendEnable));
}NAN_SETTER(_VkPipelineColorBlendAttachmentState::SetblendEnable) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.blendEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAttachmentState.blendEnable", "Number");
  
    return;
  }
}// srcColorBlendFactor
NAN_GETTER(_VkPipelineColorBlendAttachmentState::GetsrcColorBlendFactor) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcColorBlendFactor));
}NAN_SETTER(_VkPipelineColorBlendAttachmentState::SetsrcColorBlendFactor) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  if (value->IsNumber()) {
    self->instance.srcColorBlendFactor = static_cast<VkBlendFactor>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAttachmentState.srcColorBlendFactor", "Number");
  
    return;
  }
}// dstColorBlendFactor
NAN_GETTER(_VkPipelineColorBlendAttachmentState::GetdstColorBlendFactor) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstColorBlendFactor));
}NAN_SETTER(_VkPipelineColorBlendAttachmentState::SetdstColorBlendFactor) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  if (value->IsNumber()) {
    self->instance.dstColorBlendFactor = static_cast<VkBlendFactor>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAttachmentState.dstColorBlendFactor", "Number");
  
    return;
  }
}// colorBlendOp
NAN_GETTER(_VkPipelineColorBlendAttachmentState::GetcolorBlendOp) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.colorBlendOp));
}NAN_SETTER(_VkPipelineColorBlendAttachmentState::SetcolorBlendOp) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  if (value->IsNumber()) {
    self->instance.colorBlendOp = static_cast<VkBlendOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAttachmentState.colorBlendOp", "Number");
  
    return;
  }
}// srcAlphaBlendFactor
NAN_GETTER(_VkPipelineColorBlendAttachmentState::GetsrcAlphaBlendFactor) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcAlphaBlendFactor));
}NAN_SETTER(_VkPipelineColorBlendAttachmentState::SetsrcAlphaBlendFactor) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  if (value->IsNumber()) {
    self->instance.srcAlphaBlendFactor = static_cast<VkBlendFactor>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAttachmentState.srcAlphaBlendFactor", "Number");
  
    return;
  }
}// dstAlphaBlendFactor
NAN_GETTER(_VkPipelineColorBlendAttachmentState::GetdstAlphaBlendFactor) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstAlphaBlendFactor));
}NAN_SETTER(_VkPipelineColorBlendAttachmentState::SetdstAlphaBlendFactor) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  if (value->IsNumber()) {
    self->instance.dstAlphaBlendFactor = static_cast<VkBlendFactor>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAttachmentState.dstAlphaBlendFactor", "Number");
  
    return;
  }
}// alphaBlendOp
NAN_GETTER(_VkPipelineColorBlendAttachmentState::GetalphaBlendOp) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.alphaBlendOp));
}NAN_SETTER(_VkPipelineColorBlendAttachmentState::SetalphaBlendOp) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  if (value->IsNumber()) {
    self->instance.alphaBlendOp = static_cast<VkBlendOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAttachmentState.alphaBlendOp", "Number");
  
    return;
  }
}// colorWriteMask
NAN_GETTER(_VkPipelineColorBlendAttachmentState::GetcolorWriteMask) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.colorWriteMask));
}NAN_SETTER(_VkPipelineColorBlendAttachmentState::SetcolorWriteMask) {
  _VkPipelineColorBlendAttachmentState *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(info.This());
  if (value->IsNumber()) {
    self->instance.colorWriteMask = static_cast<VkColorComponentFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendAttachmentState.colorWriteMask", "Number");
  
    return;
  }
}
/** ## END VkPipelineColorBlendAttachmentState ## **/

/** ## BEGIN VkPipelineColorBlendStateCreateInfo ## **/

class _VkPipelineColorBlendStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetlogicOpEnable);
    static NAN_SETTER(SetlogicOpEnable);
    
    static NAN_GETTER(GetlogicOp);
    static NAN_SETTER(SetlogicOp);
    
    static NAN_GETTER(GetattachmentCount);
    static NAN_SETTER(SetattachmentCount);
    
    std::vector<VkPipelineColorBlendAttachmentState>* vpAttachments;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pAttachments;
    static NAN_GETTER(GetpAttachments);
    static NAN_SETTER(SetpAttachments);
    
    std::vector<float>* vblendConstants;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> blendConstants;
    static NAN_GETTER(GetblendConstants);
    static NAN_SETTER(SetblendConstants);
    

    // real instance
    VkPipelineColorBlendStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineColorBlendStateCreateInfo();
    ~_VkPipelineColorBlendStateCreateInfo();

};

/*
#include <string.h>
#include "index.h"
#include "VkPipelineColorBlendStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineColorBlendStateCreateInfo::constructor;

_VkPipelineColorBlendStateCreateInfo::_VkPipelineColorBlendStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
  vpAttachments = new std::vector<VkPipelineColorBlendAttachmentState>;
  vblendConstants = new std::vector<float>;
  
}

_VkPipelineColorBlendStateCreateInfo::~_VkPipelineColorBlendStateCreateInfo() {
  //printf("VkPipelineColorBlendStateCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  vpAttachments->clear();
  delete vpAttachments;
  
  pAttachments.Reset();
  
  vblendConstants->clear();
  delete vblendConstants;
  
  
}

void _VkPipelineColorBlendStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineColorBlendStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineColorBlendStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("logicOpEnable").ToLocalChecked(), GetlogicOpEnable, SetlogicOpEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("logicOp").ToLocalChecked(), GetlogicOp, SetlogicOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("attachmentCount").ToLocalChecked(), GetattachmentCount, SetattachmentCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pAttachments").ToLocalChecked(), GetpAttachments, SetpAttachments, ctor);
  SetPrototypeAccessor(proto, Nan::New("blendConstants").ToLocalChecked(), GetblendConstants, SetblendConstants, ctor);
  Nan::Set(target, Nan::New("VkPipelineColorBlendStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineColorBlendStateCreateInfo::flush() {
  _VkPipelineColorBlendStateCreateInfo *self = this;
  if (!(self->pAttachments.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pAttachments);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.attachmentCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'attachmentCount' for 'VkPipelineColorBlendStateCreateInfo.pAttachments'");
      return false;
    }
    std::vector<VkPipelineColorBlendAttachmentState>* data = self->vpAttachments;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkPipelineColorBlendAttachmentState::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.pAttachments", "[object VkPipelineColorBlendAttachmentState]");
  
        return false;
      }
      _VkPipelineColorBlendAttachmentState* result = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendAttachmentState>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pAttachments = data->data();
  }if (!(self->blendConstants.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->blendConstants);
    
    if (value->IsArray()) {
      // validate length
      if (v8::Local<v8::Array>::Cast(value)->Length() != 4) {
        Nan::ThrowRangeError("Invalid array length, expected array length of '4' for 'VkPipelineColorBlendStateCreateInfo.blendConstants'");
        return false;
      }
      std::vector<float> array = createArrayOfV8Numbers<float>(value);
      memcpy(self->instance.blendConstants, array.data(), sizeof(float) * 4);
    } else if (value->IsNull()) {
      memset(&self->instance.blendConstants, 0, sizeof(float));
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.blendConstants", "Array");
  
      return false;
    }
  }
  return true;
}

NAN_METHOD(_VkPipelineColorBlendStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineColorBlendStateCreateInfo* self = new _VkPipelineColorBlendStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("logicOpEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("logicOp").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("attachmentCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pAttachments").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("blendConstants").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineColorBlendStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineColorBlendStateCreateInfo::GetsType) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineColorBlendStateCreateInfo::SetsType) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineColorBlendStateCreateInfo::Getflags) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineColorBlendStateCreateInfo::Setflags) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineColorBlendStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.flags", "Number");
  
    return;
  }
}// logicOpEnable
NAN_GETTER(_VkPipelineColorBlendStateCreateInfo::GetlogicOpEnable) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.logicOpEnable));
}NAN_SETTER(_VkPipelineColorBlendStateCreateInfo::SetlogicOpEnable) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.logicOpEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.logicOpEnable", "Number");
  
    return;
  }
}// logicOp
NAN_GETTER(_VkPipelineColorBlendStateCreateInfo::GetlogicOp) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.logicOp));
}NAN_SETTER(_VkPipelineColorBlendStateCreateInfo::SetlogicOp) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.logicOp = static_cast<VkLogicOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.logicOp", "Number");
  
    return;
  }
}// attachmentCount
NAN_GETTER(_VkPipelineColorBlendStateCreateInfo::GetattachmentCount) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.attachmentCount));
}NAN_SETTER(_VkPipelineColorBlendStateCreateInfo::SetattachmentCount) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.attachmentCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.attachmentCount", "Number");
  
    return;
  }
}// pAttachments
NAN_GETTER(_VkPipelineColorBlendStateCreateInfo::GetpAttachments) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  if (self->pAttachments.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pAttachments);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineColorBlendStateCreateInfo::SetpAttachments) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pAttachments.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pAttachments.Reset();
      self->instance.pAttachments = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.pAttachments", "[object VkPipelineColorBlendAttachmentState]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pAttachments = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.pAttachments", "[object VkPipelineColorBlendAttachmentState]");
  
    return;
  }
}// blendConstants
NAN_GETTER(_VkPipelineColorBlendStateCreateInfo::GetblendConstants) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  if (self->blendConstants.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->blendConstants));
  }
}NAN_SETTER(_VkPipelineColorBlendStateCreateInfo::SetblendConstants) {
  _VkPipelineColorBlendStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(info.This());
  // js
  if (value->IsArray()) {
    self->blendConstants.Reset<v8::Array>(value.As<v8::Array>());
  } else if (value->IsNull()) {
    self->blendConstants.Reset();
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineColorBlendStateCreateInfo.blendConstants", "Array");
  
    return;
  }
}
/** ## END VkPipelineColorBlendStateCreateInfo ## **/

/** ## BEGIN VkStencilOpState ## **/

class _VkStencilOpState: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetfailOp);
    static NAN_SETTER(SetfailOp);
    
    static NAN_GETTER(GetpassOp);
    static NAN_SETTER(SetpassOp);
    
    static NAN_GETTER(GetdepthFailOp);
    static NAN_SETTER(SetdepthFailOp);
    
    static NAN_GETTER(GetcompareOp);
    static NAN_SETTER(SetcompareOp);
    
    static NAN_GETTER(GetcompareMask);
    static NAN_SETTER(SetcompareMask);
    
    static NAN_GETTER(GetwriteMask);
    static NAN_SETTER(SetwriteMask);
    
    static NAN_GETTER(Getreference);
    static NAN_SETTER(Setreference);
    

    // real instance
    VkStencilOpState instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkStencilOpState();
    ~_VkStencilOpState();

};

/*
#include "index.h"
#include "VkStencilOpState.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkStencilOpState::constructor;

_VkStencilOpState::_VkStencilOpState() {
  
  
}

_VkStencilOpState::~_VkStencilOpState() {
  //printf("VkStencilOpState deconstructed!!\n");
  
  
  
  
  
  
  
  
}

void _VkStencilOpState::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkStencilOpState::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkStencilOpState").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("failOp").ToLocalChecked(), GetfailOp, SetfailOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("passOp").ToLocalChecked(), GetpassOp, SetpassOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthFailOp").ToLocalChecked(), GetdepthFailOp, SetdepthFailOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("compareOp").ToLocalChecked(), GetcompareOp, SetcompareOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("compareMask").ToLocalChecked(), GetcompareMask, SetcompareMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("writeMask").ToLocalChecked(), GetwriteMask, SetwriteMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("reference").ToLocalChecked(), Getreference, Setreference, ctor);
  Nan::Set(target, Nan::New("VkStencilOpState").ToLocalChecked(), ctor->GetFunction());
}

bool _VkStencilOpState::flush() {
  _VkStencilOpState *self = this;
  
  return true;
}

NAN_METHOD(_VkStencilOpState::New) {
  if (info.IsConstructCall()) {
    _VkStencilOpState* self = new _VkStencilOpState();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("failOp").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("passOp").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("depthFailOp").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("compareOp").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("compareMask").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("writeMask").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("reference").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkStencilOpState constructor cannot be invoked without 'new'");
  }
};

// failOp
NAN_GETTER(_VkStencilOpState::GetfailOp) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.failOp));
}NAN_SETTER(_VkStencilOpState::SetfailOp) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  if (value->IsNumber()) {
    self->instance.failOp = static_cast<VkStencilOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkStencilOpState.failOp", "Number");
  
    return;
  }
}// passOp
NAN_GETTER(_VkStencilOpState::GetpassOp) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.passOp));
}NAN_SETTER(_VkStencilOpState::SetpassOp) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  if (value->IsNumber()) {
    self->instance.passOp = static_cast<VkStencilOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkStencilOpState.passOp", "Number");
  
    return;
  }
}// depthFailOp
NAN_GETTER(_VkStencilOpState::GetdepthFailOp) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthFailOp));
}NAN_SETTER(_VkStencilOpState::SetdepthFailOp) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  if (value->IsNumber()) {
    self->instance.depthFailOp = static_cast<VkStencilOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkStencilOpState.depthFailOp", "Number");
  
    return;
  }
}// compareOp
NAN_GETTER(_VkStencilOpState::GetcompareOp) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compareOp));
}NAN_SETTER(_VkStencilOpState::SetcompareOp) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  if (value->IsNumber()) {
    self->instance.compareOp = static_cast<VkCompareOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkStencilOpState.compareOp", "Number");
  
    return;
  }
}// compareMask
NAN_GETTER(_VkStencilOpState::GetcompareMask) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.compareMask));
}NAN_SETTER(_VkStencilOpState::SetcompareMask) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  if (value->IsNumber()) {
    self->instance.compareMask = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkStencilOpState.compareMask", "Number");
  
    return;
  }
}// writeMask
NAN_GETTER(_VkStencilOpState::GetwriteMask) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.writeMask));
}NAN_SETTER(_VkStencilOpState::SetwriteMask) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  if (value->IsNumber()) {
    self->instance.writeMask = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkStencilOpState.writeMask", "Number");
  
    return;
  }
}// reference
NAN_GETTER(_VkStencilOpState::Getreference) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.reference));
}NAN_SETTER(_VkStencilOpState::Setreference) {
  _VkStencilOpState *self = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(info.This());
  if (value->IsNumber()) {
    self->instance.reference = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkStencilOpState.reference", "Number");
  
    return;
  }
}
/** ## END VkStencilOpState ## **/

/** ## BEGIN VkPipelineDepthStencilStateCreateInfo ## **/

class _VkPipelineDepthStencilStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetdepthTestEnable);
    static NAN_SETTER(SetdepthTestEnable);
    
    static NAN_GETTER(GetdepthWriteEnable);
    static NAN_SETTER(SetdepthWriteEnable);
    
    static NAN_GETTER(GetdepthCompareOp);
    static NAN_SETTER(SetdepthCompareOp);
    
    static NAN_GETTER(GetdepthBoundsTestEnable);
    static NAN_SETTER(SetdepthBoundsTestEnable);
    
    static NAN_GETTER(GetstencilTestEnable);
    static NAN_SETTER(SetstencilTestEnable);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> front;
      static NAN_GETTER(Getfront);
    static NAN_SETTER(Setfront);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> back;
      static NAN_GETTER(Getback);
    static NAN_SETTER(Setback);
    
    static NAN_GETTER(GetminDepthBounds);
    static NAN_SETTER(SetminDepthBounds);
    
    static NAN_GETTER(GetmaxDepthBounds);
    static NAN_SETTER(SetmaxDepthBounds);
    

    // real instance
    VkPipelineDepthStencilStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineDepthStencilStateCreateInfo();
    ~_VkPipelineDepthStencilStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineDepthStencilStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineDepthStencilStateCreateInfo::constructor;

_VkPipelineDepthStencilStateCreateInfo::_VkPipelineDepthStencilStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
  
}

_VkPipelineDepthStencilStateCreateInfo::~_VkPipelineDepthStencilStateCreateInfo() {
  //printf("VkPipelineDepthStencilStateCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPipelineDepthStencilStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineDepthStencilStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineDepthStencilStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthTestEnable").ToLocalChecked(), GetdepthTestEnable, SetdepthTestEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthWriteEnable").ToLocalChecked(), GetdepthWriteEnable, SetdepthWriteEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthCompareOp").ToLocalChecked(), GetdepthCompareOp, SetdepthCompareOp, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthBoundsTestEnable").ToLocalChecked(), GetdepthBoundsTestEnable, SetdepthBoundsTestEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("stencilTestEnable").ToLocalChecked(), GetstencilTestEnable, SetstencilTestEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("front").ToLocalChecked(), Getfront, Setfront, ctor);
  SetPrototypeAccessor(proto, Nan::New("back").ToLocalChecked(), Getback, Setback, ctor);
  SetPrototypeAccessor(proto, Nan::New("minDepthBounds").ToLocalChecked(), GetminDepthBounds, SetminDepthBounds, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDepthBounds").ToLocalChecked(), GetmaxDepthBounds, SetmaxDepthBounds, ctor);
  Nan::Set(target, Nan::New("VkPipelineDepthStencilStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineDepthStencilStateCreateInfo::flush() {
  _VkPipelineDepthStencilStateCreateInfo *self = this;
  if (!(self->front.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->front);
    
    _VkStencilOpState* result = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.front = result->instance;
  }if (!(self->back.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->back);
    
    _VkStencilOpState* result = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.back = result->instance;
  }
  return true;
}

NAN_METHOD(_VkPipelineDepthStencilStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineDepthStencilStateCreateInfo* self = new _VkPipelineDepthStencilStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("depthTestEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("depthWriteEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("depthCompareOp").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("depthBoundsTestEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("stencilTestEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("front").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("back").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("minDepthBounds").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("maxDepthBounds").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineDepthStencilStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::GetsType) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::SetsType) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::Getflags) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::Setflags) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineDepthStencilStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.flags", "Number");
  
    return;
  }
}// depthTestEnable
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::GetdepthTestEnable) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthTestEnable));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::SetdepthTestEnable) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.depthTestEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.depthTestEnable", "Number");
  
    return;
  }
}// depthWriteEnable
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::GetdepthWriteEnable) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthWriteEnable));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::SetdepthWriteEnable) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.depthWriteEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.depthWriteEnable", "Number");
  
    return;
  }
}// depthCompareOp
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::GetdepthCompareOp) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthCompareOp));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::SetdepthCompareOp) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.depthCompareOp = static_cast<VkCompareOp>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.depthCompareOp", "Number");
  
    return;
  }
}// depthBoundsTestEnable
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::GetdepthBoundsTestEnable) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthBoundsTestEnable));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::SetdepthBoundsTestEnable) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.depthBoundsTestEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.depthBoundsTestEnable", "Number");
  
    return;
  }
}// stencilTestEnable
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::GetstencilTestEnable) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stencilTestEnable));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::SetstencilTestEnable) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.stencilTestEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.stencilTestEnable", "Number");
  
    return;
  }
}// front
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::Getfront) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (self->front.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->front);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::Setfront) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkStencilOpState::constructor)->HasInstance(obj)) {
      self->front.Reset<v8::Object>(value.As<v8::Object>());
      _VkStencilOpState* inst = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(obj);
      inst->flush();
      self->instance.front = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.front", "[object VkStencilOpState]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->front.Reset();
    memset(&self->instance.front, 0, sizeof(VkStencilOpState));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.front", "[object VkStencilOpState]");
  
    return;
  }
}// back
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::Getback) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (self->back.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->back);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::Setback) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkStencilOpState::constructor)->HasInstance(obj)) {
      self->back.Reset<v8::Object>(value.As<v8::Object>());
      _VkStencilOpState* inst = Nan::ObjectWrap::Unwrap<_VkStencilOpState>(obj);
      inst->flush();
      self->instance.back = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.back", "[object VkStencilOpState]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->back.Reset();
    memset(&self->instance.back, 0, sizeof(VkStencilOpState));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.back", "[object VkStencilOpState]");
  
    return;
  }
}// minDepthBounds
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::GetminDepthBounds) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minDepthBounds));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::SetminDepthBounds) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.minDepthBounds = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.minDepthBounds", "Number");
  
    return;
  }
}// maxDepthBounds
NAN_GETTER(_VkPipelineDepthStencilStateCreateInfo::GetmaxDepthBounds) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDepthBounds));
}NAN_SETTER(_VkPipelineDepthStencilStateCreateInfo::SetmaxDepthBounds) {
  _VkPipelineDepthStencilStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.maxDepthBounds = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineDepthStencilStateCreateInfo.maxDepthBounds", "Number");
  
    return;
  }
}
/** ## END VkPipelineDepthStencilStateCreateInfo ## **/

/** ## BEGIN VkPipelineMultisampleStateCreateInfo ## **/

class _VkPipelineMultisampleStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetrasterizationSamples);
    static NAN_SETTER(SetrasterizationSamples);
    
    static NAN_GETTER(GetsampleShadingEnable);
    static NAN_SETTER(SetsampleShadingEnable);
    
    static NAN_GETTER(GetminSampleShading);
    static NAN_SETTER(SetminSampleShading);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSampleMask;
    static NAN_GETTER(GetpSampleMask);
    static NAN_SETTER(SetpSampleMask);
    
    static NAN_GETTER(GetalphaToCoverageEnable);
    static NAN_SETTER(SetalphaToCoverageEnable);
    
    static NAN_GETTER(GetalphaToOneEnable);
    static NAN_SETTER(SetalphaToOneEnable);
    

    // real instance
    VkPipelineMultisampleStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineMultisampleStateCreateInfo();
    ~_VkPipelineMultisampleStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineMultisampleStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineMultisampleStateCreateInfo::constructor;

_VkPipelineMultisampleStateCreateInfo::_VkPipelineMultisampleStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
  
}

_VkPipelineMultisampleStateCreateInfo::~_VkPipelineMultisampleStateCreateInfo() {
  //printf("VkPipelineMultisampleStateCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  pSampleMask.Reset();
  
  
  
}

void _VkPipelineMultisampleStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineMultisampleStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineMultisampleStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("rasterizationSamples").ToLocalChecked(), GetrasterizationSamples, SetrasterizationSamples, ctor);
  SetPrototypeAccessor(proto, Nan::New("sampleShadingEnable").ToLocalChecked(), GetsampleShadingEnable, SetsampleShadingEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("minSampleShading").ToLocalChecked(), GetminSampleShading, SetminSampleShading, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSampleMask").ToLocalChecked(), GetpSampleMask, SetpSampleMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("alphaToCoverageEnable").ToLocalChecked(), GetalphaToCoverageEnable, SetalphaToCoverageEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("alphaToOneEnable").ToLocalChecked(), GetalphaToOneEnable, SetalphaToOneEnable, ctor);
  Nan::Set(target, Nan::New("VkPipelineMultisampleStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineMultisampleStateCreateInfo::flush() {
  _VkPipelineMultisampleStateCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineMultisampleStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineMultisampleStateCreateInfo* self = new _VkPipelineMultisampleStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("rasterizationSamples").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("sampleShadingEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("minSampleShading").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pSampleMask").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("alphaToCoverageEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("alphaToOneEnable").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineMultisampleStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineMultisampleStateCreateInfo::GetsType) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineMultisampleStateCreateInfo::SetsType) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineMultisampleStateCreateInfo::Getflags) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineMultisampleStateCreateInfo::Setflags) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineMultisampleStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.flags", "Number");
  
    return;
  }
}// rasterizationSamples
NAN_GETTER(_VkPipelineMultisampleStateCreateInfo::GetrasterizationSamples) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.rasterizationSamples));
}NAN_SETTER(_VkPipelineMultisampleStateCreateInfo::SetrasterizationSamples) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.rasterizationSamples = static_cast<VkSampleCountFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.rasterizationSamples", "Number");
  
    return;
  }
}// sampleShadingEnable
NAN_GETTER(_VkPipelineMultisampleStateCreateInfo::GetsampleShadingEnable) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sampleShadingEnable));
}NAN_SETTER(_VkPipelineMultisampleStateCreateInfo::SetsampleShadingEnable) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.sampleShadingEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.sampleShadingEnable", "Number");
  
    return;
  }
}// minSampleShading
NAN_GETTER(_VkPipelineMultisampleStateCreateInfo::GetminSampleShading) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minSampleShading));
}NAN_SETTER(_VkPipelineMultisampleStateCreateInfo::SetminSampleShading) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.minSampleShading = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.minSampleShading", "Number");
  
    return;
  }
}// pSampleMask
NAN_GETTER(_VkPipelineMultisampleStateCreateInfo::GetpSampleMask) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  if (self->pSampleMask.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSampleMask);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineMultisampleStateCreateInfo::SetpSampleMask) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pSampleMask.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.pSampleMask", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pSampleMask.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.pSampleMask", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pSampleMask = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pSampleMask = nullptr;
  }
}// alphaToCoverageEnable
NAN_GETTER(_VkPipelineMultisampleStateCreateInfo::GetalphaToCoverageEnable) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.alphaToCoverageEnable));
}NAN_SETTER(_VkPipelineMultisampleStateCreateInfo::SetalphaToCoverageEnable) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.alphaToCoverageEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.alphaToCoverageEnable", "Number");
  
    return;
  }
}// alphaToOneEnable
NAN_GETTER(_VkPipelineMultisampleStateCreateInfo::GetalphaToOneEnable) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.alphaToOneEnable));
}NAN_SETTER(_VkPipelineMultisampleStateCreateInfo::SetalphaToOneEnable) {
  _VkPipelineMultisampleStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.alphaToOneEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineMultisampleStateCreateInfo.alphaToOneEnable", "Number");
  
    return;
  }
}
/** ## END VkPipelineMultisampleStateCreateInfo ## **/

/** ## BEGIN VkPipelineRasterizationStateCreateInfo ## **/

class _VkPipelineRasterizationStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetdepthClampEnable);
    static NAN_SETTER(SetdepthClampEnable);
    
    static NAN_GETTER(GetrasterizerDiscardEnable);
    static NAN_SETTER(SetrasterizerDiscardEnable);
    
    static NAN_GETTER(GetpolygonMode);
    static NAN_SETTER(SetpolygonMode);
    
    static NAN_GETTER(GetcullMode);
    static NAN_SETTER(SetcullMode);
    
    static NAN_GETTER(GetfrontFace);
    static NAN_SETTER(SetfrontFace);
    
    static NAN_GETTER(GetdepthBiasEnable);
    static NAN_SETTER(SetdepthBiasEnable);
    
    static NAN_GETTER(GetdepthBiasConstantFactor);
    static NAN_SETTER(SetdepthBiasConstantFactor);
    
    static NAN_GETTER(GetdepthBiasClamp);
    static NAN_SETTER(SetdepthBiasClamp);
    
    static NAN_GETTER(GetdepthBiasSlopeFactor);
    static NAN_SETTER(SetdepthBiasSlopeFactor);
    
    static NAN_GETTER(GetlineWidth);
    static NAN_SETTER(SetlineWidth);
    

    // real instance
    VkPipelineRasterizationStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineRasterizationStateCreateInfo();
    ~_VkPipelineRasterizationStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineRasterizationStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineRasterizationStateCreateInfo::constructor;

_VkPipelineRasterizationStateCreateInfo::_VkPipelineRasterizationStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
  
}

_VkPipelineRasterizationStateCreateInfo::~_VkPipelineRasterizationStateCreateInfo() {
  //printf("VkPipelineRasterizationStateCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
}

void _VkPipelineRasterizationStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineRasterizationStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineRasterizationStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthClampEnable").ToLocalChecked(), GetdepthClampEnable, SetdepthClampEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("rasterizerDiscardEnable").ToLocalChecked(), GetrasterizerDiscardEnable, SetrasterizerDiscardEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("polygonMode").ToLocalChecked(), GetpolygonMode, SetpolygonMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("cullMode").ToLocalChecked(), GetcullMode, SetcullMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("frontFace").ToLocalChecked(), GetfrontFace, SetfrontFace, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthBiasEnable").ToLocalChecked(), GetdepthBiasEnable, SetdepthBiasEnable, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthBiasConstantFactor").ToLocalChecked(), GetdepthBiasConstantFactor, SetdepthBiasConstantFactor, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthBiasClamp").ToLocalChecked(), GetdepthBiasClamp, SetdepthBiasClamp, ctor);
  SetPrototypeAccessor(proto, Nan::New("depthBiasSlopeFactor").ToLocalChecked(), GetdepthBiasSlopeFactor, SetdepthBiasSlopeFactor, ctor);
  SetPrototypeAccessor(proto, Nan::New("lineWidth").ToLocalChecked(), GetlineWidth, SetlineWidth, ctor);
  Nan::Set(target, Nan::New("VkPipelineRasterizationStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineRasterizationStateCreateInfo::flush() {
  _VkPipelineRasterizationStateCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineRasterizationStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineRasterizationStateCreateInfo* self = new _VkPipelineRasterizationStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("depthClampEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("rasterizerDiscardEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("polygonMode").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("cullMode").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("frontFace").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("depthBiasEnable").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("depthBiasConstantFactor").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("depthBiasClamp").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("depthBiasSlopeFactor").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("lineWidth").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineRasterizationStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetsType) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetsType) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::Getflags) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::Setflags) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineRasterizationStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.flags", "Number");
  
    return;
  }
}// depthClampEnable
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetdepthClampEnable) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthClampEnable));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetdepthClampEnable) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.depthClampEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthClampEnable", "Number");
  
    return;
  }
}// rasterizerDiscardEnable
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetrasterizerDiscardEnable) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.rasterizerDiscardEnable));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetrasterizerDiscardEnable) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.rasterizerDiscardEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.rasterizerDiscardEnable", "Number");
  
    return;
  }
}// polygonMode
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetpolygonMode) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.polygonMode));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetpolygonMode) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.polygonMode = static_cast<VkPolygonMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.polygonMode", "Number");
  
    return;
  }
}// cullMode
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetcullMode) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.cullMode));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetcullMode) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.cullMode = static_cast<VkCullModeFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.cullMode", "Number");
  
    return;
  }
}// frontFace
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetfrontFace) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.frontFace));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetfrontFace) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.frontFace = static_cast<VkFrontFace>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.frontFace", "Number");
  
    return;
  }
}// depthBiasEnable
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetdepthBiasEnable) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthBiasEnable));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetdepthBiasEnable) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.depthBiasEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthBiasEnable", "Number");
  
    return;
  }
}// depthBiasConstantFactor
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetdepthBiasConstantFactor) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthBiasConstantFactor));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetdepthBiasConstantFactor) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.depthBiasConstantFactor = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthBiasConstantFactor", "Number");
  
    return;
  }
}// depthBiasClamp
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetdepthBiasClamp) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthBiasClamp));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetdepthBiasClamp) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.depthBiasClamp = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthBiasClamp", "Number");
  
    return;
  }
}// depthBiasSlopeFactor
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetdepthBiasSlopeFactor) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.depthBiasSlopeFactor));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetdepthBiasSlopeFactor) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.depthBiasSlopeFactor = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.depthBiasSlopeFactor", "Number");
  
    return;
  }
}// lineWidth
NAN_GETTER(_VkPipelineRasterizationStateCreateInfo::GetlineWidth) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.lineWidth));
}NAN_SETTER(_VkPipelineRasterizationStateCreateInfo::SetlineWidth) {
  _VkPipelineRasterizationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.lineWidth = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineRasterizationStateCreateInfo.lineWidth", "Number");
  
    return;
  }
}
/** ## END VkPipelineRasterizationStateCreateInfo ## **/

/** ## BEGIN VkViewport ## **/

class _VkViewport: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getx);
    static NAN_SETTER(Setx);
    
    static NAN_GETTER(Gety);
    static NAN_SETTER(Sety);
    
    static NAN_GETTER(Getwidth);
    static NAN_SETTER(Setwidth);
    
    static NAN_GETTER(Getheight);
    static NAN_SETTER(Setheight);
    
    static NAN_GETTER(GetminDepth);
    static NAN_SETTER(SetminDepth);
    
    static NAN_GETTER(GetmaxDepth);
    static NAN_SETTER(SetmaxDepth);
    

    // real instance
    VkViewport instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkViewport();
    ~_VkViewport();

};

/*
#include "index.h"
#include "VkViewport.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkViewport::constructor;

_VkViewport::_VkViewport() {
  
  
}

_VkViewport::~_VkViewport() {
  //printf("VkViewport deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkViewport::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkViewport::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkViewport").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("x").ToLocalChecked(), Getx, Setx, ctor);
  SetPrototypeAccessor(proto, Nan::New("y").ToLocalChecked(), Gety, Sety, ctor);
  SetPrototypeAccessor(proto, Nan::New("width").ToLocalChecked(), Getwidth, Setwidth, ctor);
  SetPrototypeAccessor(proto, Nan::New("height").ToLocalChecked(), Getheight, Setheight, ctor);
  SetPrototypeAccessor(proto, Nan::New("minDepth").ToLocalChecked(), GetminDepth, SetminDepth, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxDepth").ToLocalChecked(), GetmaxDepth, SetmaxDepth, ctor);
  Nan::Set(target, Nan::New("VkViewport").ToLocalChecked(), ctor->GetFunction());
}

bool _VkViewport::flush() {
  _VkViewport *self = this;
  
  return true;
}

NAN_METHOD(_VkViewport::New) {
  if (info.IsConstructCall()) {
    _VkViewport* self = new _VkViewport();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("x").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("y").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("width").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("height").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("minDepth").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("maxDepth").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkViewport constructor cannot be invoked without 'new'");
  }
};

// x
NAN_GETTER(_VkViewport::Getx) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.x));
}NAN_SETTER(_VkViewport::Setx) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  if (value->IsNumber()) {
    self->instance.x = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewport.x", "Number");
  
    return;
  }
}// y
NAN_GETTER(_VkViewport::Gety) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.y));
}NAN_SETTER(_VkViewport::Sety) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  if (value->IsNumber()) {
    self->instance.y = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewport.y", "Number");
  
    return;
  }
}// width
NAN_GETTER(_VkViewport::Getwidth) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.width));
}NAN_SETTER(_VkViewport::Setwidth) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  if (value->IsNumber()) {
    self->instance.width = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewport.width", "Number");
  
    return;
  }
}// height
NAN_GETTER(_VkViewport::Getheight) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.height));
}NAN_SETTER(_VkViewport::Setheight) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  if (value->IsNumber()) {
    self->instance.height = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewport.height", "Number");
  
    return;
  }
}// minDepth
NAN_GETTER(_VkViewport::GetminDepth) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.minDepth));
}NAN_SETTER(_VkViewport::SetminDepth) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  if (value->IsNumber()) {
    self->instance.minDepth = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewport.minDepth", "Number");
  
    return;
  }
}// maxDepth
NAN_GETTER(_VkViewport::GetmaxDepth) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxDepth));
}NAN_SETTER(_VkViewport::SetmaxDepth) {
  _VkViewport *self = Nan::ObjectWrap::Unwrap<_VkViewport>(info.This());
  if (value->IsNumber()) {
    self->instance.maxDepth = static_cast<float>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkViewport.maxDepth", "Number");
  
    return;
  }
}
/** ## END VkViewport ## **/

/** ## BEGIN VkPipelineViewportStateCreateInfo ## **/

class _VkPipelineViewportStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetviewportCount);
    static NAN_SETTER(SetviewportCount);
    
    std::vector<VkViewport>* vpViewports;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pViewports;
    static NAN_GETTER(GetpViewports);
    static NAN_SETTER(SetpViewports);
    
    static NAN_GETTER(GetscissorCount);
    static NAN_SETTER(SetscissorCount);
    
    std::vector<VkRect2D>* vpScissors;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pScissors;
    static NAN_GETTER(GetpScissors);
    static NAN_SETTER(SetpScissors);
    

    // real instance
    VkPipelineViewportStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineViewportStateCreateInfo();
    ~_VkPipelineViewportStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineViewportStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineViewportStateCreateInfo::constructor;

_VkPipelineViewportStateCreateInfo::_VkPipelineViewportStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
  vpViewports = new std::vector<VkViewport>;
  vpScissors = new std::vector<VkRect2D>;
  
}

_VkPipelineViewportStateCreateInfo::~_VkPipelineViewportStateCreateInfo() {
  //printf("VkPipelineViewportStateCreateInfo deconstructed!!\n");
  
  
  
  
  vpViewports->clear();
  delete vpViewports;
  
  pViewports.Reset();
  
  
  vpScissors->clear();
  delete vpScissors;
  
  pScissors.Reset();
  
}

void _VkPipelineViewportStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineViewportStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineViewportStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewportCount").ToLocalChecked(), GetviewportCount, SetviewportCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pViewports").ToLocalChecked(), GetpViewports, SetpViewports, ctor);
  SetPrototypeAccessor(proto, Nan::New("scissorCount").ToLocalChecked(), GetscissorCount, SetscissorCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pScissors").ToLocalChecked(), GetpScissors, SetpScissors, ctor);
  Nan::Set(target, Nan::New("VkPipelineViewportStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineViewportStateCreateInfo::flush() {
  _VkPipelineViewportStateCreateInfo *self = this;
  if (!(self->pViewports.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pViewports);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.viewportCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'viewportCount' for 'VkPipelineViewportStateCreateInfo.pViewports'");
      return false;
    }
    std::vector<VkViewport>* data = self->vpViewports;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkViewport::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.pViewports", "[object VkViewport]");
  
        return false;
      }
      _VkViewport* result = Nan::ObjectWrap::Unwrap<_VkViewport>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pViewports = data->data();
  }if (!(self->pScissors.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pScissors);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.scissorCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'scissorCount' for 'VkPipelineViewportStateCreateInfo.pScissors'");
      return false;
    }
    std::vector<VkRect2D>* data = self->vpScissors;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkRect2D::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.pScissors", "[object VkRect2D]");
  
        return false;
      }
      _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pScissors = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineViewportStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineViewportStateCreateInfo* self = new _VkPipelineViewportStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("viewportCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pViewports").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("scissorCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pScissors").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineViewportStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineViewportStateCreateInfo::GetsType) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineViewportStateCreateInfo::SetsType) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineViewportStateCreateInfo::Getflags) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineViewportStateCreateInfo::Setflags) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineViewportStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.flags", "Number");
  
    return;
  }
}// viewportCount
NAN_GETTER(_VkPipelineViewportStateCreateInfo::GetviewportCount) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewportCount));
}NAN_SETTER(_VkPipelineViewportStateCreateInfo::SetviewportCount) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.viewportCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.viewportCount", "Number");
  
    return;
  }
}// pViewports
NAN_GETTER(_VkPipelineViewportStateCreateInfo::GetpViewports) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  if (self->pViewports.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pViewports);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineViewportStateCreateInfo::SetpViewports) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pViewports.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pViewports.Reset();
      self->instance.pViewports = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.pViewports", "[object VkViewport]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pViewports = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.pViewports", "[object VkViewport]");
  
    return;
  }
}// scissorCount
NAN_GETTER(_VkPipelineViewportStateCreateInfo::GetscissorCount) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.scissorCount));
}NAN_SETTER(_VkPipelineViewportStateCreateInfo::SetscissorCount) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.scissorCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.scissorCount", "Number");
  
    return;
  }
}// pScissors
NAN_GETTER(_VkPipelineViewportStateCreateInfo::GetpScissors) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  if (self->pScissors.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pScissors);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineViewportStateCreateInfo::SetpScissors) {
  _VkPipelineViewportStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pScissors.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pScissors.Reset();
      self->instance.pScissors = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.pScissors", "[object VkRect2D]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pScissors = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineViewportStateCreateInfo.pScissors", "[object VkRect2D]");
  
    return;
  }
}
/** ## END VkPipelineViewportStateCreateInfo ## **/

/** ## BEGIN VkPipelineTessellationStateCreateInfo ## **/

class _VkPipelineTessellationStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetpatchControlPoints);
    static NAN_SETTER(SetpatchControlPoints);
    

    // real instance
    VkPipelineTessellationStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineTessellationStateCreateInfo();
    ~_VkPipelineTessellationStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineTessellationStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineTessellationStateCreateInfo::constructor;

_VkPipelineTessellationStateCreateInfo::_VkPipelineTessellationStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
  
}

_VkPipelineTessellationStateCreateInfo::~_VkPipelineTessellationStateCreateInfo() {
  //printf("VkPipelineTessellationStateCreateInfo deconstructed!!\n");
  
  
  
  
}

void _VkPipelineTessellationStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineTessellationStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineTessellationStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("patchControlPoints").ToLocalChecked(), GetpatchControlPoints, SetpatchControlPoints, ctor);
  Nan::Set(target, Nan::New("VkPipelineTessellationStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineTessellationStateCreateInfo::flush() {
  _VkPipelineTessellationStateCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineTessellationStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineTessellationStateCreateInfo* self = new _VkPipelineTessellationStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("patchControlPoints").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineTessellationStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineTessellationStateCreateInfo::GetsType) {
  _VkPipelineTessellationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineTessellationStateCreateInfo::SetsType) {
  _VkPipelineTessellationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineTessellationStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineTessellationStateCreateInfo::Getflags) {
  _VkPipelineTessellationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineTessellationStateCreateInfo::Setflags) {
  _VkPipelineTessellationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineTessellationStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineTessellationStateCreateInfo.flags", "Number");
  
    return;
  }
}// patchControlPoints
NAN_GETTER(_VkPipelineTessellationStateCreateInfo::GetpatchControlPoints) {
  _VkPipelineTessellationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.patchControlPoints));
}NAN_SETTER(_VkPipelineTessellationStateCreateInfo::SetpatchControlPoints) {
  _VkPipelineTessellationStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.patchControlPoints = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineTessellationStateCreateInfo.patchControlPoints", "Number");
  
    return;
  }
}
/** ## END VkPipelineTessellationStateCreateInfo ## **/

/** ## BEGIN VkPipelineInputAssemblyStateCreateInfo ## **/

class _VkPipelineInputAssemblyStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(Gettopology);
    static NAN_SETTER(Settopology);
    
    static NAN_GETTER(GetprimitiveRestartEnable);
    static NAN_SETTER(SetprimitiveRestartEnable);
    

    // real instance
    VkPipelineInputAssemblyStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineInputAssemblyStateCreateInfo();
    ~_VkPipelineInputAssemblyStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineInputAssemblyStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineInputAssemblyStateCreateInfo::constructor;

_VkPipelineInputAssemblyStateCreateInfo::_VkPipelineInputAssemblyStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
  
}

_VkPipelineInputAssemblyStateCreateInfo::~_VkPipelineInputAssemblyStateCreateInfo() {
  //printf("VkPipelineInputAssemblyStateCreateInfo deconstructed!!\n");
  
  
  
  
  
}

void _VkPipelineInputAssemblyStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineInputAssemblyStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineInputAssemblyStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("topology").ToLocalChecked(), Gettopology, Settopology, ctor);
  SetPrototypeAccessor(proto, Nan::New("primitiveRestartEnable").ToLocalChecked(), GetprimitiveRestartEnable, SetprimitiveRestartEnable, ctor);
  Nan::Set(target, Nan::New("VkPipelineInputAssemblyStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineInputAssemblyStateCreateInfo::flush() {
  _VkPipelineInputAssemblyStateCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkPipelineInputAssemblyStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineInputAssemblyStateCreateInfo* self = new _VkPipelineInputAssemblyStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("topology").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("primitiveRestartEnable").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineInputAssemblyStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineInputAssemblyStateCreateInfo::GetsType) {
  _VkPipelineInputAssemblyStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineInputAssemblyStateCreateInfo::SetsType) {
  _VkPipelineInputAssemblyStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineInputAssemblyStateCreateInfo::Getflags) {
  _VkPipelineInputAssemblyStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineInputAssemblyStateCreateInfo::Setflags) {
  _VkPipelineInputAssemblyStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineInputAssemblyStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.flags", "Number");
  
    return;
  }
}// topology
NAN_GETTER(_VkPipelineInputAssemblyStateCreateInfo::Gettopology) {
  _VkPipelineInputAssemblyStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.topology));
}NAN_SETTER(_VkPipelineInputAssemblyStateCreateInfo::Settopology) {
  _VkPipelineInputAssemblyStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.topology = static_cast<VkPrimitiveTopology>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.topology", "Number");
  
    return;
  }
}// primitiveRestartEnable
NAN_GETTER(_VkPipelineInputAssemblyStateCreateInfo::GetprimitiveRestartEnable) {
  _VkPipelineInputAssemblyStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.primitiveRestartEnable));
}NAN_SETTER(_VkPipelineInputAssemblyStateCreateInfo::SetprimitiveRestartEnable) {
  _VkPipelineInputAssemblyStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(info.This());
  if (value->IsBoolean() || value->IsNumber()) {
    self->instance.primitiveRestartEnable = static_cast<uint32_t>(Nan::To<bool>(value).FromMaybe(false)) ? VK_TRUE : VK_FALSE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineInputAssemblyStateCreateInfo.primitiveRestartEnable", "Number");
  
    return;
  }
}
/** ## END VkPipelineInputAssemblyStateCreateInfo ## **/

/** ## BEGIN VkVertexInputAttributeDescription ## **/

class _VkVertexInputAttributeDescription: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getlocation);
    static NAN_SETTER(Setlocation);
    
    static NAN_GETTER(Getbinding);
    static NAN_SETTER(Setbinding);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    

    // real instance
    VkVertexInputAttributeDescription instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkVertexInputAttributeDescription();
    ~_VkVertexInputAttributeDescription();

};

/*
#include "index.h"
#include "VkVertexInputAttributeDescription.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkVertexInputAttributeDescription::constructor;

_VkVertexInputAttributeDescription::_VkVertexInputAttributeDescription() {
  
  
}

_VkVertexInputAttributeDescription::~_VkVertexInputAttributeDescription() {
  //printf("VkVertexInputAttributeDescription deconstructed!!\n");
  
  
  
  
  
}

void _VkVertexInputAttributeDescription::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkVertexInputAttributeDescription::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkVertexInputAttributeDescription").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("location").ToLocalChecked(), Getlocation, Setlocation, ctor);
  SetPrototypeAccessor(proto, Nan::New("binding").ToLocalChecked(), Getbinding, Setbinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  Nan::Set(target, Nan::New("VkVertexInputAttributeDescription").ToLocalChecked(), ctor->GetFunction());
}

bool _VkVertexInputAttributeDescription::flush() {
  _VkVertexInputAttributeDescription *self = this;
  
  return true;
}

NAN_METHOD(_VkVertexInputAttributeDescription::New) {
  if (info.IsConstructCall()) {
    _VkVertexInputAttributeDescription* self = new _VkVertexInputAttributeDescription();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("location").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("binding").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("offset").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkVertexInputAttributeDescription constructor cannot be invoked without 'new'");
  }
};

// location
NAN_GETTER(_VkVertexInputAttributeDescription::Getlocation) {
  _VkVertexInputAttributeDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.location));
}NAN_SETTER(_VkVertexInputAttributeDescription::Setlocation) {
  _VkVertexInputAttributeDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.location = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputAttributeDescription.location", "Number");
  
    return;
  }
}// binding
NAN_GETTER(_VkVertexInputAttributeDescription::Getbinding) {
  _VkVertexInputAttributeDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.binding));
}NAN_SETTER(_VkVertexInputAttributeDescription::Setbinding) {
  _VkVertexInputAttributeDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.binding = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputAttributeDescription.binding", "Number");
  
    return;
  }
}// format
NAN_GETTER(_VkVertexInputAttributeDescription::Getformat) {
  _VkVertexInputAttributeDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkVertexInputAttributeDescription::Setformat) {
  _VkVertexInputAttributeDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputAttributeDescription.format", "Number");
  
    return;
  }
}// offset
NAN_GETTER(_VkVertexInputAttributeDescription::Getoffset) {
  _VkVertexInputAttributeDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkVertexInputAttributeDescription::Setoffset) {
  _VkVertexInputAttributeDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputAttributeDescription.offset", "Number");
  
    return;
  }
}
/** ## END VkVertexInputAttributeDescription ## **/

/** ## BEGIN VkVertexInputBindingDescription ## **/

class _VkVertexInputBindingDescription: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getbinding);
    static NAN_SETTER(Setbinding);
    
    static NAN_GETTER(Getstride);
    static NAN_SETTER(Setstride);
    
    static NAN_GETTER(GetinputRate);
    static NAN_SETTER(SetinputRate);
    

    // real instance
    VkVertexInputBindingDescription instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkVertexInputBindingDescription();
    ~_VkVertexInputBindingDescription();

};

/*
#include "index.h"
#include "VkVertexInputBindingDescription.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkVertexInputBindingDescription::constructor;

_VkVertexInputBindingDescription::_VkVertexInputBindingDescription() {
  
  
}

_VkVertexInputBindingDescription::~_VkVertexInputBindingDescription() {
  //printf("VkVertexInputBindingDescription deconstructed!!\n");
  
  
  
  
}

void _VkVertexInputBindingDescription::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkVertexInputBindingDescription::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkVertexInputBindingDescription").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("binding").ToLocalChecked(), Getbinding, Setbinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("stride").ToLocalChecked(), Getstride, Setstride, ctor);
  SetPrototypeAccessor(proto, Nan::New("inputRate").ToLocalChecked(), GetinputRate, SetinputRate, ctor);
  Nan::Set(target, Nan::New("VkVertexInputBindingDescription").ToLocalChecked(), ctor->GetFunction());
}

bool _VkVertexInputBindingDescription::flush() {
  _VkVertexInputBindingDescription *self = this;
  
  return true;
}

NAN_METHOD(_VkVertexInputBindingDescription::New) {
  if (info.IsConstructCall()) {
    _VkVertexInputBindingDescription* self = new _VkVertexInputBindingDescription();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("binding").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("stride").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("inputRate").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkVertexInputBindingDescription constructor cannot be invoked without 'new'");
  }
};

// binding
NAN_GETTER(_VkVertexInputBindingDescription::Getbinding) {
  _VkVertexInputBindingDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.binding));
}NAN_SETTER(_VkVertexInputBindingDescription::Setbinding) {
  _VkVertexInputBindingDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.binding = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputBindingDescription.binding", "Number");
  
    return;
  }
}// stride
NAN_GETTER(_VkVertexInputBindingDescription::Getstride) {
  _VkVertexInputBindingDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stride));
}NAN_SETTER(_VkVertexInputBindingDescription::Setstride) {
  _VkVertexInputBindingDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.stride = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputBindingDescription.stride", "Number");
  
    return;
  }
}// inputRate
NAN_GETTER(_VkVertexInputBindingDescription::GetinputRate) {
  _VkVertexInputBindingDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDescription>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.inputRate));
}NAN_SETTER(_VkVertexInputBindingDescription::SetinputRate) {
  _VkVertexInputBindingDescription *self = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDescription>(info.This());
  if (value->IsNumber()) {
    self->instance.inputRate = static_cast<VkVertexInputRate>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkVertexInputBindingDescription.inputRate", "Number");
  
    return;
  }
}
/** ## END VkVertexInputBindingDescription ## **/

/** ## BEGIN VkPipelineVertexInputStateCreateInfo ## **/

class _VkPipelineVertexInputStateCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetvertexBindingDescriptionCount);
    static NAN_SETTER(SetvertexBindingDescriptionCount);
    
    std::vector<VkVertexInputBindingDescription>* vpVertexBindingDescriptions;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pVertexBindingDescriptions;
    static NAN_GETTER(GetpVertexBindingDescriptions);
    static NAN_SETTER(SetpVertexBindingDescriptions);
    
    static NAN_GETTER(GetvertexAttributeDescriptionCount);
    static NAN_SETTER(SetvertexAttributeDescriptionCount);
    
    std::vector<VkVertexInputAttributeDescription>* vpVertexAttributeDescriptions;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pVertexAttributeDescriptions;
    static NAN_GETTER(GetpVertexAttributeDescriptions);
    static NAN_SETTER(SetpVertexAttributeDescriptions);
    

    // real instance
    VkPipelineVertexInputStateCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkPipelineVertexInputStateCreateInfo();
    ~_VkPipelineVertexInputStateCreateInfo();

};

/*
#include "index.h"
#include "VkPipelineVertexInputStateCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkPipelineVertexInputStateCreateInfo::constructor;

_VkPipelineVertexInputStateCreateInfo::_VkPipelineVertexInputStateCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
  vpVertexBindingDescriptions = new std::vector<VkVertexInputBindingDescription>;
  vpVertexAttributeDescriptions = new std::vector<VkVertexInputAttributeDescription>;
  
}

_VkPipelineVertexInputStateCreateInfo::~_VkPipelineVertexInputStateCreateInfo() {
  //printf("VkPipelineVertexInputStateCreateInfo deconstructed!!\n");
  
  
  
  
  vpVertexBindingDescriptions->clear();
  delete vpVertexBindingDescriptions;
  
  pVertexBindingDescriptions.Reset();
  
  
  vpVertexAttributeDescriptions->clear();
  delete vpVertexAttributeDescriptions;
  
  pVertexAttributeDescriptions.Reset();
  
}

void _VkPipelineVertexInputStateCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkPipelineVertexInputStateCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkPipelineVertexInputStateCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexBindingDescriptionCount").ToLocalChecked(), GetvertexBindingDescriptionCount, SetvertexBindingDescriptionCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pVertexBindingDescriptions").ToLocalChecked(), GetpVertexBindingDescriptions, SetpVertexBindingDescriptions, ctor);
  SetPrototypeAccessor(proto, Nan::New("vertexAttributeDescriptionCount").ToLocalChecked(), GetvertexAttributeDescriptionCount, SetvertexAttributeDescriptionCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pVertexAttributeDescriptions").ToLocalChecked(), GetpVertexAttributeDescriptions, SetpVertexAttributeDescriptions, ctor);
  Nan::Set(target, Nan::New("VkPipelineVertexInputStateCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkPipelineVertexInputStateCreateInfo::flush() {
  _VkPipelineVertexInputStateCreateInfo *self = this;
  if (!(self->pVertexBindingDescriptions.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pVertexBindingDescriptions);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.vertexBindingDescriptionCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'vertexBindingDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions'");
      return false;
    }
    std::vector<VkVertexInputBindingDescription>* data = self->vpVertexBindingDescriptions;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkVertexInputBindingDescription::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions", "[object VkVertexInputBindingDescription]");
  
        return false;
      }
      _VkVertexInputBindingDescription* result = Nan::ObjectWrap::Unwrap<_VkVertexInputBindingDescription>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pVertexBindingDescriptions = data->data();
  }if (!(self->pVertexAttributeDescriptions.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pVertexAttributeDescriptions);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.vertexAttributeDescriptionCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'vertexAttributeDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions'");
      return false;
    }
    std::vector<VkVertexInputAttributeDescription>* data = self->vpVertexAttributeDescriptions;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkVertexInputAttributeDescription::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions", "[object VkVertexInputAttributeDescription]");
  
        return false;
      }
      _VkVertexInputAttributeDescription* result = Nan::ObjectWrap::Unwrap<_VkVertexInputAttributeDescription>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pVertexAttributeDescriptions = data->data();
  }
  return true;
}

NAN_METHOD(_VkPipelineVertexInputStateCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkPipelineVertexInputStateCreateInfo* self = new _VkPipelineVertexInputStateCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("vertexBindingDescriptionCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pVertexBindingDescriptions").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("vertexAttributeDescriptionCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pVertexAttributeDescriptions").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkPipelineVertexInputStateCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkPipelineVertexInputStateCreateInfo::GetsType) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkPipelineVertexInputStateCreateInfo::SetsType) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkPipelineVertexInputStateCreateInfo::Getflags) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkPipelineVertexInputStateCreateInfo::Setflags) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineVertexInputStateCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.flags", "Number");
  
    return;
  }
}// vertexBindingDescriptionCount
NAN_GETTER(_VkPipelineVertexInputStateCreateInfo::GetvertexBindingDescriptionCount) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexBindingDescriptionCount));
}NAN_SETTER(_VkPipelineVertexInputStateCreateInfo::SetvertexBindingDescriptionCount) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexBindingDescriptionCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount", "Number");
  
    return;
  }
}// pVertexBindingDescriptions
NAN_GETTER(_VkPipelineVertexInputStateCreateInfo::GetpVertexBindingDescriptions) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  if (self->pVertexBindingDescriptions.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pVertexBindingDescriptions);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineVertexInputStateCreateInfo::SetpVertexBindingDescriptions) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pVertexBindingDescriptions.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pVertexBindingDescriptions.Reset();
      self->instance.pVertexBindingDescriptions = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions", "[object VkVertexInputBindingDescription]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pVertexBindingDescriptions = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions", "[object VkVertexInputBindingDescription]");
  
    return;
  }
}// vertexAttributeDescriptionCount
NAN_GETTER(_VkPipelineVertexInputStateCreateInfo::GetvertexAttributeDescriptionCount) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.vertexAttributeDescriptionCount));
}NAN_SETTER(_VkPipelineVertexInputStateCreateInfo::SetvertexAttributeDescriptionCount) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.vertexAttributeDescriptionCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount", "Number");
  
    return;
  }
}// pVertexAttributeDescriptions
NAN_GETTER(_VkPipelineVertexInputStateCreateInfo::GetpVertexAttributeDescriptions) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  if (self->pVertexAttributeDescriptions.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pVertexAttributeDescriptions);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkPipelineVertexInputStateCreateInfo::SetpVertexAttributeDescriptions) {
  _VkPipelineVertexInputStateCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pVertexAttributeDescriptions.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pVertexAttributeDescriptions.Reset();
      self->instance.pVertexAttributeDescriptions = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions", "[object VkVertexInputAttributeDescription]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pVertexAttributeDescriptions = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions", "[object VkVertexInputAttributeDescription]");
  
    return;
  }
}
/** ## END VkPipelineVertexInputStateCreateInfo ## **/

/** ## BEGIN VkGraphicsPipelineCreateInfo ## **/

class _VkGraphicsPipelineCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetstageCount);
    static NAN_SETTER(SetstageCount);
    
    std::vector<VkPipelineShaderStageCreateInfo>* vpStages;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pStages;
    static NAN_GETTER(GetpStages);
    static NAN_SETTER(SetpStages);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pVertexInputState;
      static NAN_GETTER(GetpVertexInputState);
    static NAN_SETTER(SetpVertexInputState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pInputAssemblyState;
      static NAN_GETTER(GetpInputAssemblyState);
    static NAN_SETTER(SetpInputAssemblyState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pTessellationState;
      static NAN_GETTER(GetpTessellationState);
    static NAN_SETTER(SetpTessellationState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pViewportState;
      static NAN_GETTER(GetpViewportState);
    static NAN_SETTER(SetpViewportState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pRasterizationState;
      static NAN_GETTER(GetpRasterizationState);
    static NAN_SETTER(SetpRasterizationState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pMultisampleState;
      static NAN_GETTER(GetpMultisampleState);
    static NAN_SETTER(SetpMultisampleState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pDepthStencilState;
      static NAN_GETTER(GetpDepthStencilState);
    static NAN_SETTER(SetpDepthStencilState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pColorBlendState;
      static NAN_GETTER(GetpColorBlendState);
    static NAN_SETTER(SetpColorBlendState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pDynamicState;
      static NAN_GETTER(GetpDynamicState);
    static NAN_SETTER(SetpDynamicState);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> layout;
      static NAN_GETTER(Getlayout);
    static NAN_SETTER(Setlayout);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> renderPass;
      static NAN_GETTER(GetrenderPass);
    static NAN_SETTER(SetrenderPass);
    
    static NAN_GETTER(Getsubpass);
    static NAN_SETTER(Setsubpass);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> basePipelineHandle;
      static NAN_GETTER(GetbasePipelineHandle);
    static NAN_SETTER(SetbasePipelineHandle);
    
    static NAN_GETTER(GetbasePipelineIndex);
    static NAN_SETTER(SetbasePipelineIndex);
    

    // real instance
    VkGraphicsPipelineCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkGraphicsPipelineCreateInfo();
    ~_VkGraphicsPipelineCreateInfo();

};

/*
#include "index.h"
#include "VkGraphicsPipelineCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkGraphicsPipelineCreateInfo::constructor;

_VkGraphicsPipelineCreateInfo::_VkGraphicsPipelineCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
  vpStages = new std::vector<VkPipelineShaderStageCreateInfo>;
  
}

_VkGraphicsPipelineCreateInfo::~_VkGraphicsPipelineCreateInfo() {
  //printf("VkGraphicsPipelineCreateInfo deconstructed!!\n");
  
  
  
  
  vpStages->clear();
  delete vpStages;
  
  pStages.Reset();
  
  pVertexInputState.Reset();
  
  pInputAssemblyState.Reset();
  
  pTessellationState.Reset();
  
  pViewportState.Reset();
  
  pRasterizationState.Reset();
  
  pMultisampleState.Reset();
  
  pDepthStencilState.Reset();
  
  pColorBlendState.Reset();
  
  pDynamicState.Reset();
  
  
  
  
  
  
}

void _VkGraphicsPipelineCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkGraphicsPipelineCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkGraphicsPipelineCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("stageCount").ToLocalChecked(), GetstageCount, SetstageCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pStages").ToLocalChecked(), GetpStages, SetpStages, ctor);
  SetPrototypeAccessor(proto, Nan::New("pVertexInputState").ToLocalChecked(), GetpVertexInputState, SetpVertexInputState, ctor);
  SetPrototypeAccessor(proto, Nan::New("pInputAssemblyState").ToLocalChecked(), GetpInputAssemblyState, SetpInputAssemblyState, ctor);
  SetPrototypeAccessor(proto, Nan::New("pTessellationState").ToLocalChecked(), GetpTessellationState, SetpTessellationState, ctor);
  SetPrototypeAccessor(proto, Nan::New("pViewportState").ToLocalChecked(), GetpViewportState, SetpViewportState, ctor);
  SetPrototypeAccessor(proto, Nan::New("pRasterizationState").ToLocalChecked(), GetpRasterizationState, SetpRasterizationState, ctor);
  SetPrototypeAccessor(proto, Nan::New("pMultisampleState").ToLocalChecked(), GetpMultisampleState, SetpMultisampleState, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDepthStencilState").ToLocalChecked(), GetpDepthStencilState, SetpDepthStencilState, ctor);
  SetPrototypeAccessor(proto, Nan::New("pColorBlendState").ToLocalChecked(), GetpColorBlendState, SetpColorBlendState, ctor);
  SetPrototypeAccessor(proto, Nan::New("pDynamicState").ToLocalChecked(), GetpDynamicState, SetpDynamicState, ctor);
  SetPrototypeAccessor(proto, Nan::New("layout").ToLocalChecked(), Getlayout, Setlayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("renderPass").ToLocalChecked(), GetrenderPass, SetrenderPass, ctor);
  SetPrototypeAccessor(proto, Nan::New("subpass").ToLocalChecked(), Getsubpass, Setsubpass, ctor);
  SetPrototypeAccessor(proto, Nan::New("basePipelineHandle").ToLocalChecked(), GetbasePipelineHandle, SetbasePipelineHandle, ctor);
  SetPrototypeAccessor(proto, Nan::New("basePipelineIndex").ToLocalChecked(), GetbasePipelineIndex, SetbasePipelineIndex, ctor);
  Nan::Set(target, Nan::New("VkGraphicsPipelineCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkGraphicsPipelineCreateInfo::flush() {
  _VkGraphicsPipelineCreateInfo *self = this;
  if (!(self->pStages.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pStages);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.stageCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'stageCount' for 'VkGraphicsPipelineCreateInfo.pStages'");
      return false;
    }
    std::vector<VkPipelineShaderStageCreateInfo>* data = self->vpStages;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkPipelineShaderStageCreateInfo::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
        return false;
      }
      _VkPipelineShaderStageCreateInfo* result = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pStages = data->data();
  }
  return true;
}

NAN_METHOD(_VkGraphicsPipelineCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkGraphicsPipelineCreateInfo* self = new _VkGraphicsPipelineCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("stageCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pStages").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pVertexInputState").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("pInputAssemblyState").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pTessellationState").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pViewportState").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("pRasterizationState").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("pMultisampleState").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("pDepthStencilState").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("pColorBlendState").ToLocalChecked();
      v8::Local<v8::String> sAccess13 = Nan::New("pDynamicState").ToLocalChecked();
      v8::Local<v8::String> sAccess14 = Nan::New("layout").ToLocalChecked();
      v8::Local<v8::String> sAccess15 = Nan::New("renderPass").ToLocalChecked();
      v8::Local<v8::String> sAccess16 = Nan::New("subpass").ToLocalChecked();
      v8::Local<v8::String> sAccess17 = Nan::New("basePipelineHandle").ToLocalChecked();
      v8::Local<v8::String> sAccess18 = Nan::New("basePipelineIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      if (obj->Has(sAccess13)) info.This()->Set(sAccess13, obj->Get(sAccess13));
      if (obj->Has(sAccess14)) info.This()->Set(sAccess14, obj->Get(sAccess14));
      if (obj->Has(sAccess15)) info.This()->Set(sAccess15, obj->Get(sAccess15));
      if (obj->Has(sAccess16)) info.This()->Set(sAccess16, obj->Get(sAccess16));
      if (obj->Has(sAccess17)) info.This()->Set(sAccess17, obj->Get(sAccess17));
      if (obj->Has(sAccess18)) info.This()->Set(sAccess18, obj->Get(sAccess18));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkGraphicsPipelineCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetsType) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetsType) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkGraphicsPipelineCreateInfo::Getflags) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::Setflags) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.flags", "Number");
  
    return;
  }
}// stageCount
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetstageCount) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stageCount));
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetstageCount) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.stageCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.stageCount", "Number");
  
    return;
  }
}// pStages
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpStages) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pStages.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pStages);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpStages) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pStages.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pStages.Reset();
      self->instance.pStages = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pStages = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pStages", "[object VkPipelineShaderStageCreateInfo]");
  
    return;
  }
}// pVertexInputState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpVertexInputState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pVertexInputState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pVertexInputState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpVertexInputState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineVertexInputStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pVertexInputState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineVertexInputStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineVertexInputStateCreateInfo>(obj);
      inst->flush();
      self->instance.pVertexInputState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pVertexInputState", "[object VkPipelineVertexInputStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pVertexInputState.Reset();
    self->instance.pVertexInputState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pVertexInputState", "[object VkPipelineVertexInputStateCreateInfo]");
  
    return;
  }
}// pInputAssemblyState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpInputAssemblyState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pInputAssemblyState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pInputAssemblyState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpInputAssemblyState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineInputAssemblyStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pInputAssemblyState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineInputAssemblyStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineInputAssemblyStateCreateInfo>(obj);
      inst->flush();
      self->instance.pInputAssemblyState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pInputAssemblyState", "[object VkPipelineInputAssemblyStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pInputAssemblyState.Reset();
    self->instance.pInputAssemblyState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pInputAssemblyState", "[object VkPipelineInputAssemblyStateCreateInfo]");
  
    return;
  }
}// pTessellationState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpTessellationState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pTessellationState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pTessellationState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpTessellationState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineTessellationStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pTessellationState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineTessellationStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineTessellationStateCreateInfo>(obj);
      inst->flush();
      self->instance.pTessellationState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pTessellationState", "[object VkPipelineTessellationStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pTessellationState.Reset();
    self->instance.pTessellationState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pTessellationState", "[object VkPipelineTessellationStateCreateInfo]");
  
    return;
  }
}// pViewportState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpViewportState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pViewportState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pViewportState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpViewportState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineViewportStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pViewportState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineViewportStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineViewportStateCreateInfo>(obj);
      inst->flush();
      self->instance.pViewportState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pViewportState", "[object VkPipelineViewportStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pViewportState.Reset();
    self->instance.pViewportState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pViewportState", "[object VkPipelineViewportStateCreateInfo]");
  
    return;
  }
}// pRasterizationState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpRasterizationState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pRasterizationState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pRasterizationState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpRasterizationState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineRasterizationStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pRasterizationState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineRasterizationStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineRasterizationStateCreateInfo>(obj);
      inst->flush();
      self->instance.pRasterizationState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pRasterizationState", "[object VkPipelineRasterizationStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pRasterizationState.Reset();
    self->instance.pRasterizationState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pRasterizationState", "[object VkPipelineRasterizationStateCreateInfo]");
  
    return;
  }
}// pMultisampleState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpMultisampleState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pMultisampleState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pMultisampleState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpMultisampleState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineMultisampleStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pMultisampleState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineMultisampleStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineMultisampleStateCreateInfo>(obj);
      inst->flush();
      self->instance.pMultisampleState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pMultisampleState", "[object VkPipelineMultisampleStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pMultisampleState.Reset();
    self->instance.pMultisampleState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pMultisampleState", "[object VkPipelineMultisampleStateCreateInfo]");
  
    return;
  }
}// pDepthStencilState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpDepthStencilState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pDepthStencilState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDepthStencilState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpDepthStencilState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineDepthStencilStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pDepthStencilState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineDepthStencilStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineDepthStencilStateCreateInfo>(obj);
      inst->flush();
      self->instance.pDepthStencilState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pDepthStencilState", "[object VkPipelineDepthStencilStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pDepthStencilState.Reset();
    self->instance.pDepthStencilState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pDepthStencilState", "[object VkPipelineDepthStencilStateCreateInfo]");
  
    return;
  }
}// pColorBlendState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpColorBlendState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pColorBlendState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pColorBlendState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpColorBlendState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineColorBlendStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pColorBlendState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineColorBlendStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineColorBlendStateCreateInfo>(obj);
      inst->flush();
      self->instance.pColorBlendState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pColorBlendState", "[object VkPipelineColorBlendStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pColorBlendState.Reset();
    self->instance.pColorBlendState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pColorBlendState", "[object VkPipelineColorBlendStateCreateInfo]");
  
    return;
  }
}// pDynamicState
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetpDynamicState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->pDynamicState.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pDynamicState);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetpDynamicState) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineDynamicStateCreateInfo::constructor)->HasInstance(obj)) {
      self->pDynamicState.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineDynamicStateCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineDynamicStateCreateInfo>(obj);
      inst->flush();
      self->instance.pDynamicState = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pDynamicState", "[object VkPipelineDynamicStateCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pDynamicState.Reset();
    self->instance.pDynamicState = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.pDynamicState", "[object VkPipelineDynamicStateCreateInfo]");
  
    return;
  }
}// layout
NAN_GETTER(_VkGraphicsPipelineCreateInfo::Getlayout) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->layout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->layout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::Setlayout) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineLayout::constructor)->HasInstance(obj)) {
      self->layout.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineLayout* inst = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(obj);
      ;
      self->instance.layout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.layout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->layout.Reset();
    self->instance.layout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.layout", "[object VkPipelineLayout]");
  
    return;
  }
}// renderPass
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetrenderPass) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->renderPass.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->renderPass);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetrenderPass) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkRenderPass::constructor)->HasInstance(obj)) {
      self->renderPass.Reset<v8::Object>(value.As<v8::Object>());
      _VkRenderPass* inst = Nan::ObjectWrap::Unwrap<_VkRenderPass>(obj);
      ;
      self->instance.renderPass = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.renderPass", "[object VkRenderPass]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->renderPass.Reset();
    self->instance.renderPass = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.renderPass", "[object VkRenderPass]");
  
    return;
  }
}// subpass
NAN_GETTER(_VkGraphicsPipelineCreateInfo::Getsubpass) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.subpass));
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::Setsubpass) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.subpass = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.subpass", "Number");
  
    return;
  }
}// basePipelineHandle
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetbasePipelineHandle) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (self->basePipelineHandle.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->basePipelineHandle);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetbasePipelineHandle) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipeline::constructor)->HasInstance(obj)) {
      self->basePipelineHandle.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipeline* inst = Nan::ObjectWrap::Unwrap<_VkPipeline>(obj);
      ;
      self->instance.basePipelineHandle = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.basePipelineHandle", "[object VkPipeline]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->basePipelineHandle.Reset();
    self->instance.basePipelineHandle = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.basePipelineHandle", "[object VkPipeline]");
  
    return;
  }
}// basePipelineIndex
NAN_GETTER(_VkGraphicsPipelineCreateInfo::GetbasePipelineIndex) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.basePipelineIndex));
}NAN_SETTER(_VkGraphicsPipelineCreateInfo::SetbasePipelineIndex) {
  _VkGraphicsPipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.basePipelineIndex = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkGraphicsPipelineCreateInfo.basePipelineIndex", "Number");
  
    return;
  }
}
/** ## END VkGraphicsPipelineCreateInfo ## **/

/** ## BEGIN VkComputePipelineCreateInfo ## **/

class _VkComputePipelineCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> stage;
      static NAN_GETTER(Getstage);
    static NAN_SETTER(Setstage);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> layout;
      static NAN_GETTER(Getlayout);
    static NAN_SETTER(Setlayout);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> basePipelineHandle;
      static NAN_GETTER(GetbasePipelineHandle);
    static NAN_SETTER(SetbasePipelineHandle);
    
    static NAN_GETTER(GetbasePipelineIndex);
    static NAN_SETTER(SetbasePipelineIndex);
    

    // real instance
    VkComputePipelineCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkComputePipelineCreateInfo();
    ~_VkComputePipelineCreateInfo();

};

/*
#include "index.h"
#include "VkComputePipelineCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkComputePipelineCreateInfo::constructor;

_VkComputePipelineCreateInfo::_VkComputePipelineCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
  
}

_VkComputePipelineCreateInfo::~_VkComputePipelineCreateInfo() {
  //printf("VkComputePipelineCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkComputePipelineCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkComputePipelineCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkComputePipelineCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("stage").ToLocalChecked(), Getstage, Setstage, ctor);
  SetPrototypeAccessor(proto, Nan::New("layout").ToLocalChecked(), Getlayout, Setlayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("basePipelineHandle").ToLocalChecked(), GetbasePipelineHandle, SetbasePipelineHandle, ctor);
  SetPrototypeAccessor(proto, Nan::New("basePipelineIndex").ToLocalChecked(), GetbasePipelineIndex, SetbasePipelineIndex, ctor);
  Nan::Set(target, Nan::New("VkComputePipelineCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkComputePipelineCreateInfo::flush() {
  _VkComputePipelineCreateInfo *self = this;
  if (!(self->stage.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->stage);
    
    _VkPipelineShaderStageCreateInfo* result = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.stage = result->instance;
  }
  return true;
}

NAN_METHOD(_VkComputePipelineCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkComputePipelineCreateInfo* self = new _VkComputePipelineCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("stage").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("layout").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("basePipelineHandle").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("basePipelineIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkComputePipelineCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkComputePipelineCreateInfo::GetsType) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkComputePipelineCreateInfo::SetsType) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkComputePipelineCreateInfo::Getflags) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkComputePipelineCreateInfo::Setflags) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkPipelineCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.flags", "Number");
  
    return;
  }
}// stage
NAN_GETTER(_VkComputePipelineCreateInfo::Getstage) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  if (self->stage.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->stage);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkComputePipelineCreateInfo::Setstage) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineShaderStageCreateInfo::constructor)->HasInstance(obj)) {
      self->stage.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineShaderStageCreateInfo* inst = Nan::ObjectWrap::Unwrap<_VkPipelineShaderStageCreateInfo>(obj);
      inst->flush();
      self->instance.stage = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.stage", "[object VkPipelineShaderStageCreateInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->stage.Reset();
    memset(&self->instance.stage, 0, sizeof(VkPipelineShaderStageCreateInfo));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.stage", "[object VkPipelineShaderStageCreateInfo]");
  
    return;
  }
}// layout
NAN_GETTER(_VkComputePipelineCreateInfo::Getlayout) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  if (self->layout.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->layout);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkComputePipelineCreateInfo::Setlayout) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipelineLayout::constructor)->HasInstance(obj)) {
      self->layout.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipelineLayout* inst = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(obj);
      ;
      self->instance.layout = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.layout", "[object VkPipelineLayout]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->layout.Reset();
    self->instance.layout = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.layout", "[object VkPipelineLayout]");
  
    return;
  }
}// basePipelineHandle
NAN_GETTER(_VkComputePipelineCreateInfo::GetbasePipelineHandle) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  if (self->basePipelineHandle.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->basePipelineHandle);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkComputePipelineCreateInfo::SetbasePipelineHandle) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPipeline::constructor)->HasInstance(obj)) {
      self->basePipelineHandle.Reset<v8::Object>(value.As<v8::Object>());
      _VkPipeline* inst = Nan::ObjectWrap::Unwrap<_VkPipeline>(obj);
      ;
      self->instance.basePipelineHandle = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.basePipelineHandle", "[object VkPipeline]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->basePipelineHandle.Reset();
    self->instance.basePipelineHandle = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.basePipelineHandle", "[object VkPipeline]");
  
    return;
  }
}// basePipelineIndex
NAN_GETTER(_VkComputePipelineCreateInfo::GetbasePipelineIndex) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.basePipelineIndex));
}NAN_SETTER(_VkComputePipelineCreateInfo::SetbasePipelineIndex) {
  _VkComputePipelineCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.basePipelineIndex = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkComputePipelineCreateInfo.basePipelineIndex", "Number");
  
    return;
  }
}
/** ## END VkComputePipelineCreateInfo ## **/

/** ## BEGIN VkDescriptorSetAllocateInfo ## **/

class _VkDescriptorSetAllocateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> descriptorPool;
      static NAN_GETTER(GetdescriptorPool);
    static NAN_SETTER(SetdescriptorPool);
    
    static NAN_GETTER(GetdescriptorSetCount);
    static NAN_SETTER(SetdescriptorSetCount);
    
    std::vector<VkDescriptorSetLayout>* vpSetLayouts;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSetLayouts;
    static NAN_GETTER(GetpSetLayouts);
    static NAN_SETTER(SetpSetLayouts);
    

    // real instance
    VkDescriptorSetAllocateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorSetAllocateInfo();
    ~_VkDescriptorSetAllocateInfo();

};

/*
#include "index.h"
#include "VkDescriptorSetAllocateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetAllocateInfo::constructor;

_VkDescriptorSetAllocateInfo::_VkDescriptorSetAllocateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
  vpSetLayouts = new std::vector<VkDescriptorSetLayout>;
  
}

_VkDescriptorSetAllocateInfo::~_VkDescriptorSetAllocateInfo() {
  //printf("VkDescriptorSetAllocateInfo deconstructed!!\n");
  
  
  
  
  vpSetLayouts->clear();
  delete vpSetLayouts;
  
  pSetLayouts.Reset();
  
}

void _VkDescriptorSetAllocateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetAllocateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetAllocateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorPool").ToLocalChecked(), GetdescriptorPool, SetdescriptorPool, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorSetCount").ToLocalChecked(), GetdescriptorSetCount, SetdescriptorSetCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSetLayouts").ToLocalChecked(), GetpSetLayouts, SetpSetLayouts, ctor);
  Nan::Set(target, Nan::New("VkDescriptorSetAllocateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorSetAllocateInfo::flush() {
  _VkDescriptorSetAllocateInfo *self = this;
  if (!(self->pSetLayouts.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSetLayouts);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.descriptorSetCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'descriptorSetCount' for 'VkDescriptorSetAllocateInfo.pSetLayouts'");
      return false;
    }
    std::vector<VkDescriptorSetLayout>* data = self->vpSetLayouts;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDescriptorSetLayout::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetAllocateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
        return false;
      }
      _VkDescriptorSetLayout* result = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayout>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSetLayouts = data->data();
  }
  return true;
}

NAN_METHOD(_VkDescriptorSetAllocateInfo::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorSetAllocateInfo* self = new _VkDescriptorSetAllocateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("descriptorPool").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("descriptorSetCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pSetLayouts").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorSetAllocateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorSetAllocateInfo::GetsType) {
  _VkDescriptorSetAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDescriptorSetAllocateInfo::SetsType) {
  _VkDescriptorSetAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetAllocateInfo.sType", "Number");
  
    return;
  }
}// descriptorPool
NAN_GETTER(_VkDescriptorSetAllocateInfo::GetdescriptorPool) {
  _VkDescriptorSetAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(info.This());
  if (self->descriptorPool.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->descriptorPool);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorSetAllocateInfo::SetdescriptorPool) {
  _VkDescriptorSetAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDescriptorPool::constructor)->HasInstance(obj)) {
      self->descriptorPool.Reset<v8::Object>(value.As<v8::Object>());
      _VkDescriptorPool* inst = Nan::ObjectWrap::Unwrap<_VkDescriptorPool>(obj);
      ;
      self->instance.descriptorPool = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetAllocateInfo.descriptorPool", "[object VkDescriptorPool]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->descriptorPool.Reset();
    self->instance.descriptorPool = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetAllocateInfo.descriptorPool", "[object VkDescriptorPool]");
  
    return;
  }
}// descriptorSetCount
NAN_GETTER(_VkDescriptorSetAllocateInfo::GetdescriptorSetCount) {
  _VkDescriptorSetAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorSetCount));
}NAN_SETTER(_VkDescriptorSetAllocateInfo::SetdescriptorSetCount) {
  _VkDescriptorSetAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorSetCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetAllocateInfo.descriptorSetCount", "Number");
  
    return;
  }
}// pSetLayouts
NAN_GETTER(_VkDescriptorSetAllocateInfo::GetpSetLayouts) {
  _VkDescriptorSetAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(info.This());
  if (self->pSetLayouts.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSetLayouts);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorSetAllocateInfo::SetpSetLayouts) {
  _VkDescriptorSetAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSetLayouts.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSetLayouts.Reset();
      self->instance.pSetLayouts = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetAllocateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSetLayouts = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetAllocateInfo.pSetLayouts", "[object VkDescriptorSetLayout]");
  
    return;
  }
}
/** ## END VkDescriptorSetAllocateInfo ## **/

/** ## BEGIN VkDescriptorPoolSize ## **/

class _VkDescriptorPoolSize: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Gettype);
    static NAN_SETTER(Settype);
    
    static NAN_GETTER(GetdescriptorCount);
    static NAN_SETTER(SetdescriptorCount);
    

    // real instance
    VkDescriptorPoolSize instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorPoolSize();
    ~_VkDescriptorPoolSize();

};

/*
#include "index.h"
#include "VkDescriptorPoolSize.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorPoolSize::constructor;

_VkDescriptorPoolSize::_VkDescriptorPoolSize() {
  
  
}

_VkDescriptorPoolSize::~_VkDescriptorPoolSize() {
  //printf("VkDescriptorPoolSize deconstructed!!\n");
  
  
  
}

void _VkDescriptorPoolSize::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorPoolSize::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorPoolSize").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("type").ToLocalChecked(), Gettype, Settype, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorCount").ToLocalChecked(), GetdescriptorCount, SetdescriptorCount, ctor);
  Nan::Set(target, Nan::New("VkDescriptorPoolSize").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorPoolSize::flush() {
  _VkDescriptorPoolSize *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorPoolSize::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorPoolSize* self = new _VkDescriptorPoolSize();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("type").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("descriptorCount").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorPoolSize constructor cannot be invoked without 'new'");
  }
};

// type
NAN_GETTER(_VkDescriptorPoolSize::Gettype) {
  _VkDescriptorPoolSize *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolSize>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.type));
}NAN_SETTER(_VkDescriptorPoolSize::Settype) {
  _VkDescriptorPoolSize *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolSize>(info.This());
  if (value->IsNumber()) {
    self->instance.type = static_cast<VkDescriptorType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolSize.type", "Number");
  
    return;
  }
}// descriptorCount
NAN_GETTER(_VkDescriptorPoolSize::GetdescriptorCount) {
  _VkDescriptorPoolSize *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolSize>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorCount));
}NAN_SETTER(_VkDescriptorPoolSize::SetdescriptorCount) {
  _VkDescriptorPoolSize *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolSize>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolSize.descriptorCount", "Number");
  
    return;
  }
}
/** ## END VkDescriptorPoolSize ## **/

/** ## BEGIN VkDescriptorPoolCreateInfo ## **/

class _VkDescriptorPoolCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetmaxSets);
    static NAN_SETTER(SetmaxSets);
    
    static NAN_GETTER(GetpoolSizeCount);
    static NAN_SETTER(SetpoolSizeCount);
    
    std::vector<VkDescriptorPoolSize>* vpPoolSizes;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pPoolSizes;
    static NAN_GETTER(GetpPoolSizes);
    static NAN_SETTER(SetpPoolSizes);
    

    // real instance
    VkDescriptorPoolCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorPoolCreateInfo();
    ~_VkDescriptorPoolCreateInfo();

};

/*
#include "index.h"
#include "VkDescriptorPoolCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorPoolCreateInfo::constructor;

_VkDescriptorPoolCreateInfo::_VkDescriptorPoolCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
  vpPoolSizes = new std::vector<VkDescriptorPoolSize>;
  
}

_VkDescriptorPoolCreateInfo::~_VkDescriptorPoolCreateInfo() {
  //printf("VkDescriptorPoolCreateInfo deconstructed!!\n");
  
  
  
  
  
  vpPoolSizes->clear();
  delete vpPoolSizes;
  
  pPoolSizes.Reset();
  
}

void _VkDescriptorPoolCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorPoolCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorPoolCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("maxSets").ToLocalChecked(), GetmaxSets, SetmaxSets, ctor);
  SetPrototypeAccessor(proto, Nan::New("poolSizeCount").ToLocalChecked(), GetpoolSizeCount, SetpoolSizeCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pPoolSizes").ToLocalChecked(), GetpPoolSizes, SetpPoolSizes, ctor);
  Nan::Set(target, Nan::New("VkDescriptorPoolCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorPoolCreateInfo::flush() {
  _VkDescriptorPoolCreateInfo *self = this;
  if (!(self->pPoolSizes.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pPoolSizes);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.poolSizeCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'poolSizeCount' for 'VkDescriptorPoolCreateInfo.pPoolSizes'");
      return false;
    }
    std::vector<VkDescriptorPoolSize>* data = self->vpPoolSizes;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDescriptorPoolSize::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolCreateInfo.pPoolSizes", "[object VkDescriptorPoolSize]");
  
        return false;
      }
      _VkDescriptorPoolSize* result = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolSize>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pPoolSizes = data->data();
  }
  return true;
}

NAN_METHOD(_VkDescriptorPoolCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorPoolCreateInfo* self = new _VkDescriptorPoolCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("maxSets").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("poolSizeCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pPoolSizes").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorPoolCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorPoolCreateInfo::GetsType) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDescriptorPoolCreateInfo::SetsType) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDescriptorPoolCreateInfo::Getflags) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDescriptorPoolCreateInfo::Setflags) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDescriptorPoolCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolCreateInfo.flags", "Number");
  
    return;
  }
}// maxSets
NAN_GETTER(_VkDescriptorPoolCreateInfo::GetmaxSets) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.maxSets));
}NAN_SETTER(_VkDescriptorPoolCreateInfo::SetmaxSets) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.maxSets = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolCreateInfo.maxSets", "Number");
  
    return;
  }
}// poolSizeCount
NAN_GETTER(_VkDescriptorPoolCreateInfo::GetpoolSizeCount) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.poolSizeCount));
}NAN_SETTER(_VkDescriptorPoolCreateInfo::SetpoolSizeCount) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.poolSizeCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolCreateInfo.poolSizeCount", "Number");
  
    return;
  }
}// pPoolSizes
NAN_GETTER(_VkDescriptorPoolCreateInfo::GetpPoolSizes) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  if (self->pPoolSizes.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pPoolSizes);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorPoolCreateInfo::SetpPoolSizes) {
  _VkDescriptorPoolCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pPoolSizes.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pPoolSizes.Reset();
      self->instance.pPoolSizes = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolCreateInfo.pPoolSizes", "[object VkDescriptorPoolSize]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pPoolSizes = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorPoolCreateInfo.pPoolSizes", "[object VkDescriptorPoolSize]");
  
    return;
  }
}
/** ## END VkDescriptorPoolCreateInfo ## **/

/** ## BEGIN VkDescriptorSetLayoutBinding ## **/

class _VkDescriptorSetLayoutBinding: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getbinding);
    static NAN_SETTER(Setbinding);
    
    static NAN_GETTER(GetdescriptorType);
    static NAN_SETTER(SetdescriptorType);
    
    static NAN_GETTER(GetdescriptorCount);
    static NAN_SETTER(SetdescriptorCount);
    
    static NAN_GETTER(GetstageFlags);
    static NAN_SETTER(SetstageFlags);
    
    std::vector<VkSampler>* vpImmutableSamplers;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pImmutableSamplers;
    static NAN_GETTER(GetpImmutableSamplers);
    static NAN_SETTER(SetpImmutableSamplers);
    

    // real instance
    VkDescriptorSetLayoutBinding instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorSetLayoutBinding();
    ~_VkDescriptorSetLayoutBinding();

};

/*
#include "index.h"
#include "VkDescriptorSetLayoutBinding.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetLayoutBinding::constructor;

_VkDescriptorSetLayoutBinding::_VkDescriptorSetLayoutBinding() {
  
  vpImmutableSamplers = new std::vector<VkSampler>;
  
}

_VkDescriptorSetLayoutBinding::~_VkDescriptorSetLayoutBinding() {
  //printf("VkDescriptorSetLayoutBinding deconstructed!!\n");
  
  
  
  
  
  vpImmutableSamplers->clear();
  delete vpImmutableSamplers;
  
  pImmutableSamplers.Reset();
  
}

void _VkDescriptorSetLayoutBinding::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetLayoutBinding::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetLayoutBinding").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("binding").ToLocalChecked(), Getbinding, Setbinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorType").ToLocalChecked(), GetdescriptorType, SetdescriptorType, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorCount").ToLocalChecked(), GetdescriptorCount, SetdescriptorCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("stageFlags").ToLocalChecked(), GetstageFlags, SetstageFlags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pImmutableSamplers").ToLocalChecked(), GetpImmutableSamplers, SetpImmutableSamplers, ctor);
  Nan::Set(target, Nan::New("VkDescriptorSetLayoutBinding").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorSetLayoutBinding::flush() {
  _VkDescriptorSetLayoutBinding *self = this;
  if (!(self->pImmutableSamplers.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pImmutableSamplers);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.descriptorCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'descriptorCount' for 'VkDescriptorSetLayoutBinding.pImmutableSamplers'");
      return false;
    }
    std::vector<VkSampler>* data = self->vpImmutableSamplers;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSampler::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBinding.pImmutableSamplers", "[object VkSampler]");
  
        return false;
      }
      _VkSampler* result = Nan::ObjectWrap::Unwrap<_VkSampler>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pImmutableSamplers = data->data();
  }
  return true;
}

NAN_METHOD(_VkDescriptorSetLayoutBinding::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorSetLayoutBinding* self = new _VkDescriptorSetLayoutBinding();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("binding").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("descriptorType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("descriptorCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("stageFlags").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pImmutableSamplers").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorSetLayoutBinding constructor cannot be invoked without 'new'");
  }
};

// binding
NAN_GETTER(_VkDescriptorSetLayoutBinding::Getbinding) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.binding));
}NAN_SETTER(_VkDescriptorSetLayoutBinding::Setbinding) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  if (value->IsNumber()) {
    self->instance.binding = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBinding.binding", "Number");
  
    return;
  }
}// descriptorType
NAN_GETTER(_VkDescriptorSetLayoutBinding::GetdescriptorType) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorType));
}NAN_SETTER(_VkDescriptorSetLayoutBinding::SetdescriptorType) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorType = static_cast<VkDescriptorType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBinding.descriptorType", "Number");
  
    return;
  }
}// descriptorCount
NAN_GETTER(_VkDescriptorSetLayoutBinding::GetdescriptorCount) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorCount));
}NAN_SETTER(_VkDescriptorSetLayoutBinding::SetdescriptorCount) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBinding.descriptorCount", "Number");
  
    return;
  }
}// stageFlags
NAN_GETTER(_VkDescriptorSetLayoutBinding::GetstageFlags) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.stageFlags));
}NAN_SETTER(_VkDescriptorSetLayoutBinding::SetstageFlags) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  if (value->IsNumber()) {
    self->instance.stageFlags = static_cast<VkShaderStageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBinding.stageFlags", "Number");
  
    return;
  }
}// pImmutableSamplers
NAN_GETTER(_VkDescriptorSetLayoutBinding::GetpImmutableSamplers) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  if (self->pImmutableSamplers.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pImmutableSamplers);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorSetLayoutBinding::SetpImmutableSamplers) {
  _VkDescriptorSetLayoutBinding *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pImmutableSamplers.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pImmutableSamplers.Reset();
      self->instance.pImmutableSamplers = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBinding.pImmutableSamplers", "[object VkSampler]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pImmutableSamplers = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutBinding.pImmutableSamplers", "[object VkSampler]");
  
    return;
  }
}
/** ## END VkDescriptorSetLayoutBinding ## **/

/** ## BEGIN VkDescriptorSetLayoutCreateInfo ## **/

class _VkDescriptorSetLayoutCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetbindingCount);
    static NAN_SETTER(SetbindingCount);
    
    std::vector<VkDescriptorSetLayoutBinding>* vpBindings;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pBindings;
    static NAN_GETTER(GetpBindings);
    static NAN_SETTER(SetpBindings);
    

    // real instance
    VkDescriptorSetLayoutCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorSetLayoutCreateInfo();
    ~_VkDescriptorSetLayoutCreateInfo();

};

/*
#include "index.h"
#include "VkDescriptorSetLayoutCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorSetLayoutCreateInfo::constructor;

_VkDescriptorSetLayoutCreateInfo::_VkDescriptorSetLayoutCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
  vpBindings = new std::vector<VkDescriptorSetLayoutBinding>;
  
}

_VkDescriptorSetLayoutCreateInfo::~_VkDescriptorSetLayoutCreateInfo() {
  //printf("VkDescriptorSetLayoutCreateInfo deconstructed!!\n");
  
  
  
  
  vpBindings->clear();
  delete vpBindings;
  
  pBindings.Reset();
  
}

void _VkDescriptorSetLayoutCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorSetLayoutCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorSetLayoutCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("bindingCount").ToLocalChecked(), GetbindingCount, SetbindingCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pBindings").ToLocalChecked(), GetpBindings, SetpBindings, ctor);
  Nan::Set(target, Nan::New("VkDescriptorSetLayoutCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorSetLayoutCreateInfo::flush() {
  _VkDescriptorSetLayoutCreateInfo *self = this;
  if (!(self->pBindings.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pBindings);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.bindingCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'bindingCount' for 'VkDescriptorSetLayoutCreateInfo.pBindings'");
      return false;
    }
    std::vector<VkDescriptorSetLayoutBinding>* data = self->vpBindings;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDescriptorSetLayoutBinding::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutCreateInfo.pBindings", "[object VkDescriptorSetLayoutBinding]");
  
        return false;
      }
      _VkDescriptorSetLayoutBinding* result = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutBinding>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBindings = data->data();
  }
  return true;
}

NAN_METHOD(_VkDescriptorSetLayoutCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorSetLayoutCreateInfo* self = new _VkDescriptorSetLayoutCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("bindingCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pBindings").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorSetLayoutCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDescriptorSetLayoutCreateInfo::GetsType) {
  _VkDescriptorSetLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDescriptorSetLayoutCreateInfo::SetsType) {
  _VkDescriptorSetLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDescriptorSetLayoutCreateInfo::Getflags) {
  _VkDescriptorSetLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDescriptorSetLayoutCreateInfo::Setflags) {
  _VkDescriptorSetLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDescriptorSetLayoutCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutCreateInfo.flags", "Number");
  
    return;
  }
}// bindingCount
NAN_GETTER(_VkDescriptorSetLayoutCreateInfo::GetbindingCount) {
  _VkDescriptorSetLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bindingCount));
}NAN_SETTER(_VkDescriptorSetLayoutCreateInfo::SetbindingCount) {
  _VkDescriptorSetLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.bindingCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutCreateInfo.bindingCount", "Number");
  
    return;
  }
}// pBindings
NAN_GETTER(_VkDescriptorSetLayoutCreateInfo::GetpBindings) {
  _VkDescriptorSetLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(info.This());
  if (self->pBindings.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pBindings);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorSetLayoutCreateInfo::SetpBindings) {
  _VkDescriptorSetLayoutCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pBindings.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pBindings.Reset();
      self->instance.pBindings = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutCreateInfo.pBindings", "[object VkDescriptorSetLayoutBinding]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pBindings = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorSetLayoutCreateInfo.pBindings", "[object VkDescriptorSetLayoutBinding]");
  
    return;
  }
}
/** ## END VkDescriptorSetLayoutCreateInfo ## **/

/** ## BEGIN VkShaderModuleCreateInfo ## **/

class _VkShaderModuleCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetcodeSize);
    static NAN_SETTER(SetcodeSize);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pCode;
    static NAN_GETTER(GetpCode);
    static NAN_SETTER(SetpCode);
    

    // real instance
    VkShaderModuleCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkShaderModuleCreateInfo();
    ~_VkShaderModuleCreateInfo();

};

/*
#include "index.h"
#include "VkShaderModuleCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkShaderModuleCreateInfo::constructor;

_VkShaderModuleCreateInfo::_VkShaderModuleCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
  
}

_VkShaderModuleCreateInfo::~_VkShaderModuleCreateInfo() {
  //printf("VkShaderModuleCreateInfo deconstructed!!\n");
  
  
  
  
  pCode.Reset();
  
}

void _VkShaderModuleCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkShaderModuleCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkShaderModuleCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("codeSize").ToLocalChecked(), GetcodeSize, SetcodeSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("pCode").ToLocalChecked(), GetpCode, SetpCode, ctor);
  Nan::Set(target, Nan::New("VkShaderModuleCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkShaderModuleCreateInfo::flush() {
  _VkShaderModuleCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkShaderModuleCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkShaderModuleCreateInfo* self = new _VkShaderModuleCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("codeSize").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pCode").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkShaderModuleCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkShaderModuleCreateInfo::GetsType) {
  _VkShaderModuleCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkShaderModuleCreateInfo::SetsType) {
  _VkShaderModuleCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkShaderModuleCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkShaderModuleCreateInfo::Getflags) {
  _VkShaderModuleCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkShaderModuleCreateInfo::Setflags) {
  _VkShaderModuleCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkShaderModuleCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkShaderModuleCreateInfo.flags", "Number");
  
    return;
  }
}// codeSize
NAN_GETTER(_VkShaderModuleCreateInfo::GetcodeSize) {
  _VkShaderModuleCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.codeSize));
}NAN_SETTER(_VkShaderModuleCreateInfo::SetcodeSize) {
  _VkShaderModuleCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.codeSize = static_cast<size_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkShaderModuleCreateInfo.codeSize", "Number");
  
    return;
  }
}// pCode
NAN_GETTER(_VkShaderModuleCreateInfo::GetpCode) {
  _VkShaderModuleCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info.This());
  if (self->pCode.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pCode);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkShaderModuleCreateInfo::SetpCode) {
  _VkShaderModuleCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint8Array()) {
        self->pCode.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkShaderModuleCreateInfo.pCode", "Uint8Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pCode.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkShaderModuleCreateInfo.pCode", "Uint8Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pCode = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pCode = nullptr;
  }
}
/** ## END VkShaderModuleCreateInfo ## **/

/** ## BEGIN VkOffset3D ## **/

class _VkOffset3D: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(Getx);
    static NAN_SETTER(Setx);
    
    static NAN_GETTER(Gety);
    static NAN_SETTER(Sety);
    
    static NAN_GETTER(Getz);
    static NAN_SETTER(Setz);
    

    // real instance
    VkOffset3D instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkOffset3D();
    ~_VkOffset3D();

};

/*
#include "index.h"
#include "VkOffset3D.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkOffset3D::constructor;

_VkOffset3D::_VkOffset3D() {
  
  
}

_VkOffset3D::~_VkOffset3D() {
  //printf("VkOffset3D deconstructed!!\n");
  
  
  
  
}

void _VkOffset3D::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkOffset3D::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkOffset3D").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("x").ToLocalChecked(), Getx, Setx, ctor);
  SetPrototypeAccessor(proto, Nan::New("y").ToLocalChecked(), Gety, Sety, ctor);
  SetPrototypeAccessor(proto, Nan::New("z").ToLocalChecked(), Getz, Setz, ctor);
  Nan::Set(target, Nan::New("VkOffset3D").ToLocalChecked(), ctor->GetFunction());
}

bool _VkOffset3D::flush() {
  _VkOffset3D *self = this;
  
  return true;
}

NAN_METHOD(_VkOffset3D::New) {
  if (info.IsConstructCall()) {
    _VkOffset3D* self = new _VkOffset3D();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("x").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("y").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("z").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkOffset3D constructor cannot be invoked without 'new'");
  }
};

// x
NAN_GETTER(_VkOffset3D::Getx) {
  _VkOffset3D *self = Nan::ObjectWrap::Unwrap<_VkOffset3D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.x));
}NAN_SETTER(_VkOffset3D::Setx) {
  _VkOffset3D *self = Nan::ObjectWrap::Unwrap<_VkOffset3D>(info.This());
  if (value->IsNumber()) {
    self->instance.x = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkOffset3D.x", "Number");
  
    return;
  }
}// y
NAN_GETTER(_VkOffset3D::Gety) {
  _VkOffset3D *self = Nan::ObjectWrap::Unwrap<_VkOffset3D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.y));
}NAN_SETTER(_VkOffset3D::Sety) {
  _VkOffset3D *self = Nan::ObjectWrap::Unwrap<_VkOffset3D>(info.This());
  if (value->IsNumber()) {
    self->instance.y = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkOffset3D.y", "Number");
  
    return;
  }
}// z
NAN_GETTER(_VkOffset3D::Getz) {
  _VkOffset3D *self = Nan::ObjectWrap::Unwrap<_VkOffset3D>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.z));
}NAN_SETTER(_VkOffset3D::Setz) {
  _VkOffset3D *self = Nan::ObjectWrap::Unwrap<_VkOffset3D>(info.This());
  if (value->IsNumber()) {
    self->instance.z = static_cast<int32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkOffset3D.z", "Number");
  
    return;
  }
}
/** ## END VkOffset3D ## **/

/** ## BEGIN VkImageSubresourceLayers ## **/

class _VkImageSubresourceLayers: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetaspectMask);
    static NAN_SETTER(SetaspectMask);
    
    static NAN_GETTER(GetmipLevel);
    static NAN_SETTER(SetmipLevel);
    
    static NAN_GETTER(GetbaseArrayLayer);
    static NAN_SETTER(SetbaseArrayLayer);
    
    static NAN_GETTER(GetlayerCount);
    static NAN_SETTER(SetlayerCount);
    

    // real instance
    VkImageSubresourceLayers instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageSubresourceLayers();
    ~_VkImageSubresourceLayers();

};

/*
#include "index.h"
#include "VkImageSubresourceLayers.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageSubresourceLayers::constructor;

_VkImageSubresourceLayers::_VkImageSubresourceLayers() {
  
  
}

_VkImageSubresourceLayers::~_VkImageSubresourceLayers() {
  //printf("VkImageSubresourceLayers deconstructed!!\n");
  
  
  
  
  
}

void _VkImageSubresourceLayers::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageSubresourceLayers::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageSubresourceLayers").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("aspectMask").ToLocalChecked(), GetaspectMask, SetaspectMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("mipLevel").ToLocalChecked(), GetmipLevel, SetmipLevel, ctor);
  SetPrototypeAccessor(proto, Nan::New("baseArrayLayer").ToLocalChecked(), GetbaseArrayLayer, SetbaseArrayLayer, ctor);
  SetPrototypeAccessor(proto, Nan::New("layerCount").ToLocalChecked(), GetlayerCount, SetlayerCount, ctor);
  Nan::Set(target, Nan::New("VkImageSubresourceLayers").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageSubresourceLayers::flush() {
  _VkImageSubresourceLayers *self = this;
  
  return true;
}

NAN_METHOD(_VkImageSubresourceLayers::New) {
  if (info.IsConstructCall()) {
    _VkImageSubresourceLayers* self = new _VkImageSubresourceLayers();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("aspectMask").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("mipLevel").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("baseArrayLayer").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("layerCount").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageSubresourceLayers constructor cannot be invoked without 'new'");
  }
};

// aspectMask
NAN_GETTER(_VkImageSubresourceLayers::GetaspectMask) {
  _VkImageSubresourceLayers *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.aspectMask));
}NAN_SETTER(_VkImageSubresourceLayers::SetaspectMask) {
  _VkImageSubresourceLayers *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(info.This());
  if (value->IsNumber()) {
    self->instance.aspectMask = static_cast<VkImageAspectFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceLayers.aspectMask", "Number");
  
    return;
  }
}// mipLevel
NAN_GETTER(_VkImageSubresourceLayers::GetmipLevel) {
  _VkImageSubresourceLayers *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.mipLevel));
}NAN_SETTER(_VkImageSubresourceLayers::SetmipLevel) {
  _VkImageSubresourceLayers *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(info.This());
  if (value->IsNumber()) {
    self->instance.mipLevel = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceLayers.mipLevel", "Number");
  
    return;
  }
}// baseArrayLayer
NAN_GETTER(_VkImageSubresourceLayers::GetbaseArrayLayer) {
  _VkImageSubresourceLayers *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.baseArrayLayer));
}NAN_SETTER(_VkImageSubresourceLayers::SetbaseArrayLayer) {
  _VkImageSubresourceLayers *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(info.This());
  if (value->IsNumber()) {
    self->instance.baseArrayLayer = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceLayers.baseArrayLayer", "Number");
  
    return;
  }
}// layerCount
NAN_GETTER(_VkImageSubresourceLayers::GetlayerCount) {
  _VkImageSubresourceLayers *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.layerCount));
}NAN_SETTER(_VkImageSubresourceLayers::SetlayerCount) {
  _VkImageSubresourceLayers *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(info.This());
  if (value->IsNumber()) {
    self->instance.layerCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceLayers.layerCount", "Number");
  
    return;
  }
}
/** ## END VkImageSubresourceLayers ## **/

/** ## BEGIN VkImageResolve ## **/

class _VkImageResolve: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> srcSubresource;
      static NAN_GETTER(GetsrcSubresource);
    static NAN_SETTER(SetsrcSubresource);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> srcOffset;
      static NAN_GETTER(GetsrcOffset);
    static NAN_SETTER(SetsrcOffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> dstSubresource;
      static NAN_GETTER(GetdstSubresource);
    static NAN_SETTER(SetdstSubresource);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> dstOffset;
      static NAN_GETTER(GetdstOffset);
    static NAN_SETTER(SetdstOffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> extent;
      static NAN_GETTER(Getextent);
    static NAN_SETTER(Setextent);
    

    // real instance
    VkImageResolve instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageResolve();
    ~_VkImageResolve();

};

/*
#include "index.h"
#include "VkImageResolve.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageResolve::constructor;

_VkImageResolve::_VkImageResolve() {
  
  
}

_VkImageResolve::~_VkImageResolve() {
  //printf("VkImageResolve deconstructed!!\n");
  
  
  
  
  
  
}

void _VkImageResolve::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageResolve::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageResolve").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("srcSubresource").ToLocalChecked(), GetsrcSubresource, SetsrcSubresource, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcOffset").ToLocalChecked(), GetsrcOffset, SetsrcOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstSubresource").ToLocalChecked(), GetdstSubresource, SetdstSubresource, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstOffset").ToLocalChecked(), GetdstOffset, SetdstOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("extent").ToLocalChecked(), Getextent, Setextent, ctor);
  Nan::Set(target, Nan::New("VkImageResolve").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageResolve::flush() {
  _VkImageResolve *self = this;
  if (!(self->srcSubresource.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->srcSubresource);
    
    _VkImageSubresourceLayers* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.srcSubresource = result->instance;
  }if (!(self->srcOffset.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->srcOffset);
    
    _VkOffset3D* result = Nan::ObjectWrap::Unwrap<_VkOffset3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.srcOffset = result->instance;
  }if (!(self->dstSubresource.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->dstSubresource);
    
    _VkImageSubresourceLayers* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.dstSubresource = result->instance;
  }if (!(self->dstOffset.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->dstOffset);
    
    _VkOffset3D* result = Nan::ObjectWrap::Unwrap<_VkOffset3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.dstOffset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->extent);
    
    _VkExtent3D* result = Nan::ObjectWrap::Unwrap<_VkExtent3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkImageResolve::New) {
  if (info.IsConstructCall()) {
    _VkImageResolve* self = new _VkImageResolve();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("srcSubresource").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("srcOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dstSubresource").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("extent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageResolve constructor cannot be invoked without 'new'");
  }
};

// srcSubresource
NAN_GETTER(_VkImageResolve::GetsrcSubresource) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  if (self->srcSubresource.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->srcSubresource);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageResolve::SetsrcSubresource) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceLayers::constructor)->HasInstance(obj)) {
      self->srcSubresource.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceLayers* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(obj);
      inst->flush();
      self->instance.srcSubresource = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageResolve.srcSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->srcSubresource.Reset();
    memset(&self->instance.srcSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageResolve.srcSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// srcOffset
NAN_GETTER(_VkImageResolve::GetsrcOffset) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  if (self->srcOffset.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->srcOffset);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageResolve::SetsrcOffset) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkOffset3D::constructor)->HasInstance(obj)) {
      self->srcOffset.Reset<v8::Object>(value.As<v8::Object>());
      _VkOffset3D* inst = Nan::ObjectWrap::Unwrap<_VkOffset3D>(obj);
      inst->flush();
      self->instance.srcOffset = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageResolve.srcOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->srcOffset.Reset();
    memset(&self->instance.srcOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageResolve.srcOffset", "[object VkOffset3D]");
  
    return;
  }
}// dstSubresource
NAN_GETTER(_VkImageResolve::GetdstSubresource) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  if (self->dstSubresource.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->dstSubresource);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageResolve::SetdstSubresource) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceLayers::constructor)->HasInstance(obj)) {
      self->dstSubresource.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceLayers* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(obj);
      inst->flush();
      self->instance.dstSubresource = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageResolve.dstSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->dstSubresource.Reset();
    memset(&self->instance.dstSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageResolve.dstSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// dstOffset
NAN_GETTER(_VkImageResolve::GetdstOffset) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  if (self->dstOffset.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->dstOffset);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageResolve::SetdstOffset) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkOffset3D::constructor)->HasInstance(obj)) {
      self->dstOffset.Reset<v8::Object>(value.As<v8::Object>());
      _VkOffset3D* inst = Nan::ObjectWrap::Unwrap<_VkOffset3D>(obj);
      inst->flush();
      self->instance.dstOffset = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageResolve.dstOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->dstOffset.Reset();
    memset(&self->instance.dstOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageResolve.dstOffset", "[object VkOffset3D]");
  
    return;
  }
}// extent
NAN_GETTER(_VkImageResolve::Getextent) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  if (self->extent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->extent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageResolve::Setextent) {
  _VkImageResolve *self = Nan::ObjectWrap::Unwrap<_VkImageResolve>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent3D::constructor)->HasInstance(obj)) {
      self->extent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent3D* inst = Nan::ObjectWrap::Unwrap<_VkExtent3D>(obj);
      inst->flush();
      self->instance.extent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageResolve.extent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->extent.Reset();
    memset(&self->instance.extent, 0, sizeof(VkExtent3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageResolve.extent", "[object VkExtent3D]");
  
    return;
  }
}
/** ## END VkImageResolve ## **/

/** ## BEGIN VkBufferImageCopy ## **/

class _VkBufferImageCopy: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetbufferOffset);
    static NAN_SETTER(SetbufferOffset);
    
    static NAN_GETTER(GetbufferRowLength);
    static NAN_SETTER(SetbufferRowLength);
    
    static NAN_GETTER(GetbufferImageHeight);
    static NAN_SETTER(SetbufferImageHeight);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageSubresource;
      static NAN_GETTER(GetimageSubresource);
    static NAN_SETTER(SetimageSubresource);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageOffset;
      static NAN_GETTER(GetimageOffset);
    static NAN_SETTER(SetimageOffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageExtent;
      static NAN_GETTER(GetimageExtent);
    static NAN_SETTER(SetimageExtent);
    

    // real instance
    VkBufferImageCopy instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferImageCopy();
    ~_VkBufferImageCopy();

};

/*
#include "index.h"
#include "VkBufferImageCopy.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferImageCopy::constructor;

_VkBufferImageCopy::_VkBufferImageCopy() {
  
  
}

_VkBufferImageCopy::~_VkBufferImageCopy() {
  //printf("VkBufferImageCopy deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkBufferImageCopy::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferImageCopy::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferImageCopy").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("bufferOffset").ToLocalChecked(), GetbufferOffset, SetbufferOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("bufferRowLength").ToLocalChecked(), GetbufferRowLength, SetbufferRowLength, ctor);
  SetPrototypeAccessor(proto, Nan::New("bufferImageHeight").ToLocalChecked(), GetbufferImageHeight, SetbufferImageHeight, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageSubresource").ToLocalChecked(), GetimageSubresource, SetimageSubresource, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageOffset").ToLocalChecked(), GetimageOffset, SetimageOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageExtent").ToLocalChecked(), GetimageExtent, SetimageExtent, ctor);
  Nan::Set(target, Nan::New("VkBufferImageCopy").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferImageCopy::flush() {
  _VkBufferImageCopy *self = this;
  if (!(self->imageSubresource.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->imageSubresource);
    
    _VkImageSubresourceLayers* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.imageSubresource = result->instance;
  }if (!(self->imageOffset.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->imageOffset);
    
    _VkOffset3D* result = Nan::ObjectWrap::Unwrap<_VkOffset3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.imageOffset = result->instance;
  }if (!(self->imageExtent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->imageExtent);
    
    _VkExtent3D* result = Nan::ObjectWrap::Unwrap<_VkExtent3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.imageExtent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkBufferImageCopy::New) {
  if (info.IsConstructCall()) {
    _VkBufferImageCopy* self = new _VkBufferImageCopy();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("bufferOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("bufferRowLength").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("bufferImageHeight").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("imageSubresource").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("imageOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("imageExtent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferImageCopy constructor cannot be invoked without 'new'");
  }
};

// bufferOffset
NAN_GETTER(_VkBufferImageCopy::GetbufferOffset) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferOffset));
}NAN_SETTER(_VkBufferImageCopy::SetbufferOffset) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  if (value->IsNumber()) {
    self->instance.bufferOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.bufferOffset", "Number");
  
    return;
  }
}// bufferRowLength
NAN_GETTER(_VkBufferImageCopy::GetbufferRowLength) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferRowLength));
}NAN_SETTER(_VkBufferImageCopy::SetbufferRowLength) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  if (value->IsNumber()) {
    self->instance.bufferRowLength = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.bufferRowLength", "Number");
  
    return;
  }
}// bufferImageHeight
NAN_GETTER(_VkBufferImageCopy::GetbufferImageHeight) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferImageHeight));
}NAN_SETTER(_VkBufferImageCopy::SetbufferImageHeight) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  if (value->IsNumber()) {
    self->instance.bufferImageHeight = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.bufferImageHeight", "Number");
  
    return;
  }
}// imageSubresource
NAN_GETTER(_VkBufferImageCopy::GetimageSubresource) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  if (self->imageSubresource.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageSubresource);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBufferImageCopy::SetimageSubresource) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceLayers::constructor)->HasInstance(obj)) {
      self->imageSubresource.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceLayers* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(obj);
      inst->flush();
      self->instance.imageSubresource = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.imageSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->imageSubresource.Reset();
    memset(&self->instance.imageSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.imageSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// imageOffset
NAN_GETTER(_VkBufferImageCopy::GetimageOffset) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  if (self->imageOffset.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageOffset);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBufferImageCopy::SetimageOffset) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkOffset3D::constructor)->HasInstance(obj)) {
      self->imageOffset.Reset<v8::Object>(value.As<v8::Object>());
      _VkOffset3D* inst = Nan::ObjectWrap::Unwrap<_VkOffset3D>(obj);
      inst->flush();
      self->instance.imageOffset = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.imageOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->imageOffset.Reset();
    memset(&self->instance.imageOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.imageOffset", "[object VkOffset3D]");
  
    return;
  }
}// imageExtent
NAN_GETTER(_VkBufferImageCopy::GetimageExtent) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  if (self->imageExtent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageExtent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBufferImageCopy::SetimageExtent) {
  _VkBufferImageCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent3D::constructor)->HasInstance(obj)) {
      self->imageExtent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent3D* inst = Nan::ObjectWrap::Unwrap<_VkExtent3D>(obj);
      inst->flush();
      self->instance.imageExtent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.imageExtent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->imageExtent.Reset();
    memset(&self->instance.imageExtent, 0, sizeof(VkExtent3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferImageCopy.imageExtent", "[object VkExtent3D]");
  
    return;
  }
}
/** ## END VkBufferImageCopy ## **/

/** ## BEGIN VkImageBlit ## **/

class _VkImageBlit: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> srcSubresource;
      static NAN_GETTER(GetsrcSubresource);
    static NAN_SETTER(SetsrcSubresource);
    
    std::vector<VkOffset3D>* vsrcOffsets;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> srcOffsets;
    static NAN_GETTER(GetsrcOffsets);
    static NAN_SETTER(SetsrcOffsets);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> dstSubresource;
      static NAN_GETTER(GetdstSubresource);
    static NAN_SETTER(SetdstSubresource);
    
    std::vector<VkOffset3D>* vdstOffsets;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> dstOffsets;
    static NAN_GETTER(GetdstOffsets);
    static NAN_SETTER(SetdstOffsets);
    

    // real instance
    VkImageBlit instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageBlit();
    ~_VkImageBlit();

};

/*
#include <string.h>
#include "index.h"
#include "VkImageBlit.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageBlit::constructor;

_VkImageBlit::_VkImageBlit() {
  
  vsrcOffsets = new std::vector<VkOffset3D>;
  vdstOffsets = new std::vector<VkOffset3D>;
  
}

_VkImageBlit::~_VkImageBlit() {
  //printf("VkImageBlit deconstructed!!\n");
  
  
  vsrcOffsets->clear();
  delete vsrcOffsets;
  
  
  
  vdstOffsets->clear();
  delete vdstOffsets;
  
  
}

void _VkImageBlit::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageBlit::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageBlit").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("srcSubresource").ToLocalChecked(), GetsrcSubresource, SetsrcSubresource, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcOffsets").ToLocalChecked(), GetsrcOffsets, SetsrcOffsets, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstSubresource").ToLocalChecked(), GetdstSubresource, SetdstSubresource, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstOffsets").ToLocalChecked(), GetdstOffsets, SetdstOffsets, ctor);
  Nan::Set(target, Nan::New("VkImageBlit").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageBlit::flush() {
  _VkImageBlit *self = this;
  if (!(self->srcSubresource.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->srcSubresource);
    
    _VkImageSubresourceLayers* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.srcSubresource = result->instance;
  }if (!(self->srcOffsets.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->srcOffsets);
    
    if (value->IsArray()) {
      v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
      // validate length
      if (array->Length() != 2) {
        Nan::ThrowRangeError("Invalid array length, expected array length of '2' for 'VkImageBlit.srcOffsets'");
        return false;
      }
      std::vector<VkOffset3D>* data = self->vsrcOffsets;
      data->clear();
      for (unsigned int ii = 0; ii < array->Length(); ++ii) {
        v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
        if (!(Nan::New(_VkOffset3D::constructor)->HasInstance(obj))) {
          
    NanInvalidStructMemberTypeError(value, "VkImageBlit.srcOffsets", "[object VkOffset3D]");
  
          return false;
        }
        _VkOffset3D* result = Nan::ObjectWrap::Unwrap<_VkOffset3D>(obj);
        if (!result->flush()) return false;
        data->push_back(result->instance);
      };
      memcpy(self->instance.srcOffsets, data->data(), sizeof(VkOffset3D) * 2);

    } else if (value->IsNull()) {
      memset(&self->instance.srcOffsets, 0, sizeof(VkOffset3D));
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageBlit.srcOffsets", "[object VkOffset3D]");
  
      return false;
    }
  }if (!(self->dstSubresource.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->dstSubresource);
    
    _VkImageSubresourceLayers* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.dstSubresource = result->instance;
  }if (!(self->dstOffsets.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->dstOffsets);
    
    if (value->IsArray()) {
      v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
      // validate length
      if (array->Length() != 2) {
        Nan::ThrowRangeError("Invalid array length, expected array length of '2' for 'VkImageBlit.dstOffsets'");
        return false;
      }
      std::vector<VkOffset3D>* data = self->vdstOffsets;
      data->clear();
      for (unsigned int ii = 0; ii < array->Length(); ++ii) {
        v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
        if (!(Nan::New(_VkOffset3D::constructor)->HasInstance(obj))) {
          
    NanInvalidStructMemberTypeError(value, "VkImageBlit.dstOffsets", "[object VkOffset3D]");
  
          return false;
        }
        _VkOffset3D* result = Nan::ObjectWrap::Unwrap<_VkOffset3D>(obj);
        if (!result->flush()) return false;
        data->push_back(result->instance);
      };
      memcpy(self->instance.dstOffsets, data->data(), sizeof(VkOffset3D) * 2);

    } else if (value->IsNull()) {
      memset(&self->instance.dstOffsets, 0, sizeof(VkOffset3D));
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageBlit.dstOffsets", "[object VkOffset3D]");
  
      return false;
    }
  }
  return true;
}

NAN_METHOD(_VkImageBlit::New) {
  if (info.IsConstructCall()) {
    _VkImageBlit* self = new _VkImageBlit();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("srcSubresource").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("srcOffsets").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dstSubresource").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstOffsets").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageBlit constructor cannot be invoked without 'new'");
  }
};

// srcSubresource
NAN_GETTER(_VkImageBlit::GetsrcSubresource) {
  _VkImageBlit *self = Nan::ObjectWrap::Unwrap<_VkImageBlit>(info.This());
  if (self->srcSubresource.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->srcSubresource);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageBlit::SetsrcSubresource) {
  _VkImageBlit *self = Nan::ObjectWrap::Unwrap<_VkImageBlit>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceLayers::constructor)->HasInstance(obj)) {
      self->srcSubresource.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceLayers* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(obj);
      inst->flush();
      self->instance.srcSubresource = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageBlit.srcSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->srcSubresource.Reset();
    memset(&self->instance.srcSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageBlit.srcSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// srcOffsets
NAN_GETTER(_VkImageBlit::GetsrcOffsets) {
  _VkImageBlit *self = Nan::ObjectWrap::Unwrap<_VkImageBlit>(info.This());
  if (self->srcOffsets.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->srcOffsets));
  }
}NAN_SETTER(_VkImageBlit::SetsrcOffsets) {
  _VkImageBlit *self = Nan::ObjectWrap::Unwrap<_VkImageBlit>(info.This());
  // js
  if (value->IsArray()) {
    self->srcOffsets.Reset<v8::Array>(value.As<v8::Array>());
  } else if (value->IsNull()) {
    self->srcOffsets.Reset();
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageBlit.srcOffsets", "[object VkOffset3D]");
  
    return;
  }
}// dstSubresource
NAN_GETTER(_VkImageBlit::GetdstSubresource) {
  _VkImageBlit *self = Nan::ObjectWrap::Unwrap<_VkImageBlit>(info.This());
  if (self->dstSubresource.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->dstSubresource);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageBlit::SetdstSubresource) {
  _VkImageBlit *self = Nan::ObjectWrap::Unwrap<_VkImageBlit>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceLayers::constructor)->HasInstance(obj)) {
      self->dstSubresource.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceLayers* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(obj);
      inst->flush();
      self->instance.dstSubresource = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageBlit.dstSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->dstSubresource.Reset();
    memset(&self->instance.dstSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageBlit.dstSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// dstOffsets
NAN_GETTER(_VkImageBlit::GetdstOffsets) {
  _VkImageBlit *self = Nan::ObjectWrap::Unwrap<_VkImageBlit>(info.This());
  if (self->dstOffsets.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->dstOffsets));
  }
}NAN_SETTER(_VkImageBlit::SetdstOffsets) {
  _VkImageBlit *self = Nan::ObjectWrap::Unwrap<_VkImageBlit>(info.This());
  // js
  if (value->IsArray()) {
    self->dstOffsets.Reset<v8::Array>(value.As<v8::Array>());
  } else if (value->IsNull()) {
    self->dstOffsets.Reset();
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageBlit.dstOffsets", "[object VkOffset3D]");
  
    return;
  }
}
/** ## END VkImageBlit ## **/

/** ## BEGIN VkImageCopy ## **/

class _VkImageCopy: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> srcSubresource;
      static NAN_GETTER(GetsrcSubresource);
    static NAN_SETTER(SetsrcSubresource);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> srcOffset;
      static NAN_GETTER(GetsrcOffset);
    static NAN_SETTER(SetsrcOffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> dstSubresource;
      static NAN_GETTER(GetdstSubresource);
    static NAN_SETTER(SetdstSubresource);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> dstOffset;
      static NAN_GETTER(GetdstOffset);
    static NAN_SETTER(SetdstOffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> extent;
      static NAN_GETTER(Getextent);
    static NAN_SETTER(Setextent);
    

    // real instance
    VkImageCopy instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageCopy();
    ~_VkImageCopy();

};

/*
#include "index.h"
#include "VkImageCopy.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageCopy::constructor;

_VkImageCopy::_VkImageCopy() {
  
  
}

_VkImageCopy::~_VkImageCopy() {
  //printf("VkImageCopy deconstructed!!\n");
  
  
  
  
  
  
}

void _VkImageCopy::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageCopy::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageCopy").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("srcSubresource").ToLocalChecked(), GetsrcSubresource, SetsrcSubresource, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcOffset").ToLocalChecked(), GetsrcOffset, SetsrcOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstSubresource").ToLocalChecked(), GetdstSubresource, SetdstSubresource, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstOffset").ToLocalChecked(), GetdstOffset, SetdstOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("extent").ToLocalChecked(), Getextent, Setextent, ctor);
  Nan::Set(target, Nan::New("VkImageCopy").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageCopy::flush() {
  _VkImageCopy *self = this;
  if (!(self->srcSubresource.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->srcSubresource);
    
    _VkImageSubresourceLayers* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.srcSubresource = result->instance;
  }if (!(self->srcOffset.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->srcOffset);
    
    _VkOffset3D* result = Nan::ObjectWrap::Unwrap<_VkOffset3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.srcOffset = result->instance;
  }if (!(self->dstSubresource.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->dstSubresource);
    
    _VkImageSubresourceLayers* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.dstSubresource = result->instance;
  }if (!(self->dstOffset.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->dstOffset);
    
    _VkOffset3D* result = Nan::ObjectWrap::Unwrap<_VkOffset3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.dstOffset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->extent);
    
    _VkExtent3D* result = Nan::ObjectWrap::Unwrap<_VkExtent3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkImageCopy::New) {
  if (info.IsConstructCall()) {
    _VkImageCopy* self = new _VkImageCopy();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("srcSubresource").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("srcOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dstSubresource").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("extent").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageCopy constructor cannot be invoked without 'new'");
  }
};

// srcSubresource
NAN_GETTER(_VkImageCopy::GetsrcSubresource) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  if (self->srcSubresource.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->srcSubresource);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageCopy::SetsrcSubresource) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceLayers::constructor)->HasInstance(obj)) {
      self->srcSubresource.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceLayers* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(obj);
      inst->flush();
      self->instance.srcSubresource = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageCopy.srcSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->srcSubresource.Reset();
    memset(&self->instance.srcSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCopy.srcSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// srcOffset
NAN_GETTER(_VkImageCopy::GetsrcOffset) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  if (self->srcOffset.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->srcOffset);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageCopy::SetsrcOffset) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkOffset3D::constructor)->HasInstance(obj)) {
      self->srcOffset.Reset<v8::Object>(value.As<v8::Object>());
      _VkOffset3D* inst = Nan::ObjectWrap::Unwrap<_VkOffset3D>(obj);
      inst->flush();
      self->instance.srcOffset = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageCopy.srcOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->srcOffset.Reset();
    memset(&self->instance.srcOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCopy.srcOffset", "[object VkOffset3D]");
  
    return;
  }
}// dstSubresource
NAN_GETTER(_VkImageCopy::GetdstSubresource) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  if (self->dstSubresource.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->dstSubresource);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageCopy::SetdstSubresource) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceLayers::constructor)->HasInstance(obj)) {
      self->dstSubresource.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceLayers* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceLayers>(obj);
      inst->flush();
      self->instance.dstSubresource = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageCopy.dstSubresource", "[object VkImageSubresourceLayers]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->dstSubresource.Reset();
    memset(&self->instance.dstSubresource, 0, sizeof(VkImageSubresourceLayers));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCopy.dstSubresource", "[object VkImageSubresourceLayers]");
  
    return;
  }
}// dstOffset
NAN_GETTER(_VkImageCopy::GetdstOffset) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  if (self->dstOffset.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->dstOffset);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageCopy::SetdstOffset) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkOffset3D::constructor)->HasInstance(obj)) {
      self->dstOffset.Reset<v8::Object>(value.As<v8::Object>());
      _VkOffset3D* inst = Nan::ObjectWrap::Unwrap<_VkOffset3D>(obj);
      inst->flush();
      self->instance.dstOffset = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageCopy.dstOffset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->dstOffset.Reset();
    memset(&self->instance.dstOffset, 0, sizeof(VkOffset3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCopy.dstOffset", "[object VkOffset3D]");
  
    return;
  }
}// extent
NAN_GETTER(_VkImageCopy::Getextent) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  if (self->extent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->extent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageCopy::Setextent) {
  _VkImageCopy *self = Nan::ObjectWrap::Unwrap<_VkImageCopy>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent3D::constructor)->HasInstance(obj)) {
      self->extent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent3D* inst = Nan::ObjectWrap::Unwrap<_VkExtent3D>(obj);
      inst->flush();
      self->instance.extent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageCopy.extent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->extent.Reset();
    memset(&self->instance.extent, 0, sizeof(VkExtent3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCopy.extent", "[object VkExtent3D]");
  
    return;
  }
}
/** ## END VkImageCopy ## **/

/** ## BEGIN VkImageSubresource ## **/

class _VkImageSubresource: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetaspectMask);
    static NAN_SETTER(SetaspectMask);
    
    static NAN_GETTER(GetmipLevel);
    static NAN_SETTER(SetmipLevel);
    
    static NAN_GETTER(GetarrayLayer);
    static NAN_SETTER(SetarrayLayer);
    

    // real instance
    VkImageSubresource instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageSubresource();
    ~_VkImageSubresource();

};

/*
#include "index.h"
#include "VkImageSubresource.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageSubresource::constructor;

_VkImageSubresource::_VkImageSubresource() {
  
  
}

_VkImageSubresource::~_VkImageSubresource() {
  //printf("VkImageSubresource deconstructed!!\n");
  
  
  
  
}

void _VkImageSubresource::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageSubresource::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageSubresource").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("aspectMask").ToLocalChecked(), GetaspectMask, SetaspectMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("mipLevel").ToLocalChecked(), GetmipLevel, SetmipLevel, ctor);
  SetPrototypeAccessor(proto, Nan::New("arrayLayer").ToLocalChecked(), GetarrayLayer, SetarrayLayer, ctor);
  Nan::Set(target, Nan::New("VkImageSubresource").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageSubresource::flush() {
  _VkImageSubresource *self = this;
  
  return true;
}

NAN_METHOD(_VkImageSubresource::New) {
  if (info.IsConstructCall()) {
    _VkImageSubresource* self = new _VkImageSubresource();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("aspectMask").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("mipLevel").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("arrayLayer").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageSubresource constructor cannot be invoked without 'new'");
  }
};

// aspectMask
NAN_GETTER(_VkImageSubresource::GetaspectMask) {
  _VkImageSubresource *self = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.aspectMask));
}NAN_SETTER(_VkImageSubresource::SetaspectMask) {
  _VkImageSubresource *self = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(info.This());
  if (value->IsNumber()) {
    self->instance.aspectMask = static_cast<VkImageAspectFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresource.aspectMask", "Number");
  
    return;
  }
}// mipLevel
NAN_GETTER(_VkImageSubresource::GetmipLevel) {
  _VkImageSubresource *self = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.mipLevel));
}NAN_SETTER(_VkImageSubresource::SetmipLevel) {
  _VkImageSubresource *self = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(info.This());
  if (value->IsNumber()) {
    self->instance.mipLevel = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresource.mipLevel", "Number");
  
    return;
  }
}// arrayLayer
NAN_GETTER(_VkImageSubresource::GetarrayLayer) {
  _VkImageSubresource *self = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.arrayLayer));
}NAN_SETTER(_VkImageSubresource::SetarrayLayer) {
  _VkImageSubresource *self = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(info.This());
  if (value->IsNumber()) {
    self->instance.arrayLayer = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresource.arrayLayer", "Number");
  
    return;
  }
}
/** ## END VkImageSubresource ## **/

/** ## BEGIN VkSparseImageMemoryBind ## **/

class _VkSparseImageMemoryBind: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> subresource;
      static NAN_GETTER(Getsubresource);
    static NAN_SETTER(Setsubresource);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> offset;
      static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> extent;
      static NAN_GETTER(Getextent);
    static NAN_SETTER(Setextent);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memory;
      static NAN_GETTER(Getmemory);
    static NAN_SETTER(Setmemory);
    
    static NAN_GETTER(GetmemoryOffset);
    static NAN_SETTER(SetmemoryOffset);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkSparseImageMemoryBind instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageMemoryBind();
    ~_VkSparseImageMemoryBind();

};

/*
#include "index.h"
#include "VkSparseImageMemoryBind.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageMemoryBind::constructor;

_VkSparseImageMemoryBind::_VkSparseImageMemoryBind() {
  
  
}

_VkSparseImageMemoryBind::~_VkSparseImageMemoryBind() {
  //printf("VkSparseImageMemoryBind deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkSparseImageMemoryBind::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageMemoryBind::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageMemoryBind").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("subresource").ToLocalChecked(), Getsubresource, Setsubresource, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("extent").ToLocalChecked(), Getextent, Setextent, ctor);
  SetPrototypeAccessor(proto, Nan::New("memory").ToLocalChecked(), Getmemory, Setmemory, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryOffset").ToLocalChecked(), GetmemoryOffset, SetmemoryOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkSparseImageMemoryBind").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageMemoryBind::flush() {
  _VkSparseImageMemoryBind *self = this;
  if (!(self->subresource.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->subresource);
    
    _VkImageSubresource* result = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.subresource = result->instance;
  }if (!(self->offset.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->offset);
    
    _VkOffset3D* result = Nan::ObjectWrap::Unwrap<_VkOffset3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.offset = result->instance;
  }if (!(self->extent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->extent);
    
    _VkExtent3D* result = Nan::ObjectWrap::Unwrap<_VkExtent3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkSparseImageMemoryBind::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageMemoryBind* self = new _VkSparseImageMemoryBind();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("subresource").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("extent").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("memory").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("memoryOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageMemoryBind constructor cannot be invoked without 'new'");
  }
};

// subresource
NAN_GETTER(_VkSparseImageMemoryBind::Getsubresource) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  if (self->subresource.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->subresource);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseImageMemoryBind::Setsubresource) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresource::constructor)->HasInstance(obj)) {
      self->subresource.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresource* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(obj);
      inst->flush();
      self->instance.subresource = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.subresource", "[object VkImageSubresource]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->subresource.Reset();
    memset(&self->instance.subresource, 0, sizeof(VkImageSubresource));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.subresource", "[object VkImageSubresource]");
  
    return;
  }
}// offset
NAN_GETTER(_VkSparseImageMemoryBind::Getoffset) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  if (self->offset.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->offset);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseImageMemoryBind::Setoffset) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkOffset3D::constructor)->HasInstance(obj)) {
      self->offset.Reset<v8::Object>(value.As<v8::Object>());
      _VkOffset3D* inst = Nan::ObjectWrap::Unwrap<_VkOffset3D>(obj);
      inst->flush();
      self->instance.offset = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.offset", "[object VkOffset3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->offset.Reset();
    memset(&self->instance.offset, 0, sizeof(VkOffset3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.offset", "[object VkOffset3D]");
  
    return;
  }
}// extent
NAN_GETTER(_VkSparseImageMemoryBind::Getextent) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  if (self->extent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->extent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseImageMemoryBind::Setextent) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent3D::constructor)->HasInstance(obj)) {
      self->extent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent3D* inst = Nan::ObjectWrap::Unwrap<_VkExtent3D>(obj);
      inst->flush();
      self->instance.extent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.extent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->extent.Reset();
    memset(&self->instance.extent, 0, sizeof(VkExtent3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.extent", "[object VkExtent3D]");
  
    return;
  }
}// memory
NAN_GETTER(_VkSparseImageMemoryBind::Getmemory) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  if (self->memory.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memory);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseImageMemoryBind::Setmemory) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj)) {
      self->memory.Reset<v8::Object>(value.As<v8::Object>());
      _VkDeviceMemory* inst = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      ;
      self->instance.memory = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->memory.Reset();
    self->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
NAN_GETTER(_VkSparseImageMemoryBind::GetmemoryOffset) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryOffset));
}NAN_SETTER(_VkSparseImageMemoryBind::SetmemoryOffset) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  if (value->IsNumber()) {
    self->instance.memoryOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.memoryOffset", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkSparseImageMemoryBind::Getflags) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkSparseImageMemoryBind::Setflags) {
  _VkSparseImageMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSparseMemoryBindFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBind.flags", "Number");
  
    return;
  }
}
/** ## END VkSparseImageMemoryBind ## **/

/** ## BEGIN VkSparseImageMemoryBindInfo ## **/

class _VkSparseImageMemoryBindInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    
    static NAN_GETTER(GetbindCount);
    static NAN_SETTER(SetbindCount);
    
    std::vector<VkSparseImageMemoryBind>* vpBinds;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pBinds;
    static NAN_GETTER(GetpBinds);
    static NAN_SETTER(SetpBinds);
    

    // real instance
    VkSparseImageMemoryBindInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageMemoryBindInfo();
    ~_VkSparseImageMemoryBindInfo();

};

/*
#include "index.h"
#include "VkSparseImageMemoryBindInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageMemoryBindInfo::constructor;

_VkSparseImageMemoryBindInfo::_VkSparseImageMemoryBindInfo() {
  
  vpBinds = new std::vector<VkSparseImageMemoryBind>;
  
}

_VkSparseImageMemoryBindInfo::~_VkSparseImageMemoryBindInfo() {
  //printf("VkSparseImageMemoryBindInfo deconstructed!!\n");
  
  
  
  vpBinds->clear();
  delete vpBinds;
  
  pBinds.Reset();
  
}

void _VkSparseImageMemoryBindInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageMemoryBindInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageMemoryBindInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  SetPrototypeAccessor(proto, Nan::New("bindCount").ToLocalChecked(), GetbindCount, SetbindCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pBinds").ToLocalChecked(), GetpBinds, SetpBinds, ctor);
  Nan::Set(target, Nan::New("VkSparseImageMemoryBindInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageMemoryBindInfo::flush() {
  _VkSparseImageMemoryBindInfo *self = this;
  if (!(self->pBinds.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pBinds);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.bindCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'bindCount' for 'VkSparseImageMemoryBindInfo.pBinds'");
      return false;
    }
    std::vector<VkSparseImageMemoryBind>* data = self->vpBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSparseImageMemoryBind::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBindInfo.pBinds", "[object VkSparseImageMemoryBind]");
  
        return false;
      }
      _VkSparseImageMemoryBind* result = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBind>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBinds = data->data();
  }
  return true;
}

NAN_METHOD(_VkSparseImageMemoryBindInfo::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageMemoryBindInfo* self = new _VkSparseImageMemoryBindInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("image").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("bindCount").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pBinds").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageMemoryBindInfo constructor cannot be invoked without 'new'");
  }
};

// image
NAN_GETTER(_VkSparseImageMemoryBindInfo::Getimage) {
  _VkSparseImageMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBindInfo>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseImageMemoryBindInfo::Setimage) {
  _VkSparseImageMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBindInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBindInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBindInfo.image", "[object VkImage]");
  
    return;
  }
}// bindCount
NAN_GETTER(_VkSparseImageMemoryBindInfo::GetbindCount) {
  _VkSparseImageMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBindInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bindCount));
}NAN_SETTER(_VkSparseImageMemoryBindInfo::SetbindCount) {
  _VkSparseImageMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBindInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.bindCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBindInfo.bindCount", "Number");
  
    return;
  }
}// pBinds
NAN_GETTER(_VkSparseImageMemoryBindInfo::GetpBinds) {
  _VkSparseImageMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBindInfo>(info.This());
  if (self->pBinds.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pBinds);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseImageMemoryBindInfo::SetpBinds) {
  _VkSparseImageMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBindInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pBinds.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pBinds.Reset();
      self->instance.pBinds = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBindInfo.pBinds", "[object VkSparseImageMemoryBind]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pBinds = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageMemoryBindInfo.pBinds", "[object VkSparseImageMemoryBind]");
  
    return;
  }
}
/** ## END VkSparseImageMemoryBindInfo ## **/

/** ## BEGIN VkSparseMemoryBind ## **/

class _VkSparseMemoryBind: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetresourceOffset);
    static NAN_SETTER(SetresourceOffset);
    
    static NAN_GETTER(Getsize);
    static NAN_SETTER(Setsize);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memory;
      static NAN_GETTER(Getmemory);
    static NAN_SETTER(Setmemory);
    
    static NAN_GETTER(GetmemoryOffset);
    static NAN_SETTER(SetmemoryOffset);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    

    // real instance
    VkSparseMemoryBind instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseMemoryBind();
    ~_VkSparseMemoryBind();

};

/*
#include "index.h"
#include "VkSparseMemoryBind.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseMemoryBind::constructor;

_VkSparseMemoryBind::_VkSparseMemoryBind() {
  
  
}

_VkSparseMemoryBind::~_VkSparseMemoryBind() {
  //printf("VkSparseMemoryBind deconstructed!!\n");
  
  
  
  
  
  
}

void _VkSparseMemoryBind::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseMemoryBind::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseMemoryBind").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("resourceOffset").ToLocalChecked(), GetresourceOffset, SetresourceOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, Setsize, ctor);
  SetPrototypeAccessor(proto, Nan::New("memory").ToLocalChecked(), Getmemory, Setmemory, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryOffset").ToLocalChecked(), GetmemoryOffset, SetmemoryOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  Nan::Set(target, Nan::New("VkSparseMemoryBind").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseMemoryBind::flush() {
  _VkSparseMemoryBind *self = this;
  
  return true;
}

NAN_METHOD(_VkSparseMemoryBind::New) {
  if (info.IsConstructCall()) {
    _VkSparseMemoryBind* self = new _VkSparseMemoryBind();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("resourceOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("size").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("memory").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("memoryOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("flags").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseMemoryBind constructor cannot be invoked without 'new'");
  }
};

// resourceOffset
NAN_GETTER(_VkSparseMemoryBind::GetresourceOffset) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.resourceOffset));
}NAN_SETTER(_VkSparseMemoryBind::SetresourceOffset) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  if (value->IsNumber()) {
    self->instance.resourceOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseMemoryBind.resourceOffset", "Number");
  
    return;
  }
}// size
NAN_GETTER(_VkSparseMemoryBind::Getsize) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}NAN_SETTER(_VkSparseMemoryBind::Setsize) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  if (value->IsNumber()) {
    self->instance.size = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseMemoryBind.size", "Number");
  
    return;
  }
}// memory
NAN_GETTER(_VkSparseMemoryBind::Getmemory) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  if (self->memory.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memory);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseMemoryBind::Setmemory) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj)) {
      self->memory.Reset<v8::Object>(value.As<v8::Object>());
      _VkDeviceMemory* inst = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      ;
      self->instance.memory = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseMemoryBind.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->memory.Reset();
    self->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseMemoryBind.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// memoryOffset
NAN_GETTER(_VkSparseMemoryBind::GetmemoryOffset) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryOffset));
}NAN_SETTER(_VkSparseMemoryBind::SetmemoryOffset) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  if (value->IsNumber()) {
    self->instance.memoryOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseMemoryBind.memoryOffset", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkSparseMemoryBind::Getflags) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkSparseMemoryBind::Setflags) {
  _VkSparseMemoryBind *self = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkSparseMemoryBindFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseMemoryBind.flags", "Number");
  
    return;
  }
}
/** ## END VkSparseMemoryBind ## **/

/** ## BEGIN VkSparseImageOpaqueMemoryBindInfo ## **/

class _VkSparseImageOpaqueMemoryBindInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    
    static NAN_GETTER(GetbindCount);
    static NAN_SETTER(SetbindCount);
    
    std::vector<VkSparseMemoryBind>* vpBinds;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pBinds;
    static NAN_GETTER(GetpBinds);
    static NAN_SETTER(SetpBinds);
    

    // real instance
    VkSparseImageOpaqueMemoryBindInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseImageOpaqueMemoryBindInfo();
    ~_VkSparseImageOpaqueMemoryBindInfo();

};

/*
#include "index.h"
#include "VkSparseImageOpaqueMemoryBindInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseImageOpaqueMemoryBindInfo::constructor;

_VkSparseImageOpaqueMemoryBindInfo::_VkSparseImageOpaqueMemoryBindInfo() {
  
  vpBinds = new std::vector<VkSparseMemoryBind>;
  
}

_VkSparseImageOpaqueMemoryBindInfo::~_VkSparseImageOpaqueMemoryBindInfo() {
  //printf("VkSparseImageOpaqueMemoryBindInfo deconstructed!!\n");
  
  
  
  vpBinds->clear();
  delete vpBinds;
  
  pBinds.Reset();
  
}

void _VkSparseImageOpaqueMemoryBindInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseImageOpaqueMemoryBindInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseImageOpaqueMemoryBindInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  SetPrototypeAccessor(proto, Nan::New("bindCount").ToLocalChecked(), GetbindCount, SetbindCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pBinds").ToLocalChecked(), GetpBinds, SetpBinds, ctor);
  Nan::Set(target, Nan::New("VkSparseImageOpaqueMemoryBindInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseImageOpaqueMemoryBindInfo::flush() {
  _VkSparseImageOpaqueMemoryBindInfo *self = this;
  if (!(self->pBinds.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pBinds);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.bindCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'bindCount' for 'VkSparseImageOpaqueMemoryBindInfo.pBinds'");
      return false;
    }
    std::vector<VkSparseMemoryBind>* data = self->vpBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSparseMemoryBind::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
        return false;
      }
      _VkSparseMemoryBind* result = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBinds = data->data();
  }
  return true;
}

NAN_METHOD(_VkSparseImageOpaqueMemoryBindInfo::New) {
  if (info.IsConstructCall()) {
    _VkSparseImageOpaqueMemoryBindInfo* self = new _VkSparseImageOpaqueMemoryBindInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("image").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("bindCount").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pBinds").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseImageOpaqueMemoryBindInfo constructor cannot be invoked without 'new'");
  }
};

// image
NAN_GETTER(_VkSparseImageOpaqueMemoryBindInfo::Getimage) {
  _VkSparseImageOpaqueMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageOpaqueMemoryBindInfo>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseImageOpaqueMemoryBindInfo::Setimage) {
  _VkSparseImageOpaqueMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageOpaqueMemoryBindInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.image", "[object VkImage]");
  
    return;
  }
}// bindCount
NAN_GETTER(_VkSparseImageOpaqueMemoryBindInfo::GetbindCount) {
  _VkSparseImageOpaqueMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageOpaqueMemoryBindInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bindCount));
}NAN_SETTER(_VkSparseImageOpaqueMemoryBindInfo::SetbindCount) {
  _VkSparseImageOpaqueMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageOpaqueMemoryBindInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.bindCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.bindCount", "Number");
  
    return;
  }
}// pBinds
NAN_GETTER(_VkSparseImageOpaqueMemoryBindInfo::GetpBinds) {
  _VkSparseImageOpaqueMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageOpaqueMemoryBindInfo>(info.This());
  if (self->pBinds.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pBinds);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseImageOpaqueMemoryBindInfo::SetpBinds) {
  _VkSparseImageOpaqueMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseImageOpaqueMemoryBindInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pBinds.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pBinds.Reset();
      self->instance.pBinds = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pBinds = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseImageOpaqueMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
    return;
  }
}
/** ## END VkSparseImageOpaqueMemoryBindInfo ## **/

/** ## BEGIN VkSparseBufferMemoryBindInfo ## **/

class _VkSparseBufferMemoryBindInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    
    static NAN_GETTER(GetbindCount);
    static NAN_SETTER(SetbindCount);
    
    std::vector<VkSparseMemoryBind>* vpBinds;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pBinds;
    static NAN_GETTER(GetpBinds);
    static NAN_SETTER(SetpBinds);
    

    // real instance
    VkSparseBufferMemoryBindInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkSparseBufferMemoryBindInfo();
    ~_VkSparseBufferMemoryBindInfo();

};

/*
#include "index.h"
#include "VkSparseBufferMemoryBindInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkSparseBufferMemoryBindInfo::constructor;

_VkSparseBufferMemoryBindInfo::_VkSparseBufferMemoryBindInfo() {
  
  vpBinds = new std::vector<VkSparseMemoryBind>;
  
}

_VkSparseBufferMemoryBindInfo::~_VkSparseBufferMemoryBindInfo() {
  //printf("VkSparseBufferMemoryBindInfo deconstructed!!\n");
  
  
  
  vpBinds->clear();
  delete vpBinds;
  
  pBinds.Reset();
  
}

void _VkSparseBufferMemoryBindInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkSparseBufferMemoryBindInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkSparseBufferMemoryBindInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("bindCount").ToLocalChecked(), GetbindCount, SetbindCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pBinds").ToLocalChecked(), GetpBinds, SetpBinds, ctor);
  Nan::Set(target, Nan::New("VkSparseBufferMemoryBindInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkSparseBufferMemoryBindInfo::flush() {
  _VkSparseBufferMemoryBindInfo *self = this;
  if (!(self->pBinds.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pBinds);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.bindCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'bindCount' for 'VkSparseBufferMemoryBindInfo.pBinds'");
      return false;
    }
    std::vector<VkSparseMemoryBind>* data = self->vpBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSparseMemoryBind::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkSparseBufferMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
        return false;
      }
      _VkSparseMemoryBind* result = Nan::ObjectWrap::Unwrap<_VkSparseMemoryBind>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBinds = data->data();
  }
  return true;
}

NAN_METHOD(_VkSparseBufferMemoryBindInfo::New) {
  if (info.IsConstructCall()) {
    _VkSparseBufferMemoryBindInfo* self = new _VkSparseBufferMemoryBindInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("buffer").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("bindCount").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pBinds").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkSparseBufferMemoryBindInfo constructor cannot be invoked without 'new'");
  }
};

// buffer
NAN_GETTER(_VkSparseBufferMemoryBindInfo::Getbuffer) {
  _VkSparseBufferMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseBufferMemoryBindInfo>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseBufferMemoryBindInfo::Setbuffer) {
  _VkSparseBufferMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseBufferMemoryBindInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseBufferMemoryBindInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseBufferMemoryBindInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}// bindCount
NAN_GETTER(_VkSparseBufferMemoryBindInfo::GetbindCount) {
  _VkSparseBufferMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseBufferMemoryBindInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bindCount));
}NAN_SETTER(_VkSparseBufferMemoryBindInfo::SetbindCount) {
  _VkSparseBufferMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseBufferMemoryBindInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.bindCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseBufferMemoryBindInfo.bindCount", "Number");
  
    return;
  }
}// pBinds
NAN_GETTER(_VkSparseBufferMemoryBindInfo::GetpBinds) {
  _VkSparseBufferMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseBufferMemoryBindInfo>(info.This());
  if (self->pBinds.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pBinds);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkSparseBufferMemoryBindInfo::SetpBinds) {
  _VkSparseBufferMemoryBindInfo *self = Nan::ObjectWrap::Unwrap<_VkSparseBufferMemoryBindInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pBinds.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pBinds.Reset();
      self->instance.pBinds = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkSparseBufferMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pBinds = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkSparseBufferMemoryBindInfo.pBinds", "[object VkSparseMemoryBind]");
  
    return;
  }
}
/** ## END VkSparseBufferMemoryBindInfo ## **/

/** ## BEGIN VkBindSparseInfo ## **/

class _VkBindSparseInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetwaitSemaphoreCount);
    static NAN_SETTER(SetwaitSemaphoreCount);
    
    std::vector<VkSemaphore>* vpWaitSemaphores;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pWaitSemaphores;
    static NAN_GETTER(GetpWaitSemaphores);
    static NAN_SETTER(SetpWaitSemaphores);
    
    static NAN_GETTER(GetbufferBindCount);
    static NAN_SETTER(SetbufferBindCount);
    
    std::vector<VkSparseBufferMemoryBindInfo>* vpBufferBinds;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pBufferBinds;
    static NAN_GETTER(GetpBufferBinds);
    static NAN_SETTER(SetpBufferBinds);
    
    static NAN_GETTER(GetimageOpaqueBindCount);
    static NAN_SETTER(SetimageOpaqueBindCount);
    
    std::vector<VkSparseImageOpaqueMemoryBindInfo>* vpImageOpaqueBinds;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pImageOpaqueBinds;
    static NAN_GETTER(GetpImageOpaqueBinds);
    static NAN_SETTER(SetpImageOpaqueBinds);
    
    static NAN_GETTER(GetimageBindCount);
    static NAN_SETTER(SetimageBindCount);
    
    std::vector<VkSparseImageMemoryBindInfo>* vpImageBinds;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pImageBinds;
    static NAN_GETTER(GetpImageBinds);
    static NAN_SETTER(SetpImageBinds);
    
    static NAN_GETTER(GetsignalSemaphoreCount);
    static NAN_SETTER(SetsignalSemaphoreCount);
    
    std::vector<VkSemaphore>* vpSignalSemaphores;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pSignalSemaphores;
    static NAN_GETTER(GetpSignalSemaphores);
    static NAN_SETTER(SetpSignalSemaphores);
    

    // real instance
    VkBindSparseInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBindSparseInfo();
    ~_VkBindSparseInfo();

};

/*
#include "index.h"
#include "VkBindSparseInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBindSparseInfo::constructor;

_VkBindSparseInfo::_VkBindSparseInfo() {
  instance.sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
  vpWaitSemaphores = new std::vector<VkSemaphore>;
  vpBufferBinds = new std::vector<VkSparseBufferMemoryBindInfo>;
  vpImageOpaqueBinds = new std::vector<VkSparseImageOpaqueMemoryBindInfo>;
  vpImageBinds = new std::vector<VkSparseImageMemoryBindInfo>;
  vpSignalSemaphores = new std::vector<VkSemaphore>;
  
}

_VkBindSparseInfo::~_VkBindSparseInfo() {
  //printf("VkBindSparseInfo deconstructed!!\n");
  
  
  
  vpWaitSemaphores->clear();
  delete vpWaitSemaphores;
  
  pWaitSemaphores.Reset();
  
  
  vpBufferBinds->clear();
  delete vpBufferBinds;
  
  pBufferBinds.Reset();
  
  
  vpImageOpaqueBinds->clear();
  delete vpImageOpaqueBinds;
  
  pImageOpaqueBinds.Reset();
  
  
  vpImageBinds->clear();
  delete vpImageBinds;
  
  pImageBinds.Reset();
  
  
  vpSignalSemaphores->clear();
  delete vpSignalSemaphores;
  
  pSignalSemaphores.Reset();
  
}

void _VkBindSparseInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBindSparseInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBindSparseInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("waitSemaphoreCount").ToLocalChecked(), GetwaitSemaphoreCount, SetwaitSemaphoreCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pWaitSemaphores").ToLocalChecked(), GetpWaitSemaphores, SetpWaitSemaphores, ctor);
  SetPrototypeAccessor(proto, Nan::New("bufferBindCount").ToLocalChecked(), GetbufferBindCount, SetbufferBindCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pBufferBinds").ToLocalChecked(), GetpBufferBinds, SetpBufferBinds, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageOpaqueBindCount").ToLocalChecked(), GetimageOpaqueBindCount, SetimageOpaqueBindCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pImageOpaqueBinds").ToLocalChecked(), GetpImageOpaqueBinds, SetpImageOpaqueBinds, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageBindCount").ToLocalChecked(), GetimageBindCount, SetimageBindCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pImageBinds").ToLocalChecked(), GetpImageBinds, SetpImageBinds, ctor);
  SetPrototypeAccessor(proto, Nan::New("signalSemaphoreCount").ToLocalChecked(), GetsignalSemaphoreCount, SetsignalSemaphoreCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pSignalSemaphores").ToLocalChecked(), GetpSignalSemaphores, SetpSignalSemaphores, ctor);
  Nan::Set(target, Nan::New("VkBindSparseInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBindSparseInfo::flush() {
  _VkBindSparseInfo *self = this;
  if (!(self->pWaitSemaphores.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pWaitSemaphores);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.waitSemaphoreCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'waitSemaphoreCount' for 'VkBindSparseInfo.pWaitSemaphores'");
      return false;
    }
    std::vector<VkSemaphore>* data = self->vpWaitSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSemaphore::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pWaitSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pWaitSemaphores = data->data();
  }if (!(self->pBufferBinds.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pBufferBinds);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.bufferBindCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'bufferBindCount' for 'VkBindSparseInfo.pBufferBinds'");
      return false;
    }
    std::vector<VkSparseBufferMemoryBindInfo>* data = self->vpBufferBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSparseBufferMemoryBindInfo::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pBufferBinds", "[object VkSparseBufferMemoryBindInfo]");
  
        return false;
      }
      _VkSparseBufferMemoryBindInfo* result = Nan::ObjectWrap::Unwrap<_VkSparseBufferMemoryBindInfo>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBufferBinds = data->data();
  }if (!(self->pImageOpaqueBinds.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pImageOpaqueBinds);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.imageOpaqueBindCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'imageOpaqueBindCount' for 'VkBindSparseInfo.pImageOpaqueBinds'");
      return false;
    }
    std::vector<VkSparseImageOpaqueMemoryBindInfo>* data = self->vpImageOpaqueBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSparseImageOpaqueMemoryBindInfo::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pImageOpaqueBinds", "[object VkSparseImageOpaqueMemoryBindInfo]");
  
        return false;
      }
      _VkSparseImageOpaqueMemoryBindInfo* result = Nan::ObjectWrap::Unwrap<_VkSparseImageOpaqueMemoryBindInfo>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pImageOpaqueBinds = data->data();
  }if (!(self->pImageBinds.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pImageBinds);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.imageBindCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'imageBindCount' for 'VkBindSparseInfo.pImageBinds'");
      return false;
    }
    std::vector<VkSparseImageMemoryBindInfo>* data = self->vpImageBinds;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSparseImageMemoryBindInfo::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pImageBinds", "[object VkSparseImageMemoryBindInfo]");
  
        return false;
      }
      _VkSparseImageMemoryBindInfo* result = Nan::ObjectWrap::Unwrap<_VkSparseImageMemoryBindInfo>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pImageBinds = data->data();
  }if (!(self->pSignalSemaphores.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pSignalSemaphores);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.signalSemaphoreCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'signalSemaphoreCount' for 'VkBindSparseInfo.pSignalSemaphores'");
      return false;
    }
    std::vector<VkSemaphore>* data = self->vpSignalSemaphores;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkSemaphore::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pSignalSemaphores", "[object VkSemaphore]");
  
        return false;
      }
      _VkSemaphore* result = Nan::ObjectWrap::Unwrap<_VkSemaphore>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pSignalSemaphores = data->data();
  }
  return true;
}

NAN_METHOD(_VkBindSparseInfo::New) {
  if (info.IsConstructCall()) {
    _VkBindSparseInfo* self = new _VkBindSparseInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("waitSemaphoreCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pWaitSemaphores").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("bufferBindCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pBufferBinds").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("imageOpaqueBindCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pImageOpaqueBinds").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("imageBindCount").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("pImageBinds").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("signalSemaphoreCount").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("pSignalSemaphores").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBindSparseInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBindSparseInfo::GetsType) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBindSparseInfo::SetsType) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.sType", "Number");
  
    return;
  }
}// waitSemaphoreCount
NAN_GETTER(_VkBindSparseInfo::GetwaitSemaphoreCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.waitSemaphoreCount));
}NAN_SETTER(_VkBindSparseInfo::SetwaitSemaphoreCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.waitSemaphoreCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.waitSemaphoreCount", "Number");
  
    return;
  }
}// pWaitSemaphores
NAN_GETTER(_VkBindSparseInfo::GetpWaitSemaphores) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (self->pWaitSemaphores.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pWaitSemaphores);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindSparseInfo::SetpWaitSemaphores) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pWaitSemaphores.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pWaitSemaphores.Reset();
      self->instance.pWaitSemaphores = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pWaitSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pWaitSemaphores = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pWaitSemaphores", "[object VkSemaphore]");
  
    return;
  }
}// bufferBindCount
NAN_GETTER(_VkBindSparseInfo::GetbufferBindCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.bufferBindCount));
}NAN_SETTER(_VkBindSparseInfo::SetbufferBindCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.bufferBindCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.bufferBindCount", "Number");
  
    return;
  }
}// pBufferBinds
NAN_GETTER(_VkBindSparseInfo::GetpBufferBinds) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (self->pBufferBinds.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pBufferBinds);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindSparseInfo::SetpBufferBinds) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pBufferBinds.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pBufferBinds.Reset();
      self->instance.pBufferBinds = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pBufferBinds", "[object VkSparseBufferMemoryBindInfo]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pBufferBinds = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pBufferBinds", "[object VkSparseBufferMemoryBindInfo]");
  
    return;
  }
}// imageOpaqueBindCount
NAN_GETTER(_VkBindSparseInfo::GetimageOpaqueBindCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageOpaqueBindCount));
}NAN_SETTER(_VkBindSparseInfo::SetimageOpaqueBindCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.imageOpaqueBindCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.imageOpaqueBindCount", "Number");
  
    return;
  }
}// pImageOpaqueBinds
NAN_GETTER(_VkBindSparseInfo::GetpImageOpaqueBinds) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (self->pImageOpaqueBinds.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pImageOpaqueBinds);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindSparseInfo::SetpImageOpaqueBinds) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pImageOpaqueBinds.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pImageOpaqueBinds.Reset();
      self->instance.pImageOpaqueBinds = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pImageOpaqueBinds", "[object VkSparseImageOpaqueMemoryBindInfo]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pImageOpaqueBinds = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pImageOpaqueBinds", "[object VkSparseImageOpaqueMemoryBindInfo]");
  
    return;
  }
}// imageBindCount
NAN_GETTER(_VkBindSparseInfo::GetimageBindCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageBindCount));
}NAN_SETTER(_VkBindSparseInfo::SetimageBindCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.imageBindCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.imageBindCount", "Number");
  
    return;
  }
}// pImageBinds
NAN_GETTER(_VkBindSparseInfo::GetpImageBinds) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (self->pImageBinds.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pImageBinds);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindSparseInfo::SetpImageBinds) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pImageBinds.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pImageBinds.Reset();
      self->instance.pImageBinds = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pImageBinds", "[object VkSparseImageMemoryBindInfo]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pImageBinds = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pImageBinds", "[object VkSparseImageMemoryBindInfo]");
  
    return;
  }
}// signalSemaphoreCount
NAN_GETTER(_VkBindSparseInfo::GetsignalSemaphoreCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.signalSemaphoreCount));
}NAN_SETTER(_VkBindSparseInfo::SetsignalSemaphoreCount) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.signalSemaphoreCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.signalSemaphoreCount", "Number");
  
    return;
  }
}// pSignalSemaphores
NAN_GETTER(_VkBindSparseInfo::GetpSignalSemaphores) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  if (self->pSignalSemaphores.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pSignalSemaphores);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBindSparseInfo::SetpSignalSemaphores) {
  _VkBindSparseInfo *self = Nan::ObjectWrap::Unwrap<_VkBindSparseInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pSignalSemaphores.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pSignalSemaphores.Reset();
      self->instance.pSignalSemaphores = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pSignalSemaphores", "[object VkSemaphore]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pSignalSemaphores = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBindSparseInfo.pSignalSemaphores", "[object VkSemaphore]");
  
    return;
  }
}
/** ## END VkBindSparseInfo ## **/

/** ## BEGIN VkBufferCopy ## **/

class _VkBufferCopy: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsrcOffset);
    static NAN_SETTER(SetsrcOffset);
    
    static NAN_GETTER(GetdstOffset);
    static NAN_SETTER(SetdstOffset);
    
    static NAN_GETTER(Getsize);
    static NAN_SETTER(Setsize);
    

    // real instance
    VkBufferCopy instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferCopy();
    ~_VkBufferCopy();

};

/*
#include "index.h"
#include "VkBufferCopy.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferCopy::constructor;

_VkBufferCopy::_VkBufferCopy() {
  
  
}

_VkBufferCopy::~_VkBufferCopy() {
  //printf("VkBufferCopy deconstructed!!\n");
  
  
  
  
}

void _VkBufferCopy::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferCopy::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferCopy").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("srcOffset").ToLocalChecked(), GetsrcOffset, SetsrcOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstOffset").ToLocalChecked(), GetdstOffset, SetdstOffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, Setsize, ctor);
  Nan::Set(target, Nan::New("VkBufferCopy").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferCopy::flush() {
  _VkBufferCopy *self = this;
  
  return true;
}

NAN_METHOD(_VkBufferCopy::New) {
  if (info.IsConstructCall()) {
    _VkBufferCopy* self = new _VkBufferCopy();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("srcOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("dstOffset").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("size").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferCopy constructor cannot be invoked without 'new'");
  }
};

// srcOffset
NAN_GETTER(_VkBufferCopy::GetsrcOffset) {
  _VkBufferCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferCopy>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcOffset));
}NAN_SETTER(_VkBufferCopy::SetsrcOffset) {
  _VkBufferCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferCopy>(info.This());
  if (value->IsNumber()) {
    self->instance.srcOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCopy.srcOffset", "Number");
  
    return;
  }
}// dstOffset
NAN_GETTER(_VkBufferCopy::GetdstOffset) {
  _VkBufferCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferCopy>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstOffset));
}NAN_SETTER(_VkBufferCopy::SetdstOffset) {
  _VkBufferCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferCopy>(info.This());
  if (value->IsNumber()) {
    self->instance.dstOffset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCopy.dstOffset", "Number");
  
    return;
  }
}// size
NAN_GETTER(_VkBufferCopy::Getsize) {
  _VkBufferCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferCopy>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}NAN_SETTER(_VkBufferCopy::Setsize) {
  _VkBufferCopy *self = Nan::ObjectWrap::Unwrap<_VkBufferCopy>(info.This());
  if (value->IsNumber()) {
    self->instance.size = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCopy.size", "Number");
  
    return;
  }
}
/** ## END VkBufferCopy ## **/

/** ## BEGIN VkImageSubresourceRange ## **/

class _VkImageSubresourceRange: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetaspectMask);
    static NAN_SETTER(SetaspectMask);
    
    static NAN_GETTER(GetbaseMipLevel);
    static NAN_SETTER(SetbaseMipLevel);
    
    static NAN_GETTER(GetlevelCount);
    static NAN_SETTER(SetlevelCount);
    
    static NAN_GETTER(GetbaseArrayLayer);
    static NAN_SETTER(SetbaseArrayLayer);
    
    static NAN_GETTER(GetlayerCount);
    static NAN_SETTER(SetlayerCount);
    

    // real instance
    VkImageSubresourceRange instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageSubresourceRange();
    ~_VkImageSubresourceRange();

};

/*
#include "index.h"
#include "VkImageSubresourceRange.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageSubresourceRange::constructor;

_VkImageSubresourceRange::_VkImageSubresourceRange() {
  
  
}

_VkImageSubresourceRange::~_VkImageSubresourceRange() {
  //printf("VkImageSubresourceRange deconstructed!!\n");
  
  
  
  
  
  
}

void _VkImageSubresourceRange::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageSubresourceRange::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageSubresourceRange").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("aspectMask").ToLocalChecked(), GetaspectMask, SetaspectMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("baseMipLevel").ToLocalChecked(), GetbaseMipLevel, SetbaseMipLevel, ctor);
  SetPrototypeAccessor(proto, Nan::New("levelCount").ToLocalChecked(), GetlevelCount, SetlevelCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("baseArrayLayer").ToLocalChecked(), GetbaseArrayLayer, SetbaseArrayLayer, ctor);
  SetPrototypeAccessor(proto, Nan::New("layerCount").ToLocalChecked(), GetlayerCount, SetlayerCount, ctor);
  Nan::Set(target, Nan::New("VkImageSubresourceRange").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageSubresourceRange::flush() {
  _VkImageSubresourceRange *self = this;
  
  return true;
}

NAN_METHOD(_VkImageSubresourceRange::New) {
  if (info.IsConstructCall()) {
    _VkImageSubresourceRange* self = new _VkImageSubresourceRange();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("aspectMask").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("baseMipLevel").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("levelCount").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("baseArrayLayer").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("layerCount").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageSubresourceRange constructor cannot be invoked without 'new'");
  }
};

// aspectMask
NAN_GETTER(_VkImageSubresourceRange::GetaspectMask) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.aspectMask));
}NAN_SETTER(_VkImageSubresourceRange::SetaspectMask) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  if (value->IsNumber()) {
    self->instance.aspectMask = static_cast<VkImageAspectFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceRange.aspectMask", "Number");
  
    return;
  }
}// baseMipLevel
NAN_GETTER(_VkImageSubresourceRange::GetbaseMipLevel) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.baseMipLevel));
}NAN_SETTER(_VkImageSubresourceRange::SetbaseMipLevel) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  if (value->IsNumber()) {
    self->instance.baseMipLevel = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceRange.baseMipLevel", "Number");
  
    return;
  }
}// levelCount
NAN_GETTER(_VkImageSubresourceRange::GetlevelCount) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.levelCount));
}NAN_SETTER(_VkImageSubresourceRange::SetlevelCount) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  if (value->IsNumber()) {
    self->instance.levelCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceRange.levelCount", "Number");
  
    return;
  }
}// baseArrayLayer
NAN_GETTER(_VkImageSubresourceRange::GetbaseArrayLayer) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.baseArrayLayer));
}NAN_SETTER(_VkImageSubresourceRange::SetbaseArrayLayer) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  if (value->IsNumber()) {
    self->instance.baseArrayLayer = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceRange.baseArrayLayer", "Number");
  
    return;
  }
}// layerCount
NAN_GETTER(_VkImageSubresourceRange::GetlayerCount) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.layerCount));
}NAN_SETTER(_VkImageSubresourceRange::SetlayerCount) {
  _VkImageSubresourceRange *self = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(info.This());
  if (value->IsNumber()) {
    self->instance.layerCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageSubresourceRange.layerCount", "Number");
  
    return;
  }
}
/** ## END VkImageSubresourceRange ## **/

/** ## BEGIN VkImageViewCreateInfo ## **/

class _VkImageViewCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    
    static NAN_GETTER(GetviewType);
    static NAN_SETTER(SetviewType);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> components;
      static NAN_GETTER(Getcomponents);
    static NAN_SETTER(Setcomponents);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> subresourceRange;
      static NAN_GETTER(GetsubresourceRange);
    static NAN_SETTER(SetsubresourceRange);
    

    // real instance
    VkImageViewCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageViewCreateInfo();
    ~_VkImageViewCreateInfo();

};

/*
#include "index.h"
#include "VkImageViewCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageViewCreateInfo::constructor;

_VkImageViewCreateInfo::_VkImageViewCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
  
}

_VkImageViewCreateInfo::~_VkImageViewCreateInfo() {
  //printf("VkImageViewCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
  
}

void _VkImageViewCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageViewCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageViewCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  SetPrototypeAccessor(proto, Nan::New("viewType").ToLocalChecked(), GetviewType, SetviewType, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("components").ToLocalChecked(), Getcomponents, Setcomponents, ctor);
  SetPrototypeAccessor(proto, Nan::New("subresourceRange").ToLocalChecked(), GetsubresourceRange, SetsubresourceRange, ctor);
  Nan::Set(target, Nan::New("VkImageViewCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageViewCreateInfo::flush() {
  _VkImageViewCreateInfo *self = this;
  if (!(self->components.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->components);
    
    _VkComponentMapping* result = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.components = result->instance;
  }if (!(self->subresourceRange.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->subresourceRange);
    
    _VkImageSubresourceRange* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.subresourceRange = result->instance;
  }
  return true;
}

NAN_METHOD(_VkImageViewCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkImageViewCreateInfo* self = new _VkImageViewCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("image").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("viewType").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("components").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("subresourceRange").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageViewCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageViewCreateInfo::GetsType) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageViewCreateInfo::SetsType) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkImageViewCreateInfo::Getflags) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkImageViewCreateInfo::Setflags) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkImageViewCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.flags", "Number");
  
    return;
  }
}// image
NAN_GETTER(_VkImageViewCreateInfo::Getimage) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageViewCreateInfo::Setimage) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.image", "[object VkImage]");
  
    return;
  }
}// viewType
NAN_GETTER(_VkImageViewCreateInfo::GetviewType) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.viewType));
}NAN_SETTER(_VkImageViewCreateInfo::SetviewType) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.viewType = static_cast<VkImageViewType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.viewType", "Number");
  
    return;
  }
}// format
NAN_GETTER(_VkImageViewCreateInfo::Getformat) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkImageViewCreateInfo::Setformat) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.format", "Number");
  
    return;
  }
}// components
NAN_GETTER(_VkImageViewCreateInfo::Getcomponents) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  if (self->components.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->components);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageViewCreateInfo::Setcomponents) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkComponentMapping::constructor)->HasInstance(obj)) {
      self->components.Reset<v8::Object>(value.As<v8::Object>());
      _VkComponentMapping* inst = Nan::ObjectWrap::Unwrap<_VkComponentMapping>(obj);
      inst->flush();
      self->instance.components = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.components", "[object VkComponentMapping]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->components.Reset();
    memset(&self->instance.components, 0, sizeof(VkComponentMapping));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.components", "[object VkComponentMapping]");
  
    return;
  }
}// subresourceRange
NAN_GETTER(_VkImageViewCreateInfo::GetsubresourceRange) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  if (self->subresourceRange.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->subresourceRange);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageViewCreateInfo::SetsubresourceRange) {
  _VkImageViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceRange::constructor)->HasInstance(obj)) {
      self->subresourceRange.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceRange* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(obj);
      inst->flush();
      self->instance.subresourceRange = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.subresourceRange", "[object VkImageSubresourceRange]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->subresourceRange.Reset();
    memset(&self->instance.subresourceRange, 0, sizeof(VkImageSubresourceRange));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageViewCreateInfo.subresourceRange", "[object VkImageSubresourceRange]");
  
    return;
  }
}
/** ## END VkImageViewCreateInfo ## **/

/** ## BEGIN VkImageCreateInfo ## **/

class _VkImageCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetimageType);
    static NAN_SETTER(SetimageType);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> extent;
      static NAN_GETTER(Getextent);
    static NAN_SETTER(Setextent);
    
    static NAN_GETTER(GetmipLevels);
    static NAN_SETTER(SetmipLevels);
    
    static NAN_GETTER(GetarrayLayers);
    static NAN_SETTER(SetarrayLayers);
    
    static NAN_GETTER(Getsamples);
    static NAN_SETTER(Setsamples);
    
    static NAN_GETTER(Gettiling);
    static NAN_SETTER(Settiling);
    
    static NAN_GETTER(Getusage);
    static NAN_SETTER(Setusage);
    
    static NAN_GETTER(GetsharingMode);
    static NAN_SETTER(SetsharingMode);
    
    static NAN_GETTER(GetqueueFamilyIndexCount);
    static NAN_SETTER(SetqueueFamilyIndexCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pQueueFamilyIndices;
    static NAN_GETTER(GetpQueueFamilyIndices);
    static NAN_SETTER(SetpQueueFamilyIndices);
    
    static NAN_GETTER(GetinitialLayout);
    static NAN_SETTER(SetinitialLayout);
    

    // real instance
    VkImageCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageCreateInfo();
    ~_VkImageCreateInfo();

};

/*
#include "index.h"
#include "VkImageCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageCreateInfo::constructor;

_VkImageCreateInfo::_VkImageCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
  
}

_VkImageCreateInfo::~_VkImageCreateInfo() {
  //printf("VkImageCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
  
  
  
  pQueueFamilyIndices.Reset();
  
  
}

void _VkImageCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageType").ToLocalChecked(), GetimageType, SetimageType, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("extent").ToLocalChecked(), Getextent, Setextent, ctor);
  SetPrototypeAccessor(proto, Nan::New("mipLevels").ToLocalChecked(), GetmipLevels, SetmipLevels, ctor);
  SetPrototypeAccessor(proto, Nan::New("arrayLayers").ToLocalChecked(), GetarrayLayers, SetarrayLayers, ctor);
  SetPrototypeAccessor(proto, Nan::New("samples").ToLocalChecked(), Getsamples, Setsamples, ctor);
  SetPrototypeAccessor(proto, Nan::New("tiling").ToLocalChecked(), Gettiling, Settiling, ctor);
  SetPrototypeAccessor(proto, Nan::New("usage").ToLocalChecked(), Getusage, Setusage, ctor);
  SetPrototypeAccessor(proto, Nan::New("sharingMode").ToLocalChecked(), GetsharingMode, SetsharingMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueFamilyIndexCount").ToLocalChecked(), GetqueueFamilyIndexCount, SetqueueFamilyIndexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pQueueFamilyIndices").ToLocalChecked(), GetpQueueFamilyIndices, SetpQueueFamilyIndices, ctor);
  SetPrototypeAccessor(proto, Nan::New("initialLayout").ToLocalChecked(), GetinitialLayout, SetinitialLayout, ctor);
  Nan::Set(target, Nan::New("VkImageCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageCreateInfo::flush() {
  _VkImageCreateInfo *self = this;
  if (!(self->extent.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->extent);
    
    _VkExtent3D* result = Nan::ObjectWrap::Unwrap<_VkExtent3D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.extent = result->instance;
  }
  return true;
}

NAN_METHOD(_VkImageCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkImageCreateInfo* self = new _VkImageCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("imageType").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("extent").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("mipLevels").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("arrayLayers").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("samples").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("tiling").ToLocalChecked();
      v8::Local<v8::String> sAccess10 = Nan::New("usage").ToLocalChecked();
      v8::Local<v8::String> sAccess11 = Nan::New("sharingMode").ToLocalChecked();
      v8::Local<v8::String> sAccess12 = Nan::New("queueFamilyIndexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess13 = Nan::New("pQueueFamilyIndices").ToLocalChecked();
      v8::Local<v8::String> sAccess14 = Nan::New("initialLayout").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      if (obj->Has(sAccess10)) info.This()->Set(sAccess10, obj->Get(sAccess10));
      if (obj->Has(sAccess11)) info.This()->Set(sAccess11, obj->Get(sAccess11));
      if (obj->Has(sAccess12)) info.This()->Set(sAccess12, obj->Get(sAccess12));
      if (obj->Has(sAccess13)) info.This()->Set(sAccess13, obj->Get(sAccess13));
      if (obj->Has(sAccess14)) info.This()->Set(sAccess14, obj->Get(sAccess14));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageCreateInfo::GetsType) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageCreateInfo::SetsType) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkImageCreateInfo::Getflags) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkImageCreateInfo::Setflags) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkImageCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.flags", "Number");
  
    return;
  }
}// imageType
NAN_GETTER(_VkImageCreateInfo::GetimageType) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageType));
}NAN_SETTER(_VkImageCreateInfo::SetimageType) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.imageType = static_cast<VkImageType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.imageType", "Number");
  
    return;
  }
}// format
NAN_GETTER(_VkImageCreateInfo::Getformat) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkImageCreateInfo::Setformat) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.format", "Number");
  
    return;
  }
}// extent
NAN_GETTER(_VkImageCreateInfo::Getextent) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (self->extent.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->extent);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageCreateInfo::Setextent) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkExtent3D::constructor)->HasInstance(obj)) {
      self->extent.Reset<v8::Object>(value.As<v8::Object>());
      _VkExtent3D* inst = Nan::ObjectWrap::Unwrap<_VkExtent3D>(obj);
      inst->flush();
      self->instance.extent = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.extent", "[object VkExtent3D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->extent.Reset();
    memset(&self->instance.extent, 0, sizeof(VkExtent3D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.extent", "[object VkExtent3D]");
  
    return;
  }
}// mipLevels
NAN_GETTER(_VkImageCreateInfo::GetmipLevels) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.mipLevels));
}NAN_SETTER(_VkImageCreateInfo::SetmipLevels) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.mipLevels = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.mipLevels", "Number");
  
    return;
  }
}// arrayLayers
NAN_GETTER(_VkImageCreateInfo::GetarrayLayers) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.arrayLayers));
}NAN_SETTER(_VkImageCreateInfo::SetarrayLayers) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.arrayLayers = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.arrayLayers", "Number");
  
    return;
  }
}// samples
NAN_GETTER(_VkImageCreateInfo::Getsamples) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.samples));
}NAN_SETTER(_VkImageCreateInfo::Setsamples) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.samples = static_cast<VkSampleCountFlagBits>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.samples", "Number");
  
    return;
  }
}// tiling
NAN_GETTER(_VkImageCreateInfo::Gettiling) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.tiling));
}NAN_SETTER(_VkImageCreateInfo::Settiling) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.tiling = static_cast<VkImageTiling>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.tiling", "Number");
  
    return;
  }
}// usage
NAN_GETTER(_VkImageCreateInfo::Getusage) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.usage));
}NAN_SETTER(_VkImageCreateInfo::Setusage) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.usage = static_cast<VkImageUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.usage", "Number");
  
    return;
  }
}// sharingMode
NAN_GETTER(_VkImageCreateInfo::GetsharingMode) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sharingMode));
}NAN_SETTER(_VkImageCreateInfo::SetsharingMode) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sharingMode = static_cast<VkSharingMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.sharingMode", "Number");
  
    return;
  }
}// queueFamilyIndexCount
NAN_GETTER(_VkImageCreateInfo::GetqueueFamilyIndexCount) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueFamilyIndexCount));
}NAN_SETTER(_VkImageCreateInfo::SetqueueFamilyIndexCount) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queueFamilyIndexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.queueFamilyIndexCount", "Number");
  
    return;
  }
}// pQueueFamilyIndices
NAN_GETTER(_VkImageCreateInfo::GetpQueueFamilyIndices) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (self->pQueueFamilyIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pQueueFamilyIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageCreateInfo::SetpQueueFamilyIndices) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pQueueFamilyIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.pQueueFamilyIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pQueueFamilyIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.pQueueFamilyIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pQueueFamilyIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pQueueFamilyIndices = nullptr;
  }
}// initialLayout
NAN_GETTER(_VkImageCreateInfo::GetinitialLayout) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.initialLayout));
}NAN_SETTER(_VkImageCreateInfo::SetinitialLayout) {
  _VkImageCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.initialLayout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageCreateInfo.initialLayout", "Number");
  
    return;
  }
}
/** ## END VkImageCreateInfo ## **/

/** ## BEGIN VkImageMemoryBarrier ## **/

class _VkImageMemoryBarrier: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsrcAccessMask);
    static NAN_SETTER(SetsrcAccessMask);
    
    static NAN_GETTER(GetdstAccessMask);
    static NAN_SETTER(SetdstAccessMask);
    
    static NAN_GETTER(GetoldLayout);
    static NAN_SETTER(SetoldLayout);
    
    static NAN_GETTER(GetnewLayout);
    static NAN_SETTER(SetnewLayout);
    
    static NAN_GETTER(GetsrcQueueFamilyIndex);
    static NAN_SETTER(SetsrcQueueFamilyIndex);
    
    static NAN_GETTER(GetdstQueueFamilyIndex);
    static NAN_SETTER(SetdstQueueFamilyIndex);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> image;
      static NAN_GETTER(Getimage);
    static NAN_SETTER(Setimage);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> subresourceRange;
      static NAN_GETTER(GetsubresourceRange);
    static NAN_SETTER(SetsubresourceRange);
    

    // real instance
    VkImageMemoryBarrier instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkImageMemoryBarrier();
    ~_VkImageMemoryBarrier();

};

/*
#include "index.h"
#include "VkImageMemoryBarrier.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkImageMemoryBarrier::constructor;

_VkImageMemoryBarrier::_VkImageMemoryBarrier() {
  instance.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
  
}

_VkImageMemoryBarrier::~_VkImageMemoryBarrier() {
  //printf("VkImageMemoryBarrier deconstructed!!\n");
  
  
  
  
  
  
  
  
  
  
}

void _VkImageMemoryBarrier::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkImageMemoryBarrier::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkImageMemoryBarrier").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcAccessMask").ToLocalChecked(), GetsrcAccessMask, SetsrcAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstAccessMask").ToLocalChecked(), GetdstAccessMask, SetdstAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("oldLayout").ToLocalChecked(), GetoldLayout, SetoldLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("newLayout").ToLocalChecked(), GetnewLayout, SetnewLayout, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcQueueFamilyIndex").ToLocalChecked(), GetsrcQueueFamilyIndex, SetsrcQueueFamilyIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstQueueFamilyIndex").ToLocalChecked(), GetdstQueueFamilyIndex, SetdstQueueFamilyIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("image").ToLocalChecked(), Getimage, Setimage, ctor);
  SetPrototypeAccessor(proto, Nan::New("subresourceRange").ToLocalChecked(), GetsubresourceRange, SetsubresourceRange, ctor);
  Nan::Set(target, Nan::New("VkImageMemoryBarrier").ToLocalChecked(), ctor->GetFunction());
}

bool _VkImageMemoryBarrier::flush() {
  _VkImageMemoryBarrier *self = this;
  if (!(self->subresourceRange.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->subresourceRange);
    
    _VkImageSubresourceRange* result = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.subresourceRange = result->instance;
  }
  return true;
}

NAN_METHOD(_VkImageMemoryBarrier::New) {
  if (info.IsConstructCall()) {
    _VkImageMemoryBarrier* self = new _VkImageMemoryBarrier();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("srcAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("oldLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("newLayout").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("srcQueueFamilyIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("dstQueueFamilyIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("image").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("subresourceRange").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkImageMemoryBarrier constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkImageMemoryBarrier::GetsType) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkImageMemoryBarrier::SetsType) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.sType", "Number");
  
    return;
  }
}// srcAccessMask
NAN_GETTER(_VkImageMemoryBarrier::GetsrcAccessMask) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcAccessMask));
}NAN_SETTER(_VkImageMemoryBarrier::SetsrcAccessMask) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.srcAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
NAN_GETTER(_VkImageMemoryBarrier::GetdstAccessMask) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstAccessMask));
}NAN_SETTER(_VkImageMemoryBarrier::SetdstAccessMask) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.dstAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.dstAccessMask", "Number");
  
    return;
  }
}// oldLayout
NAN_GETTER(_VkImageMemoryBarrier::GetoldLayout) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.oldLayout));
}NAN_SETTER(_VkImageMemoryBarrier::SetoldLayout) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.oldLayout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.oldLayout", "Number");
  
    return;
  }
}// newLayout
NAN_GETTER(_VkImageMemoryBarrier::GetnewLayout) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.newLayout));
}NAN_SETTER(_VkImageMemoryBarrier::SetnewLayout) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.newLayout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.newLayout", "Number");
  
    return;
  }
}// srcQueueFamilyIndex
NAN_GETTER(_VkImageMemoryBarrier::GetsrcQueueFamilyIndex) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcQueueFamilyIndex));
}NAN_SETTER(_VkImageMemoryBarrier::SetsrcQueueFamilyIndex) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.srcQueueFamilyIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.srcQueueFamilyIndex", "Number");
  
    return;
  }
}// dstQueueFamilyIndex
NAN_GETTER(_VkImageMemoryBarrier::GetdstQueueFamilyIndex) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstQueueFamilyIndex));
}NAN_SETTER(_VkImageMemoryBarrier::SetdstQueueFamilyIndex) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.dstQueueFamilyIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.dstQueueFamilyIndex", "Number");
  
    return;
  }
}// image
NAN_GETTER(_VkImageMemoryBarrier::Getimage) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (self->image.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->image);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageMemoryBarrier::Setimage) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImage::constructor)->HasInstance(obj)) {
      self->image.Reset<v8::Object>(value.As<v8::Object>());
      _VkImage* inst = Nan::ObjectWrap::Unwrap<_VkImage>(obj);
      ;
      self->instance.image = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.image", "[object VkImage]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->image.Reset();
    self->instance.image = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.image", "[object VkImage]");
  
    return;
  }
}// subresourceRange
NAN_GETTER(_VkImageMemoryBarrier::GetsubresourceRange) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  if (self->subresourceRange.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->subresourceRange);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkImageMemoryBarrier::SetsubresourceRange) {
  _VkImageMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageSubresourceRange::constructor)->HasInstance(obj)) {
      self->subresourceRange.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageSubresourceRange* inst = Nan::ObjectWrap::Unwrap<_VkImageSubresourceRange>(obj);
      inst->flush();
      self->instance.subresourceRange = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.subresourceRange", "[object VkImageSubresourceRange]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->subresourceRange.Reset();
    memset(&self->instance.subresourceRange, 0, sizeof(VkImageSubresourceRange));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkImageMemoryBarrier.subresourceRange", "[object VkImageSubresourceRange]");
  
    return;
  }
}
/** ## END VkImageMemoryBarrier ## **/

/** ## BEGIN VkBufferMemoryBarrier ## **/

class _VkBufferMemoryBarrier: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsrcAccessMask);
    static NAN_SETTER(SetsrcAccessMask);
    
    static NAN_GETTER(GetdstAccessMask);
    static NAN_SETTER(SetdstAccessMask);
    
    static NAN_GETTER(GetsrcQueueFamilyIndex);
    static NAN_SETTER(SetsrcQueueFamilyIndex);
    
    static NAN_GETTER(GetdstQueueFamilyIndex);
    static NAN_SETTER(SetdstQueueFamilyIndex);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
    static NAN_GETTER(Getsize);
    static NAN_SETTER(Setsize);
    

    // real instance
    VkBufferMemoryBarrier instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferMemoryBarrier();
    ~_VkBufferMemoryBarrier();

};

/*
#include "index.h"
#include "VkBufferMemoryBarrier.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferMemoryBarrier::constructor;

_VkBufferMemoryBarrier::_VkBufferMemoryBarrier() {
  instance.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
  
}

_VkBufferMemoryBarrier::~_VkBufferMemoryBarrier() {
  //printf("VkBufferMemoryBarrier deconstructed!!\n");
  
  
  
  
  
  
  
  
  
}

void _VkBufferMemoryBarrier::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferMemoryBarrier::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferMemoryBarrier").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcAccessMask").ToLocalChecked(), GetsrcAccessMask, SetsrcAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstAccessMask").ToLocalChecked(), GetdstAccessMask, SetdstAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcQueueFamilyIndex").ToLocalChecked(), GetsrcQueueFamilyIndex, SetsrcQueueFamilyIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstQueueFamilyIndex").ToLocalChecked(), GetdstQueueFamilyIndex, SetdstQueueFamilyIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, Setsize, ctor);
  Nan::Set(target, Nan::New("VkBufferMemoryBarrier").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferMemoryBarrier::flush() {
  _VkBufferMemoryBarrier *self = this;
  
  return true;
}

NAN_METHOD(_VkBufferMemoryBarrier::New) {
  if (info.IsConstructCall()) {
    _VkBufferMemoryBarrier* self = new _VkBufferMemoryBarrier();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("srcAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("srcQueueFamilyIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("dstQueueFamilyIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("buffer").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("size").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferMemoryBarrier constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBufferMemoryBarrier::GetsType) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBufferMemoryBarrier::SetsType) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.sType", "Number");
  
    return;
  }
}// srcAccessMask
NAN_GETTER(_VkBufferMemoryBarrier::GetsrcAccessMask) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcAccessMask));
}NAN_SETTER(_VkBufferMemoryBarrier::SetsrcAccessMask) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.srcAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
NAN_GETTER(_VkBufferMemoryBarrier::GetdstAccessMask) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstAccessMask));
}NAN_SETTER(_VkBufferMemoryBarrier::SetdstAccessMask) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.dstAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.dstAccessMask", "Number");
  
    return;
  }
}// srcQueueFamilyIndex
NAN_GETTER(_VkBufferMemoryBarrier::GetsrcQueueFamilyIndex) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcQueueFamilyIndex));
}NAN_SETTER(_VkBufferMemoryBarrier::SetsrcQueueFamilyIndex) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.srcQueueFamilyIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.srcQueueFamilyIndex", "Number");
  
    return;
  }
}// dstQueueFamilyIndex
NAN_GETTER(_VkBufferMemoryBarrier::GetdstQueueFamilyIndex) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstQueueFamilyIndex));
}NAN_SETTER(_VkBufferMemoryBarrier::SetdstQueueFamilyIndex) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.dstQueueFamilyIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.dstQueueFamilyIndex", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkBufferMemoryBarrier::Getbuffer) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBufferMemoryBarrier::Setbuffer) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.buffer", "[object VkBuffer]");
  
    return;
  }
}// offset
NAN_GETTER(_VkBufferMemoryBarrier::Getoffset) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkBufferMemoryBarrier::Setoffset) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.offset", "Number");
  
    return;
  }
}// size
NAN_GETTER(_VkBufferMemoryBarrier::Getsize) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}NAN_SETTER(_VkBufferMemoryBarrier::Setsize) {
  _VkBufferMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.size = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferMemoryBarrier.size", "Number");
  
    return;
  }
}
/** ## END VkBufferMemoryBarrier ## **/

/** ## BEGIN VkMemoryBarrier ## **/

class _VkMemoryBarrier: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetsrcAccessMask);
    static NAN_SETTER(SetsrcAccessMask);
    
    static NAN_GETTER(GetdstAccessMask);
    static NAN_SETTER(SetdstAccessMask);
    

    // real instance
    VkMemoryBarrier instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryBarrier();
    ~_VkMemoryBarrier();

};

/*
#include "index.h"
#include "VkMemoryBarrier.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryBarrier::constructor;

_VkMemoryBarrier::_VkMemoryBarrier() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
  
}

_VkMemoryBarrier::~_VkMemoryBarrier() {
  //printf("VkMemoryBarrier deconstructed!!\n");
  
  
  
  
}

void _VkMemoryBarrier::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryBarrier::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryBarrier").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcAccessMask").ToLocalChecked(), GetsrcAccessMask, SetsrcAccessMask, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstAccessMask").ToLocalChecked(), GetdstAccessMask, SetdstAccessMask, ctor);
  Nan::Set(target, Nan::New("VkMemoryBarrier").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryBarrier::flush() {
  _VkMemoryBarrier *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryBarrier::New) {
  if (info.IsConstructCall()) {
    _VkMemoryBarrier* self = new _VkMemoryBarrier();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("srcAccessMask").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstAccessMask").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryBarrier constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryBarrier::GetsType) {
  _VkMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkMemoryBarrier::SetsType) {
  _VkMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryBarrier.sType", "Number");
  
    return;
  }
}// srcAccessMask
NAN_GETTER(_VkMemoryBarrier::GetsrcAccessMask) {
  _VkMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcAccessMask));
}NAN_SETTER(_VkMemoryBarrier::SetsrcAccessMask) {
  _VkMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.srcAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryBarrier.srcAccessMask", "Number");
  
    return;
  }
}// dstAccessMask
NAN_GETTER(_VkMemoryBarrier::GetdstAccessMask) {
  _VkMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkMemoryBarrier>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstAccessMask));
}NAN_SETTER(_VkMemoryBarrier::SetdstAccessMask) {
  _VkMemoryBarrier *self = Nan::ObjectWrap::Unwrap<_VkMemoryBarrier>(info.This());
  if (value->IsNumber()) {
    self->instance.dstAccessMask = static_cast<VkAccessFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryBarrier.dstAccessMask", "Number");
  
    return;
  }
}
/** ## END VkMemoryBarrier ## **/

/** ## BEGIN VkBufferViewCreateInfo ## **/

class _VkBufferViewCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    
    static NAN_GETTER(Getformat);
    static NAN_SETTER(Setformat);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
    static NAN_GETTER(Getrange);
    static NAN_SETTER(Setrange);
    

    // real instance
    VkBufferViewCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferViewCreateInfo();
    ~_VkBufferViewCreateInfo();

};

/*
#include "index.h"
#include "VkBufferViewCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferViewCreateInfo::constructor;

_VkBufferViewCreateInfo::_VkBufferViewCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
  
}

_VkBufferViewCreateInfo::~_VkBufferViewCreateInfo() {
  //printf("VkBufferViewCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
}

void _VkBufferViewCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferViewCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferViewCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("format").ToLocalChecked(), Getformat, Setformat, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("range").ToLocalChecked(), Getrange, Setrange, ctor);
  Nan::Set(target, Nan::New("VkBufferViewCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferViewCreateInfo::flush() {
  _VkBufferViewCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkBufferViewCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkBufferViewCreateInfo* self = new _VkBufferViewCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("buffer").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("format").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("range").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferViewCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBufferViewCreateInfo::GetsType) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBufferViewCreateInfo::SetsType) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferViewCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkBufferViewCreateInfo::Getflags) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkBufferViewCreateInfo::Setflags) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkBufferViewCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferViewCreateInfo.flags", "Number");
  
    return;
  }
}// buffer
NAN_GETTER(_VkBufferViewCreateInfo::Getbuffer) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBufferViewCreateInfo::Setbuffer) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBufferViewCreateInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferViewCreateInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}// format
NAN_GETTER(_VkBufferViewCreateInfo::Getformat) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.format));
}NAN_SETTER(_VkBufferViewCreateInfo::Setformat) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.format = static_cast<VkFormat>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferViewCreateInfo.format", "Number");
  
    return;
  }
}// offset
NAN_GETTER(_VkBufferViewCreateInfo::Getoffset) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkBufferViewCreateInfo::Setoffset) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferViewCreateInfo.offset", "Number");
  
    return;
  }
}// range
NAN_GETTER(_VkBufferViewCreateInfo::Getrange) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.range));
}NAN_SETTER(_VkBufferViewCreateInfo::Setrange) {
  _VkBufferViewCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferViewCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.range = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferViewCreateInfo.range", "Number");
  
    return;
  }
}
/** ## END VkBufferViewCreateInfo ## **/

/** ## BEGIN VkBufferCreateInfo ## **/

class _VkBufferCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(Getsize);
    static NAN_SETTER(Setsize);
    
    static NAN_GETTER(Getusage);
    static NAN_SETTER(Setusage);
    
    static NAN_GETTER(GetsharingMode);
    static NAN_SETTER(SetsharingMode);
    
    static NAN_GETTER(GetqueueFamilyIndexCount);
    static NAN_SETTER(SetqueueFamilyIndexCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pQueueFamilyIndices;
    static NAN_GETTER(GetpQueueFamilyIndices);
    static NAN_SETTER(SetpQueueFamilyIndices);
    

    // real instance
    VkBufferCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBufferCreateInfo();
    ~_VkBufferCreateInfo();

};

/*
#include "index.h"
#include "VkBufferCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBufferCreateInfo::constructor;

_VkBufferCreateInfo::_VkBufferCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
  
}

_VkBufferCreateInfo::~_VkBufferCreateInfo() {
  //printf("VkBufferCreateInfo deconstructed!!\n");
  
  
  
  
  
  
  
  pQueueFamilyIndices.Reset();
  
}

void _VkBufferCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBufferCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBufferCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, Setsize, ctor);
  SetPrototypeAccessor(proto, Nan::New("usage").ToLocalChecked(), Getusage, Setusage, ctor);
  SetPrototypeAccessor(proto, Nan::New("sharingMode").ToLocalChecked(), GetsharingMode, SetsharingMode, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueFamilyIndexCount").ToLocalChecked(), GetqueueFamilyIndexCount, SetqueueFamilyIndexCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pQueueFamilyIndices").ToLocalChecked(), GetpQueueFamilyIndices, SetpQueueFamilyIndices, ctor);
  Nan::Set(target, Nan::New("VkBufferCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBufferCreateInfo::flush() {
  _VkBufferCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkBufferCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkBufferCreateInfo* self = new _VkBufferCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("size").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("usage").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("sharingMode").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("queueFamilyIndexCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pQueueFamilyIndices").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBufferCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBufferCreateInfo::GetsType) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBufferCreateInfo::SetsType) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkBufferCreateInfo::Getflags) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkBufferCreateInfo::Setflags) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkBufferCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCreateInfo.flags", "Number");
  
    return;
  }
}// size
NAN_GETTER(_VkBufferCreateInfo::Getsize) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}NAN_SETTER(_VkBufferCreateInfo::Setsize) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.size = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCreateInfo.size", "Number");
  
    return;
  }
}// usage
NAN_GETTER(_VkBufferCreateInfo::Getusage) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.usage));
}NAN_SETTER(_VkBufferCreateInfo::Setusage) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.usage = static_cast<VkBufferUsageFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCreateInfo.usage", "Number");
  
    return;
  }
}// sharingMode
NAN_GETTER(_VkBufferCreateInfo::GetsharingMode) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sharingMode));
}NAN_SETTER(_VkBufferCreateInfo::SetsharingMode) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sharingMode = static_cast<VkSharingMode>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCreateInfo.sharingMode", "Number");
  
    return;
  }
}// queueFamilyIndexCount
NAN_GETTER(_VkBufferCreateInfo::GetqueueFamilyIndexCount) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueFamilyIndexCount));
}NAN_SETTER(_VkBufferCreateInfo::SetqueueFamilyIndexCount) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queueFamilyIndexCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBufferCreateInfo.queueFamilyIndexCount", "Number");
  
    return;
  }
}// pQueueFamilyIndices
NAN_GETTER(_VkBufferCreateInfo::GetpQueueFamilyIndices) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  if (self->pQueueFamilyIndices.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pQueueFamilyIndices);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBufferCreateInfo::SetpQueueFamilyIndices) {
  _VkBufferCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsUint32Array()) {
        self->pQueueFamilyIndices.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkBufferCreateInfo.pQueueFamilyIndices", "Uint32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pQueueFamilyIndices.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBufferCreateInfo.pQueueFamilyIndices", "Uint32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pQueueFamilyIndices = getTypedArrayData<uint32_t>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pQueueFamilyIndices = nullptr;
  }
}
/** ## END VkBufferCreateInfo ## **/

/** ## BEGIN VkCopyDescriptorSet ## **/

class _VkCopyDescriptorSet: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> srcSet;
      static NAN_GETTER(GetsrcSet);
    static NAN_SETTER(SetsrcSet);
    
    static NAN_GETTER(GetsrcBinding);
    static NAN_SETTER(SetsrcBinding);
    
    static NAN_GETTER(GetsrcArrayElement);
    static NAN_SETTER(SetsrcArrayElement);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> dstSet;
      static NAN_GETTER(GetdstSet);
    static NAN_SETTER(SetdstSet);
    
    static NAN_GETTER(GetdstBinding);
    static NAN_SETTER(SetdstBinding);
    
    static NAN_GETTER(GetdstArrayElement);
    static NAN_SETTER(SetdstArrayElement);
    
    static NAN_GETTER(GetdescriptorCount);
    static NAN_SETTER(SetdescriptorCount);
    

    // real instance
    VkCopyDescriptorSet instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkCopyDescriptorSet();
    ~_VkCopyDescriptorSet();

};

/*
#include "index.h"
#include "VkCopyDescriptorSet.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkCopyDescriptorSet::constructor;

_VkCopyDescriptorSet::_VkCopyDescriptorSet() {
  instance.sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
  
}

_VkCopyDescriptorSet::~_VkCopyDescriptorSet() {
  //printf("VkCopyDescriptorSet deconstructed!!\n");
  
  
  
  
  
  
  
  
  
}

void _VkCopyDescriptorSet::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkCopyDescriptorSet::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkCopyDescriptorSet").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcSet").ToLocalChecked(), GetsrcSet, SetsrcSet, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcBinding").ToLocalChecked(), GetsrcBinding, SetsrcBinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("srcArrayElement").ToLocalChecked(), GetsrcArrayElement, SetsrcArrayElement, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstSet").ToLocalChecked(), GetdstSet, SetdstSet, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstBinding").ToLocalChecked(), GetdstBinding, SetdstBinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstArrayElement").ToLocalChecked(), GetdstArrayElement, SetdstArrayElement, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorCount").ToLocalChecked(), GetdescriptorCount, SetdescriptorCount, ctor);
  Nan::Set(target, Nan::New("VkCopyDescriptorSet").ToLocalChecked(), ctor->GetFunction());
}

bool _VkCopyDescriptorSet::flush() {
  _VkCopyDescriptorSet *self = this;
  
  return true;
}

NAN_METHOD(_VkCopyDescriptorSet::New) {
  if (info.IsConstructCall()) {
    _VkCopyDescriptorSet* self = new _VkCopyDescriptorSet();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("srcSet").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("srcBinding").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("srcArrayElement").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("dstSet").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("dstBinding").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("dstArrayElement").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("descriptorCount").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkCopyDescriptorSet constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkCopyDescriptorSet::GetsType) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkCopyDescriptorSet::SetsType) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.sType", "Number");
  
    return;
  }
}// srcSet
NAN_GETTER(_VkCopyDescriptorSet::GetsrcSet) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  if (self->srcSet.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->srcSet);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCopyDescriptorSet::SetsrcSet) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDescriptorSet::constructor)->HasInstance(obj)) {
      self->srcSet.Reset<v8::Object>(value.As<v8::Object>());
      _VkDescriptorSet* inst = Nan::ObjectWrap::Unwrap<_VkDescriptorSet>(obj);
      ;
      self->instance.srcSet = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.srcSet", "[object VkDescriptorSet]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->srcSet.Reset();
    self->instance.srcSet = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.srcSet", "[object VkDescriptorSet]");
  
    return;
  }
}// srcBinding
NAN_GETTER(_VkCopyDescriptorSet::GetsrcBinding) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcBinding));
}NAN_SETTER(_VkCopyDescriptorSet::SetsrcBinding) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.srcBinding = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.srcBinding", "Number");
  
    return;
  }
}// srcArrayElement
NAN_GETTER(_VkCopyDescriptorSet::GetsrcArrayElement) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.srcArrayElement));
}NAN_SETTER(_VkCopyDescriptorSet::SetsrcArrayElement) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.srcArrayElement = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.srcArrayElement", "Number");
  
    return;
  }
}// dstSet
NAN_GETTER(_VkCopyDescriptorSet::GetdstSet) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  if (self->dstSet.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->dstSet);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkCopyDescriptorSet::SetdstSet) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDescriptorSet::constructor)->HasInstance(obj)) {
      self->dstSet.Reset<v8::Object>(value.As<v8::Object>());
      _VkDescriptorSet* inst = Nan::ObjectWrap::Unwrap<_VkDescriptorSet>(obj);
      ;
      self->instance.dstSet = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.dstSet", "[object VkDescriptorSet]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->dstSet.Reset();
    self->instance.dstSet = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.dstSet", "[object VkDescriptorSet]");
  
    return;
  }
}// dstBinding
NAN_GETTER(_VkCopyDescriptorSet::GetdstBinding) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstBinding));
}NAN_SETTER(_VkCopyDescriptorSet::SetdstBinding) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.dstBinding = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.dstBinding", "Number");
  
    return;
  }
}// dstArrayElement
NAN_GETTER(_VkCopyDescriptorSet::GetdstArrayElement) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstArrayElement));
}NAN_SETTER(_VkCopyDescriptorSet::SetdstArrayElement) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.dstArrayElement = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.dstArrayElement", "Number");
  
    return;
  }
}// descriptorCount
NAN_GETTER(_VkCopyDescriptorSet::GetdescriptorCount) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorCount));
}NAN_SETTER(_VkCopyDescriptorSet::SetdescriptorCount) {
  _VkCopyDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkCopyDescriptorSet.descriptorCount", "Number");
  
    return;
  }
}
/** ## END VkCopyDescriptorSet ## **/

/** ## BEGIN VkDescriptorBufferInfo ## **/

class _VkDescriptorBufferInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> buffer;
      static NAN_GETTER(Getbuffer);
    static NAN_SETTER(Setbuffer);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
    static NAN_GETTER(Getrange);
    static NAN_SETTER(Setrange);
    

    // real instance
    VkDescriptorBufferInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorBufferInfo();
    ~_VkDescriptorBufferInfo();

};

/*
#include "index.h"
#include "VkDescriptorBufferInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorBufferInfo::constructor;

_VkDescriptorBufferInfo::_VkDescriptorBufferInfo() {
  
  
}

_VkDescriptorBufferInfo::~_VkDescriptorBufferInfo() {
  //printf("VkDescriptorBufferInfo deconstructed!!\n");
  
  
  
  
}

void _VkDescriptorBufferInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorBufferInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorBufferInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("buffer").ToLocalChecked(), Getbuffer, Setbuffer, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("range").ToLocalChecked(), Getrange, Setrange, ctor);
  Nan::Set(target, Nan::New("VkDescriptorBufferInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorBufferInfo::flush() {
  _VkDescriptorBufferInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorBufferInfo::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorBufferInfo* self = new _VkDescriptorBufferInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("buffer").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("range").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorBufferInfo constructor cannot be invoked without 'new'");
  }
};

// buffer
NAN_GETTER(_VkDescriptorBufferInfo::Getbuffer) {
  _VkDescriptorBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorBufferInfo>(info.This());
  if (self->buffer.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->buffer);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorBufferInfo::Setbuffer) {
  _VkDescriptorBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorBufferInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBuffer::constructor)->HasInstance(obj)) {
      self->buffer.Reset<v8::Object>(value.As<v8::Object>());
      _VkBuffer* inst = Nan::ObjectWrap::Unwrap<_VkBuffer>(obj);
      ;
      self->instance.buffer = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorBufferInfo.buffer", "[object VkBuffer]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->buffer.Reset();
    self->instance.buffer = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorBufferInfo.buffer", "[object VkBuffer]");
  
    return;
  }
}// offset
NAN_GETTER(_VkDescriptorBufferInfo::Getoffset) {
  _VkDescriptorBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorBufferInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkDescriptorBufferInfo::Setoffset) {
  _VkDescriptorBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorBufferInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorBufferInfo.offset", "Number");
  
    return;
  }
}// range
NAN_GETTER(_VkDescriptorBufferInfo::Getrange) {
  _VkDescriptorBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorBufferInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.range));
}NAN_SETTER(_VkDescriptorBufferInfo::Setrange) {
  _VkDescriptorBufferInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorBufferInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.range = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorBufferInfo.range", "Number");
  
    return;
  }
}
/** ## END VkDescriptorBufferInfo ## **/

/** ## BEGIN VkDescriptorImageInfo ## **/

class _VkDescriptorImageInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> sampler;
      static NAN_GETTER(Getsampler);
    static NAN_SETTER(Setsampler);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> imageView;
      static NAN_GETTER(GetimageView);
    static NAN_SETTER(SetimageView);
    
    static NAN_GETTER(GetimageLayout);
    static NAN_SETTER(SetimageLayout);
    

    // real instance
    VkDescriptorImageInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDescriptorImageInfo();
    ~_VkDescriptorImageInfo();

};

/*
#include "index.h"
#include "VkDescriptorImageInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDescriptorImageInfo::constructor;

_VkDescriptorImageInfo::_VkDescriptorImageInfo() {
  
  
}

_VkDescriptorImageInfo::~_VkDescriptorImageInfo() {
  //printf("VkDescriptorImageInfo deconstructed!!\n");
  
  
  
  
}

void _VkDescriptorImageInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDescriptorImageInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDescriptorImageInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sampler").ToLocalChecked(), Getsampler, Setsampler, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageView").ToLocalChecked(), GetimageView, SetimageView, ctor);
  SetPrototypeAccessor(proto, Nan::New("imageLayout").ToLocalChecked(), GetimageLayout, SetimageLayout, ctor);
  Nan::Set(target, Nan::New("VkDescriptorImageInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDescriptorImageInfo::flush() {
  _VkDescriptorImageInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkDescriptorImageInfo::New) {
  if (info.IsConstructCall()) {
    _VkDescriptorImageInfo* self = new _VkDescriptorImageInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sampler").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("imageView").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("imageLayout").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDescriptorImageInfo constructor cannot be invoked without 'new'");
  }
};

// sampler
NAN_GETTER(_VkDescriptorImageInfo::Getsampler) {
  _VkDescriptorImageInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorImageInfo>(info.This());
  if (self->sampler.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->sampler);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorImageInfo::Setsampler) {
  _VkDescriptorImageInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorImageInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkSampler::constructor)->HasInstance(obj)) {
      self->sampler.Reset<v8::Object>(value.As<v8::Object>());
      _VkSampler* inst = Nan::ObjectWrap::Unwrap<_VkSampler>(obj);
      ;
      self->instance.sampler = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorImageInfo.sampler", "[object VkSampler]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->sampler.Reset();
    self->instance.sampler = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorImageInfo.sampler", "[object VkSampler]");
  
    return;
  }
}// imageView
NAN_GETTER(_VkDescriptorImageInfo::GetimageView) {
  _VkDescriptorImageInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorImageInfo>(info.This());
  if (self->imageView.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->imageView);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDescriptorImageInfo::SetimageView) {
  _VkDescriptorImageInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorImageInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkImageView::constructor)->HasInstance(obj)) {
      self->imageView.Reset<v8::Object>(value.As<v8::Object>());
      _VkImageView* inst = Nan::ObjectWrap::Unwrap<_VkImageView>(obj);
      ;
      self->instance.imageView = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDescriptorImageInfo.imageView", "[object VkImageView]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->imageView.Reset();
    self->instance.imageView = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorImageInfo.imageView", "[object VkImageView]");
  
    return;
  }
}// imageLayout
NAN_GETTER(_VkDescriptorImageInfo::GetimageLayout) {
  _VkDescriptorImageInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorImageInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.imageLayout));
}NAN_SETTER(_VkDescriptorImageInfo::SetimageLayout) {
  _VkDescriptorImageInfo *self = Nan::ObjectWrap::Unwrap<_VkDescriptorImageInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.imageLayout = static_cast<VkImageLayout>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDescriptorImageInfo.imageLayout", "Number");
  
    return;
  }
}
/** ## END VkDescriptorImageInfo ## **/

/** ## BEGIN VkWriteDescriptorSet ## **/

class _VkWriteDescriptorSet: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> dstSet;
      static NAN_GETTER(GetdstSet);
    static NAN_SETTER(SetdstSet);
    
    static NAN_GETTER(GetdstBinding);
    static NAN_SETTER(SetdstBinding);
    
    static NAN_GETTER(GetdstArrayElement);
    static NAN_SETTER(SetdstArrayElement);
    
    static NAN_GETTER(GetdescriptorCount);
    static NAN_SETTER(SetdescriptorCount);
    
    static NAN_GETTER(GetdescriptorType);
    static NAN_SETTER(SetdescriptorType);
    
    std::vector<VkDescriptorImageInfo>* vpImageInfo;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pImageInfo;
    static NAN_GETTER(GetpImageInfo);
    static NAN_SETTER(SetpImageInfo);
    
    std::vector<VkDescriptorBufferInfo>* vpBufferInfo;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pBufferInfo;
    static NAN_GETTER(GetpBufferInfo);
    static NAN_SETTER(SetpBufferInfo);
    
    std::vector<VkBufferView>* vpTexelBufferView;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pTexelBufferView;
    static NAN_GETTER(GetpTexelBufferView);
    static NAN_SETTER(SetpTexelBufferView);
    

    // real instance
    VkWriteDescriptorSet instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkWriteDescriptorSet();
    ~_VkWriteDescriptorSet();

};

/*
#include "index.h"
#include "VkWriteDescriptorSet.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkWriteDescriptorSet::constructor;

_VkWriteDescriptorSet::_VkWriteDescriptorSet() {
  instance.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  vpImageInfo = new std::vector<VkDescriptorImageInfo>;
  vpBufferInfo = new std::vector<VkDescriptorBufferInfo>;
  vpTexelBufferView = new std::vector<VkBufferView>;
  
}

_VkWriteDescriptorSet::~_VkWriteDescriptorSet() {
  //printf("VkWriteDescriptorSet deconstructed!!\n");
  
  
  
  
  
  
  
  vpImageInfo->clear();
  delete vpImageInfo;
  
  pImageInfo.Reset();
  
  vpBufferInfo->clear();
  delete vpBufferInfo;
  
  pBufferInfo.Reset();
  
  vpTexelBufferView->clear();
  delete vpTexelBufferView;
  
  pTexelBufferView.Reset();
  
}

void _VkWriteDescriptorSet::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkWriteDescriptorSet::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkWriteDescriptorSet").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstSet").ToLocalChecked(), GetdstSet, SetdstSet, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstBinding").ToLocalChecked(), GetdstBinding, SetdstBinding, ctor);
  SetPrototypeAccessor(proto, Nan::New("dstArrayElement").ToLocalChecked(), GetdstArrayElement, SetdstArrayElement, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorCount").ToLocalChecked(), GetdescriptorCount, SetdescriptorCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("descriptorType").ToLocalChecked(), GetdescriptorType, SetdescriptorType, ctor);
  SetPrototypeAccessor(proto, Nan::New("pImageInfo").ToLocalChecked(), GetpImageInfo, SetpImageInfo, ctor);
  SetPrototypeAccessor(proto, Nan::New("pBufferInfo").ToLocalChecked(), GetpBufferInfo, SetpBufferInfo, ctor);
  SetPrototypeAccessor(proto, Nan::New("pTexelBufferView").ToLocalChecked(), GetpTexelBufferView, SetpTexelBufferView, ctor);
  Nan::Set(target, Nan::New("VkWriteDescriptorSet").ToLocalChecked(), ctor->GetFunction());
}

bool _VkWriteDescriptorSet::flush() {
  _VkWriteDescriptorSet *self = this;
  if (!(self->pImageInfo.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pImageInfo);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.descriptorCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'descriptorCount' for 'VkWriteDescriptorSet.pImageInfo'");
      return false;
    }
    std::vector<VkDescriptorImageInfo>* data = self->vpImageInfo;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDescriptorImageInfo::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pImageInfo", "[object VkDescriptorImageInfo]");
  
        return false;
      }
      _VkDescriptorImageInfo* result = Nan::ObjectWrap::Unwrap<_VkDescriptorImageInfo>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pImageInfo = data->data();
  }if (!(self->pBufferInfo.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pBufferInfo);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.descriptorCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'descriptorCount' for 'VkWriteDescriptorSet.pBufferInfo'");
      return false;
    }
    std::vector<VkDescriptorBufferInfo>* data = self->vpBufferInfo;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDescriptorBufferInfo::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pBufferInfo", "[object VkDescriptorBufferInfo]");
  
        return false;
      }
      _VkDescriptorBufferInfo* result = Nan::ObjectWrap::Unwrap<_VkDescriptorBufferInfo>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pBufferInfo = data->data();
  }if (!(self->pTexelBufferView.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pTexelBufferView);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.descriptorCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'descriptorCount' for 'VkWriteDescriptorSet.pTexelBufferView'");
      return false;
    }
    std::vector<VkBufferView>* data = self->vpTexelBufferView;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkBufferView::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pTexelBufferView", "[object VkBufferView]");
  
        return false;
      }
      _VkBufferView* result = Nan::ObjectWrap::Unwrap<_VkBufferView>(obj);
      
      data->push_back(result->instance);
    };
    self->instance.pTexelBufferView = data->data();
  }
  return true;
}

NAN_METHOD(_VkWriteDescriptorSet::New) {
  if (info.IsConstructCall()) {
    _VkWriteDescriptorSet* self = new _VkWriteDescriptorSet();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("dstSet").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("dstBinding").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("dstArrayElement").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("descriptorCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("descriptorType").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("pImageInfo").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("pBufferInfo").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("pTexelBufferView").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkWriteDescriptorSet constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkWriteDescriptorSet::GetsType) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkWriteDescriptorSet::SetsType) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.sType", "Number");
  
    return;
  }
}// dstSet
NAN_GETTER(_VkWriteDescriptorSet::GetdstSet) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (self->dstSet.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->dstSet);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWriteDescriptorSet::SetdstSet) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDescriptorSet::constructor)->HasInstance(obj)) {
      self->dstSet.Reset<v8::Object>(value.As<v8::Object>());
      _VkDescriptorSet* inst = Nan::ObjectWrap::Unwrap<_VkDescriptorSet>(obj);
      ;
      self->instance.dstSet = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.dstSet", "[object VkDescriptorSet]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->dstSet.Reset();
    self->instance.dstSet = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.dstSet", "[object VkDescriptorSet]");
  
    return;
  }
}// dstBinding
NAN_GETTER(_VkWriteDescriptorSet::GetdstBinding) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstBinding));
}NAN_SETTER(_VkWriteDescriptorSet::SetdstBinding) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.dstBinding = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.dstBinding", "Number");
  
    return;
  }
}// dstArrayElement
NAN_GETTER(_VkWriteDescriptorSet::GetdstArrayElement) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.dstArrayElement));
}NAN_SETTER(_VkWriteDescriptorSet::SetdstArrayElement) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.dstArrayElement = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.dstArrayElement", "Number");
  
    return;
  }
}// descriptorCount
NAN_GETTER(_VkWriteDescriptorSet::GetdescriptorCount) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorCount));
}NAN_SETTER(_VkWriteDescriptorSet::SetdescriptorCount) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.descriptorCount", "Number");
  
    return;
  }
}// descriptorType
NAN_GETTER(_VkWriteDescriptorSet::GetdescriptorType) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.descriptorType));
}NAN_SETTER(_VkWriteDescriptorSet::SetdescriptorType) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (value->IsNumber()) {
    self->instance.descriptorType = static_cast<VkDescriptorType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.descriptorType", "Number");
  
    return;
  }
}// pImageInfo
NAN_GETTER(_VkWriteDescriptorSet::GetpImageInfo) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (self->pImageInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pImageInfo);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWriteDescriptorSet::SetpImageInfo) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pImageInfo.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pImageInfo.Reset();
      self->instance.pImageInfo = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pImageInfo", "[object VkDescriptorImageInfo]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pImageInfo = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pImageInfo", "[object VkDescriptorImageInfo]");
  
    return;
  }
}// pBufferInfo
NAN_GETTER(_VkWriteDescriptorSet::GetpBufferInfo) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (self->pBufferInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pBufferInfo);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWriteDescriptorSet::SetpBufferInfo) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pBufferInfo.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pBufferInfo.Reset();
      self->instance.pBufferInfo = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pBufferInfo", "[object VkDescriptorBufferInfo]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pBufferInfo = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pBufferInfo", "[object VkDescriptorBufferInfo]");
  
    return;
  }
}// pTexelBufferView
NAN_GETTER(_VkWriteDescriptorSet::GetpTexelBufferView) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  if (self->pTexelBufferView.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pTexelBufferView);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkWriteDescriptorSet::SetpTexelBufferView) {
  _VkWriteDescriptorSet *self = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pTexelBufferView.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pTexelBufferView.Reset();
      self->instance.pTexelBufferView = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pTexelBufferView", "[object VkBufferView]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pTexelBufferView = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkWriteDescriptorSet.pTexelBufferView", "[object VkBufferView]");
  
    return;
  }
}
/** ## END VkWriteDescriptorSet ## **/

/** ## BEGIN VkMappedMemoryRange ## **/

class _VkMappedMemoryRange: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> memory;
      static NAN_GETTER(Getmemory);
    static NAN_SETTER(Setmemory);
    
    static NAN_GETTER(Getoffset);
    static NAN_SETTER(Setoffset);
    
    static NAN_GETTER(Getsize);
    static NAN_SETTER(Setsize);
    

    // real instance
    VkMappedMemoryRange instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMappedMemoryRange();
    ~_VkMappedMemoryRange();

};

/*
#include "index.h"
#include "VkMappedMemoryRange.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMappedMemoryRange::constructor;

_VkMappedMemoryRange::_VkMappedMemoryRange() {
  instance.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
  
}

_VkMappedMemoryRange::~_VkMappedMemoryRange() {
  //printf("VkMappedMemoryRange deconstructed!!\n");
  
  
  
  
  
}

void _VkMappedMemoryRange::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMappedMemoryRange::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMappedMemoryRange").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("memory").ToLocalChecked(), Getmemory, Setmemory, ctor);
  SetPrototypeAccessor(proto, Nan::New("offset").ToLocalChecked(), Getoffset, Setoffset, ctor);
  SetPrototypeAccessor(proto, Nan::New("size").ToLocalChecked(), Getsize, Setsize, ctor);
  Nan::Set(target, Nan::New("VkMappedMemoryRange").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMappedMemoryRange::flush() {
  _VkMappedMemoryRange *self = this;
  
  return true;
}

NAN_METHOD(_VkMappedMemoryRange::New) {
  if (info.IsConstructCall()) {
    _VkMappedMemoryRange* self = new _VkMappedMemoryRange();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("memory").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("offset").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("size").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMappedMemoryRange constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMappedMemoryRange::GetsType) {
  _VkMappedMemoryRange *self = Nan::ObjectWrap::Unwrap<_VkMappedMemoryRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkMappedMemoryRange::SetsType) {
  _VkMappedMemoryRange *self = Nan::ObjectWrap::Unwrap<_VkMappedMemoryRange>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMappedMemoryRange.sType", "Number");
  
    return;
  }
}// memory
NAN_GETTER(_VkMappedMemoryRange::Getmemory) {
  _VkMappedMemoryRange *self = Nan::ObjectWrap::Unwrap<_VkMappedMemoryRange>(info.This());
  if (self->memory.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->memory);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkMappedMemoryRange::Setmemory) {
  _VkMappedMemoryRange *self = Nan::ObjectWrap::Unwrap<_VkMappedMemoryRange>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkDeviceMemory::constructor)->HasInstance(obj)) {
      self->memory.Reset<v8::Object>(value.As<v8::Object>());
      _VkDeviceMemory* inst = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(obj);
      ;
      self->instance.memory = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkMappedMemoryRange.memory", "[object VkDeviceMemory]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->memory.Reset();
    self->instance.memory = VK_NULL_HANDLE;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMappedMemoryRange.memory", "[object VkDeviceMemory]");
  
    return;
  }
}// offset
NAN_GETTER(_VkMappedMemoryRange::Getoffset) {
  _VkMappedMemoryRange *self = Nan::ObjectWrap::Unwrap<_VkMappedMemoryRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.offset));
}NAN_SETTER(_VkMappedMemoryRange::Setoffset) {
  _VkMappedMemoryRange *self = Nan::ObjectWrap::Unwrap<_VkMappedMemoryRange>(info.This());
  if (value->IsNumber()) {
    self->instance.offset = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMappedMemoryRange.offset", "Number");
  
    return;
  }
}// size
NAN_GETTER(_VkMappedMemoryRange::Getsize) {
  _VkMappedMemoryRange *self = Nan::ObjectWrap::Unwrap<_VkMappedMemoryRange>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.size));
}NAN_SETTER(_VkMappedMemoryRange::Setsize) {
  _VkMappedMemoryRange *self = Nan::ObjectWrap::Unwrap<_VkMappedMemoryRange>(info.This());
  if (value->IsNumber()) {
    self->instance.size = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMappedMemoryRange.size", "Number");
  
    return;
  }
}
/** ## END VkMappedMemoryRange ## **/

/** ## BEGIN VkMemoryAllocateInfo ## **/

class _VkMemoryAllocateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(GetallocationSize);
    static NAN_SETTER(SetallocationSize);
    
    static NAN_GETTER(GetmemoryTypeIndex);
    static NAN_SETTER(SetmemoryTypeIndex);
    

    // real instance
    VkMemoryAllocateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkMemoryAllocateInfo();
    ~_VkMemoryAllocateInfo();

};

/*
#include "index.h"
#include "VkMemoryAllocateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkMemoryAllocateInfo::constructor;

_VkMemoryAllocateInfo::_VkMemoryAllocateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
  
}

_VkMemoryAllocateInfo::~_VkMemoryAllocateInfo() {
  //printf("VkMemoryAllocateInfo deconstructed!!\n");
  
  
  
  
}

void _VkMemoryAllocateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkMemoryAllocateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkMemoryAllocateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("allocationSize").ToLocalChecked(), GetallocationSize, SetallocationSize, ctor);
  SetPrototypeAccessor(proto, Nan::New("memoryTypeIndex").ToLocalChecked(), GetmemoryTypeIndex, SetmemoryTypeIndex, ctor);
  Nan::Set(target, Nan::New("VkMemoryAllocateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkMemoryAllocateInfo::flush() {
  _VkMemoryAllocateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkMemoryAllocateInfo::New) {
  if (info.IsConstructCall()) {
    _VkMemoryAllocateInfo* self = new _VkMemoryAllocateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("allocationSize").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("memoryTypeIndex").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkMemoryAllocateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkMemoryAllocateInfo::GetsType) {
  _VkMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkMemoryAllocateInfo::SetsType) {
  _VkMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryAllocateInfo.sType", "Number");
  
    return;
  }
}// allocationSize
NAN_GETTER(_VkMemoryAllocateInfo::GetallocationSize) {
  _VkMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.allocationSize));
}NAN_SETTER(_VkMemoryAllocateInfo::SetallocationSize) {
  _VkMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.allocationSize = static_cast<uint64_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryAllocateInfo.allocationSize", "Number");
  
    return;
  }
}// memoryTypeIndex
NAN_GETTER(_VkMemoryAllocateInfo::GetmemoryTypeIndex) {
  _VkMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.memoryTypeIndex));
}NAN_SETTER(_VkMemoryAllocateInfo::SetmemoryTypeIndex) {
  _VkMemoryAllocateInfo *self = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.memoryTypeIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkMemoryAllocateInfo.memoryTypeIndex", "Number");
  
    return;
  }
}
/** ## END VkMemoryAllocateInfo ## **/

/** ## BEGIN VkApplicationInfo ## **/

class _VkApplicationInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pApplicationName;
    static NAN_GETTER(GetpApplicationName);
    static NAN_SETTER(SetpApplicationName);
    
    static NAN_GETTER(GetapplicationVersion);
    static NAN_SETTER(SetapplicationVersion);
    
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> pEngineName;
    static NAN_GETTER(GetpEngineName);
    static NAN_SETTER(SetpEngineName);
    
    static NAN_GETTER(GetengineVersion);
    static NAN_SETTER(SetengineVersion);
    
    static NAN_GETTER(GetapiVersion);
    static NAN_SETTER(SetapiVersion);
    

    // real instance
    VkApplicationInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkApplicationInfo();
    ~_VkApplicationInfo();

};

/*
#include "index.h"
#include "VkApplicationInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkApplicationInfo::constructor;

_VkApplicationInfo::_VkApplicationInfo() {
  instance.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
  
}

_VkApplicationInfo::~_VkApplicationInfo() {
  //printf("VkApplicationInfo deconstructed!!\n");
  
  
  pApplicationName.Reset();
  
  
  pEngineName.Reset();
  
  
  
}

void _VkApplicationInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkApplicationInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkApplicationInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("pApplicationName").ToLocalChecked(), GetpApplicationName, SetpApplicationName, ctor);
  SetPrototypeAccessor(proto, Nan::New("applicationVersion").ToLocalChecked(), GetapplicationVersion, SetapplicationVersion, ctor);
  SetPrototypeAccessor(proto, Nan::New("pEngineName").ToLocalChecked(), GetpEngineName, SetpEngineName, ctor);
  SetPrototypeAccessor(proto, Nan::New("engineVersion").ToLocalChecked(), GetengineVersion, SetengineVersion, ctor);
  SetPrototypeAccessor(proto, Nan::New("apiVersion").ToLocalChecked(), GetapiVersion, SetapiVersion, ctor);
  Nan::Set(target, Nan::New("VkApplicationInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkApplicationInfo::flush() {
  _VkApplicationInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkApplicationInfo::New) {
  if (info.IsConstructCall()) {
    _VkApplicationInfo* self = new _VkApplicationInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("pApplicationName").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("applicationVersion").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pEngineName").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("engineVersion").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("apiVersion").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkApplicationInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkApplicationInfo::GetsType) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkApplicationInfo::SetsType) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkApplicationInfo.sType", "Number");
  
    return;
  }
}// pApplicationName
NAN_GETTER(_VkApplicationInfo::GetpApplicationName) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  if (self->pApplicationName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pApplicationName);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkApplicationInfo::SetpApplicationName) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pApplicationName = str;
    // free previous
    if (self->instance.pApplicationName) {
      delete[] self->instance.pApplicationName;
    }
    self->instance.pApplicationName = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pApplicationName = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkApplicationInfo.pApplicationName", "String");
  
    return;
  }
}// applicationVersion
NAN_GETTER(_VkApplicationInfo::GetapplicationVersion) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.applicationVersion));
}NAN_SETTER(_VkApplicationInfo::SetapplicationVersion) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.applicationVersion = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkApplicationInfo.applicationVersion", "Number");
  
    return;
  }
}// pEngineName
NAN_GETTER(_VkApplicationInfo::GetpEngineName) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  if (self->pEngineName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::String> str = Nan::New(self->pEngineName);
    info.GetReturnValue().Set(str);
  }
}NAN_SETTER(_VkApplicationInfo::SetpEngineName) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  if (value->IsString()) {
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(value).ToLocalChecked());
    self->pEngineName = str;
    // free previous
    if (self->instance.pEngineName) {
      delete[] self->instance.pEngineName;
    }
    self->instance.pEngineName = copyV8String(value);
  } else if (value->IsNull()) {
    self->instance.pEngineName = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkApplicationInfo.pEngineName", "String");
  
    return;
  }
}// engineVersion
NAN_GETTER(_VkApplicationInfo::GetengineVersion) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.engineVersion));
}NAN_SETTER(_VkApplicationInfo::SetengineVersion) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.engineVersion = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkApplicationInfo.engineVersion", "Number");
  
    return;
  }
}// apiVersion
NAN_GETTER(_VkApplicationInfo::GetapiVersion) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.apiVersion));
}NAN_SETTER(_VkApplicationInfo::SetapiVersion) {
  _VkApplicationInfo *self = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.apiVersion = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkApplicationInfo.apiVersion", "Number");
  
    return;
  }
}
/** ## END VkApplicationInfo ## **/

/** ## BEGIN VkInstanceCreateInfo ## **/

class _VkInstanceCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pApplicationInfo;
      static NAN_GETTER(GetpApplicationInfo);
    static NAN_SETTER(SetpApplicationInfo);
    
    static NAN_GETTER(GetenabledLayerCount);
    static NAN_SETTER(SetenabledLayerCount);
    
    std::vector<char *>* vppEnabledLayerNames;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> ppEnabledLayerNames;
    static NAN_GETTER(GetppEnabledLayerNames);
    static NAN_SETTER(SetppEnabledLayerNames);
    
    static NAN_GETTER(GetenabledExtensionCount);
    static NAN_SETTER(SetenabledExtensionCount);
    
    std::vector<char *>* vppEnabledExtensionNames;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> ppEnabledExtensionNames;
    static NAN_GETTER(GetppEnabledExtensionNames);
    static NAN_SETTER(SetppEnabledExtensionNames);
    

    // real instance
    VkInstanceCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkInstanceCreateInfo();
    ~_VkInstanceCreateInfo();

};

/*
#include "index.h"
#include "VkInstanceCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkInstanceCreateInfo::constructor;

_VkInstanceCreateInfo::_VkInstanceCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
  vppEnabledLayerNames = new std::vector<char*>;
  vppEnabledExtensionNames = new std::vector<char*>;
  
}

_VkInstanceCreateInfo::~_VkInstanceCreateInfo() {
  //printf("VkInstanceCreateInfo deconstructed!!\n");
  
  
  
  pApplicationInfo.Reset();
  
  
  for (int ii = 0; ii < vppEnabledLayerNames->size(); ++ii) {
    delete ((char*) vppEnabledLayerNames->at(ii));
  };
  vppEnabledLayerNames->clear();
  delete vppEnabledLayerNames;
  
  ppEnabledLayerNames.Reset();
  
  
  for (int ii = 0; ii < vppEnabledExtensionNames->size(); ++ii) {
    delete ((char*) vppEnabledExtensionNames->at(ii));
  };
  vppEnabledExtensionNames->clear();
  delete vppEnabledExtensionNames;
  
  ppEnabledExtensionNames.Reset();
  
}

void _VkInstanceCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkInstanceCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkInstanceCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("pApplicationInfo").ToLocalChecked(), GetpApplicationInfo, SetpApplicationInfo, ctor);
  SetPrototypeAccessor(proto, Nan::New("enabledLayerCount").ToLocalChecked(), GetenabledLayerCount, SetenabledLayerCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("ppEnabledLayerNames").ToLocalChecked(), GetppEnabledLayerNames, SetppEnabledLayerNames, ctor);
  SetPrototypeAccessor(proto, Nan::New("enabledExtensionCount").ToLocalChecked(), GetenabledExtensionCount, SetenabledExtensionCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("ppEnabledExtensionNames").ToLocalChecked(), GetppEnabledExtensionNames, SetppEnabledExtensionNames, ctor);
  Nan::Set(target, Nan::New("VkInstanceCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkInstanceCreateInfo::flush() {
  _VkInstanceCreateInfo *self = this;
  if (!(self->ppEnabledLayerNames.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->ppEnabledLayerNames);
    
    std::vector<char*>* data = self->vppEnabledLayerNames;
    data->clear();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      if (!item->IsString()) return false;
      char *copy = copyV8String(item);
      data->push_back(copy);
    };
    self->instance.ppEnabledLayerNames = data->data();
  }if (!(self->ppEnabledExtensionNames.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->ppEnabledExtensionNames);
    
    std::vector<char*>* data = self->vppEnabledExtensionNames;
    data->clear();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      if (!item->IsString()) return false;
      char *copy = copyV8String(item);
      data->push_back(copy);
    };
    self->instance.ppEnabledExtensionNames = data->data();
  }
  return true;
}

NAN_METHOD(_VkInstanceCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkInstanceCreateInfo* self = new _VkInstanceCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("pApplicationInfo").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("enabledLayerCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("ppEnabledLayerNames").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("enabledExtensionCount").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("ppEnabledExtensionNames").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkInstanceCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkInstanceCreateInfo::GetsType) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkInstanceCreateInfo::SetsType) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkInstanceCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkInstanceCreateInfo::Getflags) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkInstanceCreateInfo::Setflags) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkInstanceCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkInstanceCreateInfo.flags", "Number");
  
    return;
  }
}// pApplicationInfo
NAN_GETTER(_VkInstanceCreateInfo::GetpApplicationInfo) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  if (self->pApplicationInfo.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pApplicationInfo);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkInstanceCreateInfo::SetpApplicationInfo) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkApplicationInfo::constructor)->HasInstance(obj)) {
      self->pApplicationInfo.Reset<v8::Object>(value.As<v8::Object>());
      _VkApplicationInfo* inst = Nan::ObjectWrap::Unwrap<_VkApplicationInfo>(obj);
      inst->flush();
      self->instance.pApplicationInfo = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkInstanceCreateInfo.pApplicationInfo", "[object VkApplicationInfo]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pApplicationInfo.Reset();
    self->instance.pApplicationInfo = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkInstanceCreateInfo.pApplicationInfo", "[object VkApplicationInfo]");
  
    return;
  }
}// enabledLayerCount
NAN_GETTER(_VkInstanceCreateInfo::GetenabledLayerCount) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.enabledLayerCount));
}NAN_SETTER(_VkInstanceCreateInfo::SetenabledLayerCount) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.enabledLayerCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkInstanceCreateInfo.enabledLayerCount", "Number");
  
    return;
  }
}// ppEnabledLayerNames
NAN_GETTER(_VkInstanceCreateInfo::GetppEnabledLayerNames) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  if (self->ppEnabledLayerNames.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->ppEnabledLayerNames);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkInstanceCreateInfo::SetppEnabledLayerNames) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->ppEnabledLayerNames.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->ppEnabledLayerNames.Reset();
      self->instance.ppEnabledLayerNames = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkInstanceCreateInfo.ppEnabledLayerNames", "Array");
  
      return;
    }
  
}// enabledExtensionCount
NAN_GETTER(_VkInstanceCreateInfo::GetenabledExtensionCount) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.enabledExtensionCount));
}NAN_SETTER(_VkInstanceCreateInfo::SetenabledExtensionCount) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.enabledExtensionCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkInstanceCreateInfo.enabledExtensionCount", "Number");
  
    return;
  }
}// ppEnabledExtensionNames
NAN_GETTER(_VkInstanceCreateInfo::GetppEnabledExtensionNames) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  if (self->ppEnabledExtensionNames.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->ppEnabledExtensionNames);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkInstanceCreateInfo::SetppEnabledExtensionNames) {
  _VkInstanceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->ppEnabledExtensionNames.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->ppEnabledExtensionNames.Reset();
      self->instance.ppEnabledExtensionNames = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkInstanceCreateInfo.ppEnabledExtensionNames", "Array");
  
      return;
    }
  
}
/** ## END VkInstanceCreateInfo ## **/

/** ## BEGIN VkDeviceQueueCreateInfo ## **/

class _VkDeviceQueueCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetqueueFamilyIndex);
    static NAN_SETTER(SetqueueFamilyIndex);
    
    static NAN_GETTER(GetqueueCount);
    static NAN_SETTER(SetqueueCount);
    
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pQueuePriorities;
    static NAN_GETTER(GetpQueuePriorities);
    static NAN_SETTER(SetpQueuePriorities);
    

    // real instance
    VkDeviceQueueCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceQueueCreateInfo();
    ~_VkDeviceQueueCreateInfo();

};

/*
#include "index.h"
#include "VkDeviceQueueCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceQueueCreateInfo::constructor;

_VkDeviceQueueCreateInfo::_VkDeviceQueueCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
  
}

_VkDeviceQueueCreateInfo::~_VkDeviceQueueCreateInfo() {
  //printf("VkDeviceQueueCreateInfo deconstructed!!\n");
  
  
  
  
  
  pQueuePriorities.Reset();
  
}

void _VkDeviceQueueCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceQueueCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceQueueCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueFamilyIndex").ToLocalChecked(), GetqueueFamilyIndex, SetqueueFamilyIndex, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueCount").ToLocalChecked(), GetqueueCount, SetqueueCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pQueuePriorities").ToLocalChecked(), GetpQueuePriorities, SetpQueuePriorities, ctor);
  Nan::Set(target, Nan::New("VkDeviceQueueCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceQueueCreateInfo::flush() {
  _VkDeviceQueueCreateInfo *self = this;
  
  return true;
}

NAN_METHOD(_VkDeviceQueueCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkDeviceQueueCreateInfo* self = new _VkDeviceQueueCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("queueFamilyIndex").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("queueCount").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("pQueuePriorities").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceQueueCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceQueueCreateInfo::GetsType) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceQueueCreateInfo::SetsType) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDeviceQueueCreateInfo::Getflags) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDeviceQueueCreateInfo::Setflags) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDeviceQueueCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueCreateInfo.flags", "Number");
  
    return;
  }
}// queueFamilyIndex
NAN_GETTER(_VkDeviceQueueCreateInfo::GetqueueFamilyIndex) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueFamilyIndex));
}NAN_SETTER(_VkDeviceQueueCreateInfo::SetqueueFamilyIndex) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queueFamilyIndex = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueCreateInfo.queueFamilyIndex", "Number");
  
    return;
  }
}// queueCount
NAN_GETTER(_VkDeviceQueueCreateInfo::GetqueueCount) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueCount));
}NAN_SETTER(_VkDeviceQueueCreateInfo::SetqueueCount) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queueCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueCreateInfo.queueCount", "Number");
  
    return;
  }
}// pQueuePriorities
NAN_GETTER(_VkDeviceQueueCreateInfo::GetpQueuePriorities) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  if (self->pQueuePriorities.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pQueuePriorities);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceQueueCreateInfo::SetpQueuePriorities) {
  _VkDeviceQueueCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(info.This());
  
    // js
    if (value->IsArrayBufferView()) {
      if (value->IsFloat32Array()) {
        self->pQueuePriorities.Reset<v8::Array>(value.As<v8::Array>());
      } else {
        
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueCreateInfo.pQueuePriorities", "Float32Array");
  
        return;
      }
    } else if (value->IsNull()) {
      self->pQueuePriorities.Reset();
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceQueueCreateInfo.pQueuePriorities", "Float32Array");
  
      return;
    }
  
  
  // vulkan
  if (value->IsArrayBufferView()) {
    self->instance.pQueuePriorities = getTypedArrayData<float>(Nan::To<v8::Object>(value).ToLocalChecked(), nullptr);
  } else {
    self->instance.pQueuePriorities = nullptr;
  }
}
/** ## END VkDeviceQueueCreateInfo ## **/

/** ## BEGIN VkDeviceCreateInfo ## **/

class _VkDeviceCreateInfo: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
    static NAN_GETTER(Getflags);
    static NAN_SETTER(Setflags);
    
    static NAN_GETTER(GetqueueCreateInfoCount);
    static NAN_SETTER(SetqueueCreateInfoCount);
    
    std::vector<VkDeviceQueueCreateInfo>* vpQueueCreateInfos;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> pQueueCreateInfos;
    static NAN_GETTER(GetpQueueCreateInfos);
    static NAN_SETTER(SetpQueueCreateInfos);
    
    static NAN_GETTER(GetenabledLayerCount);
    static NAN_SETTER(SetenabledLayerCount);
    
    std::vector<char *>* vppEnabledLayerNames;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> ppEnabledLayerNames;
    static NAN_GETTER(GetppEnabledLayerNames);
    static NAN_SETTER(SetppEnabledLayerNames);
    
    static NAN_GETTER(GetenabledExtensionCount);
    static NAN_SETTER(SetenabledExtensionCount);
    
    std::vector<char *>* vppEnabledExtensionNames;
    Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>> ppEnabledExtensionNames;
    static NAN_GETTER(GetppEnabledExtensionNames);
    static NAN_SETTER(SetppEnabledExtensionNames);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pEnabledFeatures;
      static NAN_GETTER(GetpEnabledFeatures);
    static NAN_SETTER(SetpEnabledFeatures);
    

    // real instance
    VkDeviceCreateInfo instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkDeviceCreateInfo();
    ~_VkDeviceCreateInfo();

};

/*
#include "index.h"
#include "VkDeviceCreateInfo.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkDeviceCreateInfo::constructor;

_VkDeviceCreateInfo::_VkDeviceCreateInfo() {
  instance.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
  vpQueueCreateInfos = new std::vector<VkDeviceQueueCreateInfo>;
  vppEnabledLayerNames = new std::vector<char*>;
  vppEnabledExtensionNames = new std::vector<char*>;
  
}

_VkDeviceCreateInfo::~_VkDeviceCreateInfo() {
  //printf("VkDeviceCreateInfo deconstructed!!\n");
  
  
  
  
  vpQueueCreateInfos->clear();
  delete vpQueueCreateInfos;
  
  pQueueCreateInfos.Reset();
  
  
  for (int ii = 0; ii < vppEnabledLayerNames->size(); ++ii) {
    delete ((char*) vppEnabledLayerNames->at(ii));
  };
  vppEnabledLayerNames->clear();
  delete vppEnabledLayerNames;
  
  ppEnabledLayerNames.Reset();
  
  
  for (int ii = 0; ii < vppEnabledExtensionNames->size(); ++ii) {
    delete ((char*) vppEnabledExtensionNames->at(ii));
  };
  vppEnabledExtensionNames->clear();
  delete vppEnabledExtensionNames;
  
  ppEnabledExtensionNames.Reset();
  
  pEnabledFeatures.Reset();
  
}

void _VkDeviceCreateInfo::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkDeviceCreateInfo::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkDeviceCreateInfo").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("flags").ToLocalChecked(), Getflags, Setflags, ctor);
  SetPrototypeAccessor(proto, Nan::New("queueCreateInfoCount").ToLocalChecked(), GetqueueCreateInfoCount, SetqueueCreateInfoCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("pQueueCreateInfos").ToLocalChecked(), GetpQueueCreateInfos, SetpQueueCreateInfos, ctor);
  SetPrototypeAccessor(proto, Nan::New("enabledLayerCount").ToLocalChecked(), GetenabledLayerCount, SetenabledLayerCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("ppEnabledLayerNames").ToLocalChecked(), GetppEnabledLayerNames, SetppEnabledLayerNames, ctor);
  SetPrototypeAccessor(proto, Nan::New("enabledExtensionCount").ToLocalChecked(), GetenabledExtensionCount, SetenabledExtensionCount, ctor);
  SetPrototypeAccessor(proto, Nan::New("ppEnabledExtensionNames").ToLocalChecked(), GetppEnabledExtensionNames, SetppEnabledExtensionNames, ctor);
  SetPrototypeAccessor(proto, Nan::New("pEnabledFeatures").ToLocalChecked(), GetpEnabledFeatures, SetpEnabledFeatures, ctor);
  Nan::Set(target, Nan::New("VkDeviceCreateInfo").ToLocalChecked(), ctor->GetFunction());
}

bool _VkDeviceCreateInfo::flush() {
  _VkDeviceCreateInfo *self = this;
  if (!(self->pQueueCreateInfos.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->pQueueCreateInfos);
    
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    // validate length
    if (array->Length() != self->instance.queueCreateInfoCount) {
      Nan::ThrowRangeError("Invalid array length, expected array length of 'queueCreateInfoCount' for 'VkDeviceCreateInfo.pQueueCreateInfos'");
      return false;
    }
    std::vector<VkDeviceQueueCreateInfo>* data = self->vpQueueCreateInfos;
    data->clear();
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(Nan::Get(array, ii).ToLocalChecked()).ToLocalChecked();
      if (!(Nan::New(_VkDeviceQueueCreateInfo::constructor)->HasInstance(obj))) {
        
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.pQueueCreateInfos", "[object VkDeviceQueueCreateInfo]");
  
        return false;
      }
      _VkDeviceQueueCreateInfo* result = Nan::ObjectWrap::Unwrap<_VkDeviceQueueCreateInfo>(obj);
      if (!result->flush()) return false;
      data->push_back(result->instance);
    };
    self->instance.pQueueCreateInfos = data->data();
  }if (!(self->ppEnabledLayerNames.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->ppEnabledLayerNames);
    
    std::vector<char*>* data = self->vppEnabledLayerNames;
    data->clear();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      if (!item->IsString()) return false;
      char *copy = copyV8String(item);
      data->push_back(copy);
    };
    self->instance.ppEnabledLayerNames = data->data();
  }if (!(self->ppEnabledExtensionNames.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->ppEnabledExtensionNames);
    
    std::vector<char*>* data = self->vppEnabledExtensionNames;
    data->clear();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(value);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      if (!item->IsString()) return false;
      char *copy = copyV8String(item);
      data->push_back(copy);
    };
    self->instance.ppEnabledExtensionNames = data->data();
  }
  return true;
}

NAN_METHOD(_VkDeviceCreateInfo::New) {
  if (info.IsConstructCall()) {
    _VkDeviceCreateInfo* self = new _VkDeviceCreateInfo();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("flags").ToLocalChecked();
      v8::Local<v8::String> sAccess3 = Nan::New("queueCreateInfoCount").ToLocalChecked();
      v8::Local<v8::String> sAccess4 = Nan::New("pQueueCreateInfos").ToLocalChecked();
      v8::Local<v8::String> sAccess5 = Nan::New("enabledLayerCount").ToLocalChecked();
      v8::Local<v8::String> sAccess6 = Nan::New("ppEnabledLayerNames").ToLocalChecked();
      v8::Local<v8::String> sAccess7 = Nan::New("enabledExtensionCount").ToLocalChecked();
      v8::Local<v8::String> sAccess8 = Nan::New("ppEnabledExtensionNames").ToLocalChecked();
      v8::Local<v8::String> sAccess9 = Nan::New("pEnabledFeatures").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      if (obj->Has(sAccess3)) info.This()->Set(sAccess3, obj->Get(sAccess3));
      if (obj->Has(sAccess4)) info.This()->Set(sAccess4, obj->Get(sAccess4));
      if (obj->Has(sAccess5)) info.This()->Set(sAccess5, obj->Get(sAccess5));
      if (obj->Has(sAccess6)) info.This()->Set(sAccess6, obj->Get(sAccess6));
      if (obj->Has(sAccess7)) info.This()->Set(sAccess7, obj->Get(sAccess7));
      if (obj->Has(sAccess8)) info.This()->Set(sAccess8, obj->Get(sAccess8));
      if (obj->Has(sAccess9)) info.This()->Set(sAccess9, obj->Get(sAccess9));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkDeviceCreateInfo constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkDeviceCreateInfo::GetsType) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkDeviceCreateInfo::SetsType) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.sType", "Number");
  
    return;
  }
}// flags
NAN_GETTER(_VkDeviceCreateInfo::Getflags) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.flags));
}NAN_SETTER(_VkDeviceCreateInfo::Setflags) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.flags = static_cast<VkDeviceCreateFlags>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.flags", "Number");
  
    return;
  }
}// queueCreateInfoCount
NAN_GETTER(_VkDeviceCreateInfo::GetqueueCreateInfoCount) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.queueCreateInfoCount));
}NAN_SETTER(_VkDeviceCreateInfo::SetqueueCreateInfoCount) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.queueCreateInfoCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.queueCreateInfoCount", "Number");
  
    return;
  }
}// pQueueCreateInfos
NAN_GETTER(_VkDeviceCreateInfo::GetpQueueCreateInfos) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (self->pQueueCreateInfos.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pQueueCreateInfos);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceCreateInfo::SetpQueueCreateInfos) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->pQueueCreateInfos.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->pQueueCreateInfos.Reset();
      self->instance.pQueueCreateInfos = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.pQueueCreateInfos", "[object VkDeviceQueueCreateInfo]");
  
      return;
    }
  
  // vulkan
  if (value->IsArray()) {
    
  } else if (value->IsNull()) {
    self->instance.pQueueCreateInfos = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.pQueueCreateInfos", "[object VkDeviceQueueCreateInfo]");
  
    return;
  }
}// enabledLayerCount
NAN_GETTER(_VkDeviceCreateInfo::GetenabledLayerCount) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.enabledLayerCount));
}NAN_SETTER(_VkDeviceCreateInfo::SetenabledLayerCount) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.enabledLayerCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.enabledLayerCount", "Number");
  
    return;
  }
}// ppEnabledLayerNames
NAN_GETTER(_VkDeviceCreateInfo::GetppEnabledLayerNames) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (self->ppEnabledLayerNames.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->ppEnabledLayerNames);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceCreateInfo::SetppEnabledLayerNames) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->ppEnabledLayerNames.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->ppEnabledLayerNames.Reset();
      self->instance.ppEnabledLayerNames = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.ppEnabledLayerNames", "Array");
  
      return;
    }
  
}// enabledExtensionCount
NAN_GETTER(_VkDeviceCreateInfo::GetenabledExtensionCount) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.enabledExtensionCount));
}NAN_SETTER(_VkDeviceCreateInfo::SetenabledExtensionCount) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (value->IsNumber()) {
    self->instance.enabledExtensionCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.enabledExtensionCount", "Number");
  
    return;
  }
}// ppEnabledExtensionNames
NAN_GETTER(_VkDeviceCreateInfo::GetppEnabledExtensionNames) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (self->ppEnabledExtensionNames.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->ppEnabledExtensionNames);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceCreateInfo::SetppEnabledExtensionNames) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  
    // js
    if (value->IsArray()) {
      self->ppEnabledExtensionNames.Reset<v8::Array>(value.As<v8::Array>());
    } else if (value->IsNull()) {
      self->ppEnabledExtensionNames.Reset();
      self->instance.ppEnabledExtensionNames = nullptr;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.ppEnabledExtensionNames", "Array");
  
      return;
    }
  
}// pEnabledFeatures
NAN_GETTER(_VkDeviceCreateInfo::GetpEnabledFeatures) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  if (self->pEnabledFeatures.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pEnabledFeatures);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkDeviceCreateInfo::SetpEnabledFeatures) {
  _VkDeviceCreateInfo *self = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkPhysicalDeviceFeatures::constructor)->HasInstance(obj)) {
      self->pEnabledFeatures.Reset<v8::Object>(value.As<v8::Object>());
      _VkPhysicalDeviceFeatures* inst = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(obj);
      inst->flush();
      self->instance.pEnabledFeatures = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.pEnabledFeatures", "[object VkPhysicalDeviceFeatures]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pEnabledFeatures.Reset();
    self->instance.pEnabledFeatures = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkDeviceCreateInfo.pEnabledFeatures", "[object VkPhysicalDeviceFeatures]");
  
    return;
  }
}
/** ## END VkDeviceCreateInfo ## **/

/** ## BEGIN VkAllocationCallbacks ## **/

class _VkAllocationCallbacks: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors

    // real instance
    VkAllocationCallbacks instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkAllocationCallbacks();
    ~_VkAllocationCallbacks();

};

/*
#include "index.h"
#include "VkAllocationCallbacks.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkAllocationCallbacks::constructor;

_VkAllocationCallbacks::_VkAllocationCallbacks() {
  
  
}

_VkAllocationCallbacks::~_VkAllocationCallbacks() {
  //printf("VkAllocationCallbacks deconstructed!!\n");
  
}

void _VkAllocationCallbacks::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkAllocationCallbacks::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkAllocationCallbacks").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  Nan::Set(target, Nan::New("VkAllocationCallbacks").ToLocalChecked(), ctor->GetFunction());
}

bool _VkAllocationCallbacks::flush() {
  _VkAllocationCallbacks *self = this;
  
  return true;
}

NAN_METHOD(_VkAllocationCallbacks::New) {
  if (info.IsConstructCall()) {
    _VkAllocationCallbacks* self = new _VkAllocationCallbacks();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkAllocationCallbacks constructor cannot be invoked without 'new'");
  }
};


/** ## END VkAllocationCallbacks ## **/

/** ## BEGIN VkLayerProperties ## **/

class _VkLayerProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> layerName;
    static NAN_GETTER(GetlayerName);
    static NAN_GETTER(GetspecVersion);
    static NAN_GETTER(GetimplementationVersion);
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> description;
    static NAN_GETTER(Getdescription);

    // real instance
    VkLayerProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkLayerProperties();
    ~_VkLayerProperties();

};

/*
#include <string.h>
#include "index.h"
#include "VkLayerProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkLayerProperties::constructor;

_VkLayerProperties::_VkLayerProperties() {
  
  
}

_VkLayerProperties::~_VkLayerProperties() {
  //printf("VkLayerProperties deconstructed!!\n");
  
  
  
  
  
}

void _VkLayerProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkLayerProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkLayerProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("layerName").ToLocalChecked(), GetlayerName, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("specVersion").ToLocalChecked(), GetspecVersion, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("implementationVersion").ToLocalChecked(), GetimplementationVersion, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("description").ToLocalChecked(), Getdescription, nullptr, ctor);
  Nan::Set(target, Nan::New("VkLayerProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkLayerProperties::flush() {
  _VkLayerProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkLayerProperties::New) {
  if (info.IsConstructCall()) {
    _VkLayerProperties* self = new _VkLayerProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkLayerProperties constructor cannot be invoked without 'new'");
  }
};

// layerName
NAN_GETTER(_VkLayerProperties::GetlayerName) {
  _VkLayerProperties *self = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(info.This());
  if (self->layerName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->layerName));
  }
}// specVersion
NAN_GETTER(_VkLayerProperties::GetspecVersion) {
  _VkLayerProperties *self = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.specVersion));
}// implementationVersion
NAN_GETTER(_VkLayerProperties::GetimplementationVersion) {
  _VkLayerProperties *self = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.implementationVersion));
}// description
NAN_GETTER(_VkLayerProperties::Getdescription) {
  _VkLayerProperties *self = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(info.This());
  if (self->description.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->description));
  }
}
/** ## END VkLayerProperties ## **/

/** ## BEGIN VkExtensionProperties ## **/

class _VkExtensionProperties: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> extensionName;
    static NAN_GETTER(GetextensionName);
    static NAN_GETTER(GetspecVersion);

    // real instance
    VkExtensionProperties instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkExtensionProperties();
    ~_VkExtensionProperties();

};

/*
#include <string.h>
#include "index.h"
#include "VkExtensionProperties.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkExtensionProperties::constructor;

_VkExtensionProperties::_VkExtensionProperties() {
  
  
}

_VkExtensionProperties::~_VkExtensionProperties() {
  //printf("VkExtensionProperties deconstructed!!\n");
  
  
  
}

void _VkExtensionProperties::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkExtensionProperties::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkExtensionProperties").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("extensionName").ToLocalChecked(), GetextensionName, nullptr, ctor);
  SetPrototypeAccessor(proto, Nan::New("specVersion").ToLocalChecked(), GetspecVersion, nullptr, ctor);
  Nan::Set(target, Nan::New("VkExtensionProperties").ToLocalChecked(), ctor->GetFunction());
}

bool _VkExtensionProperties::flush() {
  _VkExtensionProperties *self = this;
  
  return true;
}

NAN_METHOD(_VkExtensionProperties::New) {
  if (info.IsConstructCall()) {
    _VkExtensionProperties* self = new _VkExtensionProperties();
    self->Wrap(info.Holder());
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkExtensionProperties constructor cannot be invoked without 'new'");
  }
};

// extensionName
NAN_GETTER(_VkExtensionProperties::GetextensionName) {
  _VkExtensionProperties *self = Nan::ObjectWrap::Unwrap<_VkExtensionProperties>(info.This());
  if (self->extensionName.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    info.GetReturnValue().Set(Nan::New(self->extensionName));
  }
}// specVersion
NAN_GETTER(_VkExtensionProperties::GetspecVersion) {
  _VkExtensionProperties *self = Nan::ObjectWrap::Unwrap<_VkExtensionProperties>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.specVersion));
}
/** ## END VkExtensionProperties ## **/

/** ## BEGIN VkClearRect ## **/

class _VkClearRect: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> rect;
      static NAN_GETTER(Getrect);
    static NAN_SETTER(Setrect);
    
    static NAN_GETTER(GetbaseArrayLayer);
    static NAN_SETTER(SetbaseArrayLayer);
    
    static NAN_GETTER(GetlayerCount);
    static NAN_SETTER(SetlayerCount);
    

    // real instance
    VkClearRect instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkClearRect();
    ~_VkClearRect();

};

/*
#include "index.h"
#include "VkClearRect.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkClearRect::constructor;

_VkClearRect::_VkClearRect() {
  
  
}

_VkClearRect::~_VkClearRect() {
  //printf("VkClearRect deconstructed!!\n");
  
  
  
  
}

void _VkClearRect::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkClearRect::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkClearRect").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("rect").ToLocalChecked(), Getrect, Setrect, ctor);
  SetPrototypeAccessor(proto, Nan::New("baseArrayLayer").ToLocalChecked(), GetbaseArrayLayer, SetbaseArrayLayer, ctor);
  SetPrototypeAccessor(proto, Nan::New("layerCount").ToLocalChecked(), GetlayerCount, SetlayerCount, ctor);
  Nan::Set(target, Nan::New("VkClearRect").ToLocalChecked(), ctor->GetFunction());
}

bool _VkClearRect::flush() {
  _VkClearRect *self = this;
  if (!(self->rect.IsEmpty())) {
    v8::Local<v8::Value> value = Nan::New(self->rect);
    
    _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(Nan::To<v8::Object>(value).ToLocalChecked());
    if (!result->flush()) return false;
    self->instance.rect = result->instance;
  }
  return true;
}

NAN_METHOD(_VkClearRect::New) {
  if (info.IsConstructCall()) {
    _VkClearRect* self = new _VkClearRect();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("rect").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("baseArrayLayer").ToLocalChecked();
      v8::Local<v8::String> sAccess2 = Nan::New("layerCount").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      if (obj->Has(sAccess2)) info.This()->Set(sAccess2, obj->Get(sAccess2));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkClearRect constructor cannot be invoked without 'new'");
  }
};

// rect
NAN_GETTER(_VkClearRect::Getrect) {
  _VkClearRect *self = Nan::ObjectWrap::Unwrap<_VkClearRect>(info.This());
  if (self->rect.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->rect);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkClearRect::Setrect) {
  _VkClearRect *self = Nan::ObjectWrap::Unwrap<_VkClearRect>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkRect2D::constructor)->HasInstance(obj)) {
      self->rect.Reset<v8::Object>(value.As<v8::Object>());
      _VkRect2D* inst = Nan::ObjectWrap::Unwrap<_VkRect2D>(obj);
      inst->flush();
      self->instance.rect = inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkClearRect.rect", "[object VkRect2D]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->rect.Reset();
    memset(&self->instance.rect, 0, sizeof(VkRect2D));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearRect.rect", "[object VkRect2D]");
  
    return;
  }
}// baseArrayLayer
NAN_GETTER(_VkClearRect::GetbaseArrayLayer) {
  _VkClearRect *self = Nan::ObjectWrap::Unwrap<_VkClearRect>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.baseArrayLayer));
}NAN_SETTER(_VkClearRect::SetbaseArrayLayer) {
  _VkClearRect *self = Nan::ObjectWrap::Unwrap<_VkClearRect>(info.This());
  if (value->IsNumber()) {
    self->instance.baseArrayLayer = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearRect.baseArrayLayer", "Number");
  
    return;
  }
}// layerCount
NAN_GETTER(_VkClearRect::GetlayerCount) {
  _VkClearRect *self = Nan::ObjectWrap::Unwrap<_VkClearRect>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.layerCount));
}NAN_SETTER(_VkClearRect::SetlayerCount) {
  _VkClearRect *self = Nan::ObjectWrap::Unwrap<_VkClearRect>(info.This());
  if (value->IsNumber()) {
    self->instance.layerCount = static_cast<uint32_t>(Nan::To<int64_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkClearRect.layerCount", "Number");
  
    return;
  }
}
/** ## END VkClearRect ## **/

/** ## BEGIN VkBaseInStructure ## **/

class _VkBaseInStructure: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pNext;
      static NAN_GETTER(GetpNext);
    static NAN_SETTER(SetpNext);
    

    // real instance
    VkBaseInStructure instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBaseInStructure();
    ~_VkBaseInStructure();

};

/*
#include "index.h"
#include "VkBaseInStructure.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBaseInStructure::constructor;

_VkBaseInStructure::_VkBaseInStructure() {
  
  
}

_VkBaseInStructure::~_VkBaseInStructure() {
  //printf("VkBaseInStructure deconstructed!!\n");
  
  
  pNext.Reset();
  
}

void _VkBaseInStructure::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBaseInStructure::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBaseInStructure").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("pNext").ToLocalChecked(), GetpNext, SetpNext, ctor);
  Nan::Set(target, Nan::New("VkBaseInStructure").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBaseInStructure::flush() {
  _VkBaseInStructure *self = this;
  
  return true;
}

NAN_METHOD(_VkBaseInStructure::New) {
  if (info.IsConstructCall()) {
    _VkBaseInStructure* self = new _VkBaseInStructure();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("pNext").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBaseInStructure constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBaseInStructure::GetsType) {
  _VkBaseInStructure *self = Nan::ObjectWrap::Unwrap<_VkBaseInStructure>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBaseInStructure::SetsType) {
  _VkBaseInStructure *self = Nan::ObjectWrap::Unwrap<_VkBaseInStructure>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBaseInStructure.sType", "Number");
  
    return;
  }
}// pNext
NAN_GETTER(_VkBaseInStructure::GetpNext) {
  _VkBaseInStructure *self = Nan::ObjectWrap::Unwrap<_VkBaseInStructure>(info.This());
  if (self->pNext.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pNext);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBaseInStructure::SetpNext) {
  _VkBaseInStructure *self = Nan::ObjectWrap::Unwrap<_VkBaseInStructure>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBaseInStructure::constructor)->HasInstance(obj)) {
      self->pNext.Reset<v8::Object>(value.As<v8::Object>());
      _VkBaseInStructure* inst = Nan::ObjectWrap::Unwrap<_VkBaseInStructure>(obj);
      inst->flush();
      self->instance.pNext = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBaseInStructure.pNext", "[object VkBaseInStructure]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pNext.Reset();
    self->instance.pNext = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBaseInStructure.pNext", "[object VkBaseInStructure]");
  
    return;
  }
}
/** ## END VkBaseInStructure ## **/

/** ## BEGIN VkBaseOutStructure ## **/

class _VkBaseOutStructure: public Nan::ObjectWrap {

  public:
    // #methods
    static NAN_METHOD(New);
    // #accessors
    static NAN_GETTER(GetsType);
    static NAN_SETTER(SetsType);
    
      Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>> pNext;
      static NAN_GETTER(GetpNext);
    static NAN_SETTER(SetpNext);
    

    // real instance
    VkBaseOutStructure instance = {};

    static Nan::Persistent<v8::FunctionTemplate> constructor;
    static void Initialize(v8::Local<v8::Object> exports);
    bool flush(void);

  private:

    _VkBaseOutStructure();
    ~_VkBaseOutStructure();

};

/*
#include "index.h"
#include "VkBaseOutStructure.h"
*/
Nan::Persistent<v8::FunctionTemplate> _VkBaseOutStructure::constructor;

_VkBaseOutStructure::_VkBaseOutStructure() {
  
  
}

_VkBaseOutStructure::~_VkBaseOutStructure() {
  //printf("VkBaseOutStructure deconstructed!!\n");
  
  
  pNext.Reset();
  
}

void _VkBaseOutStructure::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
  Nan::HandleScope scope;

  // constructor
  v8::Local<v8::FunctionTemplate> ctor = Nan::New<v8::FunctionTemplate>(_VkBaseOutStructure::New);
  constructor.Reset(ctor);
  ctor->InstanceTemplate()->SetInternalFieldCount(1);
  ctor->SetClassName(Nan::New("VkBaseOutStructure").ToLocalChecked());

  // prototype
  v8::Local<v8::ObjectTemplate> proto = ctor->PrototypeTemplate();
  
  SetPrototypeAccessor(proto, Nan::New("sType").ToLocalChecked(), GetsType, SetsType, ctor);
  SetPrototypeAccessor(proto, Nan::New("pNext").ToLocalChecked(), GetpNext, SetpNext, ctor);
  Nan::Set(target, Nan::New("VkBaseOutStructure").ToLocalChecked(), ctor->GetFunction());
}

bool _VkBaseOutStructure::flush() {
  _VkBaseOutStructure *self = this;
  
  return true;
}

NAN_METHOD(_VkBaseOutStructure::New) {
  if (info.IsConstructCall()) {
    _VkBaseOutStructure* self = new _VkBaseOutStructure();
    self->Wrap(info.Holder());
    
    if (info[0]->IsObject()) {
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(info[0]).ToLocalChecked();
      v8::Local<v8::String> sAccess0 = Nan::New("sType").ToLocalChecked();
      v8::Local<v8::String> sAccess1 = Nan::New("pNext").ToLocalChecked();
      if (obj->Has(sAccess0)) info.This()->Set(sAccess0, obj->Get(sAccess0));
      if (obj->Has(sAccess1)) info.This()->Set(sAccess1, obj->Get(sAccess1));
      
    }
    
    info.GetReturnValue().Set(info.Holder());
  } else {
    Nan::ThrowError("VkBaseOutStructure constructor cannot be invoked without 'new'");
  }
};

// sType
NAN_GETTER(_VkBaseOutStructure::GetsType) {
  _VkBaseOutStructure *self = Nan::ObjectWrap::Unwrap<_VkBaseOutStructure>(info.This());
  info.GetReturnValue().Set(Nan::New<v8::Number>(self->instance.sType));
}NAN_SETTER(_VkBaseOutStructure::SetsType) {
  _VkBaseOutStructure *self = Nan::ObjectWrap::Unwrap<_VkBaseOutStructure>(info.This());
  if (value->IsNumber()) {
    self->instance.sType = static_cast<VkStructureType>(Nan::To<int32_t>(value).FromMaybe(0));
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBaseOutStructure.sType", "Number");
  
    return;
  }
}// pNext
NAN_GETTER(_VkBaseOutStructure::GetpNext) {
  _VkBaseOutStructure *self = Nan::ObjectWrap::Unwrap<_VkBaseOutStructure>(info.This());
  if (self->pNext.IsEmpty()) {
    info.GetReturnValue().SetNull();
  } else {
    v8::Local<v8::Object> obj = Nan::New(self->pNext);
    info.GetReturnValue().Set(obj);
  }
}NAN_SETTER(_VkBaseOutStructure::SetpNext) {
  _VkBaseOutStructure *self = Nan::ObjectWrap::Unwrap<_VkBaseOutStructure>(info.This());
  // js
  if (!value->IsNull()) {
    v8::Local<v8::Object> obj = Nan::To<v8::Object>(value).ToLocalChecked();
    if (Nan::New(_VkBaseOutStructure::constructor)->HasInstance(obj)) {
      self->pNext.Reset<v8::Object>(value.As<v8::Object>());
      _VkBaseOutStructure* inst = Nan::ObjectWrap::Unwrap<_VkBaseOutStructure>(obj);
      inst->flush();
      self->instance.pNext = &inst->instance;
    } else {
      
    NanInvalidStructMemberTypeError(value, "VkBaseOutStructure.pNext", "[object VkBaseOutStructure]");
  
      return;
    }
  } else if (value->IsNull()) {
    self->pNext.Reset();
    self->instance.pNext = nullptr;
  } else {
    
    NanInvalidStructMemberTypeError(value, "VkBaseOutStructure.pNext", "[object VkBaseOutStructure]");
  
    return;
  }
}
/** ## END VkBaseOutStructure ## **/
