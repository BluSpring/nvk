/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY node-vulkan v0.0.7
 */
#ifndef __VK_CALLS_H__
#define __VK_CALLS_H__

#include <nan.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "utils.h"
#include "index.h"

#include <map>
#include <string>

void _vkCreateInstance(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstanceCreateInfo* obj0;
  VkInstanceCreateInfo *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = nullptr;
  }


  _VkInstance* obj2;
  VkInstance *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkInstance>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateInstance(
    $p0,
    nullptr,
    $p2
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEnumeratePhysicalDevices(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkInstance>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj1;
  uint32_t $p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::To<v8::Object>(info[1]).ToLocalChecked();
    v8::Local<v8::Value> val = obj1->Get(Nan::New("$").ToLocalChecked());
    $p1 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  VkPhysicalDevice *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = createArrayOfV8Objects<VkPhysicalDevice, _VkPhysicalDevice>(info[2]);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pPhysicalDevices'");
  }

  int32_t out = vkEnumeratePhysicalDevices(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2
  );
    obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceProperties* obj1;
  VkPhysicalDeviceProperties *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    // back reflect string
    v8::Local<v8::String> str1 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), (&obj1->instance)->deviceName);
    obj1->deviceName = Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>>(str1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 16);
    // populate array
    for (unsigned int ii = 0; ii < 16; ++ii) {
      arr1->Set(ii, Nan::New((&obj1->instance)->pipelineCacheUUID[ii]));
    };
    obj1->pipelineCacheUUID = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkPhysicalDeviceLimits::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkPhysicalDeviceLimits* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(inst);
    obj1->limits = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.limits, sizeof(VkPhysicalDeviceLimits));
    
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxComputeWorkGroupCount[ii]));
    };
    unwrapped6->maxComputeWorkGroupCount = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxComputeWorkGroupSize[ii]));
    };
    unwrapped6->maxComputeWorkGroupSize = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxViewportDimensions[ii]));
    };
    unwrapped6->maxViewportDimensions = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->viewportBoundsRange[ii]));
    };
    unwrapped6->viewportBoundsRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->pointSizeRange[ii]));
    };
    unwrapped6->pointSizeRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->lineWidthRange[ii]));
    };
    unwrapped6->lineWidthRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkPhysicalDeviceSparseProperties::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkPhysicalDeviceSparseProperties* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(inst);
    obj1->sparseProperties = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.sparseProperties, sizeof(VkPhysicalDeviceSparseProperties));
    
  }
      
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceQueueFamilyProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj1;
  uint32_t $p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::To<v8::Object>(info[1]).ToLocalChecked();
    v8::Local<v8::Value> val = obj1->Get(Nan::New("$").ToLocalChecked());
    $p1 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  VkQueueFamilyProperties *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = copyArrayOfV8Objects<VkQueueFamilyProperties, _VkQueueFamilyProperties>(info[2]);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pQueueFamilyProperties'");
  }

  vkGetPhysicalDeviceQueueFamilyProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2
  );
    obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  if (info[2]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(item).ToLocalChecked();
      _VkQueueFamilyProperties* result = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(obj);
      VkQueueFamilyProperties *instance = &result->instance;
      VkQueueFamilyProperties *copy = &$p2[ii];
      
      instance->minImageTransferGranularity = copy->minImageTransferGranularity;
      if (&copy->minImageTransferGranularity != nullptr) {
        
  v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent3D::constructor)).ToLocalChecked();
  v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
  _VkExtent3D* unwrapped = Nan::ObjectWrap::Unwrap<_VkExtent3D>(inst);
        result->minImageTransferGranularity = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
        unwrapped->instance = copy->minImageTransferGranularity;
      }
    };
  }
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceMemoryProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceMemoryProperties* obj1;
  VkPhysicalDeviceMemoryProperties *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceMemoryProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    // back reflect array
    unsigned int len = obj1->instance.memoryTypeCount;
    v8::Local<v8::Array> arr = v8::Array::New(v8::Isolate::GetCurrent(), len);
    // populate array
    for (unsigned int ii = 0; ii < len; ++ii) {
      v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkMemoryType::constructor)).ToLocalChecked();
      v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
      _VkMemoryType* unwrapped = Nan::ObjectWrap::Unwrap<_VkMemoryType>(inst);
      memcpy(&unwrapped->instance, &obj1->instance.memoryTypes[ii], sizeof(VkMemoryType));
      arr->Set(ii, inst);
    };
    obj1->memoryTypes = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr);
  }
  {
    // back reflect array
    unsigned int len = obj1->instance.memoryHeapCount;
    v8::Local<v8::Array> arr = v8::Array::New(v8::Isolate::GetCurrent(), len);
    // populate array
    for (unsigned int ii = 0; ii < len; ++ii) {
      v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkMemoryHeap::constructor)).ToLocalChecked();
      v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
      _VkMemoryHeap* unwrapped = Nan::ObjectWrap::Unwrap<_VkMemoryHeap>(inst);
      memcpy(&unwrapped->instance, &obj1->instance.memoryHeaps[ii], sizeof(VkMemoryHeap));
      arr->Set(ii, inst);
    };
    obj1->memoryHeaps = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr);
  }
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceFeatures(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceFeatures* obj1;
  VkPhysicalDeviceFeatures *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceFeatures(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateDevice(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDeviceCreateInfo* obj1;
  VkDeviceCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDevice* obj3;
  VkDevice *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateDevice(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEnumerateInstanceLayerProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  v8::Local<v8::Object> obj0;
  uint32_t $p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::To<v8::Object>(info[0]).ToLocalChecked();
    v8::Local<v8::Value> val = obj0->Get(Nan::New("$").ToLocalChecked());
    $p0 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  VkLayerProperties *$p1 = nullptr;

  if (info[1]->IsArray()) {

    $p1 = copyArrayOfV8Objects<VkLayerProperties, _VkLayerProperties>(info[1]);
  } else if (!info[1]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 2 'pProperties'");
  }

  int32_t out = vkEnumerateInstanceLayerProperties(
    &$p0,
    $p1
  );
    obj0->Set(Nan::New("$").ToLocalChecked(), Nan::New($p0));
  if (info[1]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[1]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(item).ToLocalChecked();
      _VkLayerProperties* result = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(obj);
      VkLayerProperties *instance = &result->instance;
      VkLayerProperties *copy = &$p1[ii];
      
      {
        std::string stri(copy->layerName);
        v8::Local<v8::String> strv8 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), stri.c_str());
        Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(strv8).ToLocalChecked());
        result->layerName = str;
        strcpy(instance->layerName, copy->layerName);
      }
      {
        std::string stri(copy->description);
        v8::Local<v8::String> strv8 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), stri.c_str());
        Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(strv8).ToLocalChecked());
        result->description = str;
        strcpy(instance->description, copy->description);
      }
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetDeviceQueue(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  _VkQueue* obj3;
  VkQueue *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkQueue>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  vkGetDeviceQueue(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkQueueSubmit(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkQueue>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  VkSubmitInfo *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = copyArrayOfV8Objects<VkSubmitInfo, _VkSubmitInfo>(info[2]);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pSubmits'");
  }


  _VkFence* obj3;
  VkFence *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkFence>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkQueueSubmit(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    info[3]->IsNull() ? VK_NULL_HANDLE : *$p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkQueueWaitIdle(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkQueue>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  int32_t out = vkQueueWaitIdle(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDeviceWaitIdle(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  int32_t out = vkDeviceWaitIdle(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkAllocateMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkMemoryAllocateInfo* obj1;
  VkMemoryAllocateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDeviceMemory* obj3;
  VkDeviceMemory *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkAllocateMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkMapMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint64_t $p2 = static_cast<uint64_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  uint64_t $p3 = static_cast<uint64_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  int32_t $p4 = static_cast<int32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  v8::Local<v8::Object> obj5 = Nan::To<v8::Object>(info[5]).ToLocalChecked();
  void *$p5;
  int32_t out = vkMapMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    &$p5
  );
  v8::Local<v8::BigInt> ptr5 = v8::BigInt::New(v8::Isolate::GetCurrent(), (int64_t)$p5);
  obj5->Set(Nan::New("$").ToLocalChecked(), ptr5);
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkUnmapMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }
  vkUnmapMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetBufferMemoryRequirements(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkMemoryRequirements* obj2;
  VkMemoryRequirements *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }
  vkGetBufferMemoryRequirements(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkBindBufferMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkDeviceMemory* obj2;
  VkDeviceMemory *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  uint64_t $p3 = static_cast<uint64_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));
  int32_t out = vkBindBufferMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetImageMemoryRequirements(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkMemoryRequirements* obj2;
  VkMemoryRequirements *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }
  vkGetImageMemoryRequirements(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkBindImageMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkDeviceMemory* obj2;
  VkDeviceMemory *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  uint64_t $p3 = static_cast<uint64_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));
  int32_t out = vkBindImageMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateSemaphore(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSemaphoreCreateInfo* obj1;
  VkSemaphoreCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSemaphoreCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkSemaphore* obj3;
  VkSemaphore *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSemaphore>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateSemaphore(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBufferCreateInfo* obj1;
  VkBufferCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateImage(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImageCreateInfo* obj1;
  VkImageCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkImage* obj3;
  VkImage *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateImage(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetImageSubresourceLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkImageSubresource* obj2;
  VkImageSubresource *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }

  _VkSubresourceLayout* obj3;
  VkSubresourceLayout *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSubresourceLayout>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = nullptr;
  }
  vkGetImageSubresourceLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateImageView(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImageViewCreateInfo* obj1;
  VkImageViewCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkImageView* obj3;
  VkImageView *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkImageView>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateImageView(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyImageView(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImageView* obj1;
  VkImageView *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImageView>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyImageView(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateShaderModule(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkShaderModuleCreateInfo* obj1;
  VkShaderModuleCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkShaderModule* obj3;
  VkShaderModule *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkShaderModule>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateShaderModule(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyShaderModule(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkShaderModule* obj1;
  VkShaderModule *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkShaderModule>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyShaderModule(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateGraphicsPipelines(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineCache>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  VkGraphicsPipelineCreateInfo *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = copyArrayOfV8Objects<VkGraphicsPipelineCreateInfo, _VkGraphicsPipelineCreateInfo>(info[3]);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pCreateInfos'");
  }



  VkPipeline *$p5 = nullptr;

  if (info[5]->IsArray()) {

    $p5 = createArrayOfV8Handles<VkPipeline, _VkPipeline>(info[5]);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pPipelines'");
  }

  int32_t out = vkCreateGraphicsPipelines(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    nullptr,
    $p5
  );
  if (info[5]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkPipeline* target = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $p5[ii];
    };
    delete[] $p5;
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyPipeline(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipeline* obj1;
  VkPipeline *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyPipeline(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreatePipelineLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineLayoutCreateInfo* obj1;
  VkPipelineLayoutCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkPipelineLayout* obj3;
  VkPipelineLayout *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreatePipelineLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyPipelineLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineLayout* obj1;
  VkPipelineLayout *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyPipelineLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateSampler(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSamplerCreateInfo* obj1;
  VkSamplerCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkSampler* obj3;
  VkSampler *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSampler>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateSampler(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateDescriptorSetLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorSetLayoutCreateInfo* obj1;
  VkDescriptorSetLayoutCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDescriptorSetLayout* obj3;
  VkDescriptorSetLayout *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayout>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateDescriptorSetLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateDescriptorPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorPoolCreateInfo* obj1;
  VkDescriptorPoolCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDescriptorPool* obj3;
  VkDescriptorPool *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDescriptorPool>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateDescriptorPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkAllocateDescriptorSets(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorSetAllocateInfo* obj1;
  VkDescriptorSetAllocateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }

  VkDescriptorSet *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = createArrayOfV8Handles<VkDescriptorSet, _VkDescriptorSet>(info[2]);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pDescriptorSets'");
  }

  int32_t out = vkAllocateDescriptorSets(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkDescriptorSet* target = Nan::ObjectWrap::Unwrap<_VkDescriptorSet>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $p2[ii];
    };
    delete[] $p2;
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkUpdateDescriptorSets(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  VkWriteDescriptorSet *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = copyArrayOfV8Objects<VkWriteDescriptorSet, _VkWriteDescriptorSet>(info[2]);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pDescriptorWrites'");
  }


  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  VkCopyDescriptorSet *$p4 = nullptr;

  if (info[4]->IsArray()) {

    $p4 = copyArrayOfV8Objects<VkCopyDescriptorSet, _VkCopyDescriptorSet>(info[4]);
  } else if (!info[4]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 5 'pDescriptorCopies'");
  }

  vkUpdateDescriptorSets(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateFramebuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkFramebufferCreateInfo* obj1;
  VkFramebufferCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkFramebuffer* obj3;
  VkFramebuffer *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkFramebuffer>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateFramebuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyFramebuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkFramebuffer* obj1;
  VkFramebuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkFramebuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyFramebuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkRenderPassCreateInfo* obj1;
  VkRenderPassCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkRenderPass* obj3;
  VkRenderPass *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkRenderPass>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkRenderPass* obj1;
  VkRenderPass *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPass>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateCommandPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandPoolCreateInfo* obj1;
  VkCommandPoolCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkCommandPool* obj3;
  VkCommandPool *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkCommandPool>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateCommandPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyCommandPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandPool* obj1;
  VkCommandPool *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandPool>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyCommandPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkAllocateCommandBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandBufferAllocateInfo* obj1;
  VkCommandBufferAllocateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }

  VkCommandBuffer *$p2 = nullptr;

  if (info[2]->IsArray()) {

    $p2 = createArrayOfV8Handles<VkCommandBuffer, _VkCommandBuffer>(info[2]);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pCommandBuffers'");
  }

  int32_t out = vkAllocateCommandBuffers(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkCommandBuffer* target = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $p2[ii];
    };
    delete[] $p2;
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkFreeCommandBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandPool* obj1;
  VkCommandPool *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandPool>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  VkCommandBuffer *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = createArrayOfV8Handles<VkCommandBuffer, _VkCommandBuffer>(info[3]);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pCommandBuffers'");
  }

  vkFreeCommandBuffers(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkBeginCommandBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandBufferBeginInfo* obj1;
  VkCommandBufferBeginInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  int32_t out = vkBeginCommandBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEndCommandBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  int32_t out = vkEndCommandBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCmdBindPipeline(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  _VkPipeline* obj2;
  VkPipeline *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }
  vkCmdBindPipeline(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdSetViewport(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  VkViewport *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = copyArrayOfV8Objects<VkViewport, _VkViewport>(info[3]);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pViewports'");
  }

  vkCmdSetViewport(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdSetScissor(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  VkRect2D *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = copyArrayOfV8Objects<VkRect2D, _VkRect2D>(info[3]);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pScissors'");
  }

  vkCmdSetScissor(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBindDescriptorSets(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  _VkPipelineLayout* obj2;
  VkPipelineLayout *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  uint32_t $p4 = static_cast<uint32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  VkDescriptorSet *$p5 = nullptr;

  if (info[5]->IsArray()) {

    $p5 = createArrayOfV8Handles<VkDescriptorSet, _VkDescriptorSet>(info[5]);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pDescriptorSets'");
  }


  uint32_t $p6 = static_cast<uint32_t>(Nan::To<int64_t>(info[6]).FromMaybe(0));

  std::shared_ptr<std::vector<uint32_t>> $p7 = nullptr;

  if (info[7]->IsArray()) {

    std::vector<uint32_t> data = createArrayOfV8Numbers<uint32_t>(info[7]);
    $p7 = std::make_shared<std::vector<uint32_t>>(data);
  } else if (!info[7]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 8 'pDynamicOffsets'");
  }

  vkCmdBindDescriptorSets(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5,
    $p6,
    $p7 ? $p7.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBindIndexBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint64_t $p2 = static_cast<uint64_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  VkIndexType $p3 = static_cast<VkIndexType>(Nan::To<int64_t>(info[3]).FromMaybe(0));
  vkCmdBindIndexBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBindVertexBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  VkBuffer *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = createArrayOfV8Handles<VkBuffer, _VkBuffer>(info[3]);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pBuffers'");
  }


  std::shared_ptr<std::vector<VkDeviceSize>> $p4 = nullptr;

  if (info[4]->IsArray()) {

    std::vector<VkDeviceSize> data = createArrayOfV8Numbers<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<std::vector<VkDeviceSize>>(data);
  } else if (!info[4]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 5 'pOffsets'");
  }

  vkCmdBindVertexBuffers(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4 ? $p4.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdDraw(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  uint32_t $p4 = static_cast<uint32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));
  vkCmdDraw(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdDrawIndexed(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  int32_t $p4 = static_cast<int32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  uint32_t $p5 = static_cast<uint32_t>(Nan::To<int64_t>(info[5]).FromMaybe(0));
  vkCmdDrawIndexed(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4,
    $p5
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdCopyBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj2;
  VkBuffer *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  VkBufferCopy *$p4 = nullptr;

  if (info[4]->IsArray()) {

    $p4 = copyArrayOfV8Objects<VkBufferCopy, _VkBufferCopy>(info[4]);
  } else if (!info[4]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 5 'pRegions'");
  }

  vkCmdCopyBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdCopyBufferToImage(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkImage* obj2;
  VkImage *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  VkImageLayout $p3 = static_cast<VkImageLayout>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  uint32_t $p4 = static_cast<uint32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  VkBufferImageCopy *$p5 = nullptr;

  if (info[5]->IsArray()) {

    $p5 = copyArrayOfV8Objects<VkBufferImageCopy, _VkBufferImageCopy>(info[5]);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pRegions'");
  }

  vkCmdCopyBufferToImage(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdPipelineBarrier(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  int32_t $p1 = static_cast<int32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  int32_t $p2 = static_cast<int32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  int32_t $p3 = static_cast<int32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  uint32_t $p4 = static_cast<uint32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  VkMemoryBarrier *$p5 = nullptr;

  if (info[5]->IsArray()) {

    $p5 = copyArrayOfV8Objects<VkMemoryBarrier, _VkMemoryBarrier>(info[5]);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pMemoryBarriers'");
  }


  uint32_t $p6 = static_cast<uint32_t>(Nan::To<int64_t>(info[6]).FromMaybe(0));

  VkBufferMemoryBarrier *$p7 = nullptr;

  if (info[7]->IsArray()) {

    $p7 = copyArrayOfV8Objects<VkBufferMemoryBarrier, _VkBufferMemoryBarrier>(info[7]);
  } else if (!info[7]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 8 'pBufferMemoryBarriers'");
  }


  uint32_t $p8 = static_cast<uint32_t>(Nan::To<int64_t>(info[8]).FromMaybe(0));

  VkImageMemoryBarrier *$p9 = nullptr;

  if (info[9]->IsArray()) {

    $p9 = copyArrayOfV8Objects<VkImageMemoryBarrier, _VkImageMemoryBarrier>(info[9]);
  } else if (!info[9]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 10 'pImageMemoryBarriers'");
  }

  vkCmdPipelineBarrier(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4,
    $p5,
    $p6,
    $p7,
    $p8,
    $p9
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBeginRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkRenderPassBeginInfo* obj1;
  VkRenderPassBeginInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }

  VkSubpassContents $p2 = static_cast<VkSubpassContents>(Nan::To<int64_t>(info[2]).FromMaybe(0));
  vkCmdBeginRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdEndRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  vkCmdEndRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceSurfaceSupportKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  _VkSurfaceKHR* obj2;
  VkSurfaceKHR *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj3;
  uint32_t $p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::To<v8::Object>(info[3]).ToLocalChecked();
    v8::Local<v8::Value> val = obj3->Get(Nan::New("$").ToLocalChecked());
    $p3 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }
  int32_t out = vkGetPhysicalDeviceSurfaceSupportKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    &$p3
  );
    obj3->Set(Nan::New("$").ToLocalChecked(), Nan::New($p3));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceCapabilitiesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkSurfaceCapabilitiesKHR* obj2;
  VkSurfaceCapabilitiesKHR *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }
  int32_t out = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->currentExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.currentExtent, sizeof(VkExtent2D));
    
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->minImageExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.minImageExtent, sizeof(VkExtent2D));
    
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->maxImageExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.maxImageExtent, sizeof(VkExtent2D));
    
  }
      
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceFormatsKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::To<v8::Object>(info[2]).ToLocalChecked();
    v8::Local<v8::Value> val = obj2->Get(Nan::New("$").ToLocalChecked());
    $p2 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  VkSurfaceFormatKHR *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = copyArrayOfV8Objects<VkSurfaceFormatKHR, _VkSurfaceFormatKHR>(info[3]);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pSurfaceFormats'");
  }

  int32_t out = vkGetPhysicalDeviceSurfaceFormatsKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(item).ToLocalChecked();
      _VkSurfaceFormatKHR* result = Nan::ObjectWrap::Unwrap<_VkSurfaceFormatKHR>(obj);
      VkSurfaceFormatKHR *instance = &result->instance;
      VkSurfaceFormatKHR *copy = &$p3[ii];
      
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfacePresentModesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::To<v8::Object>(info[2]).ToLocalChecked();
    v8::Local<v8::Value> val = obj2->Get(Nan::New("$").ToLocalChecked());
    $p2 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  VkPresentModeKHR *$p3 = nullptr;

  if (info[3]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    VkPresentModeKHR * arr3 = new VkPresentModeKHR[array->Length()];
    $p3 = arr3;
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pPresentModes'");
  }

  int32_t out = vkGetPhysicalDeviceSurfacePresentModesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      array->Set(ii, Nan::New($p3[ii]));
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateSwapchainKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainCreateInfoKHR* obj1;
  VkSwapchainCreateInfoKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkSwapchainKHR* obj3;
  VkSwapchainKHR *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateSwapchainKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroySwapchainKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroySwapchainKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetSwapchainImagesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::To<v8::Object>(info[2]).ToLocalChecked();
    v8::Local<v8::Value> val = obj2->Get(Nan::New("$").ToLocalChecked());
    $p2 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  VkImage *$p3 = nullptr;

  if (info[3]->IsArray()) {

    $p3 = createArrayOfV8Handles<VkImage, _VkImage>(info[3]);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pSwapchainImages'");
  }

  int32_t out = vkGetSwapchainImagesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkImage* target = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $p3[ii];
    };
    delete[] $p3;
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkAcquireNextImageKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint64_t $p2 = static_cast<uint64_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  _VkSemaphore* obj3;
  VkSemaphore *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSemaphore>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }

  _VkFence* obj4;
  VkFence *$p4;
  if (!(info[4]->IsNull())) {
    obj4 = Nan::ObjectWrap::Unwrap<_VkFence>(Nan::To<v8::Object>(info[4]).ToLocalChecked());
    $p4 = &obj4->instance;
  } else {
    $p4 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj5;
  uint32_t $p5;
  if (!(info[5]->IsNull())) {
    obj5 = Nan::To<v8::Object>(info[5]).ToLocalChecked();
    v8::Local<v8::Value> val = obj5->Get(Nan::New("$").ToLocalChecked());
    $p5 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }
  int32_t out = vkAcquireNextImageKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3]->IsNull() ? VK_NULL_HANDLE : *$p3,
    info[4]->IsNull() ? VK_NULL_HANDLE : *$p4,
    &$p5
  );
    obj5->Set(Nan::New("$").ToLocalChecked(), Nan::New($p5));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkQueuePresentKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkQueue>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPresentInfoKHR* obj1;
  VkPresentInfoKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  int32_t out = vkQueuePresentKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};



#endif
