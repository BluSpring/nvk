/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY node-vulkan v0.0.9
 */
#ifndef __VK_CALLS_H__
#define __VK_CALLS_H__

#include <nan.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "utils.h"
#include "index.h"

#include <map>
#include <string>

void _vkCreateInstance(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstanceCreateInfo* obj0;
  VkInstanceCreateInfo *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkInstanceCreateInfo>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    if (!obj0->flush()) return;
    $p0 = &obj0->instance;
  } else {
    $p0 = nullptr;
  }


  _VkInstance* obj2;
  VkInstance *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkInstance>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateInstance(
    $p0,
    nullptr,
    $p2
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyInstance(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkInstance>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  vkDestroyInstance(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkEnumeratePhysicalDevices(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkInstance>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj1;
  uint32_t $p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::To<v8::Object>(info[1]).ToLocalChecked();
    v8::Local<v8::Value> val = obj1->Get(Nan::New("$").ToLocalChecked());
    $p1 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  std::shared_ptr<std::vector<VkPhysicalDevice>> $p2 = nullptr;

  if (info[2]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    std::vector<VkPhysicalDevice> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkPhysicalDevice* result = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkPhysicalDevice>>(data);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pPhysicalDevices'");
  }

  int32_t out = vkEnumeratePhysicalDevices(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? $p2.get()->data() : nullptr
  );
    obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  if (info[2]->IsArray()) {
    VkPhysicalDevice* $pdata = $p2.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkPhysicalDevice* target = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $pdata[ii];
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceProperties* obj1;
  VkPhysicalDeviceProperties *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceProperties>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    // back reflect string
    v8::Local<v8::String> str1 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), (&obj1->instance)->deviceName);
    obj1->deviceName = Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>>(str1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 16);
    // populate array
    for (unsigned int ii = 0; ii < 16; ++ii) {
      arr1->Set(ii, Nan::New((&obj1->instance)->pipelineCacheUUID[ii]));
    };
    obj1->pipelineCacheUUID = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkPhysicalDeviceLimits::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkPhysicalDeviceLimits* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceLimits>(inst);
    obj1->limits = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.limits, sizeof(VkPhysicalDeviceLimits));
    
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxComputeWorkGroupCount[ii]));
    };
    unwrapped6->maxComputeWorkGroupCount = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 3);
    // populate array
    for (unsigned int ii = 0; ii < 3; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxComputeWorkGroupSize[ii]));
    };
    unwrapped6->maxComputeWorkGroupSize = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->maxViewportDimensions[ii]));
    };
    unwrapped6->maxViewportDimensions = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->viewportBoundsRange[ii]));
    };
    unwrapped6->viewportBoundsRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->pointSizeRange[ii]));
    };
    unwrapped6->pointSizeRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  {
    // back reflect array
    v8::Local<v8::Array> arr1 = v8::Array::New(v8::Isolate::GetCurrent(), 2);
    // populate array
    for (unsigned int ii = 0; ii < 2; ++ii) {
      arr1->Set(ii, Nan::New((&unwrapped6->instance)->lineWidthRange[ii]));
    };
    unwrapped6->lineWidthRange = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr1);
  }
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkPhysicalDeviceSparseProperties::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkPhysicalDeviceSparseProperties* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceSparseProperties>(inst);
    obj1->sparseProperties = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj1->instance.sparseProperties, sizeof(VkPhysicalDeviceSparseProperties));
    
  }
      
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceQueueFamilyProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj1;
  uint32_t $p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::To<v8::Object>(info[1]).ToLocalChecked();
    v8::Local<v8::Value> val = obj1->Get(Nan::New("$").ToLocalChecked());
    $p1 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  std::shared_ptr<std::vector<VkQueueFamilyProperties>> $p2 = nullptr;

  if (info[2]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkQueueFamilyProperties* result = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    std::vector<VkQueueFamilyProperties> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkQueueFamilyProperties* result = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkQueueFamilyProperties>>(data);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pQueueFamilyProperties'");
  }

  vkGetPhysicalDeviceQueueFamilyProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? $p2.get()->data() : nullptr
  );
    obj1->Set(Nan::New("$").ToLocalChecked(), Nan::New($p1));
  if (info[2]->IsArray()) {
    VkQueueFamilyProperties* $pdata = $p2.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(item).ToLocalChecked();
      _VkQueueFamilyProperties* result = Nan::ObjectWrap::Unwrap<_VkQueueFamilyProperties>(obj);
      VkQueueFamilyProperties *instance = &result->instance;
      VkQueueFamilyProperties *copy = &$pdata[ii];
      
      instance->minImageTransferGranularity = copy->minImageTransferGranularity;
      if (&copy->minImageTransferGranularity != nullptr) {
        
  v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent3D::constructor)).ToLocalChecked();
  v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
  _VkExtent3D* unwrapped = Nan::ObjectWrap::Unwrap<_VkExtent3D>(inst);
        result->minImageTransferGranularity = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
        unwrapped->instance = copy->minImageTransferGranularity;
      }
    };
  }
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceMemoryProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceMemoryProperties* obj1;
  VkPhysicalDeviceMemoryProperties *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceMemoryProperties>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceMemoryProperties(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  {
    // back reflect array
    unsigned int len = obj1->instance.memoryTypeCount;
    v8::Local<v8::Array> arr = v8::Array::New(v8::Isolate::GetCurrent(), len);
    // populate array
    for (unsigned int ii = 0; ii < len; ++ii) {
      v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkMemoryType::constructor)).ToLocalChecked();
      v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
      _VkMemoryType* unwrapped = Nan::ObjectWrap::Unwrap<_VkMemoryType>(inst);
      memcpy(&unwrapped->instance, &obj1->instance.memoryTypes[ii], sizeof(VkMemoryType));
      arr->Set(ii, inst);
    };
    obj1->memoryTypes = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr);
  }
  {
    // back reflect array
    unsigned int len = obj1->instance.memoryHeapCount;
    v8::Local<v8::Array> arr = v8::Array::New(v8::Isolate::GetCurrent(), len);
    // populate array
    for (unsigned int ii = 0; ii < len; ++ii) {
      v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkMemoryHeap::constructor)).ToLocalChecked();
      v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
      _VkMemoryHeap* unwrapped = Nan::ObjectWrap::Unwrap<_VkMemoryHeap>(inst);
      memcpy(&unwrapped->instance, &obj1->instance.memoryHeaps[ii], sizeof(VkMemoryHeap));
      arr->Set(ii, inst);
    };
    obj1->memoryHeaps = Nan::Persistent<v8::Array, v8::CopyablePersistentTraits<v8::Array>>(arr);
  }
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceFeatures(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPhysicalDeviceFeatures* obj1;
  VkPhysicalDeviceFeatures *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPhysicalDeviceFeatures>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  vkGetPhysicalDeviceFeatures(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateDevice(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDeviceCreateInfo* obj1;
  VkDeviceCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDeviceCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDevice* obj3;
  VkDevice *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateDevice(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyDevice(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  vkDestroyDevice(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkEnumerateInstanceLayerProperties(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  v8::Local<v8::Object> obj0;
  uint32_t $p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::To<v8::Object>(info[0]).ToLocalChecked();
    v8::Local<v8::Value> val = obj0->Get(Nan::New("$").ToLocalChecked());
    $p0 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  std::shared_ptr<std::vector<VkLayerProperties>> $p1 = nullptr;

  if (info[1]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[1]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkLayerProperties* result = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[1]);
    std::vector<VkLayerProperties> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkLayerProperties* result = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p1 = std::make_shared<std::vector<VkLayerProperties>>(data);
  } else if (!info[1]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 2 'pProperties'");
  }

  int32_t out = vkEnumerateInstanceLayerProperties(
    &$p0,
    $p1 ? $p1.get()->data() : nullptr
  );
    obj0->Set(Nan::New("$").ToLocalChecked(), Nan::New($p0));
  if (info[1]->IsArray()) {
    VkLayerProperties* $pdata = $p1.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[1]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(item).ToLocalChecked();
      _VkLayerProperties* result = Nan::ObjectWrap::Unwrap<_VkLayerProperties>(obj);
      VkLayerProperties *instance = &result->instance;
      VkLayerProperties *copy = &$pdata[ii];
      
      {
        std::string stri(copy->layerName);
        v8::Local<v8::String> strv8 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), stri.c_str());
        Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(strv8).ToLocalChecked());
        result->layerName = str;
        strcpy(instance->layerName, copy->layerName);
      }
      {
        std::string stri(copy->description);
        v8::Local<v8::String> strv8 = v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), stri.c_str());
        Nan::Persistent<v8::String, v8::CopyablePersistentTraits<v8::String>> str(Nan::To<v8::String>(strv8).ToLocalChecked());
        result->description = str;
        strcpy(instance->description, copy->description);
      }
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetDeviceQueue(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  _VkQueue* obj3;
  VkQueue *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkQueue>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  vkGetDeviceQueue(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkQueueSubmit(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkQueue>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  std::shared_ptr<std::vector<VkSubmitInfo>> $p2 = nullptr;

  if (info[2]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkSubmitInfo* result = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    std::vector<VkSubmitInfo> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkSubmitInfo* result = Nan::ObjectWrap::Unwrap<_VkSubmitInfo>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkSubmitInfo>>(data);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pSubmits'");
  }


  _VkFence* obj3;
  VkFence *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkFence>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkQueueSubmit(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? $p2.get()->data() : nullptr,
    info[3]->IsNull() ? VK_NULL_HANDLE : *$p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkQueueWaitIdle(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkQueue>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  int32_t out = vkQueueWaitIdle(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDeviceWaitIdle(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  int32_t out = vkDeviceWaitIdle(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkAllocateMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkMemoryAllocateInfo* obj1;
  VkMemoryAllocateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkMemoryAllocateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDeviceMemory* obj3;
  VkDeviceMemory *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkAllocateMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkMapMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint64_t $p2 = static_cast<uint64_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  uint64_t $p3 = static_cast<uint64_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  int32_t $p4 = static_cast<int32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  v8::Local<v8::Object> obj5 = Nan::To<v8::Object>(info[5]).ToLocalChecked();
  void *$p5;
  int32_t out = vkMapMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    &$p5
  );
  v8::Local<v8::BigInt> ptr5 = v8::BigInt::New(v8::Isolate::GetCurrent(), (int64_t)$p5);
  obj5->Set(Nan::New("$").ToLocalChecked(), ptr5);
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkUnmapMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDeviceMemory* obj1;
  VkDeviceMemory *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }
  vkUnmapMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetBufferMemoryRequirements(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkMemoryRequirements* obj2;
  VkMemoryRequirements *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }
  vkGetBufferMemoryRequirements(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkBindBufferMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkDeviceMemory* obj2;
  VkDeviceMemory *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  uint64_t $p3 = static_cast<uint64_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));
  int32_t out = vkBindBufferMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetImageMemoryRequirements(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkMemoryRequirements* obj2;
  VkMemoryRequirements *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkMemoryRequirements>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }
  vkGetImageMemoryRequirements(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkBindImageMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkDeviceMemory* obj2;
  VkDeviceMemory *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkDeviceMemory>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  uint64_t $p3 = static_cast<uint64_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));
  int32_t out = vkBindImageMemory(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyFence(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkFence* obj1;
  VkFence *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkFence>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyFence(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateSemaphore(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSemaphoreCreateInfo* obj1;
  VkSemaphoreCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSemaphoreCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkSemaphore* obj3;
  VkSemaphore *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSemaphore>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateSemaphore(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroySemaphore(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSemaphore* obj1;
  VkSemaphore *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSemaphore>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroySemaphore(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkDestroyEvent(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkEvent* obj1;
  VkEvent *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkEvent>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyEvent(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkDestroyQueryPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkQueryPool* obj1;
  VkQueryPool *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkQueryPool>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyQueryPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBufferCreateInfo* obj1;
  VkBufferCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBufferCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkBuffer* obj3;
  VkBuffer *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkDestroyBufferView(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBufferView* obj1;
  VkBufferView *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBufferView>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyBufferView(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateImage(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImageCreateInfo* obj1;
  VkImageCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImageCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkImage* obj3;
  VkImage *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateImage(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyImage(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyImage(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetImageSubresourceLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImage* obj1;
  VkImage *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkImageSubresource* obj2;
  VkImageSubresource *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkImageSubresource>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }

  _VkSubresourceLayout* obj3;
  VkSubresourceLayout *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSubresourceLayout>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    if (!obj3->flush()) return;
    $p3 = &obj3->instance;
  } else {
    $p3 = nullptr;
  }
  vkGetImageSubresourceLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateImageView(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImageViewCreateInfo* obj1;
  VkImageViewCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImageViewCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkImageView* obj3;
  VkImageView *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkImageView>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateImageView(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyImageView(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkImageView* obj1;
  VkImageView *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkImageView>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyImageView(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateShaderModule(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkShaderModuleCreateInfo* obj1;
  VkShaderModuleCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkShaderModuleCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkShaderModule* obj3;
  VkShaderModule *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkShaderModule>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateShaderModule(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyShaderModule(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkShaderModule* obj1;
  VkShaderModule *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkShaderModule>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyShaderModule(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkDestroyPipelineCache(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineCache>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyPipelineCache(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateGraphicsPipelines(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineCache>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  std::shared_ptr<std::vector<VkGraphicsPipelineCreateInfo>> $p3 = nullptr;

  if (info[3]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkGraphicsPipelineCreateInfo* result = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    std::vector<VkGraphicsPipelineCreateInfo> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkGraphicsPipelineCreateInfo* result = Nan::ObjectWrap::Unwrap<_VkGraphicsPipelineCreateInfo>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkGraphicsPipelineCreateInfo>>(data);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pCreateInfos'");
  }



  std::shared_ptr<std::vector<VkPipeline>> $p5 = nullptr;

  if (info[5]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    std::vector<VkPipeline> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkPipeline* result = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkPipeline>>(data);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pPipelines'");
  }

  int32_t out = vkCreateGraphicsPipelines(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? $p3.get()->data() : nullptr,
    nullptr,
    $p5 ? $p5.get()->data() : nullptr
  );
  if (info[5]->IsArray()) {
    VkPipeline* $pdata = $p5.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkPipeline* target = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $pdata[ii];
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateComputePipelines(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineCache* obj1;
  VkPipelineCache *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineCache>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  std::shared_ptr<std::vector<VkComputePipelineCreateInfo>> $p3 = nullptr;

  if (info[3]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkComputePipelineCreateInfo* result = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    std::vector<VkComputePipelineCreateInfo> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkComputePipelineCreateInfo* result = Nan::ObjectWrap::Unwrap<_VkComputePipelineCreateInfo>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkComputePipelineCreateInfo>>(data);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pCreateInfos'");
  }



  std::shared_ptr<std::vector<VkPipeline>> $p5 = nullptr;

  if (info[5]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    std::vector<VkPipeline> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkPipeline* result = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkPipeline>>(data);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pPipelines'");
  }

  int32_t out = vkCreateComputePipelines(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? $p3.get()->data() : nullptr,
    nullptr,
    $p5 ? $p5.get()->data() : nullptr
  );
  if (info[5]->IsArray()) {
    VkPipeline* $pdata = $p5.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkPipeline* target = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $pdata[ii];
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyPipeline(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipeline* obj1;
  VkPipeline *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyPipeline(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreatePipelineLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineLayoutCreateInfo* obj1;
  VkPipelineLayoutCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineLayoutCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkPipelineLayout* obj3;
  VkPipelineLayout *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreatePipelineLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyPipelineLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPipelineLayout* obj1;
  VkPipelineLayout *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyPipelineLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateSampler(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSamplerCreateInfo* obj1;
  VkSamplerCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSamplerCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkSampler* obj3;
  VkSampler *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSampler>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateSampler(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroySampler(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSampler* obj1;
  VkSampler *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSampler>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroySampler(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateDescriptorSetLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorSetLayoutCreateInfo* obj1;
  VkDescriptorSetLayoutCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayoutCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDescriptorSetLayout* obj3;
  VkDescriptorSetLayout *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayout>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateDescriptorSetLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyDescriptorSetLayout(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorSetLayout* obj1;
  VkDescriptorSetLayout *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorSetLayout>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyDescriptorSetLayout(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateDescriptorPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorPoolCreateInfo* obj1;
  VkDescriptorPoolCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorPoolCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkDescriptorPool* obj3;
  VkDescriptorPool *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkDescriptorPool>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateDescriptorPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyDescriptorPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorPool* obj1;
  VkDescriptorPool *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorPool>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyDescriptorPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkAllocateDescriptorSets(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorSetAllocateInfo* obj1;
  VkDescriptorSetAllocateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorSetAllocateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }

  std::shared_ptr<std::vector<VkDescriptorSet>> $p2 = nullptr;

  if (info[2]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    std::vector<VkDescriptorSet> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkDescriptorSet* result = Nan::ObjectWrap::Unwrap<_VkDescriptorSet>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkDescriptorSet>>(data);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pDescriptorSets'");
  }

  int32_t out = vkAllocateDescriptorSets(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? $p2.get()->data() : nullptr
  );
  if (info[2]->IsArray()) {
    VkDescriptorSet* $pdata = $p2.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkDescriptorSet* target = Nan::ObjectWrap::Unwrap<_VkDescriptorSet>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $pdata[ii];
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkUpdateDescriptorSets(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  std::shared_ptr<std::vector<VkWriteDescriptorSet>> $p2 = nullptr;

  if (info[2]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkWriteDescriptorSet* result = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    std::vector<VkWriteDescriptorSet> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkWriteDescriptorSet* result = Nan::ObjectWrap::Unwrap<_VkWriteDescriptorSet>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkWriteDescriptorSet>>(data);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pDescriptorWrites'");
  }


  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  std::shared_ptr<std::vector<VkCopyDescriptorSet>> $p4 = nullptr;

  if (info[4]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[4]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkCopyDescriptorSet* result = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[4]);
    std::vector<VkCopyDescriptorSet> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkCopyDescriptorSet* result = Nan::ObjectWrap::Unwrap<_VkCopyDescriptorSet>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p4 = std::make_shared<std::vector<VkCopyDescriptorSet>>(data);
  } else if (!info[4]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 5 'pDescriptorCopies'");
  }

  vkUpdateDescriptorSets(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? $p2.get()->data() : nullptr,
    $p3,
    $p4 ? $p4.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateFramebuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkFramebufferCreateInfo* obj1;
  VkFramebufferCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkFramebufferCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkFramebuffer* obj3;
  VkFramebuffer *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkFramebuffer>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateFramebuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyFramebuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkFramebuffer* obj1;
  VkFramebuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkFramebuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyFramebuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkRenderPassCreateInfo* obj1;
  VkRenderPassCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPassCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkRenderPass* obj3;
  VkRenderPass *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkRenderPass>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkRenderPass* obj1;
  VkRenderPass *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPass>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCreateCommandPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandPoolCreateInfo* obj1;
  VkCommandPoolCreateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandPoolCreateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkCommandPool* obj3;
  VkCommandPool *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkCommandPool>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateCommandPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyCommandPool(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandPool* obj1;
  VkCommandPool *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandPool>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyCommandPool(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkAllocateCommandBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandBufferAllocateInfo* obj1;
  VkCommandBufferAllocateInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandBufferAllocateInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }

  std::shared_ptr<std::vector<VkCommandBuffer>> $p2 = nullptr;

  if (info[2]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    std::vector<VkCommandBuffer> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkCommandBuffer* result = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p2 = std::make_shared<std::vector<VkCommandBuffer>>(data);
  } else if (!info[2]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 3 'pCommandBuffers'");
  }

  int32_t out = vkAllocateCommandBuffers(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? $p2.get()->data() : nullptr
  );
  if (info[2]->IsArray()) {
    VkCommandBuffer* $pdata = $p2.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[2]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkCommandBuffer* target = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $pdata[ii];
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkFreeCommandBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandPool* obj1;
  VkCommandPool *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandPool>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  std::shared_ptr<std::vector<VkCommandBuffer>> $p3 = nullptr;

  if (info[3]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    std::vector<VkCommandBuffer> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkCommandBuffer* result = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkCommandBuffer>>(data);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pCommandBuffers'");
  }

  vkFreeCommandBuffers(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? $p3.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkBeginCommandBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkCommandBufferBeginInfo* obj1;
  VkCommandBufferBeginInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkCommandBufferBeginInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  int32_t out = vkBeginCommandBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkEndCommandBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  int32_t out = vkEndCommandBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCmdBindPipeline(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  _VkPipeline* obj2;
  VkPipeline *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkPipeline>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }
  vkCmdBindPipeline(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdSetViewport(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  std::shared_ptr<std::vector<VkViewport>> $p3 = nullptr;

  if (info[3]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkViewport* result = Nan::ObjectWrap::Unwrap<_VkViewport>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    std::vector<VkViewport> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkViewport* result = Nan::ObjectWrap::Unwrap<_VkViewport>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkViewport>>(data);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pViewports'");
  }

  vkCmdSetViewport(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? $p3.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdSetScissor(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    std::vector<VkRect2D> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkRect2D* result = Nan::ObjectWrap::Unwrap<_VkRect2D>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pScissors'");
  }

  vkCmdSetScissor(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? $p3.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBindDescriptorSets(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  _VkPipelineLayout* obj2;
  VkPipelineLayout *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkPipelineLayout>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  uint32_t $p4 = static_cast<uint32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  std::shared_ptr<std::vector<VkDescriptorSet>> $p5 = nullptr;

  if (info[5]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    std::vector<VkDescriptorSet> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkDescriptorSet* result = Nan::ObjectWrap::Unwrap<_VkDescriptorSet>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkDescriptorSet>>(data);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pDescriptorSets'");
  }


  uint32_t $p6 = static_cast<uint32_t>(Nan::To<int64_t>(info[6]).FromMaybe(0));

  std::shared_ptr<std::vector<uint32_t>> $p7 = nullptr;

  if (info[7]->IsArray()) {

    std::vector<uint32_t> data = createArrayOfV8Numbers<uint32_t>(info[7]);
    $p7 = std::make_shared<std::vector<uint32_t>>(data);
  } else if (!info[7]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 8 'pDynamicOffsets'");
  }

  vkCmdBindDescriptorSets(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5 ? $p5.get()->data() : nullptr,
    $p6,
    $p7 ? $p7.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBindIndexBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint64_t $p2 = static_cast<uint64_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  VkIndexType $p3 = static_cast<VkIndexType>(Nan::To<int64_t>(info[3]).FromMaybe(0));
  vkCmdBindIndexBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBindVertexBuffers(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    std::vector<VkBuffer> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkBuffer* result = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pBuffers'");
  }


  std::shared_ptr<std::vector<VkDeviceSize>> $p4 = nullptr;

  if (info[4]->IsArray()) {

    std::vector<VkDeviceSize> data = createArrayOfV8Numbers<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<std::vector<VkDeviceSize>>(data);
  } else if (!info[4]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 5 'pOffsets'");
  }

  vkCmdBindVertexBuffers(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? $p3.get()->data() : nullptr,
    $p4 ? $p4.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdDraw(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  uint32_t $p4 = static_cast<uint32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));
  vkCmdDraw(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdDrawIndexed(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  uint32_t $p2 = static_cast<uint32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  int32_t $p4 = static_cast<int32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  uint32_t $p5 = static_cast<uint32_t>(Nan::To<int64_t>(info[5]).FromMaybe(0));
  vkCmdDrawIndexed(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4,
    $p5
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdCopyBuffer(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj2;
  VkBuffer *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  uint32_t $p3 = static_cast<uint32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  std::shared_ptr<std::vector<VkBufferCopy>> $p4 = nullptr;

  if (info[4]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[4]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkBufferCopy* result = Nan::ObjectWrap::Unwrap<_VkBufferCopy>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[4]);
    std::vector<VkBufferCopy> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkBufferCopy* result = Nan::ObjectWrap::Unwrap<_VkBufferCopy>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p4 = std::make_shared<std::vector<VkBufferCopy>>(data);
  } else if (!info[4]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 5 'pRegions'");
  }

  vkCmdCopyBuffer(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4 ? $p4.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdCopyBufferToImage(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkBuffer* obj1;
  VkBuffer *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkBuffer>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkImage* obj2;
  VkImage *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  VkImageLayout $p3 = static_cast<VkImageLayout>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  uint32_t $p4 = static_cast<uint32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  std::shared_ptr<std::vector<VkBufferImageCopy>> $p5 = nullptr;

  if (info[5]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkBufferImageCopy* result = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    std::vector<VkBufferImageCopy> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkBufferImageCopy* result = Nan::ObjectWrap::Unwrap<_VkBufferImageCopy>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkBufferImageCopy>>(data);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pRegions'");
  }

  vkCmdCopyBufferToImage(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5 ? $p5.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdPipelineBarrier(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  int32_t $p1 = static_cast<int32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  int32_t $p2 = static_cast<int32_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  int32_t $p3 = static_cast<int32_t>(Nan::To<int64_t>(info[3]).FromMaybe(0));

  uint32_t $p4 = static_cast<uint32_t>(Nan::To<int64_t>(info[4]).FromMaybe(0));

  std::shared_ptr<std::vector<VkMemoryBarrier>> $p5 = nullptr;

  if (info[5]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkMemoryBarrier* result = Nan::ObjectWrap::Unwrap<_VkMemoryBarrier>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[5]);
    std::vector<VkMemoryBarrier> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkMemoryBarrier* result = Nan::ObjectWrap::Unwrap<_VkMemoryBarrier>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p5 = std::make_shared<std::vector<VkMemoryBarrier>>(data);
  } else if (!info[5]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 6 'pMemoryBarriers'");
  }


  uint32_t $p6 = static_cast<uint32_t>(Nan::To<int64_t>(info[6]).FromMaybe(0));

  std::shared_ptr<std::vector<VkBufferMemoryBarrier>> $p7 = nullptr;

  if (info[7]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[7]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkBufferMemoryBarrier* result = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[7]);
    std::vector<VkBufferMemoryBarrier> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkBufferMemoryBarrier* result = Nan::ObjectWrap::Unwrap<_VkBufferMemoryBarrier>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p7 = std::make_shared<std::vector<VkBufferMemoryBarrier>>(data);
  } else if (!info[7]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 8 'pBufferMemoryBarriers'");
  }


  uint32_t $p8 = static_cast<uint32_t>(Nan::To<int64_t>(info[8]).FromMaybe(0));

  std::shared_ptr<std::vector<VkImageMemoryBarrier>> $p9 = nullptr;

  if (info[9]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[9]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkImageMemoryBarrier* result = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[9]);
    std::vector<VkImageMemoryBarrier> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkImageMemoryBarrier* result = Nan::ObjectWrap::Unwrap<_VkImageMemoryBarrier>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p9 = std::make_shared<std::vector<VkImageMemoryBarrier>>(data);
  } else if (!info[9]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 10 'pImageMemoryBarriers'");
  }

  vkCmdPipelineBarrier(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4,
    $p5 ? $p5.get()->data() : nullptr,
    $p6,
    $p7 ? $p7.get()->data() : nullptr,
    $p8,
    $p9 ? $p9.get()->data() : nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdBeginRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkRenderPassBeginInfo* obj1;
  VkRenderPassBeginInfo *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkRenderPassBeginInfo>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }

  VkSubpassContents $p2 = static_cast<VkSubpassContents>(Nan::To<int64_t>(info[2]).FromMaybe(0));
  vkCmdBeginRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkCmdEndRenderPass(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkCommandBuffer* obj0;
  VkCommandBuffer *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkCommandBuffer>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }
  vkCmdEndRenderPass(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkDestroySurfaceKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkInstance* obj0;
  VkInstance *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkInstance>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroySurfaceKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetPhysicalDeviceSurfaceSupportKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  uint32_t $p1 = static_cast<uint32_t>(Nan::To<int64_t>(info[1]).FromMaybe(0));

  _VkSurfaceKHR* obj2;
  VkSurfaceKHR *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    
    $p2 = &obj2->instance;
  } else {
    $p2 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj3;
  uint32_t $p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::To<v8::Object>(info[3]).ToLocalChecked();
    v8::Local<v8::Value> val = obj3->Get(Nan::New("$").ToLocalChecked());
    $p3 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }
  int32_t out = vkGetPhysicalDeviceSurfaceSupportKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2]->IsNull() ? VK_NULL_HANDLE : *$p2,
    &$p3
  );
    obj3->Set(Nan::New("$").ToLocalChecked(), Nan::New($p3));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceCapabilitiesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  _VkSurfaceCapabilitiesKHR* obj2;
  VkSurfaceCapabilitiesKHR *$p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::ObjectWrap::Unwrap<_VkSurfaceCapabilitiesKHR>(Nan::To<v8::Object>(info[2]).ToLocalChecked());
    if (!obj2->flush()) return;
    $p2 = &obj2->instance;
  } else {
    $p2 = nullptr;
  }
  int32_t out = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->currentExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.currentExtent, sizeof(VkExtent2D));
    
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->minImageExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.minImageExtent, sizeof(VkExtent2D));
    
  }
      
  {
    v8::Local<v8::Function> ctor = Nan::GetFunction(Nan::New(_VkExtent2D::constructor)).ToLocalChecked();
    v8::Local<v8::Object> inst = Nan::NewInstance(ctor).ToLocalChecked();
    _VkExtent2D* unwrapped6 = Nan::ObjectWrap::Unwrap<_VkExtent2D>(inst);
    obj2->maxImageExtent = Nan::Persistent<v8::Object, v8::CopyablePersistentTraits<v8::Object>>(inst);
    memcpy((&unwrapped6->instance), &obj2->instance.maxImageExtent, sizeof(VkExtent2D));
    
  }
      
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfaceFormatsKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::To<v8::Object>(info[2]).ToLocalChecked();
    v8::Local<v8::Value> val = obj2->Get(Nan::New("$").ToLocalChecked());
    $p2 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  std::shared_ptr<std::vector<VkSurfaceFormatKHR>> $p3 = nullptr;

  if (info[3]->IsArray()) {

  {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkSurfaceFormatKHR* result = Nan::ObjectWrap::Unwrap<_VkSurfaceFormatKHR>(Nan::To<v8::Object>(item).ToLocalChecked());
      if (!result->flush()) return;
    };
  }
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    std::vector<VkSurfaceFormatKHR> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkSurfaceFormatKHR* result = Nan::ObjectWrap::Unwrap<_VkSurfaceFormatKHR>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkSurfaceFormatKHR>>(data);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pSurfaceFormats'");
  }

  int32_t out = vkGetPhysicalDeviceSurfaceFormatsKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? $p3.get()->data() : nullptr
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    VkSurfaceFormatKHR* $pdata = $p3.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      v8::Local<v8::Object> obj = Nan::To<v8::Object>(item).ToLocalChecked();
      _VkSurfaceFormatKHR* result = Nan::ObjectWrap::Unwrap<_VkSurfaceFormatKHR>(obj);
      VkSurfaceFormatKHR *instance = &result->instance;
      VkSurfaceFormatKHR *copy = &$pdata[ii];
      
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkGetPhysicalDeviceSurfacePresentModesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkPhysicalDevice* obj0;
  VkPhysicalDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkPhysicalDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSurfaceKHR* obj1;
  VkSurfaceKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSurfaceKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::To<v8::Object>(info[2]).ToLocalChecked();
    v8::Local<v8::Value> val = obj2->Get(Nan::New("$").ToLocalChecked());
    $p2 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  VkPresentModeKHR *$p3 = nullptr;

  if (info[3]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    VkPresentModeKHR * arr3 = new VkPresentModeKHR[array->Length()];
    $p3 = arr3;
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pPresentModes'");
  }

  int32_t out = vkGetPhysicalDeviceSurfacePresentModesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      array->Set(ii, Nan::New($p3[ii]));
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkCreateSwapchainKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainCreateInfoKHR* obj1;
  VkSwapchainCreateInfoKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainCreateInfoKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }


  _VkSwapchainKHR* obj3;
  VkSwapchainKHR *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }
  int32_t out = vkCreateSwapchainKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroySwapchainKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroySwapchainKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkGetSwapchainImagesKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj2;
  uint32_t $p2;
  if (!(info[2]->IsNull())) {
    obj2 = Nan::To<v8::Object>(info[2]).ToLocalChecked();
    v8::Local<v8::Value> val = obj2->Get(Nan::New("$").ToLocalChecked());
    $p2 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }

  std::shared_ptr<std::vector<VkImage>> $p3 = nullptr;

  if (info[3]->IsArray()) {

    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    std::vector<VkImage> data(array->Length());
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Local<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkImage* result = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(item).ToLocalChecked());
      data[ii] = result->instance;
    };
    $p3 = std::make_shared<std::vector<VkImage>>(data);
  } else if (!info[3]->IsNull()) {
    return Nan::ThrowError("Invalid type for argument 4 'pSwapchainImages'");
  }

  int32_t out = vkGetSwapchainImagesKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? $p3.get()->data() : nullptr
  );
    obj2->Set(Nan::New("$").ToLocalChecked(), Nan::New($p2));
  if (info[3]->IsArray()) {
    VkImage* $pdata = $p3.get()->data();
    v8::Local<v8::Array> array = v8::Local<v8::Array>::Cast(info[3]);
    for (unsigned int ii = 0; ii < array->Length(); ++ii) {
      v8::Handle<v8::Value> item = Nan::Get(array, ii).ToLocalChecked();
      _VkImage* target = Nan::ObjectWrap::Unwrap<_VkImage>(Nan::To<v8::Object>(item).ToLocalChecked());
      target->instance = $pdata[ii];
    };
  }
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkAcquireNextImageKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSwapchainKHR* obj1;
  VkSwapchainKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSwapchainKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  uint64_t $p2 = static_cast<uint64_t>(Nan::To<int64_t>(info[2]).FromMaybe(0));

  _VkSemaphore* obj3;
  VkSemaphore *$p3;
  if (!(info[3]->IsNull())) {
    obj3 = Nan::ObjectWrap::Unwrap<_VkSemaphore>(Nan::To<v8::Object>(info[3]).ToLocalChecked());
    
    $p3 = &obj3->instance;
  } else {
    $p3 = VK_NULL_HANDLE;
  }

  _VkFence* obj4;
  VkFence *$p4;
  if (!(info[4]->IsNull())) {
    obj4 = Nan::ObjectWrap::Unwrap<_VkFence>(Nan::To<v8::Object>(info[4]).ToLocalChecked());
    
    $p4 = &obj4->instance;
  } else {
    $p4 = VK_NULL_HANDLE;
  }

  v8::Local<v8::Object> obj5;
  uint32_t $p5;
  if (!(info[5]->IsNull())) {
    obj5 = Nan::To<v8::Object>(info[5]).ToLocalChecked();
    v8::Local<v8::Value> val = obj5->Get(Nan::New("$").ToLocalChecked());
    $p5 = static_cast<uint32_t>(Nan::To<int64_t>(val).FromMaybe(0));
  }
  int32_t out = vkAcquireNextImageKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3]->IsNull() ? VK_NULL_HANDLE : *$p3,
    info[4]->IsNull() ? VK_NULL_HANDLE : *$p4,
    &$p5
  );
    obj5->Set(Nan::New("$").ToLocalChecked(), Nan::New($p5));
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkQueuePresentKHR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkQueue* obj0;
  VkQueue *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkQueue>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkPresentInfoKHR* obj1;
  VkPresentInfoKHR *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkPresentInfoKHR>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    if (!obj1->flush()) return;
    $p1 = &obj1->instance;
  } else {
    $p1 = nullptr;
  }
  int32_t out = vkQueuePresentKHR(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  info.GetReturnValue().Set(Nan::New(static_cast<int32_t>(out)));
};

void _vkDestroyDescriptorUpdateTemplate(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkDescriptorUpdateTemplate* obj1;
  VkDescriptorUpdateTemplate *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkDescriptorUpdateTemplate>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroyDescriptorUpdateTemplate(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};

void _vkDestroySamplerYcbcrConversion(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  
  _VkDevice* obj0;
  VkDevice *$p0;
  if (!(info[0]->IsNull())) {
    obj0 = Nan::ObjectWrap::Unwrap<_VkDevice>(Nan::To<v8::Object>(info[0]).ToLocalChecked());
    
    $p0 = &obj0->instance;
  } else {
    $p0 = VK_NULL_HANDLE;
  }

  _VkSamplerYcbcrConversion* obj1;
  VkSamplerYcbcrConversion *$p1;
  if (!(info[1]->IsNull())) {
    obj1 = Nan::ObjectWrap::Unwrap<_VkSamplerYcbcrConversion>(Nan::To<v8::Object>(info[1]).ToLocalChecked());
    
    $p1 = &obj1->instance;
  } else {
    $p1 = VK_NULL_HANDLE;
  }

  vkDestroySamplerYcbcrConversion(
    info[0]->IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1]->IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  info.GetReturnValue().SetUndefined();
  
};



#endif
