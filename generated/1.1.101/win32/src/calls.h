/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.3.8
 */
#ifndef __VK_CALLS_H__
#define __VK_CALLS_H__

#define NAPI_EXPERIMENTAL
#include <napi.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include "utils.h"
#include "source.h"

#include <map>
#include <string>
#include <memory>

inline VkStructureType GetStructureTypeFromObject(Napi::Object obj) {
  if (!obj.Has("sType")) Napi::TypeError::New(obj.Env(), "Failed to resolve structure type, 'sType' property is missing").ThrowAsJavaScriptException();
  VkStructureType sType = static_cast<VkStructureType>(obj.Get("sType").As<Napi::Number>().Int32Value());
  return sType;
};

VkDevice currentDevice = VK_NULL_HANDLE;
VkInstance currentInstance = VK_NULL_HANDLE;


static PFN_vkCmdBeginConditionalRenderingEXT $vkCmdBeginConditionalRenderingEXT = nullptr;
static PFN_vkCmdEndConditionalRenderingEXT $vkCmdEndConditionalRenderingEXT = nullptr;
static PFN_vkGetPhysicalDeviceDisplayPropertiesKHR $vkGetPhysicalDeviceDisplayPropertiesKHR = nullptr;
static PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR $vkGetPhysicalDeviceDisplayPlanePropertiesKHR = nullptr;
static PFN_vkGetDisplayPlaneSupportedDisplaysKHR $vkGetDisplayPlaneSupportedDisplaysKHR = nullptr;
static PFN_vkGetDisplayModePropertiesKHR $vkGetDisplayModePropertiesKHR = nullptr;
static PFN_vkCreateDisplayModeKHR $vkCreateDisplayModeKHR = nullptr;
static PFN_vkGetDisplayPlaneCapabilitiesKHR $vkGetDisplayPlaneCapabilitiesKHR = nullptr;
static PFN_vkCreateDisplayPlaneSurfaceKHR $vkCreateDisplayPlaneSurfaceKHR = nullptr;
static PFN_vkCreateSharedSwapchainsKHR $vkCreateSharedSwapchainsKHR = nullptr;
static PFN_vkDestroySurfaceKHR $vkDestroySurfaceKHR = nullptr;
static PFN_vkGetPhysicalDeviceSurfaceSupportKHR $vkGetPhysicalDeviceSurfaceSupportKHR = nullptr;
static PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR $vkGetPhysicalDeviceSurfaceCapabilitiesKHR = nullptr;
static PFN_vkGetPhysicalDeviceSurfaceFormatsKHR $vkGetPhysicalDeviceSurfaceFormatsKHR = nullptr;
static PFN_vkGetPhysicalDeviceSurfacePresentModesKHR $vkGetPhysicalDeviceSurfacePresentModesKHR = nullptr;
static PFN_vkCreateSwapchainKHR $vkCreateSwapchainKHR = nullptr;
static PFN_vkDestroySwapchainKHR $vkDestroySwapchainKHR = nullptr;
static PFN_vkGetSwapchainImagesKHR $vkGetSwapchainImagesKHR = nullptr;
static PFN_vkAcquireNextImageKHR $vkAcquireNextImageKHR = nullptr;
static PFN_vkQueuePresentKHR $vkQueuePresentKHR = nullptr;
static PFN_vkCreateWin32SurfaceKHR $vkCreateWin32SurfaceKHR = nullptr;
static PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR $vkGetPhysicalDeviceWin32PresentationSupportKHR = nullptr;
static PFN_vkCreateDebugReportCallbackEXT $vkCreateDebugReportCallbackEXT = nullptr;
static PFN_vkDestroyDebugReportCallbackEXT $vkDestroyDebugReportCallbackEXT = nullptr;
static PFN_vkDebugReportMessageEXT $vkDebugReportMessageEXT = nullptr;
static PFN_vkDebugMarkerSetObjectNameEXT $vkDebugMarkerSetObjectNameEXT = nullptr;
static PFN_vkDebugMarkerSetObjectTagEXT $vkDebugMarkerSetObjectTagEXT = nullptr;
static PFN_vkCmdDebugMarkerBeginEXT $vkCmdDebugMarkerBeginEXT = nullptr;
static PFN_vkCmdDebugMarkerEndEXT $vkCmdDebugMarkerEndEXT = nullptr;
static PFN_vkCmdDebugMarkerInsertEXT $vkCmdDebugMarkerInsertEXT = nullptr;
static PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV $vkGetPhysicalDeviceExternalImageFormatPropertiesNV = nullptr;
static PFN_vkGetMemoryWin32HandleNV $vkGetMemoryWin32HandleNV = nullptr;
static PFN_vkCmdDrawIndirectCountAMD $vkCmdDrawIndirectCountAMD = nullptr;
static PFN_vkCmdDrawIndexedIndirectCountAMD $vkCmdDrawIndexedIndirectCountAMD = nullptr;
static PFN_vkCmdProcessCommandsNVX $vkCmdProcessCommandsNVX = nullptr;
static PFN_vkCmdReserveSpaceForCommandsNVX $vkCmdReserveSpaceForCommandsNVX = nullptr;
static PFN_vkCreateIndirectCommandsLayoutNVX $vkCreateIndirectCommandsLayoutNVX = nullptr;
static PFN_vkDestroyIndirectCommandsLayoutNVX $vkDestroyIndirectCommandsLayoutNVX = nullptr;
static PFN_vkCreateObjectTableNVX $vkCreateObjectTableNVX = nullptr;
static PFN_vkDestroyObjectTableNVX $vkDestroyObjectTableNVX = nullptr;
static PFN_vkRegisterObjectsNVX $vkRegisterObjectsNVX = nullptr;
static PFN_vkUnregisterObjectsNVX $vkUnregisterObjectsNVX = nullptr;
static PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX $vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = nullptr;
static PFN_vkCmdPushDescriptorSetKHR $vkCmdPushDescriptorSetKHR = nullptr;
static PFN_vkGetMemoryWin32HandleKHR $vkGetMemoryWin32HandleKHR = nullptr;
static PFN_vkGetMemoryWin32HandlePropertiesKHR $vkGetMemoryWin32HandlePropertiesKHR = nullptr;
static PFN_vkGetMemoryFdKHR $vkGetMemoryFdKHR = nullptr;
static PFN_vkGetMemoryFdPropertiesKHR $vkGetMemoryFdPropertiesKHR = nullptr;
static PFN_vkGetSemaphoreWin32HandleKHR $vkGetSemaphoreWin32HandleKHR = nullptr;
static PFN_vkImportSemaphoreWin32HandleKHR $vkImportSemaphoreWin32HandleKHR = nullptr;
static PFN_vkGetSemaphoreFdKHR $vkGetSemaphoreFdKHR = nullptr;
static PFN_vkImportSemaphoreFdKHR $vkImportSemaphoreFdKHR = nullptr;
static PFN_vkGetFenceWin32HandleKHR $vkGetFenceWin32HandleKHR = nullptr;
static PFN_vkImportFenceWin32HandleKHR $vkImportFenceWin32HandleKHR = nullptr;
static PFN_vkGetFenceFdKHR $vkGetFenceFdKHR = nullptr;
static PFN_vkImportFenceFdKHR $vkImportFenceFdKHR = nullptr;
static PFN_vkReleaseDisplayEXT $vkReleaseDisplayEXT = nullptr;
static PFN_vkDisplayPowerControlEXT $vkDisplayPowerControlEXT = nullptr;
static PFN_vkRegisterDeviceEventEXT $vkRegisterDeviceEventEXT = nullptr;
static PFN_vkRegisterDisplayEventEXT $vkRegisterDisplayEventEXT = nullptr;
static PFN_vkGetSwapchainCounterEXT $vkGetSwapchainCounterEXT = nullptr;
static PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT $vkGetPhysicalDeviceSurfaceCapabilities2EXT = nullptr;
static PFN_vkGetDeviceGroupPresentCapabilitiesKHR $vkGetDeviceGroupPresentCapabilitiesKHR = nullptr;
static PFN_vkGetDeviceGroupSurfacePresentModesKHR $vkGetDeviceGroupSurfacePresentModesKHR = nullptr;
static PFN_vkAcquireNextImage2KHR $vkAcquireNextImage2KHR = nullptr;
static PFN_vkGetPhysicalDevicePresentRectanglesKHR $vkGetPhysicalDevicePresentRectanglesKHR = nullptr;
static PFN_vkCmdPushDescriptorSetWithTemplateKHR $vkCmdPushDescriptorSetWithTemplateKHR = nullptr;
static PFN_vkSetHdrMetadataEXT $vkSetHdrMetadataEXT = nullptr;
static PFN_vkGetSwapchainStatusKHR $vkGetSwapchainStatusKHR = nullptr;
static PFN_vkGetRefreshCycleDurationGOOGLE $vkGetRefreshCycleDurationGOOGLE = nullptr;
static PFN_vkGetPastPresentationTimingGOOGLE $vkGetPastPresentationTimingGOOGLE = nullptr;
static PFN_vkCmdSetViewportWScalingNV $vkCmdSetViewportWScalingNV = nullptr;
static PFN_vkCmdSetDiscardRectangleEXT $vkCmdSetDiscardRectangleEXT = nullptr;
static PFN_vkCmdSetSampleLocationsEXT $vkCmdSetSampleLocationsEXT = nullptr;
static PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT $vkGetPhysicalDeviceMultisamplePropertiesEXT = nullptr;
static PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR $vkGetPhysicalDeviceSurfaceCapabilities2KHR = nullptr;
static PFN_vkGetPhysicalDeviceSurfaceFormats2KHR $vkGetPhysicalDeviceSurfaceFormats2KHR = nullptr;
static PFN_vkGetPhysicalDeviceDisplayProperties2KHR $vkGetPhysicalDeviceDisplayProperties2KHR = nullptr;
static PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR $vkGetPhysicalDeviceDisplayPlaneProperties2KHR = nullptr;
static PFN_vkGetDisplayModeProperties2KHR $vkGetDisplayModeProperties2KHR = nullptr;
static PFN_vkGetDisplayPlaneCapabilities2KHR $vkGetDisplayPlaneCapabilities2KHR = nullptr;
static PFN_vkCreateValidationCacheEXT $vkCreateValidationCacheEXT = nullptr;
static PFN_vkDestroyValidationCacheEXT $vkDestroyValidationCacheEXT = nullptr;
static PFN_vkGetValidationCacheDataEXT $vkGetValidationCacheDataEXT = nullptr;
static PFN_vkMergeValidationCachesEXT $vkMergeValidationCachesEXT = nullptr;
static PFN_vkGetShaderInfoAMD $vkGetShaderInfoAMD = nullptr;
static PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT $vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = nullptr;
static PFN_vkGetCalibratedTimestampsEXT $vkGetCalibratedTimestampsEXT = nullptr;
static PFN_vkSetDebugUtilsObjectNameEXT $vkSetDebugUtilsObjectNameEXT = nullptr;
static PFN_vkSetDebugUtilsObjectTagEXT $vkSetDebugUtilsObjectTagEXT = nullptr;
static PFN_vkQueueBeginDebugUtilsLabelEXT $vkQueueBeginDebugUtilsLabelEXT = nullptr;
static PFN_vkQueueEndDebugUtilsLabelEXT $vkQueueEndDebugUtilsLabelEXT = nullptr;
static PFN_vkQueueInsertDebugUtilsLabelEXT $vkQueueInsertDebugUtilsLabelEXT = nullptr;
static PFN_vkCmdBeginDebugUtilsLabelEXT $vkCmdBeginDebugUtilsLabelEXT = nullptr;
static PFN_vkCmdEndDebugUtilsLabelEXT $vkCmdEndDebugUtilsLabelEXT = nullptr;
static PFN_vkCmdInsertDebugUtilsLabelEXT $vkCmdInsertDebugUtilsLabelEXT = nullptr;
static PFN_vkCreateDebugUtilsMessengerEXT $vkCreateDebugUtilsMessengerEXT = nullptr;
static PFN_vkDestroyDebugUtilsMessengerEXT $vkDestroyDebugUtilsMessengerEXT = nullptr;
static PFN_vkSubmitDebugUtilsMessageEXT $vkSubmitDebugUtilsMessageEXT = nullptr;
static PFN_vkGetMemoryHostPointerPropertiesEXT $vkGetMemoryHostPointerPropertiesEXT = nullptr;
static PFN_vkCmdWriteBufferMarkerAMD $vkCmdWriteBufferMarkerAMD = nullptr;
static PFN_vkCreateRenderPass2KHR $vkCreateRenderPass2KHR = nullptr;
static PFN_vkCmdBeginRenderPass2KHR $vkCmdBeginRenderPass2KHR = nullptr;
static PFN_vkCmdNextSubpass2KHR $vkCmdNextSubpass2KHR = nullptr;
static PFN_vkCmdEndRenderPass2KHR $vkCmdEndRenderPass2KHR = nullptr;
static PFN_vkCmdDrawIndirectCountKHR $vkCmdDrawIndirectCountKHR = nullptr;
static PFN_vkCmdDrawIndexedIndirectCountKHR $vkCmdDrawIndexedIndirectCountKHR = nullptr;
static PFN_vkCmdSetCheckpointNV $vkCmdSetCheckpointNV = nullptr;
static PFN_vkGetQueueCheckpointDataNV $vkGetQueueCheckpointDataNV = nullptr;
static PFN_vkCmdBindTransformFeedbackBuffersEXT $vkCmdBindTransformFeedbackBuffersEXT = nullptr;
static PFN_vkCmdBeginTransformFeedbackEXT $vkCmdBeginTransformFeedbackEXT = nullptr;
static PFN_vkCmdEndTransformFeedbackEXT $vkCmdEndTransformFeedbackEXT = nullptr;
static PFN_vkCmdBeginQueryIndexedEXT $vkCmdBeginQueryIndexedEXT = nullptr;
static PFN_vkCmdEndQueryIndexedEXT $vkCmdEndQueryIndexedEXT = nullptr;
static PFN_vkCmdDrawIndirectByteCountEXT $vkCmdDrawIndirectByteCountEXT = nullptr;
static PFN_vkCmdSetExclusiveScissorNV $vkCmdSetExclusiveScissorNV = nullptr;
static PFN_vkCmdBindShadingRateImageNV $vkCmdBindShadingRateImageNV = nullptr;
static PFN_vkCmdSetViewportShadingRatePaletteNV $vkCmdSetViewportShadingRatePaletteNV = nullptr;
static PFN_vkCmdSetCoarseSampleOrderNV $vkCmdSetCoarseSampleOrderNV = nullptr;
static PFN_vkCmdDrawMeshTasksNV $vkCmdDrawMeshTasksNV = nullptr;
static PFN_vkCmdDrawMeshTasksIndirectNV $vkCmdDrawMeshTasksIndirectNV = nullptr;
static PFN_vkCmdDrawMeshTasksIndirectCountNV $vkCmdDrawMeshTasksIndirectCountNV = nullptr;
static PFN_vkCompileDeferredNV $vkCompileDeferredNV = nullptr;
static PFN_vkCreateAccelerationStructureNV $vkCreateAccelerationStructureNV = nullptr;
static PFN_vkDestroyAccelerationStructureNV $vkDestroyAccelerationStructureNV = nullptr;
static PFN_vkGetAccelerationStructureMemoryRequirementsNV $vkGetAccelerationStructureMemoryRequirementsNV = nullptr;
static PFN_vkBindAccelerationStructureMemoryNV $vkBindAccelerationStructureMemoryNV = nullptr;
static PFN_vkCmdCopyAccelerationStructureNV $vkCmdCopyAccelerationStructureNV = nullptr;
static PFN_vkCmdWriteAccelerationStructuresPropertiesNV $vkCmdWriteAccelerationStructuresPropertiesNV = nullptr;
static PFN_vkCmdBuildAccelerationStructureNV $vkCmdBuildAccelerationStructureNV = nullptr;
static PFN_vkCmdTraceRaysNV $vkCmdTraceRaysNV = nullptr;
static PFN_vkGetRayTracingShaderGroupHandlesNV $vkGetRayTracingShaderGroupHandlesNV = nullptr;
static PFN_vkGetAccelerationStructureHandleNV $vkGetAccelerationStructureHandleNV = nullptr;
static PFN_vkCreateRayTracingPipelinesNV $vkCreateRayTracingPipelinesNV = nullptr;
static PFN_vkGetImageDrmFormatModifierPropertiesEXT $vkGetImageDrmFormatModifierPropertiesEXT = nullptr;
static PFN_vkGetBufferDeviceAddressEXT $vkGetBufferDeviceAddressEXT = nullptr;
static PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV $vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = nullptr;

void vkUseDevice(VkDevice pDevice) {
  currentDevice = pDevice;
  $vkCmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdBeginConditionalRenderingEXT");
  $vkCmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdEndConditionalRenderingEXT");
  $vkCreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR) vkGetDeviceProcAddr(currentDevice, "vkCreateSharedSwapchainsKHR");
  $vkCreateSwapchainKHR = (PFN_vkCreateSwapchainKHR) vkGetDeviceProcAddr(currentDevice, "vkCreateSwapchainKHR");
  $vkDestroySwapchainKHR = (PFN_vkDestroySwapchainKHR) vkGetDeviceProcAddr(currentDevice, "vkDestroySwapchainKHR");
  $vkGetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetSwapchainImagesKHR");
  $vkAcquireNextImageKHR = (PFN_vkAcquireNextImageKHR) vkGetDeviceProcAddr(currentDevice, "vkAcquireNextImageKHR");
  $vkQueuePresentKHR = (PFN_vkQueuePresentKHR) vkGetDeviceProcAddr(currentDevice, "vkQueuePresentKHR");
  $vkDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT) vkGetDeviceProcAddr(currentDevice, "vkDebugMarkerSetObjectNameEXT");
  $vkDebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT) vkGetDeviceProcAddr(currentDevice, "vkDebugMarkerSetObjectTagEXT");
  $vkCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdDebugMarkerBeginEXT");
  $vkCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdDebugMarkerEndEXT");
  $vkCmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdDebugMarkerInsertEXT");
  $vkGetMemoryWin32HandleNV = (PFN_vkGetMemoryWin32HandleNV) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryWin32HandleNV");
  $vkCmdDrawIndirectCountAMD = (PFN_vkCmdDrawIndirectCountAMD) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndirectCountAMD");
  $vkCmdDrawIndexedIndirectCountAMD = (PFN_vkCmdDrawIndexedIndirectCountAMD) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndexedIndirectCountAMD");
  $vkCmdProcessCommandsNVX = (PFN_vkCmdProcessCommandsNVX) vkGetDeviceProcAddr(currentDevice, "vkCmdProcessCommandsNVX");
  $vkCmdReserveSpaceForCommandsNVX = (PFN_vkCmdReserveSpaceForCommandsNVX) vkGetDeviceProcAddr(currentDevice, "vkCmdReserveSpaceForCommandsNVX");
  $vkCreateIndirectCommandsLayoutNVX = (PFN_vkCreateIndirectCommandsLayoutNVX) vkGetDeviceProcAddr(currentDevice, "vkCreateIndirectCommandsLayoutNVX");
  $vkDestroyIndirectCommandsLayoutNVX = (PFN_vkDestroyIndirectCommandsLayoutNVX) vkGetDeviceProcAddr(currentDevice, "vkDestroyIndirectCommandsLayoutNVX");
  $vkCreateObjectTableNVX = (PFN_vkCreateObjectTableNVX) vkGetDeviceProcAddr(currentDevice, "vkCreateObjectTableNVX");
  $vkDestroyObjectTableNVX = (PFN_vkDestroyObjectTableNVX) vkGetDeviceProcAddr(currentDevice, "vkDestroyObjectTableNVX");
  $vkRegisterObjectsNVX = (PFN_vkRegisterObjectsNVX) vkGetDeviceProcAddr(currentDevice, "vkRegisterObjectsNVX");
  $vkUnregisterObjectsNVX = (PFN_vkUnregisterObjectsNVX) vkGetDeviceProcAddr(currentDevice, "vkUnregisterObjectsNVX");
  $vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = (PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX");
  $vkCmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR) vkGetDeviceProcAddr(currentDevice, "vkCmdPushDescriptorSetKHR");
  $vkGetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryWin32HandleKHR");
  $vkGetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryWin32HandlePropertiesKHR");
  $vkGetMemoryFdKHR = (PFN_vkGetMemoryFdKHR) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryFdKHR");
  $vkGetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryFdPropertiesKHR");
  $vkGetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkGetSemaphoreWin32HandleKHR");
  $vkImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkImportSemaphoreWin32HandleKHR");
  $vkGetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR) vkGetDeviceProcAddr(currentDevice, "vkGetSemaphoreFdKHR");
  $vkImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR) vkGetDeviceProcAddr(currentDevice, "vkImportSemaphoreFdKHR");
  $vkGetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkGetFenceWin32HandleKHR");
  $vkImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR) vkGetDeviceProcAddr(currentDevice, "vkImportFenceWin32HandleKHR");
  $vkGetFenceFdKHR = (PFN_vkGetFenceFdKHR) vkGetDeviceProcAddr(currentDevice, "vkGetFenceFdKHR");
  $vkImportFenceFdKHR = (PFN_vkImportFenceFdKHR) vkGetDeviceProcAddr(currentDevice, "vkImportFenceFdKHR");
  $vkDisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT) vkGetDeviceProcAddr(currentDevice, "vkDisplayPowerControlEXT");
  $vkRegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT) vkGetDeviceProcAddr(currentDevice, "vkRegisterDeviceEventEXT");
  $vkRegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT) vkGetDeviceProcAddr(currentDevice, "vkRegisterDisplayEventEXT");
  $vkGetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT) vkGetDeviceProcAddr(currentDevice, "vkGetSwapchainCounterEXT");
  $vkGetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetDeviceGroupPresentCapabilitiesKHR");
  $vkGetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetDeviceGroupSurfacePresentModesKHR");
  $vkAcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR) vkGetDeviceProcAddr(currentDevice, "vkAcquireNextImage2KHR");
  $vkGetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDevicePresentRectanglesKHR");
  $vkCmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR) vkGetDeviceProcAddr(currentDevice, "vkCmdPushDescriptorSetWithTemplateKHR");
  $vkSetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT) vkGetDeviceProcAddr(currentDevice, "vkSetHdrMetadataEXT");
  $vkGetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR) vkGetDeviceProcAddr(currentDevice, "vkGetSwapchainStatusKHR");
  $vkGetRefreshCycleDurationGOOGLE = (PFN_vkGetRefreshCycleDurationGOOGLE) vkGetDeviceProcAddr(currentDevice, "vkGetRefreshCycleDurationGOOGLE");
  $vkGetPastPresentationTimingGOOGLE = (PFN_vkGetPastPresentationTimingGOOGLE) vkGetDeviceProcAddr(currentDevice, "vkGetPastPresentationTimingGOOGLE");
  $vkCmdSetViewportWScalingNV = (PFN_vkCmdSetViewportWScalingNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetViewportWScalingNV");
  $vkCmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdSetDiscardRectangleEXT");
  $vkCmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdSetSampleLocationsEXT");
  $vkGetPhysicalDeviceMultisamplePropertiesEXT = (PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
  $vkCreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT) vkGetDeviceProcAddr(currentDevice, "vkCreateValidationCacheEXT");
  $vkDestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT) vkGetDeviceProcAddr(currentDevice, "vkDestroyValidationCacheEXT");
  $vkGetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT) vkGetDeviceProcAddr(currentDevice, "vkGetValidationCacheDataEXT");
  $vkMergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT) vkGetDeviceProcAddr(currentDevice, "vkMergeValidationCachesEXT");
  $vkGetShaderInfoAMD = (PFN_vkGetShaderInfoAMD) vkGetDeviceProcAddr(currentDevice, "vkGetShaderInfoAMD");
  $vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
  $vkGetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT) vkGetDeviceProcAddr(currentDevice, "vkGetCalibratedTimestampsEXT");
  $vkGetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT) vkGetDeviceProcAddr(currentDevice, "vkGetMemoryHostPointerPropertiesEXT");
  $vkCmdWriteBufferMarkerAMD = (PFN_vkCmdWriteBufferMarkerAMD) vkGetDeviceProcAddr(currentDevice, "vkCmdWriteBufferMarkerAMD");
  $vkCreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR) vkGetDeviceProcAddr(currentDevice, "vkCreateRenderPass2KHR");
  $vkCmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR) vkGetDeviceProcAddr(currentDevice, "vkCmdBeginRenderPass2KHR");
  $vkCmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR) vkGetDeviceProcAddr(currentDevice, "vkCmdNextSubpass2KHR");
  $vkCmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR) vkGetDeviceProcAddr(currentDevice, "vkCmdEndRenderPass2KHR");
  $vkCmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndirectCountKHR");
  $vkCmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndexedIndirectCountKHR");
  $vkCmdSetCheckpointNV = (PFN_vkCmdSetCheckpointNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetCheckpointNV");
  $vkGetQueueCheckpointDataNV = (PFN_vkGetQueueCheckpointDataNV) vkGetDeviceProcAddr(currentDevice, "vkGetQueueCheckpointDataNV");
  $vkCmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdBindTransformFeedbackBuffersEXT");
  $vkCmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdBeginTransformFeedbackEXT");
  $vkCmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdEndTransformFeedbackEXT");
  $vkCmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdBeginQueryIndexedEXT");
  $vkCmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdEndQueryIndexedEXT");
  $vkCmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawIndirectByteCountEXT");
  $vkCmdSetExclusiveScissorNV = (PFN_vkCmdSetExclusiveScissorNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetExclusiveScissorNV");
  $vkCmdBindShadingRateImageNV = (PFN_vkCmdBindShadingRateImageNV) vkGetDeviceProcAddr(currentDevice, "vkCmdBindShadingRateImageNV");
  $vkCmdSetViewportShadingRatePaletteNV = (PFN_vkCmdSetViewportShadingRatePaletteNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetViewportShadingRatePaletteNV");
  $vkCmdSetCoarseSampleOrderNV = (PFN_vkCmdSetCoarseSampleOrderNV) vkGetDeviceProcAddr(currentDevice, "vkCmdSetCoarseSampleOrderNV");
  $vkCmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawMeshTasksNV");
  $vkCmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawMeshTasksIndirectNV");
  $vkCmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV) vkGetDeviceProcAddr(currentDevice, "vkCmdDrawMeshTasksIndirectCountNV");
  $vkCompileDeferredNV = (PFN_vkCompileDeferredNV) vkGetDeviceProcAddr(currentDevice, "vkCompileDeferredNV");
  $vkCreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV) vkGetDeviceProcAddr(currentDevice, "vkCreateAccelerationStructureNV");
  $vkDestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV) vkGetDeviceProcAddr(currentDevice, "vkDestroyAccelerationStructureNV");
  $vkGetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV) vkGetDeviceProcAddr(currentDevice, "vkGetAccelerationStructureMemoryRequirementsNV");
  $vkBindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV) vkGetDeviceProcAddr(currentDevice, "vkBindAccelerationStructureMemoryNV");
  $vkCmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV) vkGetDeviceProcAddr(currentDevice, "vkCmdCopyAccelerationStructureNV");
  $vkCmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV) vkGetDeviceProcAddr(currentDevice, "vkCmdWriteAccelerationStructuresPropertiesNV");
  $vkCmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV) vkGetDeviceProcAddr(currentDevice, "vkCmdBuildAccelerationStructureNV");
  $vkCmdTraceRaysNV = (PFN_vkCmdTraceRaysNV) vkGetDeviceProcAddr(currentDevice, "vkCmdTraceRaysNV");
  $vkGetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV) vkGetDeviceProcAddr(currentDevice, "vkGetRayTracingShaderGroupHandlesNV");
  $vkGetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV) vkGetDeviceProcAddr(currentDevice, "vkGetAccelerationStructureHandleNV");
  $vkCreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV) vkGetDeviceProcAddr(currentDevice, "vkCreateRayTracingPipelinesNV");
  $vkGetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT) vkGetDeviceProcAddr(currentDevice, "vkGetImageDrmFormatModifierPropertiesEXT");
  $vkGetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT) vkGetDeviceProcAddr(currentDevice, "vkGetBufferDeviceAddressEXT");
  $vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV) vkGetDeviceProcAddr(currentDevice, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
};

void vkUseInstance(VkInstance pInstance) {
  currentInstance = pInstance;
  $vkGetPhysicalDeviceDisplayPropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceDisplayPropertiesKHR");
  $vkGetPhysicalDeviceDisplayPlanePropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
  $vkGetDisplayPlaneSupportedDisplaysKHR = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayPlaneSupportedDisplaysKHR");
  $vkGetDisplayModePropertiesKHR = (PFN_vkGetDisplayModePropertiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayModePropertiesKHR");
  $vkCreateDisplayModeKHR = (PFN_vkCreateDisplayModeKHR) vkGetInstanceProcAddr(currentInstance, "vkCreateDisplayModeKHR");
  $vkGetDisplayPlaneCapabilitiesKHR = (PFN_vkGetDisplayPlaneCapabilitiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayPlaneCapabilitiesKHR");
  $vkCreateDisplayPlaneSurfaceKHR = (PFN_vkCreateDisplayPlaneSurfaceKHR) vkGetInstanceProcAddr(currentInstance, "vkCreateDisplayPlaneSurfaceKHR");
  $vkDestroySurfaceKHR = (PFN_vkDestroySurfaceKHR) vkGetInstanceProcAddr(currentInstance, "vkDestroySurfaceKHR");
  $vkGetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceSupportKHR");
  $vkGetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
  $vkGetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceFormatsKHR");
  $vkGetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfacePresentModesKHR");
  $vkCreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(currentInstance, "vkCreateWin32SurfaceKHR");
  $vkGetPhysicalDeviceWin32PresentationSupportKHR = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
  $vkCreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT) vkGetInstanceProcAddr(currentInstance, "vkCreateDebugReportCallbackEXT");
  $vkDestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT) vkGetInstanceProcAddr(currentInstance, "vkDestroyDebugReportCallbackEXT");
  $vkDebugReportMessageEXT = (PFN_vkDebugReportMessageEXT) vkGetInstanceProcAddr(currentInstance, "vkDebugReportMessageEXT");
  $vkGetPhysicalDeviceExternalImageFormatPropertiesNV = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
  $vkReleaseDisplayEXT = (PFN_vkReleaseDisplayEXT) vkGetInstanceProcAddr(currentInstance, "vkReleaseDisplayEXT");
  $vkGetPhysicalDeviceSurfaceCapabilities2EXT = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
  $vkGetPhysicalDeviceSurfaceCapabilities2KHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR");
  $vkGetPhysicalDeviceSurfaceFormats2KHR = (PFN_vkGetPhysicalDeviceSurfaceFormats2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceSurfaceFormats2KHR");
  $vkGetPhysicalDeviceDisplayProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayProperties2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceDisplayProperties2KHR");
  $vkGetPhysicalDeviceDisplayPlaneProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
  $vkGetDisplayModeProperties2KHR = (PFN_vkGetDisplayModeProperties2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayModeProperties2KHR");
  $vkGetDisplayPlaneCapabilities2KHR = (PFN_vkGetDisplayPlaneCapabilities2KHR) vkGetInstanceProcAddr(currentInstance, "vkGetDisplayPlaneCapabilities2KHR");
  $vkSetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT) vkGetInstanceProcAddr(currentInstance, "vkSetDebugUtilsObjectNameEXT");
  $vkSetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT) vkGetInstanceProcAddr(currentInstance, "vkSetDebugUtilsObjectTagEXT");
  $vkQueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkQueueBeginDebugUtilsLabelEXT");
  $vkQueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkQueueEndDebugUtilsLabelEXT");
  $vkQueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkQueueInsertDebugUtilsLabelEXT");
  $vkCmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkCmdBeginDebugUtilsLabelEXT");
  $vkCmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkCmdEndDebugUtilsLabelEXT");
  $vkCmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT) vkGetInstanceProcAddr(currentInstance, "vkCmdInsertDebugUtilsLabelEXT");
  $vkCreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(currentInstance, "vkCreateDebugUtilsMessengerEXT");
  $vkDestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(currentInstance, "vkDestroyDebugUtilsMessengerEXT");
  $vkSubmitDebugUtilsMessageEXT = (PFN_vkSubmitDebugUtilsMessageEXT) vkGetInstanceProcAddr(currentInstance, "vkSubmitDebugUtilsMessageEXT");
};

Napi::Value _vkUseDevice(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    vkUseDevice(*instance);
  } else if (info[0].IsNull()) {
    currentDevice = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'pDevice'").ThrowAsJavaScriptException();
  }
  return env.Undefined();
};

Napi::Value _vkUseInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    vkUseInstance(*instance);
  } else if (info[0].IsNull()) {
    currentInstance = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'pInstance'").ThrowAsJavaScriptException();
  }
  return env.Undefined();
};

Napi::Value _vkCreateInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstanceCreateInfo *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO) {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstanceCreateInfo]");
      return env.Undefined();
    }
    obj0 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkInstanceCreateInfo* instance = reinterpret_cast<VkInstanceCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstanceCreateInfo' or 'null' for argument 1 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj2;
  VkInstance *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkInstance]");
      return env.Undefined();
    }
    obj2 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 3 'pInstance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateInstance(
    $p0,
    nullptr,
    $p2
  );
  
  vkUseInstance(*$p2);
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyInstance(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyInstance(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkEnumeratePhysicalDevices(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPhysicalDeviceCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkPhysicalDevice>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkPhysicalDevice> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkPhysicalDevice>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pPhysicalDevices'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkEnumeratePhysicalDevices(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkPhysicalDevice *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkPhysicalDevice* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDeviceProcAddr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  char* $p1 = nullptr;
  if (info[1].IsString()) {
    $p1 = copyV8String(info[1]);
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 2 'pName'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  PFN_vkVoidFunction out = vkGetDeviceProcAddr(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if ($p1) delete[] $p1;
  
  
  return Napi::Number::New(env, 0);
  
};

Napi::Value _vkGetInstanceProcAddr(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  char* $p1 = nullptr;
  if (info[1].IsString()) {
    $p1 = copyV8String(info[1]);
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 2 'pName'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  PFN_vkVoidFunction out = vkGetInstanceProcAddr(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if ($p1) delete[] $p1;
  
  
  return Napi::Number::New(env, 0);
  
};

Napi::Value _vkGetPhysicalDeviceProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceProperties *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDeviceProperties") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceProperties]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceProperties* instance = reinterpret_cast<VkPhysicalDeviceProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceProperties' or 'null' for argument 2 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if (info[1].IsObject()) {
     Napi::Object obj = info[1].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p1));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceQueueFamilyProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pQueueFamilyPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkQueueFamilyProperties>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkQueueFamilyProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkQueueFamilyProperties* instance = reinterpret_cast<VkQueueFamilyProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkQueueFamilyProperties>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pQueueFamilyProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkGetPhysicalDeviceQueueFamilyProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkQueueFamilyProperties *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkQueueFamilyProperties* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceMemoryProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceMemoryProperties *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDeviceMemoryProperties") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceMemoryProperties]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceMemoryProperties* instance = reinterpret_cast<VkPhysicalDeviceMemoryProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceMemoryProperties' or 'null' for argument 2 'pMemoryProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceMemoryProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if (info[1].IsObject()) {
     Napi::Object obj = info[1].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p1));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceFeatures *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDeviceFeatures") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceFeatures]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceFeatures* instance = reinterpret_cast<VkPhysicalDeviceFeatures*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceFeatures' or 'null' for argument 2 'pFeatures'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceFeatures(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if (info[1].IsObject()) {
     Napi::Object obj = info[1].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p1));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkFormatProperties *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFormatProperties") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkFormatProperties]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkFormatProperties* instance = reinterpret_cast<VkFormatProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFormatProperties' or 'null' for argument 3 'pFormatProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceFormatProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceImageFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  VkImageType $p2 = static_cast<VkImageType>(info[2].As<Napi::Number>().Int64Value());

  VkImageTiling $p3 = static_cast<VkImageTiling>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  int32_t $p5 = static_cast<int32_t>(info[5].As<Napi::Number>().Int64Value());

  Napi::Object obj6;
  VkImageFormatProperties *$p6 = nullptr;
  if (info[6].IsObject()) {
    Napi::Object obj = info[6].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImageFormatProperties") {
      NapiObjectTypeError(info[6], "argument 7", "[object VkImageFormatProperties]");
      return env.Undefined();
    }
    obj6 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImageFormatProperties* instance = reinterpret_cast<VkImageFormatProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p6 = instance;
  } else if (info[6].IsNull()) {
    $p6 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageFormatProperties' or 'null' for argument 7 'pImageFormatProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkGetPhysicalDeviceImageFormatProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    static_cast<VkImageUsageFlags>($p4),
    static_cast<VkImageCreateFlags>($p5),
    $p6
  );
  if (info[6].IsObject()) {
     Napi::Object obj = info[6].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p6));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateDevice(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDeviceCreateInfo* instance = reinterpret_cast<VkDeviceCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkDevice *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDevice]");
      return env.Undefined();
    }
    obj3 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 4 'pDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateDevice(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  vkUseDevice(*$p3);
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyDevice(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyDevice(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkEnumerateInstanceVersion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  uint32_t $p0 = 0;
  if (info[0].IsObject()) {
    obj0 = info[0].As<Napi::Object>();
    if (!obj0.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 1").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj0.Get("$");
    $p0 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[0].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'pApiVersion'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkEnumerateInstanceVersion(
    &$p0
  );
    if (info[0].IsObject()) obj0.Set("$", $p0);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkEnumerateInstanceLayerProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  uint32_t $p0 = 0;
  if (info[0].IsObject()) {
    obj0 = info[0].As<Napi::Object>();
    if (!obj0.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 1").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj0.Get("$");
    $p0 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[0].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 1 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkLayerProperties>> $p1 = nullptr;

  if (info[1].IsArray()) {

  {
    Napi::Array array = info[1].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[1].As<Napi::Array>();
    std::vector<VkLayerProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkLayerProperties* instance = reinterpret_cast<VkLayerProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p1 = std::make_shared<std::vector<VkLayerProperties>>(data);
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 2 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkEnumerateInstanceLayerProperties(
    &$p0,
    $p1 ? (VkLayerProperties *) $p1.get()->data() : nullptr
  );
    if (info[0].IsObject()) obj0.Set("$", $p0);
  if (info[1].IsArray()) {
    VkLayerProperties* $pdata = $p1.get()->data();
    Napi::Array array = info[1].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkEnumerateInstanceExtensionProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  char* $p0 = nullptr;
  if (info[0].IsString()) {
    $p0 = copyV8String(info[0]);
  } else if (!info[0].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 1 'pLayerName'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkExtensionProperties>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkExtensionProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkExtensionProperties* instance = reinterpret_cast<VkExtensionProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkExtensionProperties>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkEnumerateInstanceExtensionProperties(
    $p0,
    &$p1,
    $p2 ? (VkExtensionProperties *) $p2.get()->data() : nullptr
  );
  if ($p0) delete[] $p0;
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkExtensionProperties* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkEnumerateDeviceLayerProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkLayerProperties>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkLayerProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkLayerProperties* instance = reinterpret_cast<VkLayerProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkLayerProperties>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkEnumerateDeviceLayerProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkLayerProperties *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkLayerProperties* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkEnumerateDeviceExtensionProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  char* $p1 = nullptr;
  if (info[1].IsString()) {
    $p1 = copyV8String(info[1]);
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 2 'pLayerName'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkExtensionProperties>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkExtensionProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkExtensionProperties* instance = reinterpret_cast<VkExtensionProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkExtensionProperties>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkEnumerateDeviceExtensionProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkExtensionProperties *) $p3.get()->data() : nullptr
  );
  if ($p1) delete[] $p1;
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkExtensionProperties* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDeviceQueue(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkQueue *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkQueue]");
      return env.Undefined();
    }
    obj3 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 4 'pQueue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetDeviceQueue(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkQueueSubmit(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkQueue *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return env.Undefined();
    }
    obj0 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkSubmitInfo>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkSubmitInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSubmitInfo* instance = reinterpret_cast<VkSubmitInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkSubmitInfo>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pSubmits'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkFence *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFence") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkFence]");
      return env.Undefined();
    }
    obj3 = obj;
    VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFence' or 'null' for argument 4 'fence'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkQueueSubmit(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkSubmitInfo *) $p2.get()->data() : nullptr,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkQueueWaitIdle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkQueue *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return env.Undefined();
    }
    obj0 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkQueueWaitIdle(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDeviceWaitIdle(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkDeviceWaitIdle(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkAllocateMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkMemoryAllocateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkMemoryAllocateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryAllocateInfo* instance = reinterpret_cast<VkMemoryAllocateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryAllocateInfo' or 'null' for argument 2 'pAllocateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkDeviceMemory *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDeviceMemory") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDeviceMemory]");
      return env.Undefined();
    }
    obj3 = obj;
    VkDeviceMemory* instance = reinterpret_cast<VkDeviceMemory*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceMemory' or 'null' for argument 4 'pMemory'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkAllocateMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkFreeMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceMemory *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDeviceMemory") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDeviceMemory* instance = reinterpret_cast<VkDeviceMemory*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceMemory' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkFreeMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkMapMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceMemory *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDeviceMemory") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDeviceMemory* instance = reinterpret_cast<VkDeviceMemory*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceMemory' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  Napi::Object obj5 = info[5].As<Napi::Object>();
  void *$p5 = nullptr;
  int32_t out = vkMapMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    static_cast<VkMemoryMapFlags>($p4),
    &$p5
  );
  Napi::BigInt ptr5 = Napi::BigInt::New(env, (int64_t)$p5);
  if (info[5].IsObject()) obj5.Set("$", ptr5);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkUnmapMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceMemory *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDeviceMemory") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDeviceMemory* instance = reinterpret_cast<VkDeviceMemory*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceMemory' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkUnmapMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkFlushMappedMemoryRanges(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkMappedMemoryRange>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkMappedMemoryRange> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkMappedMemoryRange* instance = reinterpret_cast<VkMappedMemoryRange*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkMappedMemoryRange>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pMemoryRanges'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkFlushMappedMemoryRanges(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkMappedMemoryRange *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkInvalidateMappedMemoryRanges(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkMappedMemoryRange>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkMappedMemoryRange> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkMappedMemoryRange* instance = reinterpret_cast<VkMappedMemoryRange*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkMappedMemoryRange>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pMemoryRanges'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkInvalidateMappedMemoryRanges(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkMappedMemoryRange *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDeviceMemoryCommitment(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceMemory *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDeviceMemory") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDeviceMemory* instance = reinterpret_cast<VkDeviceMemory*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceMemory' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint64_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint64_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pCommittedMemoryInBytes'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetDeviceMemoryCommitment(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2
  );
    Napi::BigInt pnum2 = Napi::BigInt::New(env, (uint64_t)$p2);
    if (info[2].IsObject()) obj2.Set("$", pnum2);
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetBufferMemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkMemoryRequirements *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkMemoryRequirements") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryRequirements* instance = reinterpret_cast<VkMemoryRequirements*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryRequirements' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetBufferMemoryRequirements(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkBindBufferMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDeviceMemory *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDeviceMemory") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDeviceMemory]");
      return env.Undefined();
    }
    obj2 = obj;
    VkDeviceMemory* instance = reinterpret_cast<VkDeviceMemory*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceMemory' or 'null' for argument 3 'memory'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());
  int32_t out = vkBindBufferMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetImageMemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkMemoryRequirements *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkMemoryRequirements") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryRequirements* instance = reinterpret_cast<VkMemoryRequirements*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryRequirements' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetImageMemoryRequirements(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkBindImageMemory(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDeviceMemory *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDeviceMemory") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDeviceMemory]");
      return env.Undefined();
    }
    obj2 = obj;
    VkDeviceMemory* instance = reinterpret_cast<VkDeviceMemory*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceMemory' or 'null' for argument 3 'memory'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());
  int32_t out = vkBindImageMemory(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetImageSparseMemoryRequirements(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSparseMemoryRequirementCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkSparseImageMemoryRequirements>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSparseImageMemoryRequirements> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSparseImageMemoryRequirements* instance = reinterpret_cast<VkSparseImageMemoryRequirements*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkSparseImageMemoryRequirements>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSparseMemoryRequirements'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkGetImageSparseMemoryRequirements(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkSparseImageMemoryRequirements *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSparseImageMemoryRequirements* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceSparseImageFormatProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  VkImageType $p2 = static_cast<VkImageType>(info[2].As<Napi::Number>().Int64Value());

  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  VkImageTiling $p5 = static_cast<VkImageTiling>(info[5].As<Napi::Number>().Int64Value());

  Napi::Object obj6;
  uint32_t $p6 = 0;
  if (info[6].IsObject()) {
    obj6 = info[6].As<Napi::Object>();
    if (!obj6.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 7").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj6.Get("$");
    $p6 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 7 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkSparseImageFormatProperties>> $p7 = nullptr;

  if (info[7].IsArray()) {

  {
    Napi::Array array = info[7].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[7].As<Napi::Array>();
    std::vector<VkSparseImageFormatProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSparseImageFormatProperties* instance = reinterpret_cast<VkSparseImageFormatProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p7 = std::make_shared<std::vector<VkSparseImageFormatProperties>>(data);
  } else if (!info[7].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 8 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkGetPhysicalDeviceSparseImageFormatProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    static_cast<VkSampleCountFlagBits>($p3),
    static_cast<VkImageUsageFlags>($p4),
    $p5,
    &$p6,
    $p7 ? (VkSparseImageFormatProperties *) $p7.get()->data() : nullptr
  );
    if (info[6].IsObject()) obj6.Set("$", $p6);
  if (info[7].IsArray()) {
    VkSparseImageFormatProperties* $pdata = $p7.get()->data();
    Napi::Array array = info[7].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkQueueBindSparse(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkQueue *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return env.Undefined();
    }
    obj0 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBindSparseInfo>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkBindSparseInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBindSparseInfo* instance = reinterpret_cast<VkBindSparseInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkBindSparseInfo>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pBindInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkFence *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFence") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkFence]");
      return env.Undefined();
    }
    obj3 = obj;
    VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFence' or 'null' for argument 4 'fence'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkQueueBindSparse(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkBindSparseInfo *) $p2.get()->data() : nullptr,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateFence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkFenceCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_FENCE_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkFenceCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkFenceCreateInfo* instance = reinterpret_cast<VkFenceCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFenceCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkFence *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFence") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkFence]");
      return env.Undefined();
    }
    obj3 = obj;
    VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFence' or 'null' for argument 4 'pFence'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateFence(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyFence(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkFence *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFence") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkFence]");
      return env.Undefined();
    }
    obj1 = obj;
    VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFence' or 'null' for argument 2 'fence'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyFence(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkResetFences(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkFence>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkFence> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkFence>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pFences'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkResetFences(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkFence *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetFenceStatus(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkFence *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFence") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkFence]");
      return env.Undefined();
    }
    obj1 = obj;
    VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFence' or 'null' for argument 2 'fence'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkGetFenceStatus(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkWaitForFences(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkFence>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkFence> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkFence>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pFences'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());
  int32_t out = vkWaitForFences(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkFence *) $p2.get()->data() : nullptr,
    $p3,
    $p4
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateSemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSemaphoreCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSemaphoreCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSemaphoreCreateInfo* instance = reinterpret_cast<VkSemaphoreCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSemaphoreCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkSemaphore *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSemaphore") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkSemaphore]");
      return env.Undefined();
    }
    obj3 = obj;
    VkSemaphore* instance = reinterpret_cast<VkSemaphore*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSemaphore' or 'null' for argument 4 'pSemaphore'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateSemaphore(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroySemaphore(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSemaphore *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSemaphore") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSemaphore]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSemaphore* instance = reinterpret_cast<VkSemaphore*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSemaphore' or 'null' for argument 2 'semaphore'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroySemaphore(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkEventCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_EVENT_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkEventCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkEventCreateInfo* instance = reinterpret_cast<VkEventCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkEventCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkEvent *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkEvent") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkEvent]");
      return env.Undefined();
    }
    obj3 = obj;
    VkEvent* instance = reinterpret_cast<VkEvent*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkEvent' or 'null' for argument 4 'pEvent'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkEvent *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkEvent") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return env.Undefined();
    }
    obj1 = obj;
    VkEvent* instance = reinterpret_cast<VkEvent*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkEvent' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetEventStatus(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkEvent *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkEvent") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return env.Undefined();
    }
    obj1 = obj;
    VkEvent* instance = reinterpret_cast<VkEvent*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkEvent' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkGetEventStatus(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkSetEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkEvent *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkEvent") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return env.Undefined();
    }
    obj1 = obj;
    VkEvent* instance = reinterpret_cast<VkEvent*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkEvent' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkSetEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkResetEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkEvent *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkEvent") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return env.Undefined();
    }
    obj1 = obj;
    VkEvent* instance = reinterpret_cast<VkEvent*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkEvent' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkResetEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateQueryPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPoolCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPoolCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkQueryPoolCreateInfo* instance = reinterpret_cast<VkQueryPoolCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPoolCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkQueryPool *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj3 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 4 'pQueryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateQueryPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyQueryPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyQueryPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetQueryPoolResults(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  size_t $p4 = static_cast<size_t>(info[4].As<Napi::Number>().Int64Value());

  void* $p5 = nullptr;
  if (info[5].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[5].As<Napi::ArrayBuffer>();
    $p5 = buf.Data();
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 6 'pData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p6 = static_cast<uint64_t>(info[6].As<Napi::Number>().Int64Value());

  int32_t $p7 = static_cast<int32_t>(info[7].As<Napi::Number>().Int64Value());
  int32_t out = vkGetQueryPoolResults(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    info[5].IsNull() ? nullptr : $p5,
    $p6,
    static_cast<VkQueryResultFlags>($p7)
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBufferCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBufferCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkBufferCreateInfo* instance = reinterpret_cast<VkBufferCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBufferCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'pBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateBufferView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBufferViewCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBufferViewCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkBufferViewCreateInfo* instance = reinterpret_cast<VkBufferViewCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBufferViewCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkBufferView *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBufferView") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBufferView]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBufferView* instance = reinterpret_cast<VkBufferView*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBufferView' or 'null' for argument 4 'pView'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateBufferView(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyBufferView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBufferView *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBufferView") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBufferView]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBufferView* instance = reinterpret_cast<VkBufferView*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBufferView' or 'null' for argument 2 'bufferView'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyBufferView(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImageCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImageCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImageCreateInfo* instance = reinterpret_cast<VkImageCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkImage *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkImage]");
      return env.Undefined();
    }
    obj3 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 4 'pImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetImageSubresourceLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkImageSubresource *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImageSubresource") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkImageSubresource]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImageSubresource* instance = reinterpret_cast<VkImageSubresource*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageSubresource' or 'null' for argument 3 'pSubresource'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj3;
  VkSubresourceLayout *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSubresourceLayout") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkSubresourceLayout]");
      return env.Undefined();
    }
    obj3 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSubresourceLayout* instance = reinterpret_cast<VkSubresourceLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSubresourceLayout' or 'null' for argument 4 'pLayout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetImageSubresourceLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  if (info[3].IsObject()) {
     Napi::Object obj = info[3].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p3));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateImageView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImageViewCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImageViewCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImageViewCreateInfo* instance = reinterpret_cast<VkImageViewCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageViewCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkImageView *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImageView") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkImageView]");
      return env.Undefined();
    }
    obj3 = obj;
    VkImageView* instance = reinterpret_cast<VkImageView*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageView' or 'null' for argument 4 'pView'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateImageView(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyImageView(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImageView *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImageView") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImageView]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImageView* instance = reinterpret_cast<VkImageView*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageView' or 'null' for argument 2 'imageView'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyImageView(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateShaderModule(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkShaderModuleCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkShaderModuleCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkShaderModuleCreateInfo* instance = reinterpret_cast<VkShaderModuleCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkShaderModuleCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkShaderModule *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkShaderModule") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkShaderModule]");
      return env.Undefined();
    }
    obj3 = obj;
    VkShaderModule* instance = reinterpret_cast<VkShaderModule*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkShaderModule' or 'null' for argument 4 'pShaderModule'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateShaderModule(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyShaderModule(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkShaderModule *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkShaderModule") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkShaderModule]");
      return env.Undefined();
    }
    obj1 = obj;
    VkShaderModule* instance = reinterpret_cast<VkShaderModule*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkShaderModule' or 'null' for argument 2 'shaderModule'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyShaderModule(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreatePipelineCache(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineCacheCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineCacheCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPipelineCacheCreateInfo* instance = reinterpret_cast<VkPipelineCacheCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineCacheCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkPipelineCache *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineCache") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkPipelineCache]");
      return env.Undefined();
    }
    obj3 = obj;
    VkPipelineCache* instance = reinterpret_cast<VkPipelineCache*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineCache' or 'null' for argument 4 'pPipelineCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreatePipelineCache(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyPipelineCache(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineCache *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineCache") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipelineCache* instance = reinterpret_cast<VkPipelineCache*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineCache' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyPipelineCache(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPipelineCacheData(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineCache *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineCache") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipelineCache* instance = reinterpret_cast<VkPipelineCache*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineCache' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  size_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<size_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDataSize'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  void* $p3 = nullptr;
  if (info[3].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[3].As<Napi::ArrayBuffer>();
    $p3 = buf.Data();
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 4 'pData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkGetPipelineCacheData(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    info[3].IsNull() ? nullptr : $p3
  );
    Napi::BigInt pnum2 = Napi::BigInt::New(env, (uint64_t)$p2);
    if (info[2].IsObject()) obj2.Set("$", pnum2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkMergePipelineCaches(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineCache *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineCache") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipelineCache* instance = reinterpret_cast<VkPipelineCache*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineCache' or 'null' for argument 2 'dstCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkPipelineCache>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkPipelineCache> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkPipelineCache* instance = reinterpret_cast<VkPipelineCache*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkPipelineCache>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSrcCaches'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkMergePipelineCaches(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkPipelineCache *) $p3.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateGraphicsPipelines(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineCache *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineCache") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipelineCache* instance = reinterpret_cast<VkPipelineCache*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineCache' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkGraphicsPipelineCreateInfo>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkGraphicsPipelineCreateInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkGraphicsPipelineCreateInfo* instance = reinterpret_cast<VkGraphicsPipelineCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkGraphicsPipelineCreateInfo>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCreateInfos'").ThrowAsJavaScriptException();
    return env.Undefined();
  }



  std::shared_ptr<std::vector<VkPipeline>> $p5 = nullptr;

  if (info[5].IsArray()) {

    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkPipeline> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkPipeline* instance = reinterpret_cast<VkPipeline*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkPipeline>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pPipelines'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkCreateGraphicsPipelines(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkGraphicsPipelineCreateInfo *) $p3.get()->data() : nullptr,
    nullptr,
    $p5 ? (VkPipeline *) $p5.get()->data() : nullptr
  );
  if (info[5].IsArray()) {
    VkPipeline* $pdata = $p5.get()->data();
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateComputePipelines(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineCache *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineCache") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipelineCache* instance = reinterpret_cast<VkPipelineCache*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineCache' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkComputePipelineCreateInfo>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkComputePipelineCreateInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkComputePipelineCreateInfo* instance = reinterpret_cast<VkComputePipelineCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkComputePipelineCreateInfo>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCreateInfos'").ThrowAsJavaScriptException();
    return env.Undefined();
  }



  std::shared_ptr<std::vector<VkPipeline>> $p5 = nullptr;

  if (info[5].IsArray()) {

    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkPipeline> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkPipeline* instance = reinterpret_cast<VkPipeline*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkPipeline>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pPipelines'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkCreateComputePipelines(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkComputePipelineCreateInfo *) $p3.get()->data() : nullptr,
    nullptr,
    $p5 ? (VkPipeline *) $p5.get()->data() : nullptr
  );
  if (info[5].IsArray()) {
    VkPipeline* $pdata = $p5.get()->data();
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyPipeline(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipeline *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipeline") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipeline]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipeline* instance = reinterpret_cast<VkPipeline*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipeline' or 'null' for argument 2 'pipeline'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyPipeline(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreatePipelineLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineLayoutCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineLayoutCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPipelineLayoutCreateInfo* instance = reinterpret_cast<VkPipelineLayoutCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineLayoutCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkPipelineLayout *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineLayout") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkPipelineLayout]");
      return env.Undefined();
    }
    obj3 = obj;
    VkPipelineLayout* instance = reinterpret_cast<VkPipelineLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineLayout' or 'null' for argument 4 'pPipelineLayout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreatePipelineLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyPipelineLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineLayout *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineLayout") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineLayout]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipelineLayout* instance = reinterpret_cast<VkPipelineLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineLayout' or 'null' for argument 2 'pipelineLayout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyPipelineLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateSampler(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSamplerCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSamplerCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSamplerCreateInfo* instance = reinterpret_cast<VkSamplerCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSamplerCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkSampler *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSampler") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkSampler]");
      return env.Undefined();
    }
    obj3 = obj;
    VkSampler* instance = reinterpret_cast<VkSampler*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSampler' or 'null' for argument 4 'pSampler'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateSampler(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroySampler(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSampler *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSampler") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSampler]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSampler* instance = reinterpret_cast<VkSampler*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSampler' or 'null' for argument 2 'sampler'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroySampler(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateDescriptorSetLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorSetLayoutCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorSetLayoutCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDescriptorSetLayoutCreateInfo* instance = reinterpret_cast<VkDescriptorSetLayoutCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorSetLayoutCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkDescriptorSetLayout *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorSetLayout") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDescriptorSetLayout]");
      return env.Undefined();
    }
    obj3 = obj;
    VkDescriptorSetLayout* instance = reinterpret_cast<VkDescriptorSetLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorSetLayout' or 'null' for argument 4 'pSetLayout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateDescriptorSetLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyDescriptorSetLayout(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorSetLayout *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorSetLayout") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorSetLayout]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDescriptorSetLayout* instance = reinterpret_cast<VkDescriptorSetLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorSetLayout' or 'null' for argument 2 'descriptorSetLayout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyDescriptorSetLayout(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateDescriptorPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorPoolCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorPoolCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDescriptorPoolCreateInfo* instance = reinterpret_cast<VkDescriptorPoolCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorPoolCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkDescriptorPool *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorPool") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDescriptorPool]");
      return env.Undefined();
    }
    obj3 = obj;
    VkDescriptorPool* instance = reinterpret_cast<VkDescriptorPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorPool' or 'null' for argument 4 'pDescriptorPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateDescriptorPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyDescriptorPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDescriptorPool* instance = reinterpret_cast<VkDescriptorPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorPool' or 'null' for argument 2 'descriptorPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyDescriptorPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkResetDescriptorPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDescriptorPool* instance = reinterpret_cast<VkDescriptorPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorPool' or 'null' for argument 2 'descriptorPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
  int32_t out = vkResetDescriptorPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkDescriptorPoolResetFlags>($p2)
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkAllocateDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorSetAllocateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorSetAllocateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDescriptorSetAllocateInfo* instance = reinterpret_cast<VkDescriptorSetAllocateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorSetAllocateInfo' or 'null' for argument 2 'pAllocateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkDescriptorSet>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDescriptorSet* instance = reinterpret_cast<VkDescriptorSet*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkDescriptorSet>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pDescriptorSets'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkAllocateDescriptorSets(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (VkDescriptorSet *) $p2.get()->data() : nullptr
  );
  if (info[2].IsArray()) {
    VkDescriptorSet* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkFreeDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDescriptorPool* instance = reinterpret_cast<VkDescriptorPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorPool' or 'null' for argument 2 'descriptorPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkDescriptorSet>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDescriptorSet* instance = reinterpret_cast<VkDescriptorSet*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkDescriptorSet>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pDescriptorSets'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkFreeDescriptorSets(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkDescriptorSet *) $p3.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkUpdateDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkWriteDescriptorSet>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkWriteDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkWriteDescriptorSet* instance = reinterpret_cast<VkWriteDescriptorSet*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkWriteDescriptorSet>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pDescriptorWrites'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCopyDescriptorSet>> $p4 = nullptr;

  if (info[4].IsArray()) {

  {
    Napi::Array array = info[4].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[4].As<Napi::Array>();
    std::vector<VkCopyDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkCopyDescriptorSet* instance = reinterpret_cast<VkCopyDescriptorSet*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p4 = std::make_shared<std::vector<VkCopyDescriptorSet>>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pDescriptorCopies'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkUpdateDescriptorSets(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkWriteDescriptorSet *) $p2.get()->data() : nullptr,
    $p3,
    $p4 ? (const VkCopyDescriptorSet *) $p4.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateFramebuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkFramebufferCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkFramebufferCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkFramebufferCreateInfo* instance = reinterpret_cast<VkFramebufferCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFramebufferCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkFramebuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFramebuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkFramebuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkFramebuffer* instance = reinterpret_cast<VkFramebuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFramebuffer' or 'null' for argument 4 'pFramebuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateFramebuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyFramebuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkFramebuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFramebuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkFramebuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkFramebuffer* instance = reinterpret_cast<VkFramebuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFramebuffer' or 'null' for argument 2 'framebuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyFramebuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateRenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkRenderPassCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkRenderPassCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkRenderPassCreateInfo* instance = reinterpret_cast<VkRenderPassCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRenderPassCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkRenderPass *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkRenderPass") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkRenderPass]");
      return env.Undefined();
    }
    obj3 = obj;
    VkRenderPass* instance = reinterpret_cast<VkRenderPass*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRenderPass' or 'null' for argument 4 'pRenderPass'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateRenderPass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyRenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkRenderPass *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkRenderPass") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkRenderPass]");
      return env.Undefined();
    }
    obj1 = obj;
    VkRenderPass* instance = reinterpret_cast<VkRenderPass*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRenderPass' or 'null' for argument 2 'renderPass'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyRenderPass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetRenderAreaGranularity(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkRenderPass *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkRenderPass") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkRenderPass]");
      return env.Undefined();
    }
    obj1 = obj;
    VkRenderPass* instance = reinterpret_cast<VkRenderPass*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRenderPass' or 'null' for argument 2 'renderPass'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkExtent2D *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkExtent2D") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkExtent2D]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkExtent2D* instance = reinterpret_cast<VkExtent2D*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkExtent2D' or 'null' for argument 3 'pGranularity'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetRenderAreaGranularity(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateCommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCommandPoolCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCommandPoolCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkCommandPoolCreateInfo* instance = reinterpret_cast<VkCommandPoolCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandPoolCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkCommandPool *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandPool") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkCommandPool]");
      return env.Undefined();
    }
    obj3 = obj;
    VkCommandPool* instance = reinterpret_cast<VkCommandPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandPool' or 'null' for argument 4 'pCommandPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateCommandPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyCommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCommandPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCommandPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkCommandPool* instance = reinterpret_cast<VkCommandPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandPool' or 'null' for argument 2 'commandPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyCommandPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkResetCommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCommandPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCommandPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkCommandPool* instance = reinterpret_cast<VkCommandPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandPool' or 'null' for argument 2 'commandPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
  int32_t out = vkResetCommandPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkCommandPoolResetFlags>($p2)
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkAllocateCommandBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCommandBufferAllocateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCommandBufferAllocateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkCommandBufferAllocateInfo* instance = reinterpret_cast<VkCommandBufferAllocateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBufferAllocateInfo' or 'null' for argument 2 'pAllocateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkCommandBuffer>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCommandBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkCommandBuffer>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pCommandBuffers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkAllocateCommandBuffers(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (VkCommandBuffer *) $p2.get()->data() : nullptr
  );
  if (info[2].IsArray()) {
    VkCommandBuffer* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkFreeCommandBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCommandPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCommandPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkCommandPool* instance = reinterpret_cast<VkCommandPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandPool' or 'null' for argument 2 'commandPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCommandBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkCommandBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkCommandBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCommandBuffers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkFreeCommandBuffers(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkCommandBuffer *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkBeginCommandBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCommandBufferBeginInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCommandBufferBeginInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkCommandBufferBeginInfo* instance = reinterpret_cast<VkCommandBufferBeginInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBufferBeginInfo' or 'null' for argument 2 'pBeginInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkBeginCommandBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkEndCommandBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkEndCommandBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkResetCommandBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());
  int32_t out = vkResetCommandBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkCommandBufferResetFlags>($p1)
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdBindPipeline(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkPipeline *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipeline") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkPipeline]");
      return env.Undefined();
    }
    obj2 = obj;
    VkPipeline* instance = reinterpret_cast<VkPipeline*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipeline' or 'null' for argument 3 'pipeline'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkCmdBindPipeline(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetViewport(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkViewport>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkViewport> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkViewport* instance = reinterpret_cast<VkViewport*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkViewport>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pViewports'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdSetViewport(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkViewport *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetScissor(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRect2D> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkRect2D* instance = reinterpret_cast<VkRect2D*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pScissors'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdSetScissor(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkRect2D *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetLineWidth(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  float $p1 = static_cast<float>(info[1].As<Napi::Number>().Int64Value());
vkCmdSetLineWidth(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetDepthBias(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  float $p1 = static_cast<float>(info[1].As<Napi::Number>().Int64Value());

  float $p2 = static_cast<float>(info[2].As<Napi::Number>().Int64Value());

  float $p3 = static_cast<float>(info[3].As<Napi::Number>().Int64Value());
vkCmdSetDepthBias(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetBlendConstants(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

    std::shared_ptr<std::vector<float>> $p1 = nullptr;
    if (info[1].IsArray()) {
      // validate length
      if (info[1].As<Napi::Array>().Length() != 4) {
        Napi::RangeError::New(env, "Invalid array length for argument 2 'blendConstants'").ThrowAsJavaScriptException();
        return env.Undefined();
      } else {
        std::vector<float> data = createArrayOfV8Numbers<float>(info[1]);
        $p1 = std::make_shared<std::vector<float>>(data);
      }
    } else if (!info[1].IsNull()) {
      Napi::TypeError::New(env, "Invalid type for argument 2 'blendConstants'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
vkCmdSetBlendConstants(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1 ? $p1.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetDepthBounds(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  float $p1 = static_cast<float>(info[1].As<Napi::Number>().Int64Value());

  float $p2 = static_cast<float>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetDepthBounds(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetStencilCompareMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetStencilCompareMask(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkStencilFaceFlags>($p1),
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetStencilWriteMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetStencilWriteMask(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkStencilFaceFlags>($p1),
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetStencilReference(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetStencilReference(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkStencilFaceFlags>($p1),
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBindDescriptorSets(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkPipelineLayout *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineLayout") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkPipelineLayout]");
      return env.Undefined();
    }
    obj2 = obj;
    VkPipelineLayout* instance = reinterpret_cast<VkPipelineLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineLayout' or 'null' for argument 3 'layout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkDescriptorSet>> $p5 = nullptr;

  if (info[5].IsArray()) {

    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDescriptorSet* instance = reinterpret_cast<VkDescriptorSet*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkDescriptorSet>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pDescriptorSets'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());

  std::shared_ptr<uint32_t*> $p7 = nullptr;

  if (info[7].IsTypedArray()) {

    if (info[7].As<Napi::TypedArray>().TypedArrayType() != napi_uint32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 8 'pDynamicOffsets'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    uint32_t* data = getTypedArrayData<uint32_t>(info[7]);
    $p7 = std::make_shared<uint32_t*>(data);
  } else if (!info[7].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 8 'pDynamicOffsets'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdBindDescriptorSets(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5 ? (const VkDescriptorSet *) $p5.get()->data() : nullptr,
    $p6,
    $p7 ? *$p7.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBindIndexBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  VkIndexType $p3 = static_cast<VkIndexType>(info[3].As<Napi::Number>().Int64Value());
vkCmdBindIndexBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBindVertexBuffers(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pBuffers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<uint64_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pOffsets'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pOffsets'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdBindVertexBuffers(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkBuffer *) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDraw(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
vkCmdDraw(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawIndexed(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());
vkCmdDrawIndexed(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4,
    $p5
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawIndirect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
vkCmdDrawIndirect(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawIndexedIndirect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
vkCmdDrawIndexedIndirect(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDispatch(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
vkCmdDispatch(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDispatchIndirect(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdDispatchIndirect(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdCopyBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'srcBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkBuffer *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkBuffer]");
      return env.Undefined();
    }
    obj2 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 3 'dstBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferCopy>> $p4 = nullptr;

  if (info[4].IsArray()) {

  {
    Napi::Array array = info[4].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[4].As<Napi::Array>();
    std::vector<VkBufferCopy> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBufferCopy* instance = reinterpret_cast<VkBufferCopy*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p4 = std::make_shared<std::vector<VkBufferCopy>>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pRegions'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdCopyBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4 ? (const VkBufferCopy *) $p4.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdCopyImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'srcImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkImage *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkImage]");
      return env.Undefined();
    }
    obj3 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 4 'dstImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p4 = static_cast<VkImageLayout>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageCopy>> $p6 = nullptr;

  if (info[6].IsArray()) {

  {
    Napi::Array array = info[6].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[6].As<Napi::Array>();
    std::vector<VkImageCopy> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkImageCopy* instance = reinterpret_cast<VkImageCopy*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p6 = std::make_shared<std::vector<VkImageCopy>>(data);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 7 'pRegions'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdCopyImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6 ? (const VkImageCopy *) $p6.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBlitImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'srcImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkImage *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkImage]");
      return env.Undefined();
    }
    obj3 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 4 'dstImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p4 = static_cast<VkImageLayout>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageBlit>> $p6 = nullptr;

  if (info[6].IsArray()) {

  {
    Napi::Array array = info[6].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[6].As<Napi::Array>();
    std::vector<VkImageBlit> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkImageBlit* instance = reinterpret_cast<VkImageBlit*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p6 = std::make_shared<std::vector<VkImageBlit>>(data);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 7 'pRegions'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  VkFilter $p7 = static_cast<VkFilter>(info[7].As<Napi::Number>().Int64Value());
vkCmdBlitImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6 ? (const VkImageBlit *) $p6.get()->data() : nullptr,
    $p7
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdCopyBufferToImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'srcBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkImage *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkImage]");
      return env.Undefined();
    }
    obj2 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 3 'dstImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p3 = static_cast<VkImageLayout>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferImageCopy>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkBufferImageCopy> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBufferImageCopy* instance = reinterpret_cast<VkBufferImageCopy*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkBufferImageCopy>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pRegions'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdCopyBufferToImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5 ? (const VkBufferImageCopy *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdCopyImageToBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'srcImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'dstBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferImageCopy>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkBufferImageCopy> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBufferImageCopy* instance = reinterpret_cast<VkBufferImageCopy*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkBufferImageCopy>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pRegions'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdCopyImageToBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5 ? (const VkBufferImageCopy *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdUpdateBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'dstBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  void* $p4 = nullptr;
  if (info[4].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[4].As<Napi::ArrayBuffer>();
    $p4 = buf.Data();
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 5 'pData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkCmdUpdateBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    info[4].IsNull() ? nullptr : $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdFillBuffer(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'dstBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
vkCmdFillBuffer(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdClearColorImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkClearColorValue *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkClearColorValue") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkClearColorValue]");
      return env.Undefined();
    }
    obj3 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkClearColorValue* instance = reinterpret_cast<VkClearColorValue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkClearColorValue' or 'null' for argument 4 'pColor'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageSubresourceRange>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkImageSubresourceRange> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkImageSubresourceRange* instance = reinterpret_cast<VkImageSubresourceRange*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkImageSubresourceRange>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pRanges'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdClearColorImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    $p5 ? (const VkImageSubresourceRange *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdClearDepthStencilImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkClearDepthStencilValue *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkClearDepthStencilValue") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkClearDepthStencilValue]");
      return env.Undefined();
    }
    obj3 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkClearDepthStencilValue* instance = reinterpret_cast<VkClearDepthStencilValue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkClearDepthStencilValue' or 'null' for argument 4 'pDepthStencil'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageSubresourceRange>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkImageSubresourceRange> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkImageSubresourceRange* instance = reinterpret_cast<VkImageSubresourceRange*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkImageSubresourceRange>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pRanges'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdClearDepthStencilImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    $p5 ? (const VkImageSubresourceRange *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdClearAttachments(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkClearAttachment>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkClearAttachment> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkClearAttachment* instance = reinterpret_cast<VkClearAttachment*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkClearAttachment>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pAttachments'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkClearRect>> $p4 = nullptr;

  if (info[4].IsArray()) {

  {
    Napi::Array array = info[4].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[4].As<Napi::Array>();
    std::vector<VkClearRect> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkClearRect* instance = reinterpret_cast<VkClearRect*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p4 = std::make_shared<std::vector<VkClearRect>>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pRects'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdClearAttachments(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkClearAttachment *) $p2.get()->data() : nullptr,
    $p3,
    $p4 ? (const VkClearRect *) $p4.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdResolveImage(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'srcImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkImage *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkImage]");
      return env.Undefined();
    }
    obj3 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 4 'dstImage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p4 = static_cast<VkImageLayout>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageResolve>> $p6 = nullptr;

  if (info[6].IsArray()) {

  {
    Napi::Array array = info[6].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[6].As<Napi::Array>();
    std::vector<VkImageResolve> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkImageResolve* instance = reinterpret_cast<VkImageResolve*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p6 = std::make_shared<std::vector<VkImageResolve>>(data);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 7 'pRegions'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdResolveImage(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6 ? (const VkImageResolve *) $p6.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkEvent *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkEvent") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return env.Undefined();
    }
    obj1 = obj;
    VkEvent* instance = reinterpret_cast<VkEvent*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkEvent' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdSetEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkPipelineStageFlags>($p2)
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdResetEvent(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkEvent *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkEvent") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkEvent]");
      return env.Undefined();
    }
    obj1 = obj;
    VkEvent* instance = reinterpret_cast<VkEvent*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkEvent' or 'null' for argument 2 'event'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdResetEvent(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkPipelineStageFlags>($p2)
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdWaitEvents(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkEvent>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkEvent> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkEvent* instance = reinterpret_cast<VkEvent*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkEvent>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pEvents'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkMemoryBarrier>> $p6 = nullptr;

  if (info[6].IsArray()) {

  {
    Napi::Array array = info[6].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[6].As<Napi::Array>();
    std::vector<VkMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkMemoryBarrier* instance = reinterpret_cast<VkMemoryBarrier*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p6 = std::make_shared<std::vector<VkMemoryBarrier>>(data);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 7 'pMemoryBarriers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  uint32_t $p7 = static_cast<uint32_t>(info[7].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferMemoryBarrier>> $p8 = nullptr;

  if (info[8].IsArray()) {

  {
    Napi::Array array = info[8].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[8].As<Napi::Array>();
    std::vector<VkBufferMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBufferMemoryBarrier* instance = reinterpret_cast<VkBufferMemoryBarrier*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p8 = std::make_shared<std::vector<VkBufferMemoryBarrier>>(data);
  } else if (!info[8].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 9 'pBufferMemoryBarriers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  uint32_t $p9 = static_cast<uint32_t>(info[9].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageMemoryBarrier>> $p10 = nullptr;

  if (info[10].IsArray()) {

  {
    Napi::Array array = info[10].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[10].As<Napi::Array>();
    std::vector<VkImageMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkImageMemoryBarrier* instance = reinterpret_cast<VkImageMemoryBarrier*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p10 = std::make_shared<std::vector<VkImageMemoryBarrier>>(data);
  } else if (!info[10].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 11 'pImageMemoryBarriers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdWaitEvents(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkEvent *) $p2.get()->data() : nullptr,
    static_cast<VkPipelineStageFlags>($p3),
    static_cast<VkPipelineStageFlags>($p4),
    $p5,
    $p6 ? (const VkMemoryBarrier *) $p6.get()->data() : nullptr,
    $p7,
    $p8 ? (const VkBufferMemoryBarrier *) $p8.get()->data() : nullptr,
    $p9,
    $p10 ? (const VkImageMemoryBarrier *) $p10.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdPipelineBarrier(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkMemoryBarrier>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkMemoryBarrier* instance = reinterpret_cast<VkMemoryBarrier*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkMemoryBarrier>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pMemoryBarriers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBufferMemoryBarrier>> $p7 = nullptr;

  if (info[7].IsArray()) {

  {
    Napi::Array array = info[7].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[7].As<Napi::Array>();
    std::vector<VkBufferMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBufferMemoryBarrier* instance = reinterpret_cast<VkBufferMemoryBarrier*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p7 = std::make_shared<std::vector<VkBufferMemoryBarrier>>(data);
  } else if (!info[7].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 8 'pBufferMemoryBarriers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  uint32_t $p8 = static_cast<uint32_t>(info[8].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkImageMemoryBarrier>> $p9 = nullptr;

  if (info[9].IsArray()) {

  {
    Napi::Array array = info[9].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[9].As<Napi::Array>();
    std::vector<VkImageMemoryBarrier> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkImageMemoryBarrier* instance = reinterpret_cast<VkImageMemoryBarrier*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p9 = std::make_shared<std::vector<VkImageMemoryBarrier>>(data);
  } else if (!info[9].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 10 'pImageMemoryBarriers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdPipelineBarrier(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkPipelineStageFlags>($p1),
    static_cast<VkPipelineStageFlags>($p2),
    static_cast<VkDependencyFlags>($p3),
    $p4,
    $p5 ? (const VkMemoryBarrier *) $p5.get()->data() : nullptr,
    $p6,
    $p7 ? (const VkBufferMemoryBarrier *) $p7.get()->data() : nullptr,
    $p8,
    $p9 ? (const VkImageMemoryBarrier *) $p9.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBeginQuery(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());
vkCmdBeginQuery(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    static_cast<VkQueryControlFlags>($p3)
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdEndQuery(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
vkCmdEndQuery(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBeginConditionalRenderingEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkConditionalRenderingBeginInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkConditionalRenderingBeginInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkConditionalRenderingBeginInfoEXT* instance = reinterpret_cast<VkConditionalRenderingBeginInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkConditionalRenderingBeginInfoEXT' or 'null' for argument 2 'pConditionalRenderingBegin'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdBeginConditionalRenderingEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdEndConditionalRenderingEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdEndConditionalRenderingEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdResetQueryPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
vkCmdResetQueryPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdWriteTimestamp(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkQueryPool *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj2 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 3 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
vkCmdWriteTimestamp(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkPipelineStageFlagBits>($p1),
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdCopyQueryPoolResults(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  Napi::Object obj4;
  VkBuffer *$p4 = nullptr;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[4], "argument 5", "[object VkBuffer]");
      return env.Undefined();
    }
    obj4 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p4 = instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 5 'dstBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p5 = static_cast<uint64_t>(info[5].As<Napi::Number>().Int64Value());

  uint64_t $p6 = static_cast<uint64_t>(info[6].As<Napi::Number>().Int64Value());

  int32_t $p7 = static_cast<int32_t>(info[7].As<Napi::Number>().Int64Value());
vkCmdCopyQueryPoolResults(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    info[4].IsNull() ? VK_NULL_HANDLE : *$p4,
    $p5,
    $p6,
    static_cast<VkQueryResultFlags>($p7)
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdPushConstants(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineLayout *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineLayout") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineLayout]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipelineLayout* instance = reinterpret_cast<VkPipelineLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineLayout' or 'null' for argument 2 'layout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  void* $p5 = nullptr;
  if (info[5].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[5].As<Napi::ArrayBuffer>();
    $p5 = buf.Data();
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 6 'pValues'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkCmdPushConstants(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkShaderStageFlags>($p2),
    $p3,
    $p4,
    info[5].IsNull() ? nullptr : $p5
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBeginRenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkRenderPassBeginInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkRenderPassBeginInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkRenderPassBeginInfo* instance = reinterpret_cast<VkRenderPassBeginInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRenderPassBeginInfo' or 'null' for argument 2 'pRenderPassBegin'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkSubpassContents $p2 = static_cast<VkSubpassContents>(info[2].As<Napi::Number>().Int64Value());
vkCmdBeginRenderPass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdNextSubpass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkSubpassContents $p1 = static_cast<VkSubpassContents>(info[1].As<Napi::Number>().Int64Value());
vkCmdNextSubpass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdEndRenderPass(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkCmdEndRenderPass(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdExecuteCommands(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCommandBuffer>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCommandBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkCommandBuffer>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pCommandBuffers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkCmdExecuteCommands(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkCommandBuffer *) $p2.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceDisplayPropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkDisplayPropertiesKHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDisplayPropertiesKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDisplayPropertiesKHR* instance = reinterpret_cast<VkDisplayPropertiesKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkDisplayPropertiesKHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceDisplayPropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkDisplayPropertiesKHR *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkDisplayPropertiesKHR* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceDisplayPlanePropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkDisplayPlanePropertiesKHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDisplayPlanePropertiesKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDisplayPlanePropertiesKHR* instance = reinterpret_cast<VkDisplayPlanePropertiesKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkDisplayPlanePropertiesKHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkDisplayPlanePropertiesKHR *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkDisplayPlanePropertiesKHR* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDisplayPlaneSupportedDisplaysKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDisplayCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkDisplayKHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkDisplayKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDisplayKHR* instance = reinterpret_cast<VkDisplayKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkDisplayKHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pDisplays'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetDisplayPlaneSupportedDisplaysKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkDisplayKHR *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkDisplayKHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDisplayModePropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplayKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDisplayKHR* instance = reinterpret_cast<VkDisplayKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayKHR' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkDisplayModePropertiesKHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkDisplayModePropertiesKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDisplayModePropertiesKHR* instance = reinterpret_cast<VkDisplayModePropertiesKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkDisplayModePropertiesKHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetDisplayModePropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkDisplayModePropertiesKHR *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkDisplayModePropertiesKHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateDisplayModeKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplayKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDisplayKHR* instance = reinterpret_cast<VkDisplayKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayKHR' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDisplayModeCreateInfoKHR *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDisplayModeCreateInfoKHR]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDisplayModeCreateInfoKHR* instance = reinterpret_cast<VkDisplayModeCreateInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayModeCreateInfoKHR' or 'null' for argument 3 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj4;
  VkDisplayModeKHR *$p4 = nullptr;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayModeKHR") {
      NapiObjectTypeError(info[4], "argument 5", "[object VkDisplayModeKHR]");
      return env.Undefined();
    }
    obj4 = obj;
    VkDisplayModeKHR* instance = reinterpret_cast<VkDisplayModeKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p4 = instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayModeKHR' or 'null' for argument 5 'pMode'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateDisplayModeKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    nullptr,
    $p4
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDisplayPlaneCapabilitiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplayModeKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayModeKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplayModeKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDisplayModeKHR* instance = reinterpret_cast<VkDisplayModeKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayModeKHR' or 'null' for argument 2 'mode'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkDisplayPlaneCapabilitiesKHR *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayPlaneCapabilitiesKHR") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDisplayPlaneCapabilitiesKHR]");
      return env.Undefined();
    }
    obj3 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDisplayPlaneCapabilitiesKHR* instance = reinterpret_cast<VkDisplayPlaneCapabilitiesKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayPlaneCapabilitiesKHR' or 'null' for argument 4 'pCapabilities'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetDisplayPlaneCapabilitiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  if (info[3].IsObject()) {
     Napi::Object obj = info[3].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p3));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateDisplayPlaneSurfaceKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplaySurfaceCreateInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplaySurfaceCreateInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDisplaySurfaceCreateInfoKHR* instance = reinterpret_cast<VkDisplaySurfaceCreateInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplaySurfaceCreateInfoKHR' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkSurfaceKHR *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj3 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 4 'pSurface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateDisplayPlaneSurfaceKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateSharedSwapchainsKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkSwapchainCreateInfoKHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkSwapchainCreateInfoKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSwapchainCreateInfoKHR* instance = reinterpret_cast<VkSwapchainCreateInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkSwapchainCreateInfoKHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pCreateInfos'").ThrowAsJavaScriptException();
    return env.Undefined();
  }



  std::shared_ptr<std::vector<VkSwapchainKHR>> $p4 = nullptr;

  if (info[4].IsArray()) {

    Napi::Array array = info[4].As<Napi::Array>();
    std::vector<VkSwapchainKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p4 = std::make_shared<std::vector<VkSwapchainKHR>>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pSwapchains'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkCreateSharedSwapchainsKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkSwapchainCreateInfoKHR *) $p2.get()->data() : nullptr,
    nullptr,
    $p4 ? (VkSwapchainKHR *) $p4.get()->data() : nullptr
  );
  if (info[4].IsArray()) {
    VkSwapchainKHR* $pdata = $p4.get()->data();
    Napi::Array array = info[4].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroySurfaceKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSurfaceKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkDestroySurfaceKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceSurfaceSupportKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkSurfaceKHR *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj2 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 3 'surface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

    Napi::Object obj3;
    uint32_t $p3 = 0;
    if (info[3].IsObject()) {
      obj3 = info[3].As<Napi::Object>();
      if (!obj3.Has("$")) {
        Napi::Error::New(env, "Missing Object property '$' for argument 4").ThrowAsJavaScriptException();
        return env.Undefined();
      }
      Napi::Value val = obj3.Get("$");
      $p3 = static_cast<uint32_t>(val.As<Napi::Boolean>().Value());
    } else if (!info[3].IsNull()) {
      Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pSupported'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
  int32_t out = $vkGetPhysicalDeviceSurfaceSupportKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    &$p3
  );
    if (info[3].IsObject()) obj3.Set("$", $p3);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceSurfaceCapabilitiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSurfaceKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkSurfaceCapabilitiesKHR *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceCapabilitiesKHR") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkSurfaceCapabilitiesKHR]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSurfaceCapabilitiesKHR* instance = reinterpret_cast<VkSurfaceCapabilitiesKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceCapabilitiesKHR' or 'null' for argument 3 'pSurfaceCapabilities'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceSurfaceFormatsKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSurfaceKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSurfaceFormatCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkSurfaceFormatKHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSurfaceFormatKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSurfaceFormatKHR* instance = reinterpret_cast<VkSurfaceFormatKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkSurfaceFormatKHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSurfaceFormats'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceSurfaceFormatsKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkSurfaceFormatKHR *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSurfaceFormatKHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceSurfacePresentModesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSurfaceKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPresentModeCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<int32_t*> $p3 = nullptr;

  if (info[3].IsTypedArray()) {

    if (info[3].As<Napi::TypedArray>().TypedArrayType() != napi_int32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 4 'pPresentModes'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    int32_t* data = getTypedArrayData<int32_t>(info[3]);
    $p3 = std::make_shared<int32_t*>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pPresentModes'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceSurfacePresentModesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkPresentModeKHR *) *$p3.get() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateSwapchainKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSwapchainCreateInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSwapchainCreateInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSwapchainCreateInfoKHR* instance = reinterpret_cast<VkSwapchainCreateInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainCreateInfoKHR' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkSwapchainKHR *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSwapchainKHR") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkSwapchainKHR]");
      return env.Undefined();
    }
    obj3 = obj;
    VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainKHR' or 'null' for argument 4 'pSwapchain'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateSwapchainKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroySwapchainKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSwapchainKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSwapchainKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainKHR' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkDestroySwapchainKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetSwapchainImagesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSwapchainKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSwapchainKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainKHR' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSwapchainImageCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkImage>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkImage> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkImage>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSwapchainImages'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetSwapchainImagesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkImage *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkImage* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkAcquireNextImageKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSwapchainKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSwapchainKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainKHR' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkSemaphore *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSemaphore") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkSemaphore]");
      return env.Undefined();
    }
    obj3 = obj;
    VkSemaphore* instance = reinterpret_cast<VkSemaphore*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSemaphore' or 'null' for argument 4 'semaphore'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj4;
  VkFence *$p4 = nullptr;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFence") {
      NapiObjectTypeError(info[4], "argument 5", "[object VkFence]");
      return env.Undefined();
    }
    obj4 = obj;
    VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p4 = instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFence' or 'null' for argument 5 'fence'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj5;
  uint32_t $p5 = 0;
  if (info[5].IsObject()) {
    obj5 = info[5].As<Napi::Object>();
    if (!obj5.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 6").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj5.Get("$");
    $p5 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 6 'pImageIndex'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkAcquireNextImageKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    info[4].IsNull() ? VK_NULL_HANDLE : *$p4,
    &$p5
  );
    if (info[5].IsObject()) obj5.Set("$", $p5);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkQueuePresentKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkQueue *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return env.Undefined();
    }
    obj0 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPresentInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PRESENT_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPresentInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPresentInfoKHR* instance = reinterpret_cast<VkPresentInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPresentInfoKHR' or 'null' for argument 2 'pPresentInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkQueuePresentKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateWin32SurfaceKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkWin32SurfaceCreateInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkWin32SurfaceCreateInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkWin32SurfaceCreateInfoKHR* instance = reinterpret_cast<VkWin32SurfaceCreateInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkWin32SurfaceCreateInfoKHR' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkSurfaceKHR *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj3 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 4 'pSurface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateWin32SurfaceKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceWin32PresentationSupportKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
  uint32_t out = $vkGetPhysicalDeviceWin32PresentationSupportKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateDebugReportCallbackEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugReportCallbackCreateInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugReportCallbackCreateInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugReportCallbackCreateInfoEXT* instance = reinterpret_cast<VkDebugReportCallbackCreateInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugReportCallbackCreateInfoEXT' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkDebugReportCallbackEXT *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDebugReportCallbackEXT") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDebugReportCallbackEXT]");
      return env.Undefined();
    }
    obj3 = obj;
    VkDebugReportCallbackEXT* instance = reinterpret_cast<VkDebugReportCallbackEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugReportCallbackEXT' or 'null' for argument 4 'pCallback'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateDebugReportCallbackEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyDebugReportCallbackEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugReportCallbackEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDebugReportCallbackEXT") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugReportCallbackEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDebugReportCallbackEXT* instance = reinterpret_cast<VkDebugReportCallbackEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugReportCallbackEXT' or 'null' for argument 2 'callback'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkDestroyDebugReportCallbackEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkDebugReportMessageEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  VkDebugReportObjectTypeEXT $p2 = static_cast<VkDebugReportObjectTypeEXT>(info[2].As<Napi::Number>().Int64Value());

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  size_t $p4 = static_cast<size_t>(info[4].As<Napi::Number>().Int64Value());

  int32_t $p5 = static_cast<int32_t>(info[5].As<Napi::Number>().Int64Value());

  char* $p6 = nullptr;
  if (info[6].IsString()) {
    $p6 = copyV8String(info[6]);
  } else if (!info[6].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 7 'pLayerPrefix'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  char* $p7 = nullptr;
  if (info[7].IsString()) {
    $p7 = copyV8String(info[7]);
  } else if (!info[7].IsNull()) {
    Napi::TypeError::New(env, "Expected 'String' or 'null' for argument 8 'pMessage'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkDebugReportMessageEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkDebugReportFlagsEXT>($p1),
    $p2,
    $p3,
    $p4,
    $p5,
    $p6,
    $p7
  );
  if ($p6) delete[] $p6;
  if ($p7) delete[] $p7;
  
  
  return env.Undefined();
  
};

Napi::Value _vkDebugMarkerSetObjectNameEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugMarkerObjectNameInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugMarkerObjectNameInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugMarkerObjectNameInfoEXT* instance = reinterpret_cast<VkDebugMarkerObjectNameInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugMarkerObjectNameInfoEXT' or 'null' for argument 2 'pNameInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkDebugMarkerSetObjectNameEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDebugMarkerSetObjectTagEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugMarkerObjectTagInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugMarkerObjectTagInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugMarkerObjectTagInfoEXT* instance = reinterpret_cast<VkDebugMarkerObjectTagInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugMarkerObjectTagInfoEXT' or 'null' for argument 2 'pTagInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkDebugMarkerSetObjectTagEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdDebugMarkerBeginEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugMarkerMarkerInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugMarkerMarkerInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugMarkerMarkerInfoEXT* instance = reinterpret_cast<VkDebugMarkerMarkerInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugMarkerMarkerInfoEXT' or 'null' for argument 2 'pMarkerInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdDebugMarkerBeginEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDebugMarkerEndEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdDebugMarkerEndEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDebugMarkerInsertEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugMarkerMarkerInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugMarkerMarkerInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugMarkerMarkerInfoEXT* instance = reinterpret_cast<VkDebugMarkerMarkerInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugMarkerMarkerInfoEXT' or 'null' for argument 2 'pMarkerInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdDebugMarkerInsertEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceExternalImageFormatPropertiesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  VkImageType $p2 = static_cast<VkImageType>(info[2].As<Napi::Number>().Int64Value());

  VkImageTiling $p3 = static_cast<VkImageTiling>(info[3].As<Napi::Number>().Int64Value());

  int32_t $p4 = static_cast<int32_t>(info[4].As<Napi::Number>().Int64Value());

  int32_t $p5 = static_cast<int32_t>(info[5].As<Napi::Number>().Int64Value());

  int32_t $p6 = static_cast<int32_t>(info[6].As<Napi::Number>().Int64Value());

  Napi::Object obj7;
  VkExternalImageFormatPropertiesNV *$p7 = nullptr;
  if (info[7].IsObject()) {
    Napi::Object obj = info[7].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkExternalImageFormatPropertiesNV") {
      NapiObjectTypeError(info[7], "argument 8", "[object VkExternalImageFormatPropertiesNV]");
      return env.Undefined();
    }
    obj7 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkExternalImageFormatPropertiesNV* instance = reinterpret_cast<VkExternalImageFormatPropertiesNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p7 = instance;
  } else if (info[7].IsNull()) {
    $p7 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkExternalImageFormatPropertiesNV' or 'null' for argument 8 'pExternalImageFormatProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    static_cast<VkImageUsageFlags>($p4),
    static_cast<VkImageCreateFlags>($p5),
    static_cast<VkExternalMemoryHandleTypeFlagsNV>($p6),
    $p7
  );
  if (info[7].IsObject()) {
     Napi::Object obj = info[7].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p7));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetMemoryWin32HandleNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceMemory *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDeviceMemory") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceMemory]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDeviceMemory* instance = reinterpret_cast<VkDeviceMemory*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceMemory' or 'null' for argument 2 'memory'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  HANDLE* $p3 = nullptr;
  if (info[3].IsObject()) {
    obj3 = info[3].As<Napi::Object>();
    if (!obj3.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 4").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj3.Get("$");
    bool lossless = false;
    $p3 = reinterpret_cast<HANDLE*>(val.As<Napi::BigInt>().Int64Value(&lossless));
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pHandle'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetMemoryWin32HandleNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkExternalMemoryHandleTypeFlagsNV>($p2),
    info[3].IsNull() ? nullptr : $p3
  );
  Napi::BigInt ptr3 = Napi::BigInt::New(env, (int64_t)$p3);
  if (info[3].IsObject()) obj3.Set("$", ptr3);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdDrawIndirectCountAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndirectCountAMD(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawIndexedIndirectCountAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndexedIndirectCountAMD(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdProcessCommandsNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCmdProcessCommandsInfoNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCmdProcessCommandsInfoNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkCmdProcessCommandsInfoNVX* instance = reinterpret_cast<VkCmdProcessCommandsInfoNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCmdProcessCommandsInfoNVX' or 'null' for argument 2 'pProcessCommandsInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdProcessCommandsNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdReserveSpaceForCommandsNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCmdReserveSpaceForCommandsInfoNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCmdReserveSpaceForCommandsInfoNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkCmdReserveSpaceForCommandsInfoNVX* instance = reinterpret_cast<VkCmdReserveSpaceForCommandsInfoNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCmdReserveSpaceForCommandsInfoNVX' or 'null' for argument 2 'pReserveSpaceInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdReserveSpaceForCommandsNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateIndirectCommandsLayoutNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkIndirectCommandsLayoutCreateInfoNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkIndirectCommandsLayoutCreateInfoNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkIndirectCommandsLayoutCreateInfoNVX* instance = reinterpret_cast<VkIndirectCommandsLayoutCreateInfoNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkIndirectCommandsLayoutCreateInfoNVX' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkIndirectCommandsLayoutNVX *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkIndirectCommandsLayoutNVX") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkIndirectCommandsLayoutNVX]");
      return env.Undefined();
    }
    obj3 = obj;
    VkIndirectCommandsLayoutNVX* instance = reinterpret_cast<VkIndirectCommandsLayoutNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkIndirectCommandsLayoutNVX' or 'null' for argument 4 'pIndirectCommandsLayout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateIndirectCommandsLayoutNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyIndirectCommandsLayoutNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkIndirectCommandsLayoutNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkIndirectCommandsLayoutNVX") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkIndirectCommandsLayoutNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    VkIndirectCommandsLayoutNVX* instance = reinterpret_cast<VkIndirectCommandsLayoutNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkIndirectCommandsLayoutNVX' or 'null' for argument 2 'indirectCommandsLayout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkDestroyIndirectCommandsLayoutNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateObjectTableNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkObjectTableCreateInfoNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkObjectTableCreateInfoNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkObjectTableCreateInfoNVX* instance = reinterpret_cast<VkObjectTableCreateInfoNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkObjectTableCreateInfoNVX' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkObjectTableNVX *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkObjectTableNVX") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkObjectTableNVX]");
      return env.Undefined();
    }
    obj3 = obj;
    VkObjectTableNVX* instance = reinterpret_cast<VkObjectTableNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkObjectTableNVX' or 'null' for argument 4 'pObjectTable'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateObjectTableNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyObjectTableNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkObjectTableNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkObjectTableNVX") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkObjectTableNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    VkObjectTableNVX* instance = reinterpret_cast<VkObjectTableNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkObjectTableNVX' or 'null' for argument 2 'objectTable'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkDestroyObjectTableNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkRegisterObjectsNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkObjectTableNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkObjectTableNVX") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkObjectTableNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    VkObjectTableNVX* instance = reinterpret_cast<VkObjectTableNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkObjectTableNVX' or 'null' for argument 2 'objectTable'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkObjectTableEntryNVX>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkObjectTableEntryNVX> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkObjectTableEntryNVX* instance = reinterpret_cast<VkObjectTableEntryNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkObjectTableEntryNVX>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'ppObjectTableEntries'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<uint32_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_uint32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pObjectIndices'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    uint32_t* data = getTypedArrayData<uint32_t>(info[4]);
    $p4 = std::make_shared<uint32_t*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pObjectIndices'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkRegisterObjectsNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkObjectTableEntryNVX * const*) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkUnregisterObjectsNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkObjectTableNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkObjectTableNVX") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkObjectTableNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    VkObjectTableNVX* instance = reinterpret_cast<VkObjectTableNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkObjectTableNVX' or 'null' for argument 2 'objectTable'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<int32_t*> $p3 = nullptr;

  if (info[3].IsTypedArray()) {

    if (info[3].As<Napi::TypedArray>().TypedArrayType() != napi_int32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 4 'pObjectEntryTypes'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    int32_t* data = getTypedArrayData<int32_t>(info[3]);
    $p3 = std::make_shared<int32_t*>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pObjectEntryTypes'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<uint32_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_uint32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pObjectIndices'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    uint32_t* data = getTypedArrayData<uint32_t>(info[4]);
    $p4 = std::make_shared<uint32_t*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pObjectIndices'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkUnregisterObjectsNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (VkObjectEntryTypeNVX *) *$p3.get() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceGeneratedCommandsFeaturesNVX *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceGeneratedCommandsFeaturesNVX]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDeviceGeneratedCommandsFeaturesNVX* instance = reinterpret_cast<VkDeviceGeneratedCommandsFeaturesNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceGeneratedCommandsFeaturesNVX' or 'null' for argument 2 'pFeatures'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDeviceGeneratedCommandsLimitsNVX *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDeviceGeneratedCommandsLimitsNVX]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDeviceGeneratedCommandsLimitsNVX* instance = reinterpret_cast<VkDeviceGeneratedCommandsLimitsNVX*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceGeneratedCommandsLimitsNVX' or 'null' for argument 3 'pLimits'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[1].IsObject()) {
     Napi::Object obj = info[1].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p1));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceFeatures2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceFeatures2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceFeatures2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceFeatures2* instance = reinterpret_cast<VkPhysicalDeviceFeatures2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceFeatures2' or 'null' for argument 2 'pFeatures'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceFeatures2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if (info[1].IsObject()) {
     Napi::Object obj = info[1].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p1));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceProperties2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceProperties2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceProperties2* instance = reinterpret_cast<VkPhysicalDeviceProperties2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceProperties2' or 'null' for argument 2 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if (info[1].IsObject()) {
     Napi::Object obj = info[1].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p1));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceFormatProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkFormat $p1 = static_cast<VkFormat>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkFormatProperties2 *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkFormatProperties2]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkFormatProperties2* instance = reinterpret_cast<VkFormatProperties2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFormatProperties2' or 'null' for argument 3 'pFormatProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceFormatProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceImageFormatProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceImageFormatInfo2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceImageFormatInfo2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceImageFormatInfo2* instance = reinterpret_cast<VkPhysicalDeviceImageFormatInfo2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceImageFormatInfo2' or 'null' for argument 2 'pImageFormatInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkImageFormatProperties2 *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkImageFormatProperties2]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImageFormatProperties2* instance = reinterpret_cast<VkImageFormatProperties2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageFormatProperties2' or 'null' for argument 3 'pImageFormatProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkGetPhysicalDeviceImageFormatProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceQueueFamilyProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pQueueFamilyPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkQueueFamilyProperties2>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkQueueFamilyProperties2> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkQueueFamilyProperties2* instance = reinterpret_cast<VkQueueFamilyProperties2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkQueueFamilyProperties2>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pQueueFamilyProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkGetPhysicalDeviceQueueFamilyProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkQueueFamilyProperties2 *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkQueueFamilyProperties2* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceMemoryProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceMemoryProperties2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceMemoryProperties2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceMemoryProperties2* instance = reinterpret_cast<VkPhysicalDeviceMemoryProperties2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceMemoryProperties2' or 'null' for argument 2 'pMemoryProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceMemoryProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if (info[1].IsObject()) {
     Napi::Object obj = info[1].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p1));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceSparseImageFormatProperties2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceSparseImageFormatInfo2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceSparseImageFormatInfo2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceSparseImageFormatInfo2* instance = reinterpret_cast<VkPhysicalDeviceSparseImageFormatInfo2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceSparseImageFormatInfo2' or 'null' for argument 2 'pFormatInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkSparseImageFormatProperties2>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSparseImageFormatProperties2> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSparseImageFormatProperties2* instance = reinterpret_cast<VkSparseImageFormatProperties2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkSparseImageFormatProperties2>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkGetPhysicalDeviceSparseImageFormatProperties2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkSparseImageFormatProperties2 *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSparseImageFormatProperties2* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdPushDescriptorSetKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkPipelineBindPoint $p1 = static_cast<VkPipelineBindPoint>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkPipelineLayout *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineLayout") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkPipelineLayout]");
      return env.Undefined();
    }
    obj2 = obj;
    VkPipelineLayout* instance = reinterpret_cast<VkPipelineLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineLayout' or 'null' for argument 3 'layout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkWriteDescriptorSet>> $p5 = nullptr;

  if (info[5].IsArray()) {

  {
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkWriteDescriptorSet> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkWriteDescriptorSet* instance = reinterpret_cast<VkWriteDescriptorSet*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkWriteDescriptorSet>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pDescriptorWrites'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdPushDescriptorSetKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    $p5 ? (const VkWriteDescriptorSet *) $p5.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkTrimCommandPool(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkCommandPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkCommandPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkCommandPool* instance = reinterpret_cast<VkCommandPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandPool' or 'null' for argument 2 'commandPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());
vkTrimCommandPool(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkCommandPoolTrimFlags>($p2)
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceExternalBufferProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceExternalBufferInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceExternalBufferInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceExternalBufferInfo* instance = reinterpret_cast<VkPhysicalDeviceExternalBufferInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceExternalBufferInfo' or 'null' for argument 2 'pExternalBufferInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkExternalBufferProperties *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkExternalBufferProperties]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkExternalBufferProperties* instance = reinterpret_cast<VkExternalBufferProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkExternalBufferProperties' or 'null' for argument 3 'pExternalBufferProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceExternalBufferProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetMemoryWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkMemoryGetWin32HandleInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkMemoryGetWin32HandleInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryGetWin32HandleInfoKHR* instance = reinterpret_cast<VkMemoryGetWin32HandleInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryGetWin32HandleInfoKHR' or 'null' for argument 2 'pGetWin32HandleInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  HANDLE* $p2 = nullptr;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    bool lossless = false;
    $p2 = reinterpret_cast<HANDLE*>(val.As<Napi::BigInt>().Int64Value(&lossless));
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pHandle'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetMemoryWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? nullptr : $p2
  );
  Napi::BigInt ptr2 = Napi::BigInt::New(env, (int64_t)$p2);
  if (info[2].IsObject()) obj2.Set("$", ptr2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetMemoryWin32HandlePropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  bool lossless2 = false;
  HANDLE $p2 = reinterpret_cast<HANDLE>(info[2].As<Napi::BigInt>().Int64Value(&lossless2));

  Napi::Object obj3;
  VkMemoryWin32HandlePropertiesKHR *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR) {
      NapiObjectTypeError(info[3], "argument 4", "[object VkMemoryWin32HandlePropertiesKHR]");
      return env.Undefined();
    }
    obj3 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryWin32HandlePropertiesKHR* instance = reinterpret_cast<VkMemoryWin32HandlePropertiesKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryWin32HandlePropertiesKHR' or 'null' for argument 4 'pMemoryWin32HandleProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetMemoryWin32HandlePropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkExternalMemoryHandleTypeFlagBits>($p1),
    $p2,
    $p3
  );
  if (info[3].IsObject()) {
     Napi::Object obj = info[3].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p3));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetMemoryFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkMemoryGetFdInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkMemoryGetFdInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryGetFdInfoKHR* instance = reinterpret_cast<VkMemoryGetFdInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryGetFdInfoKHR' or 'null' for argument 2 'pGetFdInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  int $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<int>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pFd'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetMemoryFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetMemoryFdPropertiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  int $p2 = static_cast<int>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkMemoryFdPropertiesKHR *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR) {
      NapiObjectTypeError(info[3], "argument 4", "[object VkMemoryFdPropertiesKHR]");
      return env.Undefined();
    }
    obj3 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryFdPropertiesKHR* instance = reinterpret_cast<VkMemoryFdPropertiesKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryFdPropertiesKHR' or 'null' for argument 4 'pMemoryFdProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetMemoryFdPropertiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkExternalMemoryHandleTypeFlagBits>($p1),
    $p2,
    $p3
  );
  if (info[3].IsObject()) {
     Napi::Object obj = info[3].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p3));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceExternalSemaphoreProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceExternalSemaphoreInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceExternalSemaphoreInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceExternalSemaphoreInfo* instance = reinterpret_cast<VkPhysicalDeviceExternalSemaphoreInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceExternalSemaphoreInfo' or 'null' for argument 2 'pExternalSemaphoreInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkExternalSemaphoreProperties *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkExternalSemaphoreProperties]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkExternalSemaphoreProperties* instance = reinterpret_cast<VkExternalSemaphoreProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkExternalSemaphoreProperties' or 'null' for argument 3 'pExternalSemaphoreProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceExternalSemaphoreProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetSemaphoreWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSemaphoreGetWin32HandleInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSemaphoreGetWin32HandleInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSemaphoreGetWin32HandleInfoKHR* instance = reinterpret_cast<VkSemaphoreGetWin32HandleInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSemaphoreGetWin32HandleInfoKHR' or 'null' for argument 2 'pGetWin32HandleInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  HANDLE* $p2 = nullptr;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    bool lossless = false;
    $p2 = reinterpret_cast<HANDLE*>(val.As<Napi::BigInt>().Int64Value(&lossless));
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pHandle'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetSemaphoreWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? nullptr : $p2
  );
  Napi::BigInt ptr2 = Napi::BigInt::New(env, (int64_t)$p2);
  if (info[2].IsObject()) obj2.Set("$", ptr2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkImportSemaphoreWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImportSemaphoreWin32HandleInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImportSemaphoreWin32HandleInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImportSemaphoreWin32HandleInfoKHR* instance = reinterpret_cast<VkImportSemaphoreWin32HandleInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImportSemaphoreWin32HandleInfoKHR' or 'null' for argument 2 'pImportSemaphoreWin32HandleInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkImportSemaphoreWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetSemaphoreFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSemaphoreGetFdInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSemaphoreGetFdInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSemaphoreGetFdInfoKHR* instance = reinterpret_cast<VkSemaphoreGetFdInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSemaphoreGetFdInfoKHR' or 'null' for argument 2 'pGetFdInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  int $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<int>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pFd'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetSemaphoreFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkImportSemaphoreFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImportSemaphoreFdInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImportSemaphoreFdInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImportSemaphoreFdInfoKHR* instance = reinterpret_cast<VkImportSemaphoreFdInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImportSemaphoreFdInfoKHR' or 'null' for argument 2 'pImportSemaphoreFdInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkImportSemaphoreFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceExternalFenceProperties(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceExternalFenceInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceExternalFenceInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceExternalFenceInfo* instance = reinterpret_cast<VkPhysicalDeviceExternalFenceInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceExternalFenceInfo' or 'null' for argument 2 'pExternalFenceInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkExternalFenceProperties *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkExternalFenceProperties]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkExternalFenceProperties* instance = reinterpret_cast<VkExternalFenceProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkExternalFenceProperties' or 'null' for argument 3 'pExternalFenceProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetPhysicalDeviceExternalFenceProperties(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetFenceWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkFenceGetWin32HandleInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkFenceGetWin32HandleInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkFenceGetWin32HandleInfoKHR* instance = reinterpret_cast<VkFenceGetWin32HandleInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFenceGetWin32HandleInfoKHR' or 'null' for argument 2 'pGetWin32HandleInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  HANDLE* $p2 = nullptr;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    bool lossless = false;
    $p2 = reinterpret_cast<HANDLE*>(val.As<Napi::BigInt>().Int64Value(&lossless));
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pHandle'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetFenceWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? nullptr : $p2
  );
  Napi::BigInt ptr2 = Napi::BigInt::New(env, (int64_t)$p2);
  if (info[2].IsObject()) obj2.Set("$", ptr2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkImportFenceWin32HandleKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImportFenceWin32HandleInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImportFenceWin32HandleInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImportFenceWin32HandleInfoKHR* instance = reinterpret_cast<VkImportFenceWin32HandleInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImportFenceWin32HandleInfoKHR' or 'null' for argument 2 'pImportFenceWin32HandleInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkImportFenceWin32HandleKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetFenceFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkFenceGetFdInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkFenceGetFdInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkFenceGetFdInfoKHR* instance = reinterpret_cast<VkFenceGetFdInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFenceGetFdInfoKHR' or 'null' for argument 2 'pGetFdInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  int $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<int>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pFd'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetFenceFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkImportFenceFdKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImportFenceFdInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImportFenceFdInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImportFenceFdInfoKHR* instance = reinterpret_cast<VkImportFenceFdInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImportFenceFdInfoKHR' or 'null' for argument 2 'pImportFenceFdInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkImportFenceFdKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkReleaseDisplayEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplayKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDisplayKHR* instance = reinterpret_cast<VkDisplayKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayKHR' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkReleaseDisplayEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDisplayPowerControlEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplayKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDisplayKHR* instance = reinterpret_cast<VkDisplayKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayKHR' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDisplayPowerInfoEXT *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDisplayPowerInfoEXT]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDisplayPowerInfoEXT* instance = reinterpret_cast<VkDisplayPowerInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayPowerInfoEXT' or 'null' for argument 3 'pDisplayPowerInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkDisplayPowerControlEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkRegisterDeviceEventEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceEventInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceEventInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDeviceEventInfoEXT* instance = reinterpret_cast<VkDeviceEventInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceEventInfoEXT' or 'null' for argument 2 'pDeviceEventInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkFence *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFence") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkFence]");
      return env.Undefined();
    }
    obj3 = obj;
    VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFence' or 'null' for argument 4 'pFence'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkRegisterDeviceEventEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkRegisterDisplayEventEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplayKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDisplayKHR* instance = reinterpret_cast<VkDisplayKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayKHR' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDisplayEventInfoEXT *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDisplayEventInfoEXT]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDisplayEventInfoEXT* instance = reinterpret_cast<VkDisplayEventInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayEventInfoEXT' or 'null' for argument 3 'pDisplayEventInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj4;
  VkFence *$p4 = nullptr;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkFence") {
      NapiObjectTypeError(info[4], "argument 5", "[object VkFence]");
      return env.Undefined();
    }
    obj4 = obj;
    VkFence* instance = reinterpret_cast<VkFence*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p4 = instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkFence' or 'null' for argument 5 'pFence'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkRegisterDisplayEventEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    nullptr,
    $p4
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetSwapchainCounterEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSwapchainKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSwapchainKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainKHR' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  uint64_t $p3 = 0;
  if (info[3].IsObject()) {
    obj3 = info[3].As<Napi::Object>();
    if (!obj3.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 4").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj3.Get("$");
    $p3 = static_cast<uint64_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 4 'pCounterValue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetSwapchainCounterEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkSurfaceCounterFlagBitsEXT>($p2),
    &$p3
  );
    Napi::BigInt pnum3 = Napi::BigInt::New(env, (uint64_t)$p3);
    if (info[3].IsObject()) obj3.Set("$", pnum3);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceSurfaceCapabilities2EXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSurfaceKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkSurfaceCapabilities2EXT *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkSurfaceCapabilities2EXT]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSurfaceCapabilities2EXT* instance = reinterpret_cast<VkSurfaceCapabilities2EXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceCapabilities2EXT' or 'null' for argument 3 'pSurfaceCapabilities'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkEnumeratePhysicalDeviceGroups(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPhysicalDeviceGroupCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkPhysicalDeviceGroupProperties>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkPhysicalDeviceGroupProperties> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkPhysicalDeviceGroupProperties* instance = reinterpret_cast<VkPhysicalDeviceGroupProperties*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkPhysicalDeviceGroupProperties>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pPhysicalDeviceGroupProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkEnumeratePhysicalDeviceGroups(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkPhysicalDeviceGroupProperties *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkPhysicalDeviceGroupProperties* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDeviceGroupPeerMemoryFeatures(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  Napi::Object obj4;
  int32_t $p4 = 0;
  if (info[4].IsObject()) {
    obj4 = info[4].As<Napi::Object>();
    if (!obj4.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 5").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj4.Get("$");
    $p4 = static_cast<int32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'pPeerMemoryFeatures'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetDeviceGroupPeerMemoryFeatures(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    reinterpret_cast<VkPeerMemoryFeatureFlags *>(&$p4)
  );
    if (info[4].IsObject()) obj4.Set("$", $p4);
  
  
  return env.Undefined();
  
};

Napi::Value _vkBindBufferMemory2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBindBufferMemoryInfo>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkBindBufferMemoryInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBindBufferMemoryInfo* instance = reinterpret_cast<VkBindBufferMemoryInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkBindBufferMemoryInfo>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pBindInfos'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkBindBufferMemory2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkBindBufferMemoryInfo *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkBindImageMemory2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBindImageMemoryInfo>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkBindImageMemoryInfo> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBindImageMemoryInfo* instance = reinterpret_cast<VkBindImageMemoryInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkBindImageMemoryInfo>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pBindInfos'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = vkBindImageMemory2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkBindImageMemoryInfo *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdSetDeviceMask(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());
vkCmdSetDeviceMask(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetDeviceGroupPresentCapabilitiesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceGroupPresentCapabilitiesKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceGroupPresentCapabilitiesKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDeviceGroupPresentCapabilitiesKHR* instance = reinterpret_cast<VkDeviceGroupPresentCapabilitiesKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceGroupPresentCapabilitiesKHR' or 'null' for argument 2 'pDeviceGroupPresentCapabilities'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetDeviceGroupPresentCapabilitiesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  if (info[1].IsObject()) {
     Napi::Object obj = info[1].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p1));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDeviceGroupSurfacePresentModesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSurfaceKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  int32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<int32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pModes'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetDeviceGroupSurfacePresentModesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    reinterpret_cast<VkDeviceGroupPresentModeFlagsKHR *>(&$p2)
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkAcquireNextImage2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkAcquireNextImageInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkAcquireNextImageInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkAcquireNextImageInfoKHR* instance = reinterpret_cast<VkAcquireNextImageInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAcquireNextImageInfoKHR' or 'null' for argument 2 'pAcquireInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pImageIndex'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkAcquireNextImage2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdDispatchBase(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
vkCmdDispatchBase(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDevicePresentRectanglesKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSurfaceKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSurfaceKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSurfaceKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSurfaceKHR* instance = reinterpret_cast<VkSurfaceKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceKHR' or 'null' for argument 2 'surface'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pRectCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRect2D> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkRect2D* instance = reinterpret_cast<VkRect2D*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pRects'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDevicePresentRectanglesKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkRect2D *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkRect2D* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateDescriptorUpdateTemplate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorUpdateTemplateCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorUpdateTemplateCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDescriptorUpdateTemplateCreateInfo* instance = reinterpret_cast<VkDescriptorUpdateTemplateCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorUpdateTemplateCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkDescriptorUpdateTemplate *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorUpdateTemplate") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDescriptorUpdateTemplate]");
      return env.Undefined();
    }
    obj3 = obj;
    VkDescriptorUpdateTemplate* instance = reinterpret_cast<VkDescriptorUpdateTemplate*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorUpdateTemplate' or 'null' for argument 4 'pDescriptorUpdateTemplate'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateDescriptorUpdateTemplate(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyDescriptorUpdateTemplate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorUpdateTemplate *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorUpdateTemplate") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorUpdateTemplate]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDescriptorUpdateTemplate* instance = reinterpret_cast<VkDescriptorUpdateTemplate*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorUpdateTemplate' or 'null' for argument 2 'descriptorUpdateTemplate'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroyDescriptorUpdateTemplate(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkUpdateDescriptorSetWithTemplate(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorSet *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorSet") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorSet]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDescriptorSet* instance = reinterpret_cast<VkDescriptorSet*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorSet' or 'null' for argument 2 'descriptorSet'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDescriptorUpdateTemplate *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorUpdateTemplate") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDescriptorUpdateTemplate]");
      return env.Undefined();
    }
    obj2 = obj;
    VkDescriptorUpdateTemplate* instance = reinterpret_cast<VkDescriptorUpdateTemplate*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorUpdateTemplate' or 'null' for argument 3 'descriptorUpdateTemplate'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  void* $p3 = nullptr;
  if (info[3].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[3].As<Napi::ArrayBuffer>();
    $p3 = buf.Data();
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 4 'pData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkUpdateDescriptorSetWithTemplate(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    info[3].IsNull() ? nullptr : $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdPushDescriptorSetWithTemplateKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorUpdateTemplate *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDescriptorUpdateTemplate") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorUpdateTemplate]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDescriptorUpdateTemplate* instance = reinterpret_cast<VkDescriptorUpdateTemplate*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorUpdateTemplate' or 'null' for argument 2 'descriptorUpdateTemplate'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkPipelineLayout *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineLayout") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkPipelineLayout]");
      return env.Undefined();
    }
    obj2 = obj;
    VkPipelineLayout* instance = reinterpret_cast<VkPipelineLayout*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineLayout' or 'null' for argument 3 'layout'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  void* $p4 = nullptr;
  if (info[4].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[4].As<Napi::ArrayBuffer>();
    $p4 = buf.Data();
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 5 'pData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdPushDescriptorSetWithTemplateKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    info[4].IsNull() ? nullptr : $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkSetHdrMetadataEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkSwapchainKHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkSwapchainKHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkSwapchainKHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pSwapchains'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<std::vector<VkHdrMetadataEXT>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkHdrMetadataEXT> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkHdrMetadataEXT* instance = reinterpret_cast<VkHdrMetadataEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkHdrMetadataEXT>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pMetadata'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkSetHdrMetadataEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkSwapchainKHR *) $p2.get()->data() : nullptr,
    $p3 ? (const VkHdrMetadataEXT *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetSwapchainStatusKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSwapchainKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSwapchainKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainKHR' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetSwapchainStatusKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetRefreshCycleDurationGOOGLE(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSwapchainKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSwapchainKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainKHR' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkRefreshCycleDurationGOOGLE *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkRefreshCycleDurationGOOGLE") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkRefreshCycleDurationGOOGLE]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkRefreshCycleDurationGOOGLE* instance = reinterpret_cast<VkRefreshCycleDurationGOOGLE*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRefreshCycleDurationGOOGLE' or 'null' for argument 3 'pDisplayTimingProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetRefreshCycleDurationGOOGLE(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPastPresentationTimingGOOGLE(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSwapchainKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSwapchainKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSwapchainKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSwapchainKHR* instance = reinterpret_cast<VkSwapchainKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSwapchainKHR' or 'null' for argument 2 'swapchain'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPresentationTimingCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkPastPresentationTimingGOOGLE>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkPastPresentationTimingGOOGLE> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkPastPresentationTimingGOOGLE* instance = reinterpret_cast<VkPastPresentationTimingGOOGLE*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkPastPresentationTimingGOOGLE>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pPresentationTimings'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPastPresentationTimingGOOGLE(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkPastPresentationTimingGOOGLE *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkPastPresentationTimingGOOGLE* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdSetViewportWScalingNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkViewportWScalingNV>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkViewportWScalingNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkViewportWScalingNV* instance = reinterpret_cast<VkViewportWScalingNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkViewportWScalingNV>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pViewportWScalings'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdSetViewportWScalingNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkViewportWScalingNV *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetDiscardRectangleEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRect2D> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkRect2D* instance = reinterpret_cast<VkRect2D*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pDiscardRectangles'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdSetDiscardRectangleEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkRect2D *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetSampleLocationsEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSampleLocationsInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSampleLocationsInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSampleLocationsInfoEXT* instance = reinterpret_cast<VkSampleLocationsInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSampleLocationsInfoEXT' or 'null' for argument 2 'pSampleLocationsInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdSetSampleLocationsEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceMultisamplePropertiesEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkMultisamplePropertiesEXT *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkMultisamplePropertiesEXT]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMultisamplePropertiesEXT* instance = reinterpret_cast<VkMultisamplePropertiesEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMultisamplePropertiesEXT' or 'null' for argument 3 'pMultisampleProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkGetPhysicalDeviceMultisamplePropertiesEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkSampleCountFlagBits>($p1),
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetPhysicalDeviceSurfaceCapabilities2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceSurfaceInfo2KHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceSurfaceInfo2KHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceSurfaceInfo2KHR* instance = reinterpret_cast<VkPhysicalDeviceSurfaceInfo2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceSurfaceInfo2KHR' or 'null' for argument 2 'pSurfaceInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkSurfaceCapabilities2KHR *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkSurfaceCapabilities2KHR]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSurfaceCapabilities2KHR* instance = reinterpret_cast<VkSurfaceCapabilities2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSurfaceCapabilities2KHR' or 'null' for argument 3 'pSurfaceCapabilities'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceSurfaceFormats2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPhysicalDeviceSurfaceInfo2KHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPhysicalDeviceSurfaceInfo2KHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkPhysicalDeviceSurfaceInfo2KHR* instance = reinterpret_cast<VkPhysicalDeviceSurfaceInfo2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDeviceSurfaceInfo2KHR' or 'null' for argument 2 'pSurfaceInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSurfaceFormatCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkSurfaceFormat2KHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSurfaceFormat2KHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSurfaceFormat2KHR* instance = reinterpret_cast<VkSurfaceFormat2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkSurfaceFormat2KHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSurfaceFormats'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceSurfaceFormats2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkSurfaceFormat2KHR *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSurfaceFormat2KHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceDisplayProperties2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkDisplayProperties2KHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDisplayProperties2KHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDisplayProperties2KHR* instance = reinterpret_cast<VkDisplayProperties2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkDisplayProperties2KHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceDisplayProperties2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkDisplayProperties2KHR *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkDisplayProperties2KHR* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceDisplayPlaneProperties2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkDisplayPlaneProperties2KHR>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkDisplayPlaneProperties2KHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDisplayPlaneProperties2KHR* instance = reinterpret_cast<VkDisplayPlaneProperties2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkDisplayPlaneProperties2KHR>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkDisplayPlaneProperties2KHR *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkDisplayPlaneProperties2KHR* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDisplayModeProperties2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplayKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDisplayKHR") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplayKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDisplayKHR* instance = reinterpret_cast<VkDisplayKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayKHR' or 'null' for argument 2 'display'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkDisplayModeProperties2KHR>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkDisplayModeProperties2KHR> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkDisplayModeProperties2KHR* instance = reinterpret_cast<VkDisplayModeProperties2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkDisplayModeProperties2KHR>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetDisplayModeProperties2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    $p3 ? (VkDisplayModeProperties2KHR *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkDisplayModeProperties2KHR* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDisplayPlaneCapabilities2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDisplayPlaneInfo2KHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDisplayPlaneInfo2KHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDisplayPlaneInfo2KHR* instance = reinterpret_cast<VkDisplayPlaneInfo2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayPlaneInfo2KHR' or 'null' for argument 2 'pDisplayPlaneInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDisplayPlaneCapabilities2KHR *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDisplayPlaneCapabilities2KHR]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDisplayPlaneCapabilities2KHR* instance = reinterpret_cast<VkDisplayPlaneCapabilities2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDisplayPlaneCapabilities2KHR' or 'null' for argument 3 'pCapabilities'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetDisplayPlaneCapabilities2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetBufferMemoryRequirements2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBufferMemoryRequirementsInfo2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBufferMemoryRequirementsInfo2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkBufferMemoryRequirementsInfo2* instance = reinterpret_cast<VkBufferMemoryRequirementsInfo2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBufferMemoryRequirementsInfo2' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkMemoryRequirements2 *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements2]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryRequirements2* instance = reinterpret_cast<VkMemoryRequirements2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryRequirements2' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetBufferMemoryRequirements2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetImageMemoryRequirements2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImageMemoryRequirementsInfo2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImageMemoryRequirementsInfo2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImageMemoryRequirementsInfo2* instance = reinterpret_cast<VkImageMemoryRequirementsInfo2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageMemoryRequirementsInfo2' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkMemoryRequirements2 *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements2]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryRequirements2* instance = reinterpret_cast<VkMemoryRequirements2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryRequirements2' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetImageMemoryRequirements2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetImageSparseMemoryRequirements2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImageSparseMemoryRequirementsInfo2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImageSparseMemoryRequirementsInfo2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImageSparseMemoryRequirementsInfo2* instance = reinterpret_cast<VkImageSparseMemoryRequirementsInfo2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageSparseMemoryRequirementsInfo2' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  uint32_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pSparseMemoryRequirementCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkSparseImageMemoryRequirements2>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkSparseImageMemoryRequirements2> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkSparseImageMemoryRequirements2* instance = reinterpret_cast<VkSparseImageMemoryRequirements2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkSparseImageMemoryRequirements2>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSparseMemoryRequirements'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkGetImageSparseMemoryRequirements2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    &$p2,
    $p3 ? (VkSparseImageMemoryRequirements2 *) $p3.get()->data() : nullptr
  );
    if (info[2].IsObject()) obj2.Set("$", $p2);
  if (info[3].IsArray()) {
    VkSparseImageMemoryRequirements2* $pdata = $p3.get()->data();
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateSamplerYcbcrConversion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSamplerYcbcrConversionCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSamplerYcbcrConversionCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSamplerYcbcrConversionCreateInfo* instance = reinterpret_cast<VkSamplerYcbcrConversionCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSamplerYcbcrConversionCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkSamplerYcbcrConversion *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSamplerYcbcrConversion") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkSamplerYcbcrConversion]");
      return env.Undefined();
    }
    obj3 = obj;
    VkSamplerYcbcrConversion* instance = reinterpret_cast<VkSamplerYcbcrConversion*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSamplerYcbcrConversion' or 'null' for argument 4 'pYcbcrConversion'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = vkCreateSamplerYcbcrConversion(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroySamplerYcbcrConversion(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSamplerYcbcrConversion *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkSamplerYcbcrConversion") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSamplerYcbcrConversion]");
      return env.Undefined();
    }
    obj1 = obj;
    VkSamplerYcbcrConversion* instance = reinterpret_cast<VkSamplerYcbcrConversion*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSamplerYcbcrConversion' or 'null' for argument 2 'ycbcrConversion'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

vkDestroySamplerYcbcrConversion(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetDeviceQueue2(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDeviceQueueInfo2 *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDeviceQueueInfo2]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDeviceQueueInfo2* instance = reinterpret_cast<VkDeviceQueueInfo2*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDeviceQueueInfo2' or 'null' for argument 2 'pQueueInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkQueue *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkQueue]");
      return env.Undefined();
    }
    obj2 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 3 'pQueue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetDeviceQueue2(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateValidationCacheEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkValidationCacheCreateInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkValidationCacheCreateInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkValidationCacheCreateInfoEXT* instance = reinterpret_cast<VkValidationCacheCreateInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkValidationCacheCreateInfoEXT' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkValidationCacheEXT *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkValidationCacheEXT") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkValidationCacheEXT]");
      return env.Undefined();
    }
    obj3 = obj;
    VkValidationCacheEXT* instance = reinterpret_cast<VkValidationCacheEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkValidationCacheEXT' or 'null' for argument 4 'pValidationCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateValidationCacheEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyValidationCacheEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkValidationCacheEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkValidationCacheEXT") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkValidationCacheEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    VkValidationCacheEXT* instance = reinterpret_cast<VkValidationCacheEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkValidationCacheEXT' or 'null' for argument 2 'validationCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkDestroyValidationCacheEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetValidationCacheDataEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkValidationCacheEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkValidationCacheEXT") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkValidationCacheEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    VkValidationCacheEXT* instance = reinterpret_cast<VkValidationCacheEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkValidationCacheEXT' or 'null' for argument 2 'validationCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  size_t $p2 = 0;
  if (info[2].IsObject()) {
    obj2 = info[2].As<Napi::Object>();
    if (!obj2.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 3").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj2.Get("$");
    $p2 = static_cast<size_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 3 'pDataSize'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  void* $p3 = nullptr;
  if (info[3].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[3].As<Napi::ArrayBuffer>();
    $p3 = buf.Data();
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 4 'pData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetValidationCacheDataEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    &$p2,
    info[3].IsNull() ? nullptr : $p3
  );
    Napi::BigInt pnum2 = Napi::BigInt::New(env, (uint64_t)$p2);
    if (info[2].IsObject()) obj2.Set("$", pnum2);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkMergeValidationCachesEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkValidationCacheEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkValidationCacheEXT") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkValidationCacheEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    VkValidationCacheEXT* instance = reinterpret_cast<VkValidationCacheEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkValidationCacheEXT' or 'null' for argument 2 'dstCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkValidationCacheEXT>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkValidationCacheEXT> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkValidationCacheEXT* instance = reinterpret_cast<VkValidationCacheEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkValidationCacheEXT>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pSrcCaches'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkMergeValidationCachesEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkValidationCacheEXT *) $p3.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetDescriptorSetLayoutSupport(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDescriptorSetLayoutCreateInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDescriptorSetLayoutCreateInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDescriptorSetLayoutCreateInfo* instance = reinterpret_cast<VkDescriptorSetLayoutCreateInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorSetLayoutCreateInfo' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkDescriptorSetLayoutSupport *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkDescriptorSetLayoutSupport]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDescriptorSetLayoutSupport* instance = reinterpret_cast<VkDescriptorSetLayoutSupport*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDescriptorSetLayoutSupport' or 'null' for argument 3 'pSupport'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
vkGetDescriptorSetLayoutSupport(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetShaderInfoAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipeline *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipeline") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipeline]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipeline* instance = reinterpret_cast<VkPipeline*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipeline' or 'null' for argument 2 'pipeline'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  VkShaderInfoTypeAMD $p3 = static_cast<VkShaderInfoTypeAMD>(info[3].As<Napi::Number>().Int64Value());

  Napi::Object obj4;
  size_t $p4 = 0;
  if (info[4].IsObject()) {
    obj4 = info[4].As<Napi::Object>();
    if (!obj4.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 5").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj4.Get("$");
    $p4 = static_cast<size_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'pInfoSize'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  void* $p5 = nullptr;
  if (info[5].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[5].As<Napi::ArrayBuffer>();
    $p5 = buf.Data();
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 6 'pInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetShaderInfoAMD(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    static_cast<VkShaderStageFlagBits>($p2),
    $p3,
    &$p4,
    info[5].IsNull() ? nullptr : $p5
  );
    Napi::BigInt pnum4 = Napi::BigInt::New(env, (uint64_t)$p4);
    if (info[4].IsObject()) obj4.Set("$", pnum4);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pTimeDomainCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<int32_t*> $p2 = nullptr;

  if (info[2].IsTypedArray()) {

    if (info[2].As<Napi::TypedArray>().TypedArrayType() != napi_int32_array) {
      Napi::TypeError::New(env, "Invalid type for argument 3 'pTimeDomains'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    int32_t* data = getTypedArrayData<int32_t>(info[2]);
    $p2 = std::make_shared<int32_t*>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pTimeDomains'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkTimeDomainEXT *) *$p2.get() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetCalibratedTimestampsEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCalibratedTimestampInfoEXT>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCalibratedTimestampInfoEXT> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkCalibratedTimestampInfoEXT* instance = reinterpret_cast<VkCalibratedTimestampInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkCalibratedTimestampInfoEXT>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pTimestampInfos'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<uint64_t*> $p3 = nullptr;

  if (info[3].IsTypedArray()) {

    if (info[3].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 4 'pTimestamps'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    uint64_t* data = getTypedArrayData<uint64_t>(info[3]);
    $p3 = std::make_shared<uint64_t*>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pTimestamps'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj4;
  uint64_t $p4 = 0;
  if (info[4].IsObject()) {
    obj4 = info[4].As<Napi::Object>();
    if (!obj4.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 5").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj4.Get("$");
    $p4 = static_cast<uint64_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 5 'pMaxDeviation'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetCalibratedTimestampsEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkCalibratedTimestampInfoEXT *) $p2.get()->data() : nullptr,
    $p3 ? *$p3.get() : nullptr,
    &$p4
  );
    Napi::BigInt pnum4 = Napi::BigInt::New(env, (uint64_t)$p4);
    if (info[4].IsObject()) obj4.Set("$", pnum4);
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkSetDebugUtilsObjectNameEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugUtilsObjectNameInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsObjectNameInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugUtilsObjectNameInfoEXT* instance = reinterpret_cast<VkDebugUtilsObjectNameInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsObjectNameInfoEXT' or 'null' for argument 2 'pNameInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkSetDebugUtilsObjectNameEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkSetDebugUtilsObjectTagEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugUtilsObjectTagInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsObjectTagInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugUtilsObjectTagInfoEXT* instance = reinterpret_cast<VkDebugUtilsObjectTagInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsObjectTagInfoEXT' or 'null' for argument 2 'pTagInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkSetDebugUtilsObjectTagEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkQueueBeginDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkQueue *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return env.Undefined();
    }
    obj0 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugUtilsLabelEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsLabelEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugUtilsLabelEXT* instance = reinterpret_cast<VkDebugUtilsLabelEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsLabelEXT' or 'null' for argument 2 'pLabelInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkQueueBeginDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkQueueEndDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkQueue *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return env.Undefined();
    }
    obj0 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkQueueEndDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkQueueInsertDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkQueue *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return env.Undefined();
    }
    obj0 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugUtilsLabelEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsLabelEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugUtilsLabelEXT* instance = reinterpret_cast<VkDebugUtilsLabelEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsLabelEXT' or 'null' for argument 2 'pLabelInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkQueueInsertDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBeginDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugUtilsLabelEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsLabelEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugUtilsLabelEXT* instance = reinterpret_cast<VkDebugUtilsLabelEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsLabelEXT' or 'null' for argument 2 'pLabelInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdBeginDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdEndDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdEndDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdInsertDebugUtilsLabelEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugUtilsLabelEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsLabelEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugUtilsLabelEXT* instance = reinterpret_cast<VkDebugUtilsLabelEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsLabelEXT' or 'null' for argument 2 'pLabelInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdInsertDebugUtilsLabelEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateDebugUtilsMessengerEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugUtilsMessengerCreateInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsMessengerCreateInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugUtilsMessengerCreateInfoEXT* instance = reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsMessengerCreateInfoEXT' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkDebugUtilsMessengerEXT *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDebugUtilsMessengerEXT") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDebugUtilsMessengerEXT]");
      return env.Undefined();
    }
    obj3 = obj;
    VkDebugUtilsMessengerEXT* instance = reinterpret_cast<VkDebugUtilsMessengerEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsMessengerEXT' or 'null' for argument 4 'pMessenger'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateDebugUtilsMessengerEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyDebugUtilsMessengerEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkDebugUtilsMessengerEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDebugUtilsMessengerEXT") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkDebugUtilsMessengerEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    VkDebugUtilsMessengerEXT* instance = reinterpret_cast<VkDebugUtilsMessengerEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsMessengerEXT' or 'null' for argument 2 'messenger'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkDestroyDebugUtilsMessengerEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkSubmitDebugUtilsMessageEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkInstance *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkInstance") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkInstance]");
      return env.Undefined();
    }
    obj0 = obj;
    VkInstance* instance = reinterpret_cast<VkInstance*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkInstance' or 'null' for argument 1 'instance'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  int32_t $p2 = static_cast<int32_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkDebugUtilsMessengerCallbackDataEXT *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT) {
      NapiObjectTypeError(info[3], "argument 4", "[object VkDebugUtilsMessengerCallbackDataEXT]");
      return env.Undefined();
    }
    obj3 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkDebugUtilsMessengerCallbackDataEXT* instance = reinterpret_cast<VkDebugUtilsMessengerCallbackDataEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDebugUtilsMessengerCallbackDataEXT' or 'null' for argument 4 'pCallbackData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkSubmitDebugUtilsMessageEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkDebugUtilsMessageSeverityFlagBitsEXT>($p1),
    static_cast<VkDebugUtilsMessageTypeFlagsEXT>($p2),
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetMemoryHostPointerPropertiesEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  void* $p2 = nullptr;
  if (info[2].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[2].As<Napi::ArrayBuffer>();
    $p2 = buf.Data();
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 3 'pHostPointer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj3;
  VkMemoryHostPointerPropertiesEXT *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT) {
      NapiObjectTypeError(info[3], "argument 4", "[object VkMemoryHostPointerPropertiesEXT]");
      return env.Undefined();
    }
    obj3 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryHostPointerPropertiesEXT* instance = reinterpret_cast<VkMemoryHostPointerPropertiesEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryHostPointerPropertiesEXT' or 'null' for argument 4 'pMemoryHostPointerProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetMemoryHostPointerPropertiesEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkExternalMemoryHandleTypeFlagBits>($p1),
    info[2].IsNull() ? nullptr : $p2,
    $p3
  );
  if (info[3].IsObject()) {
     Napi::Object obj = info[3].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p3));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdWriteBufferMarkerAMD(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t $p1 = static_cast<int32_t>(info[1].As<Napi::Number>().Int64Value());

  Napi::Object obj2;
  VkBuffer *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkBuffer]");
      return env.Undefined();
    }
    obj2 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 3 'dstBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
$vkCmdWriteBufferMarkerAMD(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    static_cast<VkPipelineStageFlagBits>($p1),
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCreateRenderPass2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkRenderPassCreateInfo2KHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkRenderPassCreateInfo2KHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkRenderPassCreateInfo2KHR* instance = reinterpret_cast<VkRenderPassCreateInfo2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRenderPassCreateInfo2KHR' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkRenderPass *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkRenderPass") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkRenderPass]");
      return env.Undefined();
    }
    obj3 = obj;
    VkRenderPass* instance = reinterpret_cast<VkRenderPass*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRenderPass' or 'null' for argument 4 'pRenderPass'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateRenderPass2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdBeginRenderPass2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkRenderPassBeginInfo *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkRenderPassBeginInfo]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkRenderPassBeginInfo* instance = reinterpret_cast<VkRenderPassBeginInfo*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkRenderPassBeginInfo' or 'null' for argument 2 'pRenderPassBegin'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkSubpassBeginInfoKHR *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkSubpassBeginInfoKHR]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSubpassBeginInfoKHR* instance = reinterpret_cast<VkSubpassBeginInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSubpassBeginInfoKHR' or 'null' for argument 3 'pSubpassBeginInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdBeginRenderPass2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdNextSubpass2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSubpassBeginInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSubpassBeginInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSubpassBeginInfoKHR* instance = reinterpret_cast<VkSubpassBeginInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSubpassBeginInfoKHR' or 'null' for argument 2 'pSubpassBeginInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkSubpassEndInfoKHR *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkSubpassEndInfoKHR]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSubpassEndInfoKHR* instance = reinterpret_cast<VkSubpassEndInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSubpassEndInfoKHR' or 'null' for argument 3 'pSubpassEndInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdNextSubpass2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdEndRenderPass2KHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkSubpassEndInfoKHR *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkSubpassEndInfoKHR]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkSubpassEndInfoKHR* instance = reinterpret_cast<VkSubpassEndInfoKHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkSubpassEndInfoKHR' or 'null' for argument 2 'pSubpassEndInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdEndRenderPass2KHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawIndirectCountKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndirectCountKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawIndexedIndirectCountKHR(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndexedIndirectCountKHR(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetCheckpointNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  void* $p1 = nullptr;
  if (info[1].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[1].As<Napi::ArrayBuffer>();
    $p1 = buf.Data();
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 2 'pCheckpointMarker'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkCmdSetCheckpointNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? nullptr : $p1
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetQueueCheckpointDataNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkQueue *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueue") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkQueue]");
      return env.Undefined();
    }
    obj0 = obj;
    VkQueue* instance = reinterpret_cast<VkQueue*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueue' or 'null' for argument 1 'queue'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pCheckpointDataCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkCheckpointDataNV>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCheckpointDataNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkCheckpointDataNV* instance = reinterpret_cast<VkCheckpointDataNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkCheckpointDataNV>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pCheckpointData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkGetQueueCheckpointDataNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkCheckpointDataNV *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkCheckpointDataNV* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBindTransformFeedbackBuffersEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pBuffers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<uint64_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pOffsets'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pOffsets'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<uint64_t*> $p5 = nullptr;

  if (info[5].IsTypedArray()) {

    if (info[5].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 6 'pSizes'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[5]);
    $p5 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pSizes'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdBindTransformFeedbackBuffersEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkBuffer *) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr,
    $p5 ? *$p5.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBeginTransformFeedbackEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCounterBuffers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<uint64_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pCounterBufferOffsets'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pCounterBufferOffsets'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdBeginTransformFeedbackEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkBuffer *) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdEndTransformFeedbackEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBuffer>> $p3 = nullptr;

  if (info[3].IsArray()) {

    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkBuffer> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkBuffer>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCounterBuffers'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  std::shared_ptr<uint64_t*> $p4 = nullptr;

  if (info[4].IsTypedArray()) {

    if (info[4].As<Napi::TypedArray>().TypedArrayType() != napi_biguint64_array) {
      Napi::TypeError::New(env, "Invalid type for argument 5 'pCounterBufferOffsets'").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    VkDeviceSize* data = getTypedArrayData<VkDeviceSize>(info[4]);
    $p4 = std::make_shared<VkDeviceSize*>(data);
  } else if (!info[4].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 5 'pCounterBufferOffsets'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdEndTransformFeedbackEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkBuffer *) $p3.get()->data() : nullptr,
    $p4 ? *$p4.get() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBeginQueryIndexedEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  int32_t $p3 = static_cast<int32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
$vkCmdBeginQueryIndexedEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    static_cast<VkQueryControlFlags>($p3),
    $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdEndQueryIndexedEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkQueryPool *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj1 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 2 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());
$vkCmdEndQueryIndexedEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawIndirectByteCountEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'counterBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawIndirectByteCountEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetExclusiveScissorNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkRect2D>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRect2D> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkRect2D* instance = reinterpret_cast<VkRect2D*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkRect2D>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pExclusiveScissors'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdSetExclusiveScissorNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkRect2D *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBindShadingRateImageNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImageView *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImageView") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImageView]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImageView* instance = reinterpret_cast<VkImageView*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageView' or 'null' for argument 2 'imageView'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkImageLayout $p2 = static_cast<VkImageLayout>(info[2].As<Napi::Number>().Int64Value());
$vkCmdBindShadingRateImageNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetViewportShadingRatePaletteNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkShadingRatePaletteNV>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkShadingRatePaletteNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkShadingRatePaletteNV* instance = reinterpret_cast<VkShadingRatePaletteNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkShadingRatePaletteNV>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pShadingRatePalettes'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdSetViewportShadingRatePaletteNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkShadingRatePaletteNV *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdSetCoarseSampleOrderNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkCoarseSampleOrderTypeNV $p1 = static_cast<VkCoarseSampleOrderTypeNV>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkCoarseSampleOrderCustomNV>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkCoarseSampleOrderCustomNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkCoarseSampleOrderCustomNV* instance = reinterpret_cast<VkCoarseSampleOrderCustomNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkCoarseSampleOrderCustomNV>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCustomSampleOrders'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkCmdSetCoarseSampleOrderNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2,
    $p3 ? (const VkCoarseSampleOrderCustomNV *) $p3.get()->data() : nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawMeshTasksNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
$vkCmdDrawMeshTasksNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawMeshTasksIndirectNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());
$vkCmdDrawMeshTasksIndirectNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdDrawMeshTasksIndirectCountNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'buffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'countBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());

  uint32_t $p6 = static_cast<uint32_t>(info[6].As<Napi::Number>().Int64Value());
$vkCmdDrawMeshTasksIndirectCountNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    $p6
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCompileDeferredNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipeline *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipeline") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipeline]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipeline* instance = reinterpret_cast<VkPipeline*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipeline' or 'null' for argument 2 'pipeline'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());
  int32_t out = $vkCompileDeferredNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateAccelerationStructureNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkAccelerationStructureCreateInfoNV *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureCreateInfoNV]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkAccelerationStructureCreateInfoNV* instance = reinterpret_cast<VkAccelerationStructureCreateInfoNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureCreateInfoNV' or 'null' for argument 2 'pCreateInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  Napi::Object obj3;
  VkAccelerationStructureNV *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkAccelerationStructureNV") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkAccelerationStructureNV]");
      return env.Undefined();
    }
    obj3 = obj;
    VkAccelerationStructureNV* instance = reinterpret_cast<VkAccelerationStructureNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureNV' or 'null' for argument 4 'pAccelerationStructure'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkCreateAccelerationStructureNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    nullptr,
    $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkDestroyAccelerationStructureNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkAccelerationStructureNV *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkAccelerationStructureNV") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureNV]");
      return env.Undefined();
    }
    obj1 = obj;
    VkAccelerationStructureNV* instance = reinterpret_cast<VkAccelerationStructureNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureNV' or 'null' for argument 2 'accelerationStructure'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

$vkDestroyAccelerationStructureNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    nullptr
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetAccelerationStructureMemoryRequirementsNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkAccelerationStructureMemoryRequirementsInfoNV *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureMemoryRequirementsInfoNV]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkAccelerationStructureMemoryRequirementsInfoNV* instance = reinterpret_cast<VkAccelerationStructureMemoryRequirementsInfoNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureMemoryRequirementsInfoNV' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkMemoryRequirements2KHR *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkMemoryRequirements2KHR]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkMemoryRequirements2KHR* instance = reinterpret_cast<VkMemoryRequirements2KHR*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkMemoryRequirements2KHR' or 'null' for argument 3 'pMemoryRequirements'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
$vkGetAccelerationStructureMemoryRequirementsNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return env.Undefined();
  
};

Napi::Value _vkBindAccelerationStructureMemoryNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkBindAccelerationStructureMemoryInfoNV>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkBindAccelerationStructureMemoryInfoNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkBindAccelerationStructureMemoryInfoNV* instance = reinterpret_cast<VkBindAccelerationStructureMemoryInfoNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkBindAccelerationStructureMemoryInfoNV>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pBindInfos'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkBindAccelerationStructureMemoryNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkBindAccelerationStructureMemoryInfoNV *) $p2.get()->data() : nullptr
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCmdCopyAccelerationStructureNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkAccelerationStructureNV *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkAccelerationStructureNV") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureNV]");
      return env.Undefined();
    }
    obj1 = obj;
    VkAccelerationStructureNV* instance = reinterpret_cast<VkAccelerationStructureNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureNV' or 'null' for argument 2 'dst'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkAccelerationStructureNV *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkAccelerationStructureNV") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkAccelerationStructureNV]");
      return env.Undefined();
    }
    obj2 = obj;
    VkAccelerationStructureNV* instance = reinterpret_cast<VkAccelerationStructureNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureNV' or 'null' for argument 3 'src'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  VkCopyAccelerationStructureModeNV $p3 = static_cast<VkCopyAccelerationStructureModeNV>(info[3].As<Napi::Number>().Int64Value());
$vkCmdCopyAccelerationStructureNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdWriteAccelerationStructuresPropertiesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p1 = static_cast<uint32_t>(info[1].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkAccelerationStructureNV>> $p2 = nullptr;

  if (info[2].IsArray()) {

    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkAccelerationStructureNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkAccelerationStructureNV* instance = reinterpret_cast<VkAccelerationStructureNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkAccelerationStructureNV>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pAccelerationStructures'").ThrowAsJavaScriptException();
    return env.Undefined();
  }


  VkQueryType $p3 = static_cast<VkQueryType>(info[3].As<Napi::Number>().Int64Value());

  Napi::Object obj4;
  VkQueryPool *$p4 = nullptr;
  if (info[4].IsObject()) {
    Napi::Object obj = info[4].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkQueryPool") {
      NapiObjectTypeError(info[4], "argument 5", "[object VkQueryPool]");
      return env.Undefined();
    }
    obj4 = obj;
    VkQueryPool* instance = reinterpret_cast<VkQueryPool*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p4 = instance;
  } else if (info[4].IsNull()) {
    $p4 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkQueryPool' or 'null' for argument 5 'queryPool'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p5 = static_cast<uint32_t>(info[5].As<Napi::Number>().Int64Value());
$vkCmdWriteAccelerationStructuresPropertiesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    $p2 ? (const VkAccelerationStructureNV *) $p2.get()->data() : nullptr,
    $p3,
    info[4].IsNull() ? VK_NULL_HANDLE : *$p4,
    $p5
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdBuildAccelerationStructureNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkAccelerationStructureInfoNV *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureInfoNV]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkAccelerationStructureInfoNV* instance = reinterpret_cast<VkAccelerationStructureInfoNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureInfoNV' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkBuffer *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[2], "argument 3", "[object VkBuffer]");
      return env.Undefined();
    }
    obj2 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 3 'instanceData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p3 = static_cast<uint64_t>(info[3].As<Napi::Number>().Int64Value());

  uint32_t $p4 = static_cast<uint32_t>(info[4].As<Napi::Number>().Int64Value());

  Napi::Object obj5;
  VkAccelerationStructureNV *$p5 = nullptr;
  if (info[5].IsObject()) {
    Napi::Object obj = info[5].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkAccelerationStructureNV") {
      NapiObjectTypeError(info[5], "argument 6", "[object VkAccelerationStructureNV]");
      return env.Undefined();
    }
    obj5 = obj;
    VkAccelerationStructureNV* instance = reinterpret_cast<VkAccelerationStructureNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p5 = instance;
  } else if (info[5].IsNull()) {
    $p5 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureNV' or 'null' for argument 6 'dst'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj6;
  VkAccelerationStructureNV *$p6 = nullptr;
  if (info[6].IsObject()) {
    Napi::Object obj = info[6].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkAccelerationStructureNV") {
      NapiObjectTypeError(info[6], "argument 7", "[object VkAccelerationStructureNV]");
      return env.Undefined();
    }
    obj6 = obj;
    VkAccelerationStructureNV* instance = reinterpret_cast<VkAccelerationStructureNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p6 = instance;
  } else if (info[6].IsNull()) {
    $p6 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureNV' or 'null' for argument 7 'src'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj7;
  VkBuffer *$p7 = nullptr;
  if (info[7].IsObject()) {
    Napi::Object obj = info[7].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[7], "argument 8", "[object VkBuffer]");
      return env.Undefined();
    }
    obj7 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p7 = instance;
  } else if (info[7].IsNull()) {
    $p7 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 8 'scratch'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p8 = static_cast<uint64_t>(info[8].As<Napi::Number>().Int64Value());
$vkCmdBuildAccelerationStructureNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1,
    info[2].IsNull() ? VK_NULL_HANDLE : *$p2,
    $p3,
    $p4,
    info[5].IsNull() ? VK_NULL_HANDLE : *$p5,
    info[6].IsNull() ? VK_NULL_HANDLE : *$p6,
    info[7].IsNull() ? VK_NULL_HANDLE : *$p7,
    $p8
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkCmdTraceRaysNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkCommandBuffer *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkCommandBuffer") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkCommandBuffer]");
      return env.Undefined();
    }
    obj0 = obj;
    VkCommandBuffer* instance = reinterpret_cast<VkCommandBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkCommandBuffer' or 'null' for argument 1 'commandBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBuffer *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBuffer]");
      return env.Undefined();
    }
    obj1 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 2 'raygenShaderBindingTableBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p2 = static_cast<uint64_t>(info[2].As<Napi::Number>().Int64Value());

  Napi::Object obj3;
  VkBuffer *$p3 = nullptr;
  if (info[3].IsObject()) {
    Napi::Object obj = info[3].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[3], "argument 4", "[object VkBuffer]");
      return env.Undefined();
    }
    obj3 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p3 = instance;
  } else if (info[3].IsNull()) {
    $p3 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 4 'missShaderBindingTableBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p4 = static_cast<uint64_t>(info[4].As<Napi::Number>().Int64Value());

  uint64_t $p5 = static_cast<uint64_t>(info[5].As<Napi::Number>().Int64Value());

  Napi::Object obj6;
  VkBuffer *$p6 = nullptr;
  if (info[6].IsObject()) {
    Napi::Object obj = info[6].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[6], "argument 7", "[object VkBuffer]");
      return env.Undefined();
    }
    obj6 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p6 = instance;
  } else if (info[6].IsNull()) {
    $p6 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 7 'hitShaderBindingTableBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p7 = static_cast<uint64_t>(info[7].As<Napi::Number>().Int64Value());

  uint64_t $p8 = static_cast<uint64_t>(info[8].As<Napi::Number>().Int64Value());

  Napi::Object obj9;
  VkBuffer *$p9 = nullptr;
  if (info[9].IsObject()) {
    Napi::Object obj = info[9].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkBuffer") {
      NapiObjectTypeError(info[9], "argument 10", "[object VkBuffer]");
      return env.Undefined();
    }
    obj9 = obj;
    VkBuffer* instance = reinterpret_cast<VkBuffer*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p9 = instance;
  } else if (info[9].IsNull()) {
    $p9 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBuffer' or 'null' for argument 10 'callableShaderBindingTableBuffer'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint64_t $p10 = static_cast<uint64_t>(info[10].As<Napi::Number>().Int64Value());

  uint64_t $p11 = static_cast<uint64_t>(info[11].As<Napi::Number>().Int64Value());

  uint32_t $p12 = static_cast<uint32_t>(info[12].As<Napi::Number>().Int64Value());

  uint32_t $p13 = static_cast<uint32_t>(info[13].As<Napi::Number>().Int64Value());

  uint32_t $p14 = static_cast<uint32_t>(info[14].As<Napi::Number>().Int64Value());
$vkCmdTraceRaysNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? VK_NULL_HANDLE : *$p3,
    $p4,
    $p5,
    info[6].IsNull() ? VK_NULL_HANDLE : *$p6,
    $p7,
    $p8,
    info[9].IsNull() ? VK_NULL_HANDLE : *$p9,
    $p10,
    $p11,
    $p12,
    $p13,
    $p14
  );
  
  
  return env.Undefined();
  
};

Napi::Value _vkGetRayTracingShaderGroupHandlesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipeline *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipeline") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipeline]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipeline* instance = reinterpret_cast<VkPipeline*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipeline' or 'null' for argument 2 'pipeline'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  uint32_t $p3 = static_cast<uint32_t>(info[3].As<Napi::Number>().Int64Value());

  size_t $p4 = static_cast<size_t>(info[4].As<Napi::Number>().Int64Value());

  void* $p5 = nullptr;
  if (info[5].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[5].As<Napi::ArrayBuffer>();
    $p5 = buf.Data();
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 6 'pData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetRayTracingShaderGroupHandlesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3,
    $p4,
    info[5].IsNull() ? nullptr : $p5
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetAccelerationStructureHandleNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkAccelerationStructureNV *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkAccelerationStructureNV") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkAccelerationStructureNV]");
      return env.Undefined();
    }
    obj1 = obj;
    VkAccelerationStructureNV* instance = reinterpret_cast<VkAccelerationStructureNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkAccelerationStructureNV' or 'null' for argument 2 'accelerationStructure'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  size_t $p2 = static_cast<size_t>(info[2].As<Napi::Number>().Int64Value());

  void* $p3 = nullptr;
  if (info[3].IsArrayBuffer()) {
    Napi::ArrayBuffer buf = info[3].As<Napi::ArrayBuffer>();
    $p3 = buf.Data();
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Expected 'ArrayBuffer' or 'null' for argument 4 'pData'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetAccelerationStructureHandleNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    info[3].IsNull() ? nullptr : $p3
  );
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkCreateRayTracingPipelinesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkPipelineCache *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPipelineCache") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkPipelineCache]");
      return env.Undefined();
    }
    obj1 = obj;
    VkPipelineCache* instance = reinterpret_cast<VkPipelineCache*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPipelineCache' or 'null' for argument 2 'pipelineCache'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  uint32_t $p2 = static_cast<uint32_t>(info[2].As<Napi::Number>().Int64Value());

  std::shared_ptr<std::vector<VkRayTracingPipelineCreateInfoNV>> $p3 = nullptr;

  if (info[3].IsArray()) {

  {
    Napi::Array array = info[3].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[3].As<Napi::Array>();
    std::vector<VkRayTracingPipelineCreateInfoNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkRayTracingPipelineCreateInfoNV* instance = reinterpret_cast<VkRayTracingPipelineCreateInfoNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p3 = std::make_shared<std::vector<VkRayTracingPipelineCreateInfoNV>>(data);
  } else if (!info[3].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 4 'pCreateInfos'").ThrowAsJavaScriptException();
    return env.Undefined();
  }



  std::shared_ptr<std::vector<VkPipeline>> $p5 = nullptr;

  if (info[5].IsArray()) {

    Napi::Array array = info[5].As<Napi::Array>();
    std::vector<VkPipeline> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkPipeline* instance = reinterpret_cast<VkPipeline*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p5 = std::make_shared<std::vector<VkPipeline>>(data);
  } else if (!info[5].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 6 'pPipelines'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkCreateRayTracingPipelinesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2,
    $p3 ? (const VkRayTracingPipelineCreateInfoNV *) $p3.get()->data() : nullptr,
    nullptr,
    $p5 ? (VkPipeline *) $p5.get()->data() : nullptr
  );
  if (info[5].IsArray()) {
    VkPipeline* $pdata = $p5.get()->data();
    Napi::Array array = info[5].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();

      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetImageDrmFormatModifierPropertiesEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkImage *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkImage") {
      NapiObjectTypeError(info[1], "argument 2", "[object VkImage]");
      return env.Undefined();
    }
    obj1 = obj;
    VkImage* instance = reinterpret_cast<VkImage*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImage' or 'null' for argument 2 'image'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj2;
  VkImageDrmFormatModifierPropertiesEXT *$p2 = nullptr;
  if (info[2].IsObject()) {
    Napi::Object obj = info[2].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT) {
      NapiObjectTypeError(info[2], "argument 3", "[object VkImageDrmFormatModifierPropertiesEXT]");
      return env.Undefined();
    }
    obj2 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkImageDrmFormatModifierPropertiesEXT* instance = reinterpret_cast<VkImageDrmFormatModifierPropertiesEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p2 = instance;
  } else if (info[2].IsNull()) {
    $p2 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkImageDrmFormatModifierPropertiesEXT' or 'null' for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  int32_t out = $vkGetImageDrmFormatModifierPropertiesEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    info[1].IsNull() ? VK_NULL_HANDLE : *$p1,
    $p2
  );
  if (info[2].IsObject()) {
     Napi::Object obj = info[2].As<Napi::Object>();
    // reflect call
    Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>($p2));
    obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};

Napi::Value _vkGetBufferDeviceAddressEXT(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkDevice* instance = reinterpret_cast<VkDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkDevice' or 'null' for argument 1 'device'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  VkBufferDeviceAddressInfoEXT *$p1 = nullptr;
  if (info[1].IsObject()) {
    Napi::Object obj = info[1].As<Napi::Object>();
    if (GetStructureTypeFromObject(obj) != VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT) {
      NapiObjectTypeError(info[1], "argument 2", "[object VkBufferDeviceAddressInfoEXT]");
      return env.Undefined();
    }
    obj1 = obj;
    Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
    if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    VkBufferDeviceAddressInfoEXT* instance = reinterpret_cast<VkBufferDeviceAddressInfoEXT*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p1 = instance;
  } else if (info[1].IsNull()) {
    $p1 = nullptr;
  } else {
    Napi::TypeError::New(env, "Expected 'VkBufferDeviceAddressInfoEXT' or 'null' for argument 2 'pInfo'").ThrowAsJavaScriptException();
    return env.Undefined();
  }
  uint64_t out = $vkGetBufferDeviceAddressEXT(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    $p1
  );
  
  
  return Napi::BigInt::New(env, static_cast<int64_t>(out));
  
};

Napi::Value _vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  
  Napi::Object obj0;
  VkPhysicalDevice *$p0 = nullptr;
  if (info[0].IsObject()) {
    Napi::Object obj = info[0].As<Napi::Object>();
    if ((obj.Get("constructor").As<Napi::Object>().Get("name").As<Napi::String>().Utf8Value()) != "VkPhysicalDevice") {
      NapiObjectTypeError(info[0], "argument 1", "[object VkPhysicalDevice]");
      return env.Undefined();
    }
    obj0 = obj;
    VkPhysicalDevice* instance = reinterpret_cast<VkPhysicalDevice*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
    $p0 = instance;
  } else if (info[0].IsNull()) {
    $p0 = VK_NULL_HANDLE;
  } else {
    Napi::TypeError::New(env, "Expected 'VkPhysicalDevice' or 'null' for argument 1 'physicalDevice'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  Napi::Object obj1;
  uint32_t $p1 = 0;
  if (info[1].IsObject()) {
    obj1 = info[1].As<Napi::Object>();
    if (!obj1.Has("$")) {
      Napi::Error::New(env, "Missing Object property '$' for argument 2").ThrowAsJavaScriptException();
      return env.Undefined();
    }
    Napi::Value val = obj1.Get("$");
    $p1 = static_cast<uint32_t>(val.As<Napi::Number>().Int64Value());
  } else if (!info[1].IsNull()) {
    Napi::TypeError::New(env, "Expected 'Object' or 'null' for argument 2 'pPropertyCount'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  std::shared_ptr<std::vector<VkCooperativeMatrixPropertiesNV>> $p2 = nullptr;

  if (info[2].IsArray()) {

  {
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      Napi::Value flushCall = obj.Get("flush").As<Napi::Function>().Call(obj, {  });
      if (!(flushCall.As<Napi::Boolean>().Value())) return env.Undefined();
    };
  }
    Napi::Array array = info[2].As<Napi::Array>();
    std::vector<VkCooperativeMatrixPropertiesNV> data(array.Length());
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      VkCooperativeMatrixPropertiesNV* instance = reinterpret_cast<VkCooperativeMatrixPropertiesNV*>(obj.Get("memoryBuffer").As<Napi::ArrayBuffer>().Data());
      data[ii] = *instance;
    };
    $p2 = std::make_shared<std::vector<VkCooperativeMatrixPropertiesNV>>(data);
  } else if (!info[2].IsNull()) {
    Napi::TypeError::New(env, "Invalid type for argument 3 'pProperties'").ThrowAsJavaScriptException();
    return env.Undefined();
  }

  int32_t out = $vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    info[0].IsNull() ? VK_NULL_HANDLE : *$p0,
    &$p1,
    $p2 ? (VkCooperativeMatrixPropertiesNV *) $p2.get()->data() : nullptr
  );
    if (info[1].IsObject()) obj1.Set("$", $p1);
  if (info[2].IsArray()) {
    VkCooperativeMatrixPropertiesNV* $pdata = $p2.get()->data();
    Napi::Array array = info[2].As<Napi::Array>();
    for (unsigned int ii = 0; ii < array.Length(); ++ii) {
      Napi::Value item = array.Get(ii);
      Napi::Object obj = item.As<Napi::Object>();
      // reflect call
      Napi::BigInt memoryAddress = Napi::BigInt::New(env, reinterpret_cast<int64_t>(&$pdata[ii]));
      obj.Get("reflect").As<Napi::Function>().Call(obj, { memoryAddress });
    };
  }
  
  
  return Napi::Number::New(env, static_cast<int32_t>(out));
  
};



#endif
