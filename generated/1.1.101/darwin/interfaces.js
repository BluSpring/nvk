/*
 * MACHINE GENERATED, DO NOT EDIT
 * GENERATED BY nvk v0.3.8
 */

"use strict";

const {platform} = process;
const nvk = require("./build/Release/addon-" + platform + ".node");

const getAddressFromArrayBuffer = nvk.getAddressFromArrayBuffer;
const getArrayBufferFromAddress = nvk.getArrayBufferFromAddress;

global.ArrayBuffer.prototype.getAddress = function() {
  return getAddressFromArrayBuffer(this);
};

global.ArrayBuffer.fromAddress = function(address, byteLength) {
  return getArrayBufferFromAddress(address, byteLength);
};

const BI0 = BigInt(0);
const NULLT = String.fromCharCode(0x0);

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

function decodeNullTerminatedUTF8String(view) {
  let terminator = view.indexOf(0x0);
  let subview = view.subarray(0, terminator > -1 ? terminator : view.length);
  return textDecoder.decode(subview);
};

class NativeStringArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let stringBuffers = [];
    let addressView = new BigInt64Array(array.length);
    let addressBuffer = addressView.buffer;
    let addressBufferAddress = getAddressFromArrayBuffer(addressBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let strBuffer = textEncoder.encode(array[ii] + NULLT).buffer;
      addressView[ii] = getAddressFromArrayBuffer(strBuffer);
      stringBuffers.push(strBuffer);
    };
    this.address = addressBufferAddress;
    // keep references to prevent deallocation
    this.addressBuffer = addressBuffer;
    this.stringBuffers = stringBuffers;
  }
};

class NativeObjectArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let byteStride = array[0].memoryBuffer.byteLength;
    let objectBuffer = new ArrayBuffer(array.length * byteStride);
    let objectBufferView = new Uint8Array(objectBuffer);
    let objectBufferAddress = getAddressFromArrayBuffer(objectBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let byteOffset = ii * byteStride;
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      let dstView = objectBufferView.subarray(byteOffset, byteOffset + byteStride);
      dstView.set(srcView, 0x0);
    };
    this.address = objectBufferAddress;
    // keep reference to prevent deallocation
    this.objectBuffer = objectBuffer;
  }
};

class NativeObjectReferenceArray {
  constructor(array) {
    this.array = array;
    this.address = BI0;
    let addressView = new BigInt64Array(array.length);
    let addressBuffer = addressView.buffer;
    let addressBufferAddress = getAddressFromArrayBuffer(addressBuffer);
    for (let ii = 0; ii < array.length; ++ii) {
      let object = array[ii];
      let objectAddress = object.address;
      addressView[ii] = objectAddress;
    };
    this.address = addressBufferAddress;
    // keep reference to prevent deallocation
    this.addressBuffer = addressBuffer;
  }
};
/** VkInstance **/
class VkInstance {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkInstance' doesn't take any arguments");
    }
  }
};

VkInstance.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkInstance"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkInstance.byteLength = 0x8;
/** VkPhysicalDevice **/
class VkPhysicalDevice {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPhysicalDevice' doesn't take any arguments");
    }
  }
};

VkPhysicalDevice.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPhysicalDevice"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPhysicalDevice.byteLength = 0x8;
/** VkDevice **/
class VkDevice {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDevice' doesn't take any arguments");
    }
  }
};

VkDevice.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDevice"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDevice.byteLength = 0x8;
/** VkQueue **/
class VkQueue {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkQueue' doesn't take any arguments");
    }
  }
};

VkQueue.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkQueue"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkQueue.byteLength = 0x8;
/** VkCommandBuffer **/
class VkCommandBuffer {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkCommandBuffer' doesn't take any arguments");
    }
  }
};

VkCommandBuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkCommandBuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkCommandBuffer.byteLength = 0x8;
/** VkDeviceMemory **/
class VkDeviceMemory {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDeviceMemory' doesn't take any arguments");
    }
  }
};

VkDeviceMemory.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDeviceMemory"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDeviceMemory.byteLength = 0x8;
/** VkCommandPool **/
class VkCommandPool {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkCommandPool' doesn't take any arguments");
    }
  }
};

VkCommandPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkCommandPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkCommandPool.byteLength = 0x8;
/** VkBuffer **/
class VkBuffer {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkBuffer' doesn't take any arguments");
    }
  }
};

VkBuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkBuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkBuffer.byteLength = 0x8;
/** VkBufferView **/
class VkBufferView {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkBufferView' doesn't take any arguments");
    }
  }
};

VkBufferView.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkBufferView"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkBufferView.byteLength = 0x8;
/** VkImage **/
class VkImage {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkImage' doesn't take any arguments");
    }
  }
};

VkImage.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkImage"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkImage.byteLength = 0x8;
/** VkImageView **/
class VkImageView {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkImageView' doesn't take any arguments");
    }
  }
};

VkImageView.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkImageView"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkImageView.byteLength = 0x8;
/** VkShaderModule **/
class VkShaderModule {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkShaderModule' doesn't take any arguments");
    }
  }
};

VkShaderModule.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkShaderModule"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkShaderModule.byteLength = 0x8;
/** VkPipeline **/
class VkPipeline {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPipeline' doesn't take any arguments");
    }
  }
};

VkPipeline.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipeline"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipeline.byteLength = 0x8;
/** VkPipelineLayout **/
class VkPipelineLayout {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPipelineLayout' doesn't take any arguments");
    }
  }
};

VkPipelineLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipelineLayout"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipelineLayout.byteLength = 0x8;
/** VkSampler **/
class VkSampler {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSampler' doesn't take any arguments");
    }
  }
};

VkSampler.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSampler"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSampler.byteLength = 0x8;
/** VkDescriptorSet **/
class VkDescriptorSet {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDescriptorSet' doesn't take any arguments");
    }
  }
};

VkDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorSet"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorSet.byteLength = 0x8;
/** VkDescriptorSetLayout **/
class VkDescriptorSetLayout {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDescriptorSetLayout' doesn't take any arguments");
    }
  }
};

VkDescriptorSetLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorSetLayout"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorSetLayout.byteLength = 0x8;
/** VkDescriptorPool **/
class VkDescriptorPool {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDescriptorPool' doesn't take any arguments");
    }
  }
};

VkDescriptorPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorPool.byteLength = 0x8;
/** VkFence **/
class VkFence {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkFence' doesn't take any arguments");
    }
  }
};

VkFence.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkFence"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkFence.byteLength = 0x8;
/** VkSemaphore **/
class VkSemaphore {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSemaphore' doesn't take any arguments");
    }
  }
};

VkSemaphore.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSemaphore"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSemaphore.byteLength = 0x8;
/** VkEvent **/
class VkEvent {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkEvent' doesn't take any arguments");
    }
  }
};

VkEvent.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkEvent"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkEvent.byteLength = 0x8;
/** VkQueryPool **/
class VkQueryPool {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkQueryPool' doesn't take any arguments");
    }
  }
};

VkQueryPool.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkQueryPool"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkQueryPool.byteLength = 0x8;
/** VkFramebuffer **/
class VkFramebuffer {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkFramebuffer' doesn't take any arguments");
    }
  }
};

VkFramebuffer.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkFramebuffer"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkFramebuffer.byteLength = 0x8;
/** VkRenderPass **/
class VkRenderPass {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkRenderPass' doesn't take any arguments");
    }
  }
};

VkRenderPass.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkRenderPass"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkRenderPass.byteLength = 0x8;
/** VkPipelineCache **/
class VkPipelineCache {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkPipelineCache' doesn't take any arguments");
    }
  }
};

VkPipelineCache.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkPipelineCache"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkPipelineCache.byteLength = 0x8;
/** VkObjectTableNVX **/
class VkObjectTableNVX {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkObjectTableNVX' doesn't take any arguments");
    }
  }
};

VkObjectTableNVX.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkObjectTableNVX"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkObjectTableNVX.byteLength = 0x8;
/** VkIndirectCommandsLayoutNVX **/
class VkIndirectCommandsLayoutNVX {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkIndirectCommandsLayoutNVX' doesn't take any arguments");
    }
  }
};

VkIndirectCommandsLayoutNVX.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkIndirectCommandsLayoutNVX"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkIndirectCommandsLayoutNVX.byteLength = 0x8;
/** VkDescriptorUpdateTemplate **/
class VkDescriptorUpdateTemplate {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDescriptorUpdateTemplate' doesn't take any arguments");
    }
  }
};

VkDescriptorUpdateTemplate.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDescriptorUpdateTemplate"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDescriptorUpdateTemplate.byteLength = 0x8;
/** VkSamplerYcbcrConversion **/
class VkSamplerYcbcrConversion {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSamplerYcbcrConversion' doesn't take any arguments");
    }
  }
};

VkSamplerYcbcrConversion.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSamplerYcbcrConversion"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSamplerYcbcrConversion.byteLength = 0x8;
/** VkValidationCacheEXT **/
class VkValidationCacheEXT {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkValidationCacheEXT' doesn't take any arguments");
    }
  }
};

VkValidationCacheEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkValidationCacheEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkValidationCacheEXT.byteLength = 0x8;
/** VkAccelerationStructureNV **/
class VkAccelerationStructureNV {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkAccelerationStructureNV' doesn't take any arguments");
    }
  }
};

VkAccelerationStructureNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkAccelerationStructureNV"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkAccelerationStructureNV.byteLength = 0x8;
/** VkDisplayKHR **/
class VkDisplayKHR {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDisplayKHR' doesn't take any arguments");
    }
  }
};

VkDisplayKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDisplayKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDisplayKHR.byteLength = 0x8;
/** VkDisplayModeKHR **/
class VkDisplayModeKHR {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDisplayModeKHR' doesn't take any arguments");
    }
  }
};

VkDisplayModeKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDisplayModeKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDisplayModeKHR.byteLength = 0x8;
/** VkSurfaceKHR **/
class VkSurfaceKHR {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSurfaceKHR' doesn't take any arguments");
    }
  }
};

VkSurfaceKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSurfaceKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSurfaceKHR.byteLength = 0x8;
/** VkSwapchainKHR **/
class VkSwapchainKHR {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkSwapchainKHR' doesn't take any arguments");
    }
  }
};

VkSwapchainKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkSwapchainKHR"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkSwapchainKHR.byteLength = 0x8;
/** VkDebugReportCallbackEXT **/
class VkDebugReportCallbackEXT {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDebugReportCallbackEXT' doesn't take any arguments");
    }
  }
};

VkDebugReportCallbackEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDebugReportCallbackEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDebugReportCallbackEXT.byteLength = 0x8;
/** VkDebugUtilsMessengerEXT **/
class VkDebugUtilsMessengerEXT {
  constructor(opts) {
    this.memoryBuffer = new ArrayBuffer(0x8);
    this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
    this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
    if (typeof opts === "object") {
      throw new Error("'VkDebugUtilsMessengerEXT' doesn't take any arguments");
    }
  }
};

VkDebugUtilsMessengerEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  //console.log(`Reflect: "VkDebugUtilsMessengerEXT"`, this.memoryAddress, memoryAddress);
  dstView.set(srcView, 0x0);
};

VkDebugUtilsMessengerEXT.byteLength = 0x8;
/** VkBaseOutStructure **/
class VkBaseOutStructure {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBaseOutStructure.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && value.constructor === VkBaseOutStructure) {
      value.flush();
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
      
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBaseOutStructure.pNext': Expected 'VkBaseOutStructure' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBaseOutStructure.prototype.flush = function flush() {
  
  return true;
};

VkBaseOutStructure.prototype.reflect = function reflect(memoryAddress) {
  
};

VkBaseOutStructure.byteLength = 0x10;

VkBaseOutStructure.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkBaseInStructure **/
class VkBaseInStructure {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBaseInStructure.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && value.constructor === VkBaseInStructure) {
      value.flush();
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
      
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBaseInStructure.pNext': Expected 'VkBaseInStructure' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBaseInStructure.prototype.flush = function flush() {
  
  return true;
};

VkBaseInStructure.prototype.reflect = function reflect(memoryAddress) {
  
};

VkBaseInStructure.byteLength = 0x10;

VkBaseInStructure.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkOffset2D **/
class VkOffset2D {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.x !== void 0) this.x = opts.x;
      if (opts.y !== void 0) this.y = opts.y;
      
    }
  }
  get x() {
    return this.memoryViewInt32[0x0];
  }
  set x(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset2D.x': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get y() {
    return this.memoryViewInt32[0x1];
  }
  set y(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset2D.y': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  
};

VkOffset2D.prototype.flush = function flush() {
  
  return true;
};

VkOffset2D.prototype.reflect = function reflect(memoryAddress) {
  
};

VkOffset2D.byteLength = 0x8;

VkOffset2D.memoryLayout = Object.freeze({
  x: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  y: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkOffset3D **/
class VkOffset3D {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.x !== void 0) this.x = opts.x;
      if (opts.y !== void 0) this.y = opts.y;
      if (opts.z !== void 0) this.z = opts.z;
      
    }
  }
  get x() {
    return this.memoryViewInt32[0x0];
  }
  set x(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset3D.x': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get y() {
    return this.memoryViewInt32[0x1];
  }
  set y(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset3D.y': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get z() {
    return this.memoryViewInt32[0x2];
  }
  set z(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkOffset3D.z': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  
};

VkOffset3D.prototype.flush = function flush() {
  
  return true;
};

VkOffset3D.prototype.reflect = function reflect(memoryAddress) {
  
};

VkOffset3D.byteLength = 0xC;

VkOffset3D.memoryLayout = Object.freeze({
  x: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  y: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  z: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkExtent2D **/
class VkExtent2D {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.width !== void 0) this.width = opts.width;
      if (opts.height !== void 0) this.height = opts.height;
      
    }
  }
  get width() {
    return this.memoryViewUint32[0x0];
  }
  set width(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent2D.width': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get height() {
    return this.memoryViewUint32[0x1];
  }
  set height(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent2D.height': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  
};

VkExtent2D.prototype.flush = function flush() {
  
  return true;
};

VkExtent2D.prototype.reflect = function reflect(memoryAddress) {
  
};

VkExtent2D.byteLength = 0x8;

VkExtent2D.memoryLayout = Object.freeze({
  width: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  height: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkExtent3D **/
class VkExtent3D {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.width !== void 0) this.width = opts.width;
      if (opts.height !== void 0) this.height = opts.height;
      if (opts.depth !== void 0) this.depth = opts.depth;
      
    }
  }
  get width() {
    return this.memoryViewUint32[0x0];
  }
  set width(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent3D.width': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get height() {
    return this.memoryViewUint32[0x1];
  }
  set height(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent3D.height': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get depth() {
    return this.memoryViewUint32[0x2];
  }
  set depth(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExtent3D.depth': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  
};

VkExtent3D.prototype.flush = function flush() {
  
  return true;
};

VkExtent3D.prototype.reflect = function reflect(memoryAddress) {
  
};

VkExtent3D.byteLength = 0xC;

VkExtent3D.memoryLayout = Object.freeze({
  width: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  height: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  depth: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkViewport **/
class VkViewport {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.x !== void 0) this.x = opts.x;
      if (opts.y !== void 0) this.y = opts.y;
      if (opts.width !== void 0) this.width = opts.width;
      if (opts.height !== void 0) this.height = opts.height;
      if (opts.minDepth !== void 0) this.minDepth = opts.minDepth;
      if (opts.maxDepth !== void 0) this.maxDepth = opts.maxDepth;
      
    }
  }
  get x() {
    return this.memoryViewFloat32[0x0];
  }
  set x(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.x': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x0] = value;
  }
  get y() {
    return this.memoryViewFloat32[0x1];
  }
  set y(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.y': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x1] = value;
  }
  get width() {
    return this.memoryViewFloat32[0x2];
  }
  set width(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.width': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x2] = value;
  }
  get height() {
    return this.memoryViewFloat32[0x3];
  }
  set height(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.height': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x3] = value;
  }
  get minDepth() {
    return this.memoryViewFloat32[0x4];
  }
  set minDepth(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.minDepth': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x4] = value;
  }
  get maxDepth() {
    return this.memoryViewFloat32[0x5];
  }
  set maxDepth(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewport.maxDepth': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x5] = value;
  }
  
};

VkViewport.prototype.flush = function flush() {
  
  return true;
};

VkViewport.prototype.reflect = function reflect(memoryAddress) {
  
};

VkViewport.byteLength = 0x18;

VkViewport.memoryLayout = Object.freeze({
  x: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  y: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  width: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  height: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  minDepth: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxDepth: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkRect2D **/
class VkRect2D {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);

    }
    this._offset = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    this._extent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x8 });
    
    if (typeof opts === "object") {
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.extent !== void 0) this.extent = opts.extent;
      
    }
  }
  get offset() {
    return this._offset;
  }
  set offset(value) {
    if (value !== null && value.constructor === VkOffset2D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRect2D.offset': Expected 'VkOffset2D' but got '" + value.constructor.name + "'");
    }
  }
  get extent() {
    return this._extent;
  }
  set extent(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRect2D.extent': Expected 'VkExtent2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRect2D.prototype.flush = function flush() {
  
  
  if (this._offset !== null) {
    this._offset.flush();
    if (this.memoryBuffer !== this._offset.memoryBuffer) {
      let srcView = new Uint8Array(this._offset.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  
  if (this._extent !== null) {
    this._extent.flush();
    if (this.memoryBuffer !== this._extent.memoryBuffer) {
      let srcView = new Uint8Array(this._extent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
    }
  }
  
  return true;
};

VkRect2D.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRect2D.byteLength = 0x10;

VkRect2D.memoryLayout = Object.freeze({
  offset: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  extent: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkClearRect **/
class VkClearRect {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._rect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    
    
    
    if (typeof opts === "object") {
      if (opts.rect !== void 0) this.rect = opts.rect;
      if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
      if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
      
    }
  }
  get rect() {
    return this._rect;
  }
  set rect(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._rect = value;
      
      
    } else if (value === null) {
      this._rect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearRect.rect': Expected 'VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  get baseArrayLayer() {
    return this.memoryViewUint32[0x4];
  }
  set baseArrayLayer(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearRect.baseArrayLayer': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get layerCount() {
    return this.memoryViewUint32[0x5];
  }
  set layerCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearRect.layerCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  
};

VkClearRect.prototype.flush = function flush() {
  
  
  if (this._rect !== null) {
    this._rect.flush();
    if (this.memoryBuffer !== this._rect.memoryBuffer) {
      let srcView = new Uint8Array(this._rect.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  return true;
};

VkClearRect.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkClearRect.byteLength = 0x18;

VkClearRect.memoryLayout = Object.freeze({
  rect: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x10
  }),
  baseArrayLayer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  layerCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkComponentMapping **/
class VkComponentMapping {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.r !== void 0) this.r = opts.r;
      if (opts.g !== void 0) this.g = opts.g;
      if (opts.b !== void 0) this.b = opts.b;
      if (opts.a !== void 0) this.a = opts.a;
      
    }
  }
  get r() {
    return this.memoryViewInt32[0x0];
  }
  set r(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComponentMapping.r': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get g() {
    return this.memoryViewInt32[0x1];
  }
  set g(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComponentMapping.g': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get b() {
    return this.memoryViewInt32[0x2];
  }
  set b(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComponentMapping.b': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  get a() {
    return this.memoryViewInt32[0x3];
  }
  set a(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComponentMapping.a': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  
};

VkComponentMapping.prototype.flush = function flush() {
  
  return true;
};

VkComponentMapping.prototype.reflect = function reflect(memoryAddress) {
  
};

VkComponentMapping.byteLength = 0x10;

VkComponentMapping.memoryLayout = Object.freeze({
  r: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  g: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  b: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  a: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceProperties **/
class VkPhysicalDeviceProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x338) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x338) / 0x4);
      this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x338) / 0x1);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x338);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    this._pipelineCacheUUID = [...Array(16)].fill(0x0);
    this._limits = new VkPhysicalDeviceLimits({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x128 });
    this._sparseProperties = new VkPhysicalDeviceSparseProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x320 });
    
    if (typeof opts === "object") {
      
    }
  }
  get apiVersion() {
    return this.memoryViewUint32[0x0];
  }
  get driverVersion() {
    return this.memoryViewUint32[0x1];
  }
  get vendorID() {
    return this.memoryViewUint32[0x2];
  }
  get deviceID() {
    return this.memoryViewUint32[0x3];
  }
  get deviceType() {
    return this.memoryViewInt32[0x4];
  }
  get deviceName() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(0x14, 0x128)
    ) || null;
  }
  get pipelineCacheUUID() {
    return [
      this.memoryViewUint8[0x114],
      this.memoryViewUint8[0x115],
      this.memoryViewUint8[0x116],
      this.memoryViewUint8[0x117],
      this.memoryViewUint8[0x118],
      this.memoryViewUint8[0x119],
      this.memoryViewUint8[0x11A],
      this.memoryViewUint8[0x11B],
      this.memoryViewUint8[0x11C],
      this.memoryViewUint8[0x11D],
      this.memoryViewUint8[0x11E],
      this.memoryViewUint8[0x11F],
      this.memoryViewUint8[0x120],
      this.memoryViewUint8[0x121],
      this.memoryViewUint8[0x122],
      this.memoryViewUint8[0x123]
    ];
  }
  get limits() {
    return this._limits;
  }
  get sparseProperties() {
    return this._sparseProperties;
  }
  
};

VkPhysicalDeviceProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x338));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x338), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceProperties.byteLength = 0x338;

VkPhysicalDeviceProperties.memoryLayout = Object.freeze({
  apiVersion: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  driverVersion: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  vendorID: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  deviceID: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  deviceType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  deviceName: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x100
  }),
  pipelineCacheUUID: Object.freeze({
    byteOffset: 0x114,
    byteLength: 0x10
  }),
  limits: Object.freeze({
    byteOffset: 0x128,
    byteLength: 0x1F8
  }),
  sparseProperties: Object.freeze({
    byteOffset: 0x320,
    byteLength: 0x14
  }),
});
/** VkExtensionProperties **/
class VkExtensionProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x104) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x104);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get extensionName() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(0x0, 0x100)
    ) || null;
  }
  get specVersion() {
    return this.memoryViewUint32[0x40];
  }
  
};

VkExtensionProperties.prototype.flush = function flush() {
  
  return true;
};

VkExtensionProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x104));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x104), 0x0);
};

VkExtensionProperties.byteLength = 0x104;

VkExtensionProperties.memoryLayout = Object.freeze({
  extensionName: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x100
  }),
  specVersion: Object.freeze({
    byteOffset: 0x100,
    byteLength: 0x4
  }),
});
/** VkLayerProperties **/
class VkLayerProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x208) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x208);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get layerName() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(0x0, 0x100)
    ) || null;
  }
  get specVersion() {
    return this.memoryViewUint32[0x40];
  }
  get implementationVersion() {
    return this.memoryViewUint32[0x41];
  }
  get description() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(0x108, 0x310)
    ) || null;
  }
  
};

VkLayerProperties.prototype.flush = function flush() {
  
  return true;
};

VkLayerProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x208));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x208), 0x0);
};

VkLayerProperties.byteLength = 0x208;

VkLayerProperties.memoryLayout = Object.freeze({
  layerName: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x100
  }),
  specVersion: Object.freeze({
    byteOffset: 0x100,
    byteLength: 0x4
  }),
  implementationVersion: Object.freeze({
    byteOffset: 0x104,
    byteLength: 0x4
  }),
  description: Object.freeze({
    byteOffset: 0x108,
    byteLength: 0x100
  }),
});
/** VkApplicationInfo **/
class VkApplicationInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._pApplicationName = null;
    
    this._pEngineName = null;
    
    
    this.sType = 0x0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.pApplicationName !== void 0) this.pApplicationName = opts.pApplicationName;
      if (opts.applicationVersion !== void 0) this.applicationVersion = opts.applicationVersion;
      if (opts.pEngineName !== void 0) this.pEngineName = opts.pEngineName;
      if (opts.engineVersion !== void 0) this.engineVersion = opts.engineVersion;
      if (opts.apiVersion !== void 0) this.apiVersion = opts.apiVersion;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkApplicationInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkApplicationInfo.pNext' isn't allowed to be filled");
  }
  get pApplicationName() {
    if (this._pApplicationName !== null) {
      let str = textDecoder.decode(this._pApplicationName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pApplicationName(value) {
    if (value !== null && value.constructor === String) {
      this._pApplicationName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x2] = getAddressFromArrayBuffer(this._pApplicationName);
    } else if (value === null) {
      this._pApplicationName = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkApplicationInfo.pApplicationName': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  get applicationVersion() {
    return this.memoryViewUint32[0x6];
  }
  set applicationVersion(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkApplicationInfo.applicationVersion': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pEngineName() {
    if (this._pEngineName !== null) {
      let str = textDecoder.decode(this._pEngineName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pEngineName(value) {
    if (value !== null && value.constructor === String) {
      this._pEngineName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._pEngineName);
    } else if (value === null) {
      this._pEngineName = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkApplicationInfo.pEngineName': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  get engineVersion() {
    return this.memoryViewUint32[0xA];
  }
  set engineVersion(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkApplicationInfo.engineVersion': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xA] = value;
  }
  get apiVersion() {
    return this.memoryViewUint32[0xB];
  }
  set apiVersion(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkApplicationInfo.apiVersion': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xB] = value;
  }
  
};

VkApplicationInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkApplicationInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkApplicationInfo.byteLength = 0x30;

VkApplicationInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  pApplicationName: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  applicationVersion: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pEngineName: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  engineVersion: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  apiVersion: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
});
/** VkAllocationCallbacks **/
class VkAllocationCallbacks {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    this._pUserData = null;
    
    if (typeof opts === "object") {
      if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
      
    }
  }
  get pUserData() {
    return this._pUserData;
  }
  set pUserData(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryViewBigInt64[0x0] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAllocationCallbacks.pUserData': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkAllocationCallbacks.prototype.flush = function flush() {
  
  return true;
};

VkAllocationCallbacks.prototype.reflect = function reflect(memoryAddress) {
  
};

VkAllocationCallbacks.byteLength = 0x30;

VkAllocationCallbacks.memoryLayout = Object.freeze({
  pUserData: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
});
/** VkDeviceQueueCreateInfo **/
class VkDeviceQueueCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._pQueuePriorities = null;
    this.sType = 0x2;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
      if (opts.queueCount !== void 0) this.queueCount = opts.queueCount;
      if (opts.pQueuePriorities !== void 0) this.pQueuePriorities = opts.pQueuePriorities;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D71B0:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get queueFamilyIndex() {
    return this.memoryViewUint32[0x5];
  }
  set queueFamilyIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.queueFamilyIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get queueCount() {
    return this.memoryViewUint32[0x6];
  }
  set queueCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.queueCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pQueuePriorities() {
    return this._pQueuePriorities;
  }
  set pQueuePriorities(value) {
    if (value !== null && value.constructor === Float32Array) {
      this._pQueuePriorities = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueuePriorities = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceQueueCreateInfo.pQueuePriorities': Expected 'Float32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDeviceQueueCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceQueueCreateInfo.byteLength = 0x28;

VkDeviceQueueCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  queueFamilyIndex: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  queueCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pQueuePriorities: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkDeviceCreateInfo **/
class VkDeviceCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pQueueCreateInfos = null;
    this._pQueueCreateInfosNative = null;
    
    this._ppEnabledLayerNames = null;
    this._ppEnabledLayerNamesNative = null;
    
    this._ppEnabledExtensionNames = null;
    this._ppEnabledExtensionNamesNative = null;
    this._pEnabledFeatures = null;
    this.sType = 0x3;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.queueCreateInfoCount !== void 0) this.queueCreateInfoCount = opts.queueCreateInfoCount;
      if (opts.pQueueCreateInfos !== void 0) this.pQueueCreateInfos = opts.pQueueCreateInfos;
      if (opts.enabledLayerCount !== void 0) this.enabledLayerCount = opts.enabledLayerCount;
      if (opts.ppEnabledLayerNames !== void 0) this.ppEnabledLayerNames = opts.ppEnabledLayerNames;
      if (opts.enabledExtensionCount !== void 0) this.enabledExtensionCount = opts.enabledExtensionCount;
      if (opts.ppEnabledExtensionNames !== void 0) this.ppEnabledExtensionNames = opts.ppEnabledExtensionNames;
      if (opts.pEnabledFeatures !== void 0) this.pEnabledFeatures = opts.pEnabledFeatures;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB078:
        case 0x3B9C9EC0:
        case 0x3B9B9909:
        case 0x3B9BDB71:
        case 0x3B9C0E38:
        case 0x3B9D2B64:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        case 0x3B9D0C20:
        case 0x3B9CE510:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        case 0x3B9C0A50:
        case 0x3B9D3EE9:
        case 0x3B9D7D68:
        case 0x3B9C0669:
        case 0x3B9E0238:
        case 0x3B9D8920:
        case 0x3B9DB032:
        case 0x3B9BCFB9:
        case 0x3B9B3760:
        case 0x3B9D5270:
        case 0x3B9DEACA:
        case 0x3B9B8D50:
        case 0x3B9DDB28:
        case 0x3B9DE2F8:
        case 0x3B9DE6E0:
        case 0x3B9E7380:
        case 0x3B9D4AA1:
        case 0x3B9DDF10:
        case 0x3B9DAC48:
        case 0x3B9E1D90:
        case 0x3B9E2948:
        case 0x3B9C5870:
        case 0x3B9E6BB0:
        case 0x3B9E8320:
        case 0x3B9E96A8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get queueCreateInfoCount() {
    return this.memoryViewUint32[0x5];
  }
  set queueCreateInfoCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.queueCreateInfoCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pQueueCreateInfos() {
    return this._pQueueCreateInfos;
  }
  set pQueueCreateInfos(value) {
    if (value !== null && value.constructor === Array) {
      this._pQueueCreateInfos = value;
    } else if (value === null) {
      this._pQueueCreateInfos = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pQueueCreateInfos': Expected 'Array VkDeviceQueueCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get enabledLayerCount() {
    return this.memoryViewUint32[0x8];
  }
  set enabledLayerCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.enabledLayerCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get ppEnabledLayerNames() {
    return this._ppEnabledLayerNames;
  }
  set ppEnabledLayerNames(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledLayerNames = value;
    } else if (value === null) {
      this._ppEnabledLayerNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledLayerNames': Expected 'Array char' but got '" + value.constructor.name + "'");
    }
  }
  get enabledExtensionCount() {
    return this.memoryViewUint32[0xC];
  }
  set enabledExtensionCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.enabledExtensionCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get ppEnabledExtensionNames() {
    return this._ppEnabledExtensionNames;
  }
  set ppEnabledExtensionNames(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledExtensionNames = value;
    } else if (value === null) {
      this._ppEnabledExtensionNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledExtensionNames': Expected 'Array char' but got '" + value.constructor.name + "'");
    }
  }
  get pEnabledFeatures() {
    return this._pEnabledFeatures;
  }
  set pEnabledFeatures(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._pEnabledFeatures = value;
      this.memoryViewBigInt64[0x8] = value.memoryAddress;
      
    } else if (value === null) {
      this._pEnabledFeatures = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pEnabledFeatures': Expected 'VkPhysicalDeviceFeatures' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDeviceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pQueueCreateInfos !== null) {
    let array = this._pQueueCreateInfos;
    if (array.length !== this.queueCreateInfoCount) {
      throw new RangeError("Invalid array length, expected length of 'queueCreateInfoCount' for 'VkDeviceCreateInfo.pQueueCreateInfos'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDeviceQueueCreateInfo) {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.pQueueCreateInfos[" + ii + "]': Expected 'VkDeviceQueueCreateInfo' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pQueueCreateInfosNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._ppEnabledLayerNames !== null) {
    let array = this._ppEnabledLayerNames;
    // validate length
    if (array.length !== this.enabledLayerCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledLayerCount' for 'VkDeviceCreateInfo.ppEnabledLayerNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== String) {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledLayerNames[" + ii + "]': Expected 'String' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledLayerNames);
    this._ppEnabledLayerNamesNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  } else {
    this.memoryViewBigInt64[0x5] = BI0;
  }
  
  
  if (this._ppEnabledExtensionNames !== null) {
    let array = this._ppEnabledExtensionNames;
    // validate length
    if (array.length !== this.enabledExtensionCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledExtensionCount' for 'VkDeviceCreateInfo.ppEnabledExtensionNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== String) {
        throw new TypeError("Invalid type for 'VkDeviceCreateInfo.ppEnabledExtensionNames[" + ii + "]': Expected 'String' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledExtensionNames);
    this._ppEnabledExtensionNamesNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  } else {
    this.memoryViewBigInt64[0x7] = BI0;
  }
  
  return true;
};

VkDeviceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkDeviceCreateInfo.byteLength = 0x48;

VkDeviceCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  queueCreateInfoCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pQueueCreateInfos: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  enabledLayerCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  ppEnabledLayerNames: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  enabledExtensionCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  ppEnabledExtensionNames: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  pEnabledFeatures: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x8
  }),
});
/** VkInstanceCreateInfo **/
class VkInstanceCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pApplicationInfo = null;
    
    this._ppEnabledLayerNames = null;
    this._ppEnabledLayerNamesNative = null;
    
    this._ppEnabledExtensionNames = null;
    this._ppEnabledExtensionNamesNative = null;
    this.sType = 0x1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pApplicationInfo !== void 0) this.pApplicationInfo = opts.pApplicationInfo;
      if (opts.enabledLayerCount !== void 0) this.enabledLayerCount = opts.enabledLayerCount;
      if (opts.ppEnabledLayerNames !== void 0) this.ppEnabledLayerNames = opts.ppEnabledLayerNames;
      if (opts.enabledExtensionCount !== void 0) this.enabledExtensionCount = opts.enabledExtensionCount;
      if (opts.ppEnabledExtensionNames !== void 0) this.ppEnabledExtensionNames = opts.ppEnabledExtensionNames;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9AF4F8:
        case 0x3B9BB848:
        case 0x3B9E8ED8:
        case 0x3B9CBE04:
          break;
        default:
          throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get pApplicationInfo() {
    return this._pApplicationInfo;
  }
  set pApplicationInfo(value) {
    if (value !== null && value.constructor === VkApplicationInfo) {
      value.flush();
      this._pApplicationInfo = value;
      this.memoryViewBigInt64[0x3] = value.memoryAddress;
      
    } else if (value === null) {
      this._pApplicationInfo = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.pApplicationInfo': Expected 'VkApplicationInfo' but got '" + value.constructor.name + "'");
    }
  }
  get enabledLayerCount() {
    return this.memoryViewUint32[0x8];
  }
  set enabledLayerCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.enabledLayerCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get ppEnabledLayerNames() {
    return this._ppEnabledLayerNames;
  }
  set ppEnabledLayerNames(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledLayerNames = value;
    } else if (value === null) {
      this._ppEnabledLayerNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledLayerNames': Expected 'Array char' but got '" + value.constructor.name + "'");
    }
  }
  get enabledExtensionCount() {
    return this.memoryViewUint32[0xC];
  }
  set enabledExtensionCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.enabledExtensionCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get ppEnabledExtensionNames() {
    return this._ppEnabledExtensionNames;
  }
  set ppEnabledExtensionNames(value) {
    if (value !== null && value.constructor === Array) {
      this._ppEnabledExtensionNames = value;
    } else if (value === null) {
      this._ppEnabledExtensionNames = null;
    } else {
      throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledExtensionNames': Expected 'Array char' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkInstanceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._ppEnabledLayerNames !== null) {
    let array = this._ppEnabledLayerNames;
    // validate length
    if (array.length !== this.enabledLayerCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledLayerCount' for 'VkInstanceCreateInfo.ppEnabledLayerNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== String) {
        throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledLayerNames[" + ii + "]': Expected 'String' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledLayerNames);
    this._ppEnabledLayerNamesNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  } else {
    this.memoryViewBigInt64[0x5] = BI0;
  }
  
  
  if (this._ppEnabledExtensionNames !== null) {
    let array = this._ppEnabledExtensionNames;
    // validate length
    if (array.length !== this.enabledExtensionCount) {
      throw new RangeError("Invalid array length, expected length of 'enabledExtensionCount' for 'VkInstanceCreateInfo.ppEnabledExtensionNames'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== String) {
        throw new TypeError("Invalid type for 'VkInstanceCreateInfo.ppEnabledExtensionNames[" + ii + "]': Expected 'String' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    let nativeArray = new NativeStringArray(this._ppEnabledExtensionNames);
    this._ppEnabledExtensionNamesNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  } else {
    this.memoryViewBigInt64[0x7] = BI0;
  }
  
  return true;
};

VkInstanceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkInstanceCreateInfo.byteLength = 0x40;

VkInstanceCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pApplicationInfo: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  enabledLayerCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  ppEnabledLayerNames: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  enabledExtensionCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  ppEnabledExtensionNames: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkQueueFamilyProperties **/
class VkQueueFamilyProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    this._minImageTransferGranularity = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0xC });
    
    if (typeof opts === "object") {
      
    }
  }
  get queueFlags() {
    return this.memoryViewInt32[0x0];
  }
  get queueCount() {
    return this.memoryViewUint32[0x1];
  }
  get timestampValidBits() {
    return this.memoryViewUint32[0x2];
  }
  get minImageTransferGranularity() {
    return this._minImageTransferGranularity;
  }
  
};

VkQueueFamilyProperties.prototype.flush = function flush() {
  
  return true;
};

VkQueueFamilyProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkQueueFamilyProperties.byteLength = 0x18;

VkQueueFamilyProperties.memoryLayout = Object.freeze({
  queueFlags: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  queueCount: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  timestampValidBits: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  minImageTransferGranularity: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0xC
  }),
});
/** VkPhysicalDeviceMemoryProperties **/
class VkPhysicalDeviceMemoryProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x208) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x208);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._memoryTypes = [...Array(32)].map((v, i) => new VkMemoryType({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x4 + (i * 0x8) }));
    
    this._memoryHeaps = [...Array(16)].map((v, i) => new VkMemoryHeap({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x108 + (i * 0x10) }));
    
    if (typeof opts === "object") {
      
    }
  }
  get memoryTypeCount() {
    return this.memoryViewUint32[0x0];
  }
  get memoryTypes() {
    return this._memoryTypes;
  }
  get memoryHeapCount() {
    return this.memoryViewUint32[0x41];
  }
  get memoryHeaps() {
    return this._memoryHeaps;
  }
  
};

VkPhysicalDeviceMemoryProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x208));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x208), 0x0);
  
  
  
  
};

VkPhysicalDeviceMemoryProperties.byteLength = 0x208;

VkPhysicalDeviceMemoryProperties.memoryLayout = Object.freeze({
  memoryTypeCount: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  memoryTypes: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x100
  }),
  memoryHeapCount: Object.freeze({
    byteOffset: 0x104,
    byteLength: 0x4
  }),
  memoryHeaps: Object.freeze({
    byteOffset: 0x108,
    byteLength: 0x100
  }),
});
/** VkMemoryAllocateInfo **/
class VkMemoryAllocateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x5;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.allocationSize !== void 0) this.allocationSize = opts.allocationSize;
      if (opts.memoryTypeIndex !== void 0) this.memoryTypeIndex = opts.memoryTypeIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B2F92:
        case 0x3B9BA4C1:
        case 0x3B9BA8A8:
        case 0x3B9BA8A9:
        case 0x3B9BE342:
        case 0x3B9BE728:
        case 0x3B9BE729:
        case 0x3B9BEB10:
        case 0x3B9BB460:
        case 0x3B9CBA19:
        case 0x3B9D8150:
        case 0x3B9CC1EB:
        case 0x3B9E6BB1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.pNext'");
    }
  }
  get allocationSize() {
    return this.memoryViewBigUint64[0x2];
  }
  set allocationSize(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.allocationSize': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x2] = value;
  }
  get memoryTypeIndex() {
    return this.memoryViewUint32[0x6];
  }
  set memoryTypeIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateInfo.memoryTypeIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  
};

VkMemoryAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryAllocateInfo.byteLength = 0x20;

VkMemoryAllocateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  allocationSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  memoryTypeIndex: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkMemoryRequirements **/
class VkMemoryRequirements {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get size() {
    return this.memoryViewBigUint64[0x0];
  }
  get alignment() {
    return this.memoryViewBigUint64[0x1];
  }
  get memoryTypeBits() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkMemoryRequirements.prototype.flush = function flush() {
  
  return true;
};

VkMemoryRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
};

VkMemoryRequirements.byteLength = 0x18;

VkMemoryRequirements.memoryLayout = Object.freeze({
  size: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  alignment: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryTypeBits: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkSparseImageFormatProperties **/
class VkSparseImageFormatProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x14);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    this._imageGranularity = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x4 });
    
    
    if (typeof opts === "object") {
      
    }
  }
  get aspectMask() {
    return this.memoryViewInt32[0x0];
  }
  get imageGranularity() {
    return this._imageGranularity;
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  
};

VkSparseImageFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkSparseImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x14));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x14), 0x0);
  
  
};

VkSparseImageFormatProperties.byteLength = 0x14;

VkSparseImageFormatProperties.memoryLayout = Object.freeze({
  aspectMask: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  imageGranularity: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0xC
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkSparseImageMemoryRequirements **/
class VkSparseImageMemoryRequirements {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    this._formatProperties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get formatProperties() {
    return this._formatProperties;
  }
  get imageMipTailFirstLod() {
    return this.memoryViewUint32[0x5];
  }
  get imageMipTailSize() {
    return this.memoryViewBigUint64[0x3];
  }
  get imageMipTailOffset() {
    return this.memoryViewBigUint64[0x4];
  }
  get imageMipTailStride() {
    return this.memoryViewBigUint64[0x5];
  }
  
};

VkSparseImageMemoryRequirements.prototype.flush = function flush() {
  
  return true;
};

VkSparseImageMemoryRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
};

VkSparseImageMemoryRequirements.byteLength = 0x30;

VkSparseImageMemoryRequirements.memoryLayout = Object.freeze({
  formatProperties: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x14
  }),
  imageMipTailFirstLod: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  imageMipTailSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  imageMipTailOffset: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  imageMipTailStride: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkMemoryType **/
class VkMemoryType {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get propertyFlags() {
    return this.memoryViewInt32[0x0];
  }
  get heapIndex() {
    return this.memoryViewUint32[0x1];
  }
  
};

VkMemoryType.prototype.flush = function flush() {
  
  return true;
};

VkMemoryType.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x8), 0x0);
};

VkMemoryType.byteLength = 0x8;

VkMemoryType.memoryLayout = Object.freeze({
  propertyFlags: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  heapIndex: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkMemoryHeap **/
class VkMemoryHeap {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get size() {
    return this.memoryViewBigUint64[0x0];
  }
  get flags() {
    return this.memoryViewInt32[0x2];
  }
  
};

VkMemoryHeap.prototype.flush = function flush() {
  
  return true;
};

VkMemoryHeap.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x10));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x10), 0x0);
};

VkMemoryHeap.byteLength = 0x10;

VkMemoryHeap.memoryLayout = Object.freeze({
  size: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkMappedMemoryRange **/
class VkMappedMemoryRange {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._memory = null;
    
    
    this.sType = 0x6;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.size !== void 0) this.size = opts.size;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMappedMemoryRange.pNext' isn't allowed to be filled");
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get offset() {
    return this.memoryViewBigUint64[0x3];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get size() {
    return this.memoryViewBigUint64[0x4];
  }
  set size(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkMappedMemoryRange.size': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  
};

VkMappedMemoryRange.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMappedMemoryRange.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMappedMemoryRange.byteLength = 0x28;

VkMappedMemoryRange.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memory: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  offset: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  size: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkFormatProperties **/
class VkFormatProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get linearTilingFeatures() {
    return this.memoryViewInt32[0x0];
  }
  get optimalTilingFeatures() {
    return this.memoryViewInt32[0x1];
  }
  get bufferFeatures() {
    return this.memoryViewInt32[0x2];
  }
  
};

VkFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0xC));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0xC), 0x0);
};

VkFormatProperties.byteLength = 0xC;

VkFormatProperties.memoryLayout = Object.freeze({
  linearTilingFeatures: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  optimalTilingFeatures: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  bufferFeatures: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkImageFormatProperties **/
class VkImageFormatProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    this._maxExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get maxExtent() {
    return this._maxExtent;
  }
  get maxMipLevels() {
    return this.memoryViewUint32[0x3];
  }
  get maxArrayLayers() {
    return this.memoryViewUint32[0x4];
  }
  get sampleCounts() {
    return this.memoryViewInt32[0x5];
  }
  get maxResourceSize() {
    return this.memoryViewBigUint64[0x3];
  }
  
};

VkImageFormatProperties.prototype.flush = function flush() {
  
  return true;
};

VkImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkImageFormatProperties.byteLength = 0x20;

VkImageFormatProperties.memoryLayout = Object.freeze({
  maxExtent: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0xC
  }),
  maxMipLevels: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  maxArrayLayers: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  sampleCounts: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  maxResourceSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDescriptorBufferInfo **/
class VkDescriptorBufferInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    this._buffer = null;
    
    
    
    if (typeof opts === "object") {
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.range !== void 0) this.range = opts.range;
      
    }
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorBufferInfo.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get offset() {
    return this.memoryViewBigUint64[0x1];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDescriptorBufferInfo.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x1] = value;
  }
  get range() {
    return this.memoryViewBigUint64[0x2];
  }
  set range(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDescriptorBufferInfo.range': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x2] = value;
  }
  
};

VkDescriptorBufferInfo.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorBufferInfo.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorBufferInfo.byteLength = 0x18;

VkDescriptorBufferInfo.memoryLayout = Object.freeze({
  buffer: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  offset: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  range: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkDescriptorImageInfo **/
class VkDescriptorImageInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    this._sampler = null;
    this._imageView = null;
    
    
    if (typeof opts === "object") {
      if (opts.sampler !== void 0) this.sampler = opts.sampler;
      if (opts.imageView !== void 0) this.imageView = opts.imageView;
      if (opts.imageLayout !== void 0) this.imageLayout = opts.imageLayout;
      
    }
  }
  get sampler() {
    return this._sampler;
  }
  set sampler(value) {
    if (value !== null && value.constructor === VkSampler) {
      
      this._sampler = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._sampler = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorImageInfo.sampler': Expected 'VkSampler' but got '" + value.constructor.name + "'");
    }
  }
  get imageView() {
    return this._imageView;
  }
  set imageView(value) {
    if (value !== null && value.constructor === VkImageView) {
      
      this._imageView = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._imageView = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorImageInfo.imageView': Expected 'VkImageView' but got '" + value.constructor.name + "'");
    }
  }
  get imageLayout() {
    return this.memoryViewInt32[0x4];
  }
  set imageLayout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorImageInfo.imageLayout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkDescriptorImageInfo.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorImageInfo.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorImageInfo.byteLength = 0x18;

VkDescriptorImageInfo.memoryLayout = Object.freeze({
  sampler: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  imageView: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  imageLayout: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkWriteDescriptorSet **/
class VkWriteDescriptorSet {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._dstSet = null;
    
    
    
    
    this._pImageInfo = null;
    this._pImageInfoNative = null;
    this._pBufferInfo = null;
    this._pBufferInfoNative = null;
    this._pTexelBufferView = null;
    this._pTexelBufferViewNative = null;
    this.sType = 0x23;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.dstSet !== void 0) this.dstSet = opts.dstSet;
      if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
      if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
      if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
      if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
      if (opts.pImageInfo !== void 0) this.pImageInfo = opts.pImageInfo;
      if (opts.pBufferInfo !== void 0) this.pBufferInfo = opts.pBufferInfo;
      if (opts.pTexelBufferView !== void 0) this.pTexelBufferView = opts.pTexelBufferView;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
      switch (sType) {
          
        case 0x3B9CE512:
        case 0x3B9D4E8F:
          break;
        default:
          throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pNext'");
    }
  }
  get dstSet() {
    return this._dstSet;
  }
  set dstSet(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._dstSet = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._dstSet = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.dstSet': Expected 'VkDescriptorSet' but got '" + value.constructor.name + "'");
    }
  }
  get dstBinding() {
    return this.memoryViewUint32[0x6];
  }
  set dstBinding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.dstBinding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get dstArrayElement() {
    return this.memoryViewUint32[0x7];
  }
  set dstArrayElement(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.dstArrayElement': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get descriptorCount() {
    return this.memoryViewUint32[0x8];
  }
  set descriptorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.descriptorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get descriptorType() {
    return this.memoryViewInt32[0x9];
  }
  set descriptorType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.descriptorType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get pImageInfo() {
    return this._pImageInfo;
  }
  set pImageInfo(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageInfo = value;
    } else if (value === null) {
      this._pImageInfo = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pImageInfo': Expected 'Array VkDescriptorImageInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pBufferInfo() {
    return this._pBufferInfo;
  }
  set pBufferInfo(value) {
    if (value !== null && value.constructor === Array) {
      this._pBufferInfo = value;
    } else if (value === null) {
      this._pBufferInfo = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pBufferInfo': Expected 'Array VkDescriptorBufferInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pTexelBufferView() {
    return this._pTexelBufferView;
  }
  set pTexelBufferView(value) {
    if (value !== null && value.constructor === Array) {
      this._pTexelBufferView = value;
    } else if (value === null) {
      this._pTexelBufferView = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pTexelBufferView': Expected 'Array VkBufferView' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkWriteDescriptorSet.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pImageInfo !== null) {
    let array = this._pImageInfo;
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pImageInfo'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDescriptorImageInfo) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pImageInfo[" + ii + "]': Expected 'VkDescriptorImageInfo' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pImageInfoNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  
  if (this._pBufferInfo !== null) {
    let array = this._pBufferInfo;
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pBufferInfo'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDescriptorBufferInfo) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pBufferInfo[" + ii + "]': Expected 'VkDescriptorBufferInfo' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pBufferInfoNative = nativeArray;
    this.memoryViewBigInt64[0x6] = nativeArray.address;
  }
  
  
  if (this._pTexelBufferView !== null) {
    let array = this._pTexelBufferView;
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkWriteDescriptorSet.pTexelBufferView'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkBufferView) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSet.pTexelBufferView[" + ii + "]': Expected 'VkBufferView' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pTexelBufferViewNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  }
  
  return true;
};

VkWriteDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkWriteDescriptorSet.byteLength = 0x40;

VkWriteDescriptorSet.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  dstSet: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  dstBinding: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  dstArrayElement: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  descriptorCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  descriptorType: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  pImageInfo: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  pBufferInfo: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  pTexelBufferView: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkCopyDescriptorSet **/
class VkCopyDescriptorSet {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._srcSet = null;
    
    
    this._dstSet = null;
    
    
    
    this.sType = 0x24;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.srcSet !== void 0) this.srcSet = opts.srcSet;
      if (opts.srcBinding !== void 0) this.srcBinding = opts.srcBinding;
      if (opts.srcArrayElement !== void 0) this.srcArrayElement = opts.srcArrayElement;
      if (opts.dstSet !== void 0) this.dstSet = opts.dstSet;
      if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
      if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
      if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCopyDescriptorSet.pNext' isn't allowed to be filled");
  }
  get srcSet() {
    return this._srcSet;
  }
  set srcSet(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._srcSet = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._srcSet = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.srcSet': Expected 'VkDescriptorSet' but got '" + value.constructor.name + "'");
    }
  }
  get srcBinding() {
    return this.memoryViewUint32[0x6];
  }
  set srcBinding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.srcBinding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get srcArrayElement() {
    return this.memoryViewUint32[0x7];
  }
  set srcArrayElement(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.srcArrayElement': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get dstSet() {
    return this._dstSet;
  }
  set dstSet(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._dstSet = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._dstSet = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.dstSet': Expected 'VkDescriptorSet' but got '" + value.constructor.name + "'");
    }
  }
  get dstBinding() {
    return this.memoryViewUint32[0xA];
  }
  set dstBinding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.dstBinding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xA] = value;
  }
  get dstArrayElement() {
    return this.memoryViewUint32[0xB];
  }
  set dstArrayElement(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.dstArrayElement': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xB] = value;
  }
  get descriptorCount() {
    return this.memoryViewUint32[0xC];
  }
  set descriptorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCopyDescriptorSet.descriptorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  
};

VkCopyDescriptorSet.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCopyDescriptorSet.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCopyDescriptorSet.byteLength = 0x38;

VkCopyDescriptorSet.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  srcSet: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  srcBinding: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  srcArrayElement: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  dstSet: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  dstBinding: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  dstArrayElement: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  descriptorCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
});
/** VkBufferCreateInfo **/
class VkBufferCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    this._pQueueFamilyIndices = null;
    this.sType = 0xC;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.size !== void 0) this.size = opts.size;
      if (opts.usage !== void 0) this.usage = opts.usage;
      if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
      if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
      if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B2F91:
        case 0x3B9BE340:
        case 0x3B9E8322:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get size() {
    return this.memoryViewBigUint64[0x3];
  }
  set size(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.size': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get usage() {
    return this.memoryViewInt32[0x8];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get sharingMode() {
    return this.memoryViewInt32[0x9];
  }
  set sharingMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.sharingMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get queueFamilyIndexCount() {
    return this.memoryViewUint32[0xA];
  }
  set queueFamilyIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.queueFamilyIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xA] = value;
  }
  get pQueueFamilyIndices() {
    return this._pQueueFamilyIndices;
  }
  set pQueueFamilyIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferCreateInfo.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferCreateInfo.byteLength = 0x38;

VkBufferCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  size: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  usage: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  sharingMode: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  queueFamilyIndexCount: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  pQueueFamilyIndices: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
});
/** VkBufferViewCreateInfo **/
class VkBufferViewCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._buffer = null;
    
    
    
    this.sType = 0xD;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.range !== void 0) this.range = opts.range;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBufferViewCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get format() {
    return this.memoryViewInt32[0x8];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get offset() {
    return this.memoryViewBigUint64[0x5];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x5] = value;
  }
  get range() {
    return this.memoryViewBigUint64[0x6];
  }
  set range(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferViewCreateInfo.range': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x6] = value;
  }
  
};

VkBufferViewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferViewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferViewCreateInfo.byteLength = 0x38;

VkBufferViewCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  buffer: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  format: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  offset: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  range: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
});
/** VkImageSubresource **/
class VkImageSubresource {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
      if (opts.mipLevel !== void 0) this.mipLevel = opts.mipLevel;
      if (opts.arrayLayer !== void 0) this.arrayLayer = opts.arrayLayer;
      
    }
  }
  get aspectMask() {
    return this.memoryViewInt32[0x0];
  }
  set aspectMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresource.aspectMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get mipLevel() {
    return this.memoryViewUint32[0x1];
  }
  set mipLevel(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresource.mipLevel': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get arrayLayer() {
    return this.memoryViewUint32[0x2];
  }
  set arrayLayer(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresource.arrayLayer': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  
};

VkImageSubresource.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresource.prototype.reflect = function reflect(memoryAddress) {
  
};

VkImageSubresource.byteLength = 0xC;

VkImageSubresource.memoryLayout = Object.freeze({
  aspectMask: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  mipLevel: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  arrayLayer: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkImageSubresourceLayers **/
class VkImageSubresourceLayers {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
      if (opts.mipLevel !== void 0) this.mipLevel = opts.mipLevel;
      if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
      if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
      
    }
  }
  get aspectMask() {
    return this.memoryViewInt32[0x0];
  }
  set aspectMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceLayers.aspectMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get mipLevel() {
    return this.memoryViewUint32[0x1];
  }
  set mipLevel(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceLayers.mipLevel': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get baseArrayLayer() {
    return this.memoryViewUint32[0x2];
  }
  set baseArrayLayer(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceLayers.baseArrayLayer': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get layerCount() {
    return this.memoryViewUint32[0x3];
  }
  set layerCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceLayers.layerCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x3] = value;
  }
  
};

VkImageSubresourceLayers.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresourceLayers.prototype.reflect = function reflect(memoryAddress) {
  
};

VkImageSubresourceLayers.byteLength = 0x10;

VkImageSubresourceLayers.memoryLayout = Object.freeze({
  aspectMask: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  mipLevel: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  baseArrayLayer: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  layerCount: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
});
/** VkImageSubresourceRange **/
class VkImageSubresourceRange {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x14);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
      if (opts.baseMipLevel !== void 0) this.baseMipLevel = opts.baseMipLevel;
      if (opts.levelCount !== void 0) this.levelCount = opts.levelCount;
      if (opts.baseArrayLayer !== void 0) this.baseArrayLayer = opts.baseArrayLayer;
      if (opts.layerCount !== void 0) this.layerCount = opts.layerCount;
      
    }
  }
  get aspectMask() {
    return this.memoryViewInt32[0x0];
  }
  set aspectMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.aspectMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get baseMipLevel() {
    return this.memoryViewUint32[0x1];
  }
  set baseMipLevel(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.baseMipLevel': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get levelCount() {
    return this.memoryViewUint32[0x2];
  }
  set levelCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.levelCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get baseArrayLayer() {
    return this.memoryViewUint32[0x3];
  }
  set baseArrayLayer(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.baseArrayLayer': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x3] = value;
  }
  get layerCount() {
    return this.memoryViewUint32[0x4];
  }
  set layerCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSubresourceRange.layerCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  
};

VkImageSubresourceRange.prototype.flush = function flush() {
  
  return true;
};

VkImageSubresourceRange.prototype.reflect = function reflect(memoryAddress) {
  
};

VkImageSubresourceRange.byteLength = 0x14;

VkImageSubresourceRange.memoryLayout = Object.freeze({
  aspectMask: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  baseMipLevel: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  levelCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  baseArrayLayer: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  layerCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkMemoryBarrier **/
class VkMemoryBarrier {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x2E;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
      if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryBarrier.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryBarrier.pNext' isn't allowed to be filled");
  }
  get srcAccessMask() {
    return this.memoryViewInt32[0x4];
  }
  set srcAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryBarrier.srcAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get dstAccessMask() {
    return this.memoryViewInt32[0x5];
  }
  set dstAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryBarrier.dstAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  
};

VkMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryBarrier.byteLength = 0x18;

VkMemoryBarrier.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  srcAccessMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  dstAccessMask: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkBufferMemoryBarrier **/
class VkBufferMemoryBarrier {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this._buffer = null;
    
    
    this.sType = 0x2C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
      if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
      if (opts.srcQueueFamilyIndex !== void 0) this.srcQueueFamilyIndex = opts.srcQueueFamilyIndex;
      if (opts.dstQueueFamilyIndex !== void 0) this.dstQueueFamilyIndex = opts.dstQueueFamilyIndex;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.size !== void 0) this.size = opts.size;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBufferMemoryBarrier.pNext' isn't allowed to be filled");
  }
  get srcAccessMask() {
    return this.memoryViewInt32[0x4];
  }
  set srcAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.srcAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get dstAccessMask() {
    return this.memoryViewInt32[0x5];
  }
  set dstAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.dstAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get srcQueueFamilyIndex() {
    return this.memoryViewUint32[0x6];
  }
  set srcQueueFamilyIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.srcQueueFamilyIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get dstQueueFamilyIndex() {
    return this.memoryViewUint32[0x7];
  }
  set dstQueueFamilyIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.dstQueueFamilyIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get offset() {
    return this.memoryViewBigUint64[0x5];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x5] = value;
  }
  get size() {
    return this.memoryViewBigUint64[0x6];
  }
  set size(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferMemoryBarrier.size': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x6] = value;
  }
  
};

VkBufferMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferMemoryBarrier.byteLength = 0x38;

VkBufferMemoryBarrier.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  srcAccessMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  dstAccessMask: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  srcQueueFamilyIndex: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  dstQueueFamilyIndex: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  buffer: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  offset: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  size: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
});
/** VkImageMemoryBarrier **/
class VkImageMemoryBarrier {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    this._image = null;
    this._subresourceRange = new VkImageSubresourceRange({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x30 });
    this.sType = 0x2D;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
      if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
      if (opts.oldLayout !== void 0) this.oldLayout = opts.oldLayout;
      if (opts.newLayout !== void 0) this.newLayout = opts.newLayout;
      if (opts.srcQueueFamilyIndex !== void 0) this.srcQueueFamilyIndex = opts.srcQueueFamilyIndex;
      if (opts.dstQueueFamilyIndex !== void 0) this.dstQueueFamilyIndex = opts.dstQueueFamilyIndex;
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.subresourceRange !== void 0) this.subresourceRange = opts.subresourceRange;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
      switch (sType) {
          
        case 0x3B9CF898:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.pNext'");
    }
  }
  get srcAccessMask() {
    return this.memoryViewInt32[0x4];
  }
  set srcAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.srcAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get dstAccessMask() {
    return this.memoryViewInt32[0x5];
  }
  set dstAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.dstAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get oldLayout() {
    return this.memoryViewInt32[0x6];
  }
  set oldLayout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.oldLayout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get newLayout() {
    return this.memoryViewInt32[0x7];
  }
  set newLayout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.newLayout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get srcQueueFamilyIndex() {
    return this.memoryViewUint32[0x8];
  }
  set srcQueueFamilyIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.srcQueueFamilyIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get dstQueueFamilyIndex() {
    return this.memoryViewUint32[0x9];
  }
  set dstQueueFamilyIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.dstQueueFamilyIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x9] = value;
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get subresourceRange() {
    return this._subresourceRange;
  }
  set subresourceRange(value) {
    if (value !== null && value.constructor === VkImageSubresourceRange) {
      value.flush();
      this._subresourceRange = value;
      
      
    } else if (value === null) {
      this._subresourceRange = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryBarrier.subresourceRange': Expected 'VkImageSubresourceRange' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageMemoryBarrier.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._subresourceRange !== null) {
    this._subresourceRange.flush();
    if (this.memoryBuffer !== this._subresourceRange.memoryBuffer) {
      let srcView = new Uint8Array(this._subresourceRange.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x30);
    }
  }
  
  return true;
};

VkImageMemoryBarrier.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkImageMemoryBarrier.byteLength = 0x48;

VkImageMemoryBarrier.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  srcAccessMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  dstAccessMask: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  oldLayout: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  newLayout: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  srcQueueFamilyIndex: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  dstQueueFamilyIndex: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  image: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  subresourceRange: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x14
  }),
});
/** VkImageCreateInfo **/
class VkImageCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x58);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x1C });
    
    
    
    
    
    
    
    this._pQueueFamilyIndices = null;
    
    this.sType = 0xE;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.imageType !== void 0) this.imageType = opts.imageType;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.extent !== void 0) this.extent = opts.extent;
      if (opts.mipLevels !== void 0) this.mipLevels = opts.mipLevels;
      if (opts.arrayLayers !== void 0) this.arrayLayers = opts.arrayLayers;
      if (opts.samples !== void 0) this.samples = opts.samples;
      if (opts.tiling !== void 0) this.tiling = opts.tiling;
      if (opts.usage !== void 0) this.usage = opts.usage;
      if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
      if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
      if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
      if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B2F90:
        case 0x3B9BA4C0:
        case 0x3B9BE341:
        case 0x3B9BB468:
        case 0x3B9D0838:
        case 0x3B9CC1ED:
        case 0x3B9D3333:
        case 0x3B9D3334:
        case 0x3B9E8AF0:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get imageType() {
    return this.memoryViewInt32[0x5];
  }
  set imageType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.imageType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get format() {
    return this.memoryViewInt32[0x6];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get extent() {
    return this._extent;
  }
  set extent(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.extent': Expected 'VkExtent3D' but got '" + value.constructor.name + "'");
    }
  }
  get mipLevels() {
    return this.memoryViewUint32[0xA];
  }
  set mipLevels(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.mipLevels': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xA] = value;
  }
  get arrayLayers() {
    return this.memoryViewUint32[0xB];
  }
  set arrayLayers(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.arrayLayers': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xB] = value;
  }
  get samples() {
    return this.memoryViewInt32[0xC];
  }
  set samples(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.samples': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  get tiling() {
    return this.memoryViewInt32[0xD];
  }
  set tiling(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.tiling': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xD] = value;
  }
  get usage() {
    return this.memoryViewInt32[0xE];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xE] = value;
  }
  get sharingMode() {
    return this.memoryViewInt32[0xF];
  }
  set sharingMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.sharingMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xF] = value;
  }
  get queueFamilyIndexCount() {
    return this.memoryViewUint32[0x10];
  }
  set queueFamilyIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.queueFamilyIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x10] = value;
  }
  get pQueueFamilyIndices() {
    return this._pQueueFamilyIndices;
  }
  set pQueueFamilyIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryViewBigInt64[0x9] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get initialLayout() {
    return this.memoryViewInt32[0x14];
  }
  set initialLayout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageCreateInfo.initialLayout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x14] = value;
  }
  
};

VkImageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._extent !== null) {
    this._extent.flush();
    if (this.memoryBuffer !== this._extent.memoryBuffer) {
      let srcView = new Uint8Array(this._extent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
    }
  }
  
  return true;
};

VkImageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkImageCreateInfo.byteLength = 0x58;

VkImageCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  imageType: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  format: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  extent: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0xC
  }),
  mipLevels: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  arrayLayers: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  samples: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  tiling: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  usage: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  sharingMode: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  queueFamilyIndexCount: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  pQueueFamilyIndices: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x8
  }),
  initialLayout: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
});
/** VkSubresourceLayout **/
class VkSubresourceLayout {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get offset() {
    return this.memoryViewBigUint64[0x0];
  }
  get size() {
    return this.memoryViewBigUint64[0x1];
  }
  get rowPitch() {
    return this.memoryViewBigUint64[0x2];
  }
  get arrayPitch() {
    return this.memoryViewBigUint64[0x3];
  }
  get depthPitch() {
    return this.memoryViewBigUint64[0x4];
  }
  
};

VkSubresourceLayout.prototype.flush = function flush() {
  
  return true;
};

VkSubresourceLayout.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
};

VkSubresourceLayout.byteLength = 0x28;

VkSubresourceLayout.memoryLayout = Object.freeze({
  offset: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  size: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  rowPitch: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  arrayPitch: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  depthPitch: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkImageViewCreateInfo **/
class VkImageViewCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x50) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x50);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._image = null;
    
    
    this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x28 });
    this._subresourceRange = new VkImageSubresourceRange({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x38 });
    this.sType = 0xF;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.viewType !== void 0) this.viewType = opts.viewType;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.components !== void 0) this.components = opts.components;
      if (opts.subresourceRange !== void 0) this.subresourceRange = opts.subresourceRange;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C930A:
        case 0x3B9D2B61:
        case 0x3B9BCFB8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get viewType() {
    return this.memoryViewInt32[0x8];
  }
  set viewType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.viewType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get format() {
    return this.memoryViewInt32[0x9];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get components() {
    return this._components;
  }
  set components(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.components': Expected 'VkComponentMapping' but got '" + value.constructor.name + "'");
    }
  }
  get subresourceRange() {
    return this._subresourceRange;
  }
  set subresourceRange(value) {
    if (value !== null && value.constructor === VkImageSubresourceRange) {
      value.flush();
      this._subresourceRange = value;
      
      
    } else if (value === null) {
      this._subresourceRange = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageViewCreateInfo.subresourceRange': Expected 'VkImageSubresourceRange' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageViewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    this._components.flush();
    if (this.memoryBuffer !== this._components.memoryBuffer) {
      let srcView = new Uint8Array(this._components.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x28);
    }
  }
  
  
  if (this._subresourceRange !== null) {
    this._subresourceRange.flush();
    if (this.memoryBuffer !== this._subresourceRange.memoryBuffer) {
      let srcView = new Uint8Array(this._subresourceRange.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x38);
    }
  }
  
  return true;
};

VkImageViewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkImageViewCreateInfo.byteLength = 0x50;

VkImageViewCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  image: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  viewType: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  format: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  components: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x10
  }),
  subresourceRange: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x14
  }),
});
/** VkBufferCopy **/
class VkBufferCopy {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
      if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
      if (opts.size !== void 0) this.size = opts.size;
      
    }
  }
  get srcOffset() {
    return this.memoryViewBigUint64[0x0];
  }
  set srcOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferCopy.srcOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x0] = value;
  }
  get dstOffset() {
    return this.memoryViewBigUint64[0x1];
  }
  set dstOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferCopy.dstOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x1] = value;
  }
  get size() {
    return this.memoryViewBigUint64[0x2];
  }
  set size(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferCopy.size': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x2] = value;
  }
  
};

VkBufferCopy.prototype.flush = function flush() {
  
  return true;
};

VkBufferCopy.prototype.reflect = function reflect(memoryAddress) {
  
};

VkBufferCopy.byteLength = 0x18;

VkBufferCopy.memoryLayout = Object.freeze({
  srcOffset: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  dstOffset: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  size: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkSparseMemoryBind **/
class VkSparseMemoryBind {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    this._memory = null;
    
    
    
    if (typeof opts === "object") {
      if (opts.resourceOffset !== void 0) this.resourceOffset = opts.resourceOffset;
      if (opts.size !== void 0) this.size = opts.size;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get resourceOffset() {
    return this.memoryViewBigUint64[0x0];
  }
  set resourceOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.resourceOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x0] = value;
  }
  get size() {
    return this.memoryViewBigUint64[0x1];
  }
  set size(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.size': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x1] = value;
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get memoryOffset() {
    return this.memoryViewBigUint64[0x3];
  }
  set memoryOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.memoryOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x8];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseMemoryBind.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkSparseMemoryBind.prototype.flush = function flush() {
  
  return true;
};

VkSparseMemoryBind.prototype.reflect = function reflect(memoryAddress) {
  
};

VkSparseMemoryBind.byteLength = 0x28;

VkSparseMemoryBind.memoryLayout = Object.freeze({
  resourceOffset: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  size: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memory: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  memoryOffset: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkSparseImageMemoryBind **/
class VkSparseImageMemoryBind {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    this._subresource = new VkImageSubresource({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    this._offset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0xC });
    this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    this._memory = null;
    
    
    
    if (typeof opts === "object") {
      if (opts.subresource !== void 0) this.subresource = opts.subresource;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.extent !== void 0) this.extent = opts.extent;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get subresource() {
    return this._subresource;
  }
  set subresource(value) {
    if (value !== null && value.constructor === VkImageSubresource) {
      value.flush();
      this._subresource = value;
      
      
    } else if (value === null) {
      this._subresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.subresource': Expected 'VkImageSubresource' but got '" + value.constructor.name + "'");
    }
  }
  get offset() {
    return this._offset;
  }
  set offset(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.offset': Expected 'VkOffset3D' but got '" + value.constructor.name + "'");
    }
  }
  get extent() {
    return this._extent;
  }
  set extent(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.extent': Expected 'VkExtent3D' but got '" + value.constructor.name + "'");
    }
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get memoryOffset() {
    return this.memoryViewBigUint64[0x6];
  }
  set memoryOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.memoryOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x6] = value;
  }
  get flags() {
    return this.memoryViewInt32[0xE];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBind.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xE] = value;
  }
  
};

VkSparseImageMemoryBind.prototype.flush = function flush() {
  
  
  if (this._subresource !== null) {
    this._subresource.flush();
    if (this.memoryBuffer !== this._subresource.memoryBuffer) {
      let srcView = new Uint8Array(this._subresource.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  
  if (this._offset !== null) {
    this._offset.flush();
    if (this.memoryBuffer !== this._offset.memoryBuffer) {
      let srcView = new Uint8Array(this._offset.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0xC);
    }
  }
  
  
  if (this._extent !== null) {
    this._extent.flush();
    if (this.memoryBuffer !== this._extent.memoryBuffer) {
      let srcView = new Uint8Array(this._extent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
    }
  }
  
  return true;
};

VkSparseImageMemoryBind.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkSparseImageMemoryBind.byteLength = 0x40;

VkSparseImageMemoryBind.memoryLayout = Object.freeze({
  subresource: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0xC
  }),
  offset: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0xC
  }),
  extent: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0xC
  }),
  memory: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  memoryOffset: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
});
/** VkSparseBufferMemoryBindInfo **/
class VkSparseBufferMemoryBindInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._buffer = null;
    
    this._pBinds = null;
    this._pBindsNative = null;
    
    if (typeof opts === "object") {
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
      if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
      
    }
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get bindCount() {
    return this.memoryViewUint32[0x2];
  }
  set bindCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.bindCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get pBinds() {
    return this._pBinds;
  }
  set pBinds(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.pBinds': Expected 'Array VkSparseMemoryBind' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSparseBufferMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseBufferMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSparseMemoryBind) {
        throw new TypeError("Invalid type for 'VkSparseBufferMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseMemoryBind' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pBindsNative = nativeArray;
    this.memoryViewBigInt64[0x2] = nativeArray.address;
  }
  
  return true;
};

VkSparseBufferMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSparseBufferMemoryBindInfo.byteLength = 0x18;

VkSparseBufferMemoryBindInfo.memoryLayout = Object.freeze({
  buffer: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  bindCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  pBinds: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkSparseImageOpaqueMemoryBindInfo **/
class VkSparseImageOpaqueMemoryBindInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._image = null;
    
    this._pBinds = null;
    this._pBindsNative = null;
    
    if (typeof opts === "object") {
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
      if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
      
    }
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get bindCount() {
    return this.memoryViewUint32[0x2];
  }
  set bindCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.bindCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get pBinds() {
    return this._pBinds;
  }
  set pBinds(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.pBinds': Expected 'Array VkSparseMemoryBind' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSparseImageOpaqueMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseImageOpaqueMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSparseMemoryBind) {
        throw new TypeError("Invalid type for 'VkSparseImageOpaqueMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseMemoryBind' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pBindsNative = nativeArray;
    this.memoryViewBigInt64[0x2] = nativeArray.address;
  }
  
  return true;
};

VkSparseImageOpaqueMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSparseImageOpaqueMemoryBindInfo.byteLength = 0x18;

VkSparseImageOpaqueMemoryBindInfo.memoryLayout = Object.freeze({
  image: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  bindCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  pBinds: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkSparseImageMemoryBindInfo **/
class VkSparseImageMemoryBindInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._image = null;
    
    this._pBinds = null;
    this._pBindsNative = null;
    
    if (typeof opts === "object") {
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.bindCount !== void 0) this.bindCount = opts.bindCount;
      if (opts.pBinds !== void 0) this.pBinds = opts.pBinds;
      
    }
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x0] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x0] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get bindCount() {
    return this.memoryViewUint32[0x2];
  }
  set bindCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.bindCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get pBinds() {
    return this._pBinds;
  }
  set pBinds(value) {
    if (value !== null && value.constructor === Array) {
      this._pBinds = value;
    } else if (value === null) {
      this._pBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.pBinds': Expected 'Array VkSparseImageMemoryBind' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSparseImageMemoryBindInfo.prototype.flush = function flush() {
  
  
  if (this._pBinds !== null) {
    let array = this._pBinds;
    if (array.length !== this.bindCount) {
      throw new RangeError("Invalid array length, expected length of 'bindCount' for 'VkSparseImageMemoryBindInfo.pBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSparseImageMemoryBind) {
        throw new TypeError("Invalid type for 'VkSparseImageMemoryBindInfo.pBinds[" + ii + "]': Expected 'VkSparseImageMemoryBind' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pBindsNative = nativeArray;
    this.memoryViewBigInt64[0x2] = nativeArray.address;
  }
  
  return true;
};

VkSparseImageMemoryBindInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSparseImageMemoryBindInfo.byteLength = 0x18;

VkSparseImageMemoryBindInfo.memoryLayout = Object.freeze({
  image: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  bindCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  pBinds: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkBindSparseInfo **/
class VkBindSparseInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x60);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
    
    this._pBufferBinds = null;
    this._pBufferBindsNative = null;
    
    this._pImageOpaqueBinds = null;
    this._pImageOpaqueBindsNative = null;
    
    this._pImageBinds = null;
    this._pImageBindsNative = null;
    
    this._pSignalSemaphores = null;
    this._pSignalSemaphoresNative = null;
    this.sType = 0x7;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
      if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
      if (opts.bufferBindCount !== void 0) this.bufferBindCount = opts.bufferBindCount;
      if (opts.pBufferBinds !== void 0) this.pBufferBinds = opts.pBufferBinds;
      if (opts.imageOpaqueBindCount !== void 0) this.imageOpaqueBindCount = opts.imageOpaqueBindCount;
      if (opts.pImageOpaqueBinds !== void 0) this.pImageOpaqueBinds = opts.pImageOpaqueBinds;
      if (opts.imageBindCount !== void 0) this.imageBindCount = opts.imageBindCount;
      if (opts.pImageBinds !== void 0) this.pImageBinds = opts.pImageBinds;
      if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
      if (opts.pSignalSemaphores !== void 0) this.pSignalSemaphores = opts.pSignalSemaphores;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB466:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pNext'");
    }
  }
  get waitSemaphoreCount() {
    return this.memoryViewUint32[0x4];
  }
  set waitSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.waitSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pWaitSemaphores() {
    return this._pWaitSemaphores;
  }
  set pWaitSemaphores(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + value.constructor.name + "'");
    }
  }
  get bufferBindCount() {
    return this.memoryViewUint32[0x8];
  }
  set bufferBindCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.bufferBindCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pBufferBinds() {
    return this._pBufferBinds;
  }
  set pBufferBinds(value) {
    if (value !== null && value.constructor === Array) {
      this._pBufferBinds = value;
    } else if (value === null) {
      this._pBufferBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pBufferBinds': Expected 'Array VkSparseBufferMemoryBindInfo' but got '" + value.constructor.name + "'");
    }
  }
  get imageOpaqueBindCount() {
    return this.memoryViewUint32[0xC];
  }
  set imageOpaqueBindCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.imageOpaqueBindCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pImageOpaqueBinds() {
    return this._pImageOpaqueBinds;
  }
  set pImageOpaqueBinds(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageOpaqueBinds = value;
    } else if (value === null) {
      this._pImageOpaqueBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageOpaqueBinds': Expected 'Array VkSparseImageOpaqueMemoryBindInfo' but got '" + value.constructor.name + "'");
    }
  }
  get imageBindCount() {
    return this.memoryViewUint32[0x10];
  }
  set imageBindCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.imageBindCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x10] = value;
  }
  get pImageBinds() {
    return this._pImageBinds;
  }
  set pImageBinds(value) {
    if (value !== null && value.constructor === Array) {
      this._pImageBinds = value;
    } else if (value === null) {
      this._pImageBinds = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageBinds': Expected 'Array VkSparseImageMemoryBindInfo' but got '" + value.constructor.name + "'");
    }
  }
  get signalSemaphoreCount() {
    return this.memoryViewUint32[0x14];
  }
  set signalSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.signalSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x14] = value;
  }
  get pSignalSemaphores() {
    return this._pSignalSemaphores;
  }
  set pSignalSemaphores(value) {
    if (value !== null && value.constructor === Array) {
      this._pSignalSemaphores = value;
    } else if (value === null) {
      this._pSignalSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindSparseInfo.pSignalSemaphores': Expected 'Array VkSemaphore' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBindSparseInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkBindSparseInfo.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSemaphore) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pWaitSemaphoresNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pBufferBinds !== null) {
    let array = this._pBufferBinds;
    if (array.length !== this.bufferBindCount) {
      throw new RangeError("Invalid array length, expected length of 'bufferBindCount' for 'VkBindSparseInfo.pBufferBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSparseBufferMemoryBindInfo) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pBufferBinds[" + ii + "]': Expected 'VkSparseBufferMemoryBindInfo' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pBufferBindsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  
  if (this._pImageOpaqueBinds !== null) {
    let array = this._pImageOpaqueBinds;
    if (array.length !== this.imageOpaqueBindCount) {
      throw new RangeError("Invalid array length, expected length of 'imageOpaqueBindCount' for 'VkBindSparseInfo.pImageOpaqueBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSparseImageOpaqueMemoryBindInfo) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageOpaqueBinds[" + ii + "]': Expected 'VkSparseImageOpaqueMemoryBindInfo' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pImageOpaqueBindsNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  }
  
  
  if (this._pImageBinds !== null) {
    let array = this._pImageBinds;
    if (array.length !== this.imageBindCount) {
      throw new RangeError("Invalid array length, expected length of 'imageBindCount' for 'VkBindSparseInfo.pImageBinds'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSparseImageMemoryBindInfo) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pImageBinds[" + ii + "]': Expected 'VkSparseImageMemoryBindInfo' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pImageBindsNative = nativeArray;
    this.memoryViewBigInt64[0x9] = nativeArray.address;
  }
  
  
  if (this._pSignalSemaphores !== null) {
    let array = this._pSignalSemaphores;
    if (array.length !== this.signalSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'signalSemaphoreCount' for 'VkBindSparseInfo.pSignalSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSemaphore) {
        throw new TypeError("Invalid type for 'VkBindSparseInfo.pSignalSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSignalSemaphoresNative = nativeArray;
    this.memoryViewBigInt64[0xB] = nativeArray.address;
  }
  
  return true;
};

VkBindSparseInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
  
  
  
  
};

VkBindSparseInfo.byteLength = 0x60;

VkBindSparseInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  waitSemaphoreCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pWaitSemaphores: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  bufferBindCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pBufferBinds: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  imageOpaqueBindCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pImageOpaqueBinds: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  imageBindCount: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  pImageBinds: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x8
  }),
  signalSemaphoreCount: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
  pSignalSemaphores: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x8
  }),
});
/** VkImageCopy **/
class VkImageCopy {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x44);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);

    }
    this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x1C });
    this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x2C });
    this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x38 });
    
    if (typeof opts === "object") {
      if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
      if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
      if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
      if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
      if (opts.extent !== void 0) this.extent = opts.extent;
      
    }
  }
  get srcSubresource() {
    return this._srcSubresource;
  }
  set srcSubresource(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + value.constructor.name + "'");
    }
  }
  get srcOffset() {
    return this._srcOffset;
  }
  set srcOffset(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._srcOffset = value;
      
      
    } else if (value === null) {
      this._srcOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.srcOffset': Expected 'VkOffset3D' but got '" + value.constructor.name + "'");
    }
  }
  get dstSubresource() {
    return this._dstSubresource;
  }
  set dstSubresource(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + value.constructor.name + "'");
    }
  }
  get dstOffset() {
    return this._dstOffset;
  }
  set dstOffset(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._dstOffset = value;
      
      
    } else if (value === null) {
      this._dstOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.dstOffset': Expected 'VkOffset3D' but got '" + value.constructor.name + "'");
    }
  }
  get extent() {
    return this._extent;
  }
  set extent(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageCopy.extent': Expected 'VkExtent3D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageCopy.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    this._srcSubresource.flush();
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(this._srcSubresource.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  
  if (this._srcOffset !== null) {
    this._srcOffset.flush();
    if (this.memoryBuffer !== this._srcOffset.memoryBuffer) {
      let srcView = new Uint8Array(this._srcOffset.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
    }
  }
  
  
  if (this._dstSubresource !== null) {
    this._dstSubresource.flush();
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(this._dstSubresource.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
    }
  }
  
  
  if (this._dstOffset !== null) {
    this._dstOffset.flush();
    if (this.memoryBuffer !== this._dstOffset.memoryBuffer) {
      let srcView = new Uint8Array(this._dstOffset.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x2C);
    }
  }
  
  
  if (this._extent !== null) {
    this._extent.flush();
    if (this.memoryBuffer !== this._extent.memoryBuffer) {
      let srcView = new Uint8Array(this._extent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x38);
    }
  }
  
  return true;
};

VkImageCopy.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
  
  
};

VkImageCopy.byteLength = 0x44;

VkImageCopy.memoryLayout = Object.freeze({
  srcSubresource: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x10
  }),
  srcOffset: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xC
  }),
  dstSubresource: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x10
  }),
  dstOffset: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0xC
  }),
  extent: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0xC
  }),
});
/** VkImageBlit **/
class VkImageBlit {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x50);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);

    }
    this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    this._srcOffsets = [...Array(2)].map((v, i) => new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 + (i * 0xC) }));
    this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x28 });
    this._dstOffsets = [...Array(2)].map((v, i) => new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x38 + (i * 0xC) }));
    
    if (typeof opts === "object") {
      if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
      if (opts.srcOffsets !== void 0) this.srcOffsets = opts.srcOffsets;
      if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
      if (opts.dstOffsets !== void 0) this.dstOffsets = opts.dstOffsets;
      
    }
  }
  get srcSubresource() {
    return this._srcSubresource;
  }
  set srcSubresource(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + value.constructor.name + "'");
    }
  }
  get srcOffsets() {
    return this._srcOffsets;
  }
  set srcOffsets(value) {
    if (value !== null && value.constructor === Array) {
      this._srcOffsets = value;
    } else if (value === null) {
      this._srcOffsets = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.srcOffsets': Expected 'Array VkOffset3D' but got '" + value.constructor.name + "'");
    }
  }
  get dstSubresource() {
    return this._dstSubresource;
  }
  set dstSubresource(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + value.constructor.name + "'");
    }
  }
  get dstOffsets() {
    return this._dstOffsets;
  }
  set dstOffsets(value) {
    if (value !== null && value.constructor === Array) {
      this._dstOffsets = value;
    } else if (value === null) {
      this._dstOffsets = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageBlit.dstOffsets': Expected 'Array VkOffset3D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageBlit.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    this._srcSubresource.flush();
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(this._srcSubresource.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  
  if (this._srcOffsets !== null) {
    let array = this._srcOffsets;
    if (array.length !== 2) {
      throw new RangeError("Invalid array length, expected length of '2' for 'VkImageBlit.srcOffsets'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkOffset3D) {
        throw new TypeError("Invalid type for 'VkImageBlit.srcOffsets[" + ii + "]': Expected 'VkOffset3D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let dstView = new Uint8Array(this.memoryBuffer);
    let byteOffset = 0x10;
    for (let ii = 0; ii < array.length; ++ii) {
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      dstView.set(srcView, byteOffset);
      byteOffset += VkOffset3D.byteLength;
    };
  }
  
  
  if (this._dstSubresource !== null) {
    this._dstSubresource.flush();
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(this._dstSubresource.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x28);
    }
  }
  
  
  if (this._dstOffsets !== null) {
    let array = this._dstOffsets;
    if (array.length !== 2) {
      throw new RangeError("Invalid array length, expected length of '2' for 'VkImageBlit.dstOffsets'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkOffset3D) {
        throw new TypeError("Invalid type for 'VkImageBlit.dstOffsets[" + ii + "]': Expected 'VkOffset3D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let dstView = new Uint8Array(this.memoryBuffer);
    let byteOffset = 0x38;
    for (let ii = 0; ii < array.length; ++ii) {
      let srcView = new Uint8Array(array[ii].memoryBuffer);
      dstView.set(srcView, byteOffset);
      byteOffset += VkOffset3D.byteLength;
    };
  }
  
  return true;
};

VkImageBlit.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkImageBlit.byteLength = 0x50;

VkImageBlit.memoryLayout = Object.freeze({
  srcSubresource: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x10
  }),
  srcOffsets: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x18
  }),
  dstSubresource: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x10
  }),
  dstOffsets: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x18
  }),
});
/** VkBufferImageCopy **/
class VkBufferImageCopy {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    this._imageSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this._imageOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x20 });
    this._imageExtent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x2C });
    
    if (typeof opts === "object") {
      if (opts.bufferOffset !== void 0) this.bufferOffset = opts.bufferOffset;
      if (opts.bufferRowLength !== void 0) this.bufferRowLength = opts.bufferRowLength;
      if (opts.bufferImageHeight !== void 0) this.bufferImageHeight = opts.bufferImageHeight;
      if (opts.imageSubresource !== void 0) this.imageSubresource = opts.imageSubresource;
      if (opts.imageOffset !== void 0) this.imageOffset = opts.imageOffset;
      if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
      
    }
  }
  get bufferOffset() {
    return this.memoryViewBigUint64[0x0];
  }
  set bufferOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.bufferOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x0] = value;
  }
  get bufferRowLength() {
    return this.memoryViewUint32[0x2];
  }
  set bufferRowLength(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.bufferRowLength': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get bufferImageHeight() {
    return this.memoryViewUint32[0x3];
  }
  set bufferImageHeight(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.bufferImageHeight': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x3] = value;
  }
  get imageSubresource() {
    return this._imageSubresource;
  }
  set imageSubresource(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._imageSubresource = value;
      
      
    } else if (value === null) {
      this._imageSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageSubresource': Expected 'VkImageSubresourceLayers' but got '" + value.constructor.name + "'");
    }
  }
  get imageOffset() {
    return this._imageOffset;
  }
  set imageOffset(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._imageOffset = value;
      
      
    } else if (value === null) {
      this._imageOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageOffset': Expected 'VkOffset3D' but got '" + value.constructor.name + "'");
    }
  }
  get imageExtent() {
    return this._imageExtent;
  }
  set imageExtent(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkBufferImageCopy.imageExtent': Expected 'VkExtent3D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBufferImageCopy.prototype.flush = function flush() {
  
  
  if (this._imageSubresource !== null) {
    this._imageSubresource.flush();
    if (this.memoryBuffer !== this._imageSubresource.memoryBuffer) {
      let srcView = new Uint8Array(this._imageSubresource.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
    }
  }
  
  
  if (this._imageOffset !== null) {
    this._imageOffset.flush();
    if (this.memoryBuffer !== this._imageOffset.memoryBuffer) {
      let srcView = new Uint8Array(this._imageOffset.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x20);
    }
  }
  
  
  if (this._imageExtent !== null) {
    this._imageExtent.flush();
    if (this.memoryBuffer !== this._imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(this._imageExtent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x2C);
    }
  }
  
  return true;
};

VkBufferImageCopy.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkBufferImageCopy.byteLength = 0x38;

VkBufferImageCopy.memoryLayout = Object.freeze({
  bufferOffset: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  bufferRowLength: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  bufferImageHeight: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  imageSubresource: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x10
  }),
  imageOffset: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0xC
  }),
  imageExtent: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0xC
  }),
});
/** VkImageResolve **/
class VkImageResolve {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x44);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);

    }
    this._srcSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    this._srcOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this._dstSubresource = new VkImageSubresourceLayers({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x1C });
    this._dstOffset = new VkOffset3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x2C });
    this._extent = new VkExtent3D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x38 });
    
    if (typeof opts === "object") {
      if (opts.srcSubresource !== void 0) this.srcSubresource = opts.srcSubresource;
      if (opts.srcOffset !== void 0) this.srcOffset = opts.srcOffset;
      if (opts.dstSubresource !== void 0) this.dstSubresource = opts.dstSubresource;
      if (opts.dstOffset !== void 0) this.dstOffset = opts.dstOffset;
      if (opts.extent !== void 0) this.extent = opts.extent;
      
    }
  }
  get srcSubresource() {
    return this._srcSubresource;
  }
  set srcSubresource(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._srcSubresource = value;
      
      
    } else if (value === null) {
      this._srcSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.srcSubresource': Expected 'VkImageSubresourceLayers' but got '" + value.constructor.name + "'");
    }
  }
  get srcOffset() {
    return this._srcOffset;
  }
  set srcOffset(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._srcOffset = value;
      
      
    } else if (value === null) {
      this._srcOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.srcOffset': Expected 'VkOffset3D' but got '" + value.constructor.name + "'");
    }
  }
  get dstSubresource() {
    return this._dstSubresource;
  }
  set dstSubresource(value) {
    if (value !== null && value.constructor === VkImageSubresourceLayers) {
      value.flush();
      this._dstSubresource = value;
      
      
    } else if (value === null) {
      this._dstSubresource = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.dstSubresource': Expected 'VkImageSubresourceLayers' but got '" + value.constructor.name + "'");
    }
  }
  get dstOffset() {
    return this._dstOffset;
  }
  set dstOffset(value) {
    if (value !== null && value.constructor === VkOffset3D) {
      value.flush();
      this._dstOffset = value;
      
      
    } else if (value === null) {
      this._dstOffset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.dstOffset': Expected 'VkOffset3D' but got '" + value.constructor.name + "'");
    }
  }
  get extent() {
    return this._extent;
  }
  set extent(value) {
    if (value !== null && value.constructor === VkExtent3D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkImageResolve.extent': Expected 'VkExtent3D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageResolve.prototype.flush = function flush() {
  
  
  if (this._srcSubresource !== null) {
    this._srcSubresource.flush();
    if (this.memoryBuffer !== this._srcSubresource.memoryBuffer) {
      let srcView = new Uint8Array(this._srcSubresource.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  
  if (this._srcOffset !== null) {
    this._srcOffset.flush();
    if (this.memoryBuffer !== this._srcOffset.memoryBuffer) {
      let srcView = new Uint8Array(this._srcOffset.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
    }
  }
  
  
  if (this._dstSubresource !== null) {
    this._dstSubresource.flush();
    if (this.memoryBuffer !== this._dstSubresource.memoryBuffer) {
      let srcView = new Uint8Array(this._dstSubresource.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
    }
  }
  
  
  if (this._dstOffset !== null) {
    this._dstOffset.flush();
    if (this.memoryBuffer !== this._dstOffset.memoryBuffer) {
      let srcView = new Uint8Array(this._dstOffset.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x2C);
    }
  }
  
  
  if (this._extent !== null) {
    this._extent.flush();
    if (this.memoryBuffer !== this._extent.memoryBuffer) {
      let srcView = new Uint8Array(this._extent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x38);
    }
  }
  
  return true;
};

VkImageResolve.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
  
  
};

VkImageResolve.byteLength = 0x44;

VkImageResolve.memoryLayout = Object.freeze({
  srcSubresource: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x10
  }),
  srcOffset: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xC
  }),
  dstSubresource: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x10
  }),
  dstOffset: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0xC
  }),
  extent: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0xC
  }),
});
/** VkShaderModuleCreateInfo **/
class VkShaderModuleCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pCode = null;
    this.sType = 0x10;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.codeSize !== void 0) this.codeSize = opts.codeSize;
      if (opts.pCode !== void 0) this.pCode = opts.pCode;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D3B01:
          break;
        default:
          throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get codeSize() {
    return this.memoryViewBigInt64[0x3];
  }
  set codeSize(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.codeSize': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x3] = value;
  }
  get pCode() {
    return this._pCode;
  }
  set pCode(value) {
    if (value !== null && value.constructor === Uint8Array) {
      this._pCode = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCode = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleCreateInfo.pCode': Expected 'Uint8Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkShaderModuleCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkShaderModuleCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkShaderModuleCreateInfo.byteLength = 0x28;

VkShaderModuleCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  codeSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pCode: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkDescriptorSetLayoutBinding **/
class VkDescriptorSetLayoutBinding {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    this._pImmutableSamplers = null;
    this._pImmutableSamplersNative = null;
    
    if (typeof opts === "object") {
      if (opts.binding !== void 0) this.binding = opts.binding;
      if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
      if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
      if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
      if (opts.pImmutableSamplers !== void 0) this.pImmutableSamplers = opts.pImmutableSamplers;
      
    }
  }
  get binding() {
    return this.memoryViewUint32[0x0];
  }
  set binding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.binding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get descriptorType() {
    return this.memoryViewInt32[0x1];
  }
  set descriptorType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.descriptorType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get descriptorCount() {
    return this.memoryViewUint32[0x2];
  }
  set descriptorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.descriptorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get stageFlags() {
    return this.memoryViewInt32[0x3];
  }
  set stageFlags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.stageFlags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  get pImmutableSamplers() {
    return this._pImmutableSamplers;
  }
  set pImmutableSamplers(value) {
    if (value !== null && value.constructor === Array) {
      this._pImmutableSamplers = value;
    } else if (value === null) {
      this._pImmutableSamplers = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.pImmutableSamplers': Expected 'Array VkSampler' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDescriptorSetLayoutBinding.prototype.flush = function flush() {
  
  
  if (this._pImmutableSamplers !== null) {
    let array = this._pImmutableSamplers;
    if (array.length !== this.descriptorCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorCount' for 'VkDescriptorSetLayoutBinding.pImmutableSamplers'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSampler) {
        throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBinding.pImmutableSamplers[" + ii + "]': Expected 'VkSampler' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pImmutableSamplersNative = nativeArray;
    this.memoryViewBigInt64[0x2] = nativeArray.address;
  }
  
  return true;
};

VkDescriptorSetLayoutBinding.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDescriptorSetLayoutBinding.byteLength = 0x18;

VkDescriptorSetLayoutBinding.memoryLayout = Object.freeze({
  binding: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  descriptorType: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  descriptorCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  stageFlags: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  pImmutableSamplers: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkDescriptorSetLayoutCreateInfo **/
class VkDescriptorSetLayoutCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pBindings = null;
    this._pBindingsNative = null;
    this.sType = 0x20;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
      if (opts.pBindings !== void 0) this.pBindings = opts.pBindings;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D3EE8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get bindingCount() {
    return this.memoryViewUint32[0x5];
  }
  set bindingCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.bindingCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pBindings() {
    return this._pBindings;
  }
  set pBindings(value) {
    if (value !== null && value.constructor === Array) {
      this._pBindings = value;
    } else if (value === null) {
      this._pBindings = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pBindings': Expected 'Array VkDescriptorSetLayoutBinding' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDescriptorSetLayoutCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pBindings !== null) {
    let array = this._pBindings;
    if (array.length !== this.bindingCount) {
      throw new RangeError("Invalid array length, expected length of 'bindingCount' for 'VkDescriptorSetLayoutCreateInfo.pBindings'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDescriptorSetLayoutBinding) {
        throw new TypeError("Invalid type for 'VkDescriptorSetLayoutCreateInfo.pBindings[" + ii + "]': Expected 'VkDescriptorSetLayoutBinding' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pBindingsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkDescriptorSetLayoutCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorSetLayoutCreateInfo.byteLength = 0x20;

VkDescriptorSetLayoutCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  bindingCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pBindings: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDescriptorPoolSize **/
class VkDescriptorPoolSize {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
      
    }
  }
  get type() {
    return this.memoryViewInt32[0x0];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolSize.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get descriptorCount() {
    return this.memoryViewUint32[0x1];
  }
  set descriptorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolSize.descriptorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  
};

VkDescriptorPoolSize.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorPoolSize.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorPoolSize.byteLength = 0x8;

VkDescriptorPoolSize.memoryLayout = Object.freeze({
  type: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  descriptorCount: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkDescriptorPoolCreateInfo **/
class VkDescriptorPoolCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._pPoolSizes = null;
    this._pPoolSizesNative = null;
    this.sType = 0x21;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.maxSets !== void 0) this.maxSets = opts.maxSets;
      if (opts.poolSizeCount !== void 0) this.poolSizeCount = opts.poolSizeCount;
      if (opts.pPoolSizes !== void 0) this.pPoolSizes = opts.pPoolSizes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9CE513:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get maxSets() {
    return this.memoryViewUint32[0x5];
  }
  set maxSets(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.maxSets': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get poolSizeCount() {
    return this.memoryViewUint32[0x6];
  }
  set poolSizeCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.poolSizeCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pPoolSizes() {
    return this._pPoolSizes;
  }
  set pPoolSizes(value) {
    if (value !== null && value.constructor === Array) {
      this._pPoolSizes = value;
    } else if (value === null) {
      this._pPoolSizes = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pPoolSizes': Expected 'Array VkDescriptorPoolSize' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDescriptorPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPoolSizes !== null) {
    let array = this._pPoolSizes;
    if (array.length !== this.poolSizeCount) {
      throw new RangeError("Invalid array length, expected length of 'poolSizeCount' for 'VkDescriptorPoolCreateInfo.pPoolSizes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDescriptorPoolSize) {
        throw new TypeError("Invalid type for 'VkDescriptorPoolCreateInfo.pPoolSizes[" + ii + "]': Expected 'VkDescriptorPoolSize' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pPoolSizesNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  return true;
};

VkDescriptorPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorPoolCreateInfo.byteLength = 0x28;

VkDescriptorPoolCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxSets: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  poolSizeCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pPoolSizes: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkDescriptorSetAllocateInfo **/
class VkDescriptorSetAllocateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._descriptorPool = null;
    
    this._pSetLayouts = null;
    this._pSetLayoutsNative = null;
    this.sType = 0x22;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.descriptorPool !== void 0) this.descriptorPool = opts.descriptorPool;
      if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
      if (opts.pSetLayouts !== void 0) this.pSetLayouts = opts.pSetLayouts;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D3EEB:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pNext'");
    }
  }
  get descriptorPool() {
    return this._descriptorPool;
  }
  set descriptorPool(value) {
    if (value !== null && value.constructor === VkDescriptorPool) {
      
      this._descriptorPool = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._descriptorPool = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.descriptorPool': Expected 'VkDescriptorPool' but got '" + value.constructor.name + "'");
    }
  }
  get descriptorSetCount() {
    return this.memoryViewUint32[0x6];
  }
  set descriptorSetCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.descriptorSetCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pSetLayouts() {
    return this._pSetLayouts;
  }
  set pSetLayouts(value) {
    if (value !== null && value.constructor === Array) {
      this._pSetLayouts = value;
    } else if (value === null) {
      this._pSetLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pSetLayouts': Expected 'Array VkDescriptorSetLayout' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDescriptorSetAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSetLayouts !== null) {
    let array = this._pSetLayouts;
    if (array.length !== this.descriptorSetCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorSetCount' for 'VkDescriptorSetAllocateInfo.pSetLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDescriptorSetLayout) {
        throw new TypeError("Invalid type for 'VkDescriptorSetAllocateInfo.pSetLayouts[" + ii + "]': Expected 'VkDescriptorSetLayout' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSetLayoutsNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  return true;
};

VkDescriptorSetAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorSetAllocateInfo.byteLength = 0x28;

VkDescriptorSetAllocateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  descriptorPool: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  descriptorSetCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pSetLayouts: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkSpecializationMapEntry **/
class VkSpecializationMapEntry {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.constantID !== void 0) this.constantID = opts.constantID;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.size !== void 0) this.size = opts.size;
      
    }
  }
  get constantID() {
    return this.memoryViewUint32[0x0];
  }
  set constantID(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSpecializationMapEntry.constantID': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get offset() {
    return this.memoryViewUint32[0x1];
  }
  set offset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSpecializationMapEntry.offset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get size() {
    return this.memoryViewBigInt64[0x1];
  }
  set size(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkSpecializationMapEntry.size': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x1] = value;
  }
  
};

VkSpecializationMapEntry.prototype.flush = function flush() {
  
  return true;
};

VkSpecializationMapEntry.prototype.reflect = function reflect(memoryAddress) {
  
};

VkSpecializationMapEntry.byteLength = 0x10;

VkSpecializationMapEntry.memoryLayout = Object.freeze({
  constantID: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  offset: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  size: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkSpecializationInfo **/
class VkSpecializationInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pMapEntries = null;
    this._pMapEntriesNative = null;
    
    this._pData = null;
    
    if (typeof opts === "object") {
      if (opts.mapEntryCount !== void 0) this.mapEntryCount = opts.mapEntryCount;
      if (opts.pMapEntries !== void 0) this.pMapEntries = opts.pMapEntries;
      if (opts.dataSize !== void 0) this.dataSize = opts.dataSize;
      if (opts.pData !== void 0) this.pData = opts.pData;
      
    }
  }
  get mapEntryCount() {
    return this.memoryViewUint32[0x0];
  }
  set mapEntryCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.mapEntryCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get pMapEntries() {
    return this._pMapEntries;
  }
  set pMapEntries(value) {
    if (value !== null && value.constructor === Array) {
      this._pMapEntries = value;
    } else if (value === null) {
      this._pMapEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.pMapEntries': Expected 'Array VkSpecializationMapEntry' but got '" + value.constructor.name + "'");
    }
  }
  get dataSize() {
    return this.memoryViewBigInt64[0x2];
  }
  set dataSize(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.dataSize': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x2] = value;
  }
  get pData() {
    return this._pData;
  }
  set pData(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pData = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pData = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSpecializationInfo.pData': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSpecializationInfo.prototype.flush = function flush() {
  
  
  if (this._pMapEntries !== null) {
    let array = this._pMapEntries;
    if (array.length !== this.mapEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'mapEntryCount' for 'VkSpecializationInfo.pMapEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSpecializationMapEntry) {
        throw new TypeError("Invalid type for 'VkSpecializationInfo.pMapEntries[" + ii + "]': Expected 'VkSpecializationMapEntry' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pMapEntriesNative = nativeArray;
    this.memoryViewBigInt64[0x1] = nativeArray.address;
  }
  
  return true;
};

VkSpecializationInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSpecializationInfo.byteLength = 0x20;

VkSpecializationInfo.memoryLayout = Object.freeze({
  mapEntryCount: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pMapEntries: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  dataSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  pData: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPipelineShaderStageCreateInfo **/
class VkPipelineShaderStageCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._module = null;
    this._pName = null;
    this._pSpecializationInfo = null;
    this.sType = 0x12;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.stage !== void 0) this.stage = opts.stage;
      if (opts.module !== void 0) this.module = opts.module;
      if (opts.pName !== void 0) this.pName = opts.pName;
      if (opts.pSpecializationInfo !== void 0) this.pSpecializationInfo = opts.pSpecializationInfo;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineShaderStageCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get stage() {
    return this.memoryViewInt32[0x5];
  }
  set stage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.stage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get module() {
    return this._module;
  }
  set module(value) {
    if (value !== null && value.constructor === VkShaderModule) {
      
      this._module = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._module = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.module': Expected 'VkShaderModule' but got '" + value.constructor.name + "'");
    }
  }
  get pName() {
    if (this._pName !== null) {
      let str = textDecoder.decode(this._pName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pName(value) {
    if (value !== null && value.constructor === String) {
      this._pName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._pName);
    } else if (value === null) {
      this._pName = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.pName': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  get pSpecializationInfo() {
    return this._pSpecializationInfo;
  }
  set pSpecializationInfo(value) {
    if (value !== null && value.constructor === VkSpecializationInfo) {
      value.flush();
      this._pSpecializationInfo = value;
      this.memoryViewBigInt64[0x5] = value.memoryAddress;
      
    } else if (value === null) {
      this._pSpecializationInfo = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineShaderStageCreateInfo.pSpecializationInfo': Expected 'VkSpecializationInfo' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineShaderStageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineShaderStageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineShaderStageCreateInfo.byteLength = 0x30;

VkPipelineShaderStageCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  stage: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  module: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pName: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  pSpecializationInfo: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkComputePipelineCreateInfo **/
class VkComputePipelineCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x60);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._stage = new VkPipelineShaderStageCreateInfo({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    this._layout = null;
    this._basePipelineHandle = null;
    
    this.sType = 0x1D;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.stage !== void 0) this.stage = opts.stage;
      if (opts.layout !== void 0) this.layout = opts.layout;
      if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
      if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkComputePipelineCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get stage() {
    return this._stage;
  }
  set stage(value) {
    if (value !== null && value.constructor === VkPipelineShaderStageCreateInfo) {
      value.flush();
      this._stage = value;
      
      
    } else if (value === null) {
      this._stage = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.stage': Expected 'VkPipelineShaderStageCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get layout() {
    return this._layout;
  }
  set layout(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryViewBigInt64[0x9] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._layout = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.layout': Expected 'VkPipelineLayout' but got '" + value.constructor.name + "'");
    }
  }
  get basePipelineHandle() {
    return this._basePipelineHandle;
  }
  set basePipelineHandle(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryViewBigInt64[0xA] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.basePipelineHandle': Expected 'VkPipeline' but got '" + value.constructor.name + "'");
    }
  }
  get basePipelineIndex() {
    return this.memoryViewInt32[0x16];
  }
  set basePipelineIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkComputePipelineCreateInfo.basePipelineIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x16] = value;
  }
  
};

VkComputePipelineCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._stage !== null) {
    this._stage.flush();
    if (this.memoryBuffer !== this._stage.memoryBuffer) {
      let srcView = new Uint8Array(this._stage.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
    }
  }
  
  return true;
};

VkComputePipelineCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkComputePipelineCreateInfo.byteLength = 0x60;

VkComputePipelineCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  stage: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x30
  }),
  layout: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x8
  }),
  basePipelineHandle: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x8
  }),
  basePipelineIndex: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x4
  }),
});
/** VkVertexInputBindingDescription **/
class VkVertexInputBindingDescription {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.binding !== void 0) this.binding = opts.binding;
      if (opts.stride !== void 0) this.stride = opts.stride;
      if (opts.inputRate !== void 0) this.inputRate = opts.inputRate;
      
    }
  }
  get binding() {
    return this.memoryViewUint32[0x0];
  }
  set binding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDescription.binding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get stride() {
    return this.memoryViewUint32[0x1];
  }
  set stride(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDescription.stride': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get inputRate() {
    return this.memoryViewInt32[0x2];
  }
  set inputRate(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDescription.inputRate': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  
};

VkVertexInputBindingDescription.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputBindingDescription.prototype.reflect = function reflect(memoryAddress) {
  
};

VkVertexInputBindingDescription.byteLength = 0xC;

VkVertexInputBindingDescription.memoryLayout = Object.freeze({
  binding: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  stride: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  inputRate: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkVertexInputAttributeDescription **/
class VkVertexInputAttributeDescription {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.location !== void 0) this.location = opts.location;
      if (opts.binding !== void 0) this.binding = opts.binding;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.offset !== void 0) this.offset = opts.offset;
      
    }
  }
  get location() {
    return this.memoryViewUint32[0x0];
  }
  set location(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputAttributeDescription.location': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get binding() {
    return this.memoryViewUint32[0x1];
  }
  set binding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputAttributeDescription.binding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get format() {
    return this.memoryViewInt32[0x2];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputAttributeDescription.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  get offset() {
    return this.memoryViewUint32[0x3];
  }
  set offset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputAttributeDescription.offset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x3] = value;
  }
  
};

VkVertexInputAttributeDescription.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputAttributeDescription.prototype.reflect = function reflect(memoryAddress) {
  
};

VkVertexInputAttributeDescription.byteLength = 0x10;

VkVertexInputAttributeDescription.memoryLayout = Object.freeze({
  location: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  binding: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  format: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  offset: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
});
/** VkPipelineVertexInputStateCreateInfo **/
class VkPipelineVertexInputStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pVertexBindingDescriptions = null;
    this._pVertexBindingDescriptionsNative = null;
    
    this._pVertexAttributeDescriptions = null;
    this._pVertexAttributeDescriptionsNative = null;
    this.sType = 0x13;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.vertexBindingDescriptionCount !== void 0) this.vertexBindingDescriptionCount = opts.vertexBindingDescriptionCount;
      if (opts.pVertexBindingDescriptions !== void 0) this.pVertexBindingDescriptions = opts.pVertexBindingDescriptions;
      if (opts.vertexAttributeDescriptionCount !== void 0) this.vertexAttributeDescriptionCount = opts.vertexAttributeDescriptionCount;
      if (opts.pVertexAttributeDescriptions !== void 0) this.pVertexAttributeDescriptions = opts.pVertexAttributeDescriptions;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9DB031:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get vertexBindingDescriptionCount() {
    return this.memoryViewUint32[0x5];
  }
  set vertexBindingDescriptionCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.vertexBindingDescriptionCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pVertexBindingDescriptions() {
    return this._pVertexBindingDescriptions;
  }
  set pVertexBindingDescriptions(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexBindingDescriptions = value;
    } else if (value === null) {
      this._pVertexBindingDescriptions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions': Expected 'Array VkVertexInputBindingDescription' but got '" + value.constructor.name + "'");
    }
  }
  get vertexAttributeDescriptionCount() {
    return this.memoryViewUint32[0x8];
  }
  set vertexAttributeDescriptionCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.vertexAttributeDescriptionCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pVertexAttributeDescriptions() {
    return this._pVertexAttributeDescriptions;
  }
  set pVertexAttributeDescriptions(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexAttributeDescriptions = value;
    } else if (value === null) {
      this._pVertexAttributeDescriptions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions': Expected 'Array VkVertexInputAttributeDescription' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineVertexInputStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pVertexBindingDescriptions !== null) {
    let array = this._pVertexBindingDescriptions;
    if (array.length !== this.vertexBindingDescriptionCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexBindingDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkVertexInputBindingDescription) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexBindingDescriptions[" + ii + "]': Expected 'VkVertexInputBindingDescription' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pVertexBindingDescriptionsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pVertexAttributeDescriptions !== null) {
    let array = this._pVertexAttributeDescriptions;
    if (array.length !== this.vertexAttributeDescriptionCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexAttributeDescriptionCount' for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkVertexInputAttributeDescription) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputStateCreateInfo.pVertexAttributeDescriptions[" + ii + "]': Expected 'VkVertexInputAttributeDescription' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pVertexAttributeDescriptionsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkPipelineVertexInputStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineVertexInputStateCreateInfo.byteLength = 0x30;

VkPipelineVertexInputStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  vertexBindingDescriptionCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pVertexBindingDescriptions: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  vertexAttributeDescriptionCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pVertexAttributeDescriptions: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkPipelineInputAssemblyStateCreateInfo **/
class VkPipelineInputAssemblyStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x14;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.topology !== void 0) this.topology = opts.topology;
      if (opts.primitiveRestartEnable !== void 0) this.primitiveRestartEnable = opts.primitiveRestartEnable;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineInputAssemblyStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineInputAssemblyStateCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineInputAssemblyStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get topology() {
    return this.memoryViewInt32[0x5];
  }
  set topology(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineInputAssemblyStateCreateInfo.topology': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get primitiveRestartEnable() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set primitiveRestartEnable(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  
};

VkPipelineInputAssemblyStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineInputAssemblyStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineInputAssemblyStateCreateInfo.byteLength = 0x20;

VkPipelineInputAssemblyStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  topology: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  primitiveRestartEnable: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPipelineTessellationStateCreateInfo **/
class VkPipelineTessellationStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x15;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.patchControlPoints !== void 0) this.patchControlPoints = opts.patchControlPoints;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C930B:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get patchControlPoints() {
    return this.memoryViewUint32[0x5];
  }
  set patchControlPoints(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationStateCreateInfo.patchControlPoints': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  
};

VkPipelineTessellationStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineTessellationStateCreateInfo.byteLength = 0x18;

VkPipelineTessellationStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  patchControlPoints: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPipelineViewportStateCreateInfo **/
class VkPipelineViewportStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pViewports = null;
    this._pViewportsNative = null;
    
    this._pScissors = null;
    this._pScissorsNative = null;
    this.sType = 0x16;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
      if (opts.pViewports !== void 0) this.pViewports = opts.pViewports;
      if (opts.scissorCount !== void 0) this.scissorCount = opts.scissorCount;
      if (opts.pScissors !== void 0) this.pScissors = opts.pScissors;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C1DD8:
        case 0x3B9C48D0:
        case 0x3B9DEAC8:
        case 0x3B9D4AA0:
        case 0x3B9D4AA5:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get viewportCount() {
    return this.memoryViewUint32[0x5];
  }
  set viewportCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.viewportCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pViewports() {
    return this._pViewports;
  }
  set pViewports(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewports = value;
    } else if (value === null) {
      this._pViewports = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pViewports': Expected 'Array VkViewport' but got '" + value.constructor.name + "'");
    }
  }
  get scissorCount() {
    return this.memoryViewUint32[0x8];
  }
  set scissorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.scissorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pScissors() {
    return this._pScissors;
  }
  set pScissors(value) {
    if (value !== null && value.constructor === Array) {
      this._pScissors = value;
    } else if (value === null) {
      this._pScissors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pScissors': Expected 'Array VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineViewportStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewports !== null) {
    let array = this._pViewports;
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportStateCreateInfo.pViewports'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkViewport) {
        throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pViewports[" + ii + "]': Expected 'VkViewport' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pViewportsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pScissors !== null) {
    let array = this._pScissors;
    if (array.length !== this.scissorCount) {
      throw new RangeError("Invalid array length, expected length of 'scissorCount' for 'VkPipelineViewportStateCreateInfo.pScissors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRect2D) {
        throw new TypeError("Invalid type for 'VkPipelineViewportStateCreateInfo.pScissors[" + ii + "]': Expected 'VkRect2D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pScissorsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkPipelineViewportStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineViewportStateCreateInfo.byteLength = 0x30;

VkPipelineViewportStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  viewportCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pViewports: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  scissorCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pScissors: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkPipelineRasterizationStateCreateInfo **/
class VkPipelineRasterizationStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    
    
    this.sType = 0x17;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.depthClampEnable !== void 0) this.depthClampEnable = opts.depthClampEnable;
      if (opts.rasterizerDiscardEnable !== void 0) this.rasterizerDiscardEnable = opts.rasterizerDiscardEnable;
      if (opts.polygonMode !== void 0) this.polygonMode = opts.polygonMode;
      if (opts.cullMode !== void 0) this.cullMode = opts.cullMode;
      if (opts.frontFace !== void 0) this.frontFace = opts.frontFace;
      if (opts.depthBiasEnable !== void 0) this.depthBiasEnable = opts.depthBiasEnable;
      if (opts.depthBiasConstantFactor !== void 0) this.depthBiasConstantFactor = opts.depthBiasConstantFactor;
      if (opts.depthBiasClamp !== void 0) this.depthBiasClamp = opts.depthBiasClamp;
      if (opts.depthBiasSlopeFactor !== void 0) this.depthBiasSlopeFactor = opts.depthBiasSlopeFactor;
      if (opts.lineWidth !== void 0) this.lineWidth = opts.lineWidth;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B1050:
        case 0x3B9C5489:
        case 0x3B9B3762:
        case 0x3B9C5871:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get depthClampEnable() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set depthClampEnable(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get rasterizerDiscardEnable() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set rasterizerDiscardEnable(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  get polygonMode() {
    return this.memoryViewInt32[0x7];
  }
  set polygonMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.polygonMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get cullMode() {
    return this.memoryViewInt32[0x8];
  }
  set cullMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.cullMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get frontFace() {
    return this.memoryViewInt32[0x9];
  }
  set frontFace(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.frontFace': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get depthBiasEnable() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  set depthBiasEnable(value) {
    this.memoryViewUint32[0xA] = value | 0;
  }
  get depthBiasConstantFactor() {
    return this.memoryViewFloat32[0xB];
  }
  set depthBiasConstantFactor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.depthBiasConstantFactor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xB] = value;
  }
  get depthBiasClamp() {
    return this.memoryViewFloat32[0xC];
  }
  set depthBiasClamp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.depthBiasClamp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xC] = value;
  }
  get depthBiasSlopeFactor() {
    return this.memoryViewFloat32[0xD];
  }
  set depthBiasSlopeFactor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.depthBiasSlopeFactor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xD] = value;
  }
  get lineWidth() {
    return this.memoryViewFloat32[0xE];
  }
  set lineWidth(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateCreateInfo.lineWidth': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xE] = value;
  }
  
};

VkPipelineRasterizationStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationStateCreateInfo.byteLength = 0x40;

VkPipelineRasterizationStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  depthClampEnable: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  rasterizerDiscardEnable: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  polygonMode: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  cullMode: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  frontFace: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  depthBiasEnable: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  depthBiasConstantFactor: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  depthBiasClamp: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  depthBiasSlopeFactor: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  lineWidth: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
});
/** VkPipelineMultisampleStateCreateInfo **/
class VkPipelineMultisampleStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this._pSampleMask = null;
    
    
    this.sType = 0x18;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.rasterizationSamples !== void 0) this.rasterizationSamples = opts.rasterizationSamples;
      if (opts.sampleShadingEnable !== void 0) this.sampleShadingEnable = opts.sampleShadingEnable;
      if (opts.minSampleShading !== void 0) this.minSampleShading = opts.minSampleShading;
      if (opts.pSampleMask !== void 0) this.pSampleMask = opts.pSampleMask;
      if (opts.alphaToCoverageEnable !== void 0) this.alphaToCoverageEnable = opts.alphaToCoverageEnable;
      if (opts.alphaToOneEnable !== void 0) this.alphaToOneEnable = opts.alphaToOneEnable;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D1008:
        case 0x3B9CF89A:
        case 0x3B9D1BC0:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get rasterizationSamples() {
    return this.memoryViewInt32[0x5];
  }
  set rasterizationSamples(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.rasterizationSamples': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get sampleShadingEnable() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set sampleShadingEnable(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  get minSampleShading() {
    return this.memoryViewFloat32[0x7];
  }
  set minSampleShading(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.minSampleShading': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x7] = value;
  }
  get pSampleMask() {
    return this._pSampleMask;
  }
  set pSampleMask(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSampleMask = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pSampleMask = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineMultisampleStateCreateInfo.pSampleMask': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get alphaToCoverageEnable() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  set alphaToCoverageEnable(value) {
    this.memoryViewUint32[0xA] = value | 0;
  }
  get alphaToOneEnable() {
    return this.memoryViewUint32[0xB] !== 0;
  }
  set alphaToOneEnable(value) {
    this.memoryViewUint32[0xB] = value | 0;
  }
  
};

VkPipelineMultisampleStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineMultisampleStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineMultisampleStateCreateInfo.byteLength = 0x30;

VkPipelineMultisampleStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  rasterizationSamples: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  sampleShadingEnable: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  minSampleShading: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  pSampleMask: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  alphaToCoverageEnable: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  alphaToOneEnable: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
});
/** VkPipelineColorBlendAttachmentState **/
class VkPipelineColorBlendAttachmentState {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.blendEnable !== void 0) this.blendEnable = opts.blendEnable;
      if (opts.srcColorBlendFactor !== void 0) this.srcColorBlendFactor = opts.srcColorBlendFactor;
      if (opts.dstColorBlendFactor !== void 0) this.dstColorBlendFactor = opts.dstColorBlendFactor;
      if (opts.colorBlendOp !== void 0) this.colorBlendOp = opts.colorBlendOp;
      if (opts.srcAlphaBlendFactor !== void 0) this.srcAlphaBlendFactor = opts.srcAlphaBlendFactor;
      if (opts.dstAlphaBlendFactor !== void 0) this.dstAlphaBlendFactor = opts.dstAlphaBlendFactor;
      if (opts.alphaBlendOp !== void 0) this.alphaBlendOp = opts.alphaBlendOp;
      if (opts.colorWriteMask !== void 0) this.colorWriteMask = opts.colorWriteMask;
      
    }
  }
  get blendEnable() {
    return this.memoryViewUint32[0x0] !== 0;
  }
  set blendEnable(value) {
    this.memoryViewUint32[0x0] = value | 0;
  }
  get srcColorBlendFactor() {
    return this.memoryViewInt32[0x1];
  }
  set srcColorBlendFactor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.srcColorBlendFactor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get dstColorBlendFactor() {
    return this.memoryViewInt32[0x2];
  }
  set dstColorBlendFactor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.dstColorBlendFactor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  get colorBlendOp() {
    return this.memoryViewInt32[0x3];
  }
  set colorBlendOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.colorBlendOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  get srcAlphaBlendFactor() {
    return this.memoryViewInt32[0x4];
  }
  set srcAlphaBlendFactor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.srcAlphaBlendFactor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get dstAlphaBlendFactor() {
    return this.memoryViewInt32[0x5];
  }
  set dstAlphaBlendFactor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.dstAlphaBlendFactor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get alphaBlendOp() {
    return this.memoryViewInt32[0x6];
  }
  set alphaBlendOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.alphaBlendOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get colorWriteMask() {
    return this.memoryViewInt32[0x7];
  }
  set colorWriteMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAttachmentState.colorWriteMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  
};

VkPipelineColorBlendAttachmentState.prototype.flush = function flush() {
  
  return true;
};

VkPipelineColorBlendAttachmentState.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPipelineColorBlendAttachmentState.byteLength = 0x20;

VkPipelineColorBlendAttachmentState.memoryLayout = Object.freeze({
  blendEnable: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  srcColorBlendFactor: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  dstColorBlendFactor: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  colorBlendOp: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  srcAlphaBlendFactor: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  dstAlphaBlendFactor: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  alphaBlendOp: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  colorWriteMask: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkPipelineColorBlendStateCreateInfo **/
class VkPipelineColorBlendStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this._pAttachments = null;
    this._pAttachmentsNative = null;
    this._blendConstants = [...Array(4)].fill(0x0);
    this.sType = 0x1A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.logicOpEnable !== void 0) this.logicOpEnable = opts.logicOpEnable;
      if (opts.logicOp !== void 0) this.logicOp = opts.logicOp;
      if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
      if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
      if (opts.blendConstants !== void 0) this.blendConstants = opts.blendConstants;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D0C22:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get logicOpEnable() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set logicOpEnable(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get logicOp() {
    return this.memoryViewInt32[0x6];
  }
  set logicOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.logicOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get attachmentCount() {
    return this.memoryViewUint32[0x7];
  }
  set attachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.attachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get pAttachments() {
    return this._pAttachments;
  }
  set pAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pAttachments': Expected 'Array VkPipelineColorBlendAttachmentState' but got '" + value.constructor.name + "'");
    }
  }
  get blendConstants() {
    return this._blendConstants;
  }
  set blendConstants(value) {
    if (value !== null && value.constructor === Array) {
      this._blendConstants = value;
    } else if (value === null) {
      this._blendConstants = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.blendConstants': Expected 'Array float' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineColorBlendStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkPipelineColorBlendStateCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkPipelineColorBlendAttachmentState) {
        throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.pAttachments[" + ii + "]': Expected 'VkPipelineColorBlendAttachmentState' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  
  if (this._blendConstants !== null) {
    let array = this._blendConstants;
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkPipelineColorBlendStateCreateInfo.blendConstants'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== Number) {
        throw new TypeError("Invalid type for 'VkPipelineColorBlendStateCreateInfo.blendConstants[" + ii + "]': Expected 'Number' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewFloat32[0xA + ii] = array[ii];
    };
  } else {
    this.memoryViewFloat32[0xA] = 0x0;
  }
  
  return true;
};

VkPipelineColorBlendStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineColorBlendStateCreateInfo.byteLength = 0x38;

VkPipelineColorBlendStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  logicOpEnable: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  logicOp: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  attachmentCount: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  pAttachments: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  blendConstants: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x10
  }),
});
/** VkPipelineDynamicStateCreateInfo **/
class VkPipelineDynamicStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pDynamicStates = null;
    this.sType = 0x1B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.dynamicStateCount !== void 0) this.dynamicStateCount = opts.dynamicStateCount;
      if (opts.pDynamicStates !== void 0) this.pDynamicStates = opts.pDynamicStates;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineDynamicStateCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get dynamicStateCount() {
    return this.memoryViewUint32[0x5];
  }
  set dynamicStateCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.dynamicStateCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pDynamicStates() {
    return this._pDynamicStates;
  }
  set pDynamicStates(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDynamicStates = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDynamicStates = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDynamicStateCreateInfo.pDynamicStates': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineDynamicStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineDynamicStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineDynamicStateCreateInfo.byteLength = 0x20;

VkPipelineDynamicStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  dynamicStateCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pDynamicStates: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkStencilOpState **/
class VkStencilOpState {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1C) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1C) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x1C);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.failOp !== void 0) this.failOp = opts.failOp;
      if (opts.passOp !== void 0) this.passOp = opts.passOp;
      if (opts.depthFailOp !== void 0) this.depthFailOp = opts.depthFailOp;
      if (opts.compareOp !== void 0) this.compareOp = opts.compareOp;
      if (opts.compareMask !== void 0) this.compareMask = opts.compareMask;
      if (opts.writeMask !== void 0) this.writeMask = opts.writeMask;
      if (opts.reference !== void 0) this.reference = opts.reference;
      
    }
  }
  get failOp() {
    return this.memoryViewInt32[0x0];
  }
  set failOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.failOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get passOp() {
    return this.memoryViewInt32[0x1];
  }
  set passOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.passOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get depthFailOp() {
    return this.memoryViewInt32[0x2];
  }
  set depthFailOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.depthFailOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  get compareOp() {
    return this.memoryViewInt32[0x3];
  }
  set compareOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.compareOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  get compareMask() {
    return this.memoryViewUint32[0x4];
  }
  set compareMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.compareMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get writeMask() {
    return this.memoryViewUint32[0x5];
  }
  set writeMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.writeMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get reference() {
    return this.memoryViewUint32[0x6];
  }
  set reference(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkStencilOpState.reference': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  
};

VkStencilOpState.prototype.flush = function flush() {
  
  return true;
};

VkStencilOpState.prototype.reflect = function reflect(memoryAddress) {
  
};

VkStencilOpState.byteLength = 0x1C;

VkStencilOpState.memoryLayout = Object.freeze({
  failOp: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  passOp: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  depthFailOp: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  compareOp: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  compareMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  writeMask: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  reference: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPipelineDepthStencilStateCreateInfo **/
class VkPipelineDepthStencilStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x68) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x68);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    this._front = new VkStencilOpState({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x28 });
    this._back = new VkStencilOpState({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x44 });
    
    
    this.sType = 0x19;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.depthTestEnable !== void 0) this.depthTestEnable = opts.depthTestEnable;
      if (opts.depthWriteEnable !== void 0) this.depthWriteEnable = opts.depthWriteEnable;
      if (opts.depthCompareOp !== void 0) this.depthCompareOp = opts.depthCompareOp;
      if (opts.depthBoundsTestEnable !== void 0) this.depthBoundsTestEnable = opts.depthBoundsTestEnable;
      if (opts.stencilTestEnable !== void 0) this.stencilTestEnable = opts.stencilTestEnable;
      if (opts.front !== void 0) this.front = opts.front;
      if (opts.back !== void 0) this.back = opts.back;
      if (opts.minDepthBounds !== void 0) this.minDepthBounds = opts.minDepthBounds;
      if (opts.maxDepthBounds !== void 0) this.maxDepthBounds = opts.maxDepthBounds;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineDepthStencilStateCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get depthTestEnable() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set depthTestEnable(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get depthWriteEnable() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set depthWriteEnable(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  get depthCompareOp() {
    return this.memoryViewInt32[0x7];
  }
  set depthCompareOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.depthCompareOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get depthBoundsTestEnable() {
    return this.memoryViewUint32[0x8] !== 0;
  }
  set depthBoundsTestEnable(value) {
    this.memoryViewUint32[0x8] = value | 0;
  }
  get stencilTestEnable() {
    return this.memoryViewUint32[0x9] !== 0;
  }
  set stencilTestEnable(value) {
    this.memoryViewUint32[0x9] = value | 0;
  }
  get front() {
    return this._front;
  }
  set front(value) {
    if (value !== null && value.constructor === VkStencilOpState) {
      value.flush();
      this._front = value;
      
      
    } else if (value === null) {
      this._front = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.front': Expected 'VkStencilOpState' but got '" + value.constructor.name + "'");
    }
  }
  get back() {
    return this._back;
  }
  set back(value) {
    if (value !== null && value.constructor === VkStencilOpState) {
      value.flush();
      this._back = value;
      
      
    } else if (value === null) {
      this._back = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.back': Expected 'VkStencilOpState' but got '" + value.constructor.name + "'");
    }
  }
  get minDepthBounds() {
    return this.memoryViewFloat32[0x18];
  }
  set minDepthBounds(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.minDepthBounds': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x18] = value;
  }
  get maxDepthBounds() {
    return this.memoryViewFloat32[0x19];
  }
  set maxDepthBounds(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDepthStencilStateCreateInfo.maxDepthBounds': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x19] = value;
  }
  
};

VkPipelineDepthStencilStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._front !== null) {
    this._front.flush();
    if (this.memoryBuffer !== this._front.memoryBuffer) {
      let srcView = new Uint8Array(this._front.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x28);
    }
  }
  
  
  if (this._back !== null) {
    this._back.flush();
    if (this.memoryBuffer !== this._back.memoryBuffer) {
      let srcView = new Uint8Array(this._back.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x44);
    }
  }
  
  return true;
};

VkPipelineDepthStencilStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineDepthStencilStateCreateInfo.byteLength = 0x68;

VkPipelineDepthStencilStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  depthTestEnable: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  depthWriteEnable: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  depthCompareOp: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  depthBoundsTestEnable: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  stencilTestEnable: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  front: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x1C
  }),
  back: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x1C
  }),
  minDepthBounds: Object.freeze({
    byteOffset: 0x60,
    byteLength: 0x4
  }),
  maxDepthBounds: Object.freeze({
    byteOffset: 0x64,
    byteLength: 0x4
  }),
});
/** VkGraphicsPipelineCreateInfo **/
class VkGraphicsPipelineCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x90) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x90) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x90) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x90);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pStages = null;
    this._pStagesNative = null;
    this._pVertexInputState = null;
    this._pInputAssemblyState = null;
    this._pTessellationState = null;
    this._pViewportState = null;
    this._pRasterizationState = null;
    this._pMultisampleState = null;
    this._pDepthStencilState = null;
    this._pColorBlendState = null;
    this._pDynamicState = null;
    this._layout = null;
    this._renderPass = null;
    
    this._basePipelineHandle = null;
    
    this.sType = 0x1C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
      if (opts.pStages !== void 0) this.pStages = opts.pStages;
      if (opts.pVertexInputState !== void 0) this.pVertexInputState = opts.pVertexInputState;
      if (opts.pInputAssemblyState !== void 0) this.pInputAssemblyState = opts.pInputAssemblyState;
      if (opts.pTessellationState !== void 0) this.pTessellationState = opts.pTessellationState;
      if (opts.pViewportState !== void 0) this.pViewportState = opts.pViewportState;
      if (opts.pRasterizationState !== void 0) this.pRasterizationState = opts.pRasterizationState;
      if (opts.pMultisampleState !== void 0) this.pMultisampleState = opts.pMultisampleState;
      if (opts.pDepthStencilState !== void 0) this.pDepthStencilState = opts.pDepthStencilState;
      if (opts.pColorBlendState !== void 0) this.pColorBlendState = opts.pColorBlendState;
      if (opts.pDynamicState !== void 0) this.pDynamicState = opts.pDynamicState;
      if (opts.layout !== void 0) this.layout = opts.layout;
      if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
      if (opts.subpass !== void 0) this.subpass = opts.subpass;
      if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
      if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C4CB9:
        case 0x3B9D5271:
          break;
        default:
          throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get stageCount() {
    return this.memoryViewUint32[0x5];
  }
  set stageCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.stageCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pStages() {
    return this._pStages;
  }
  set pStages(value) {
    if (value !== null && value.constructor === Array) {
      this._pStages = value;
    } else if (value === null) {
      this._pStages = null;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pStages': Expected 'Array VkPipelineShaderStageCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pVertexInputState() {
    return this._pVertexInputState;
  }
  set pVertexInputState(value) {
    if (value !== null && value.constructor === VkPipelineVertexInputStateCreateInfo) {
      value.flush();
      this._pVertexInputState = value;
      this.memoryViewBigInt64[0x4] = value.memoryAddress;
      
    } else if (value === null) {
      this._pVertexInputState = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pVertexInputState': Expected 'VkPipelineVertexInputStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pInputAssemblyState() {
    return this._pInputAssemblyState;
  }
  set pInputAssemblyState(value) {
    if (value !== null && value.constructor === VkPipelineInputAssemblyStateCreateInfo) {
      value.flush();
      this._pInputAssemblyState = value;
      this.memoryViewBigInt64[0x5] = value.memoryAddress;
      
    } else if (value === null) {
      this._pInputAssemblyState = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pInputAssemblyState': Expected 'VkPipelineInputAssemblyStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pTessellationState() {
    return this._pTessellationState;
  }
  set pTessellationState(value) {
    if (value !== null && value.constructor === VkPipelineTessellationStateCreateInfo) {
      value.flush();
      this._pTessellationState = value;
      this.memoryViewBigInt64[0x6] = value.memoryAddress;
      
    } else if (value === null) {
      this._pTessellationState = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pTessellationState': Expected 'VkPipelineTessellationStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pViewportState() {
    return this._pViewportState;
  }
  set pViewportState(value) {
    if (value !== null && value.constructor === VkPipelineViewportStateCreateInfo) {
      value.flush();
      this._pViewportState = value;
      this.memoryViewBigInt64[0x7] = value.memoryAddress;
      
    } else if (value === null) {
      this._pViewportState = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pViewportState': Expected 'VkPipelineViewportStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pRasterizationState() {
    return this._pRasterizationState;
  }
  set pRasterizationState(value) {
    if (value !== null && value.constructor === VkPipelineRasterizationStateCreateInfo) {
      value.flush();
      this._pRasterizationState = value;
      this.memoryViewBigInt64[0x8] = value.memoryAddress;
      
    } else if (value === null) {
      this._pRasterizationState = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pRasterizationState': Expected 'VkPipelineRasterizationStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pMultisampleState() {
    return this._pMultisampleState;
  }
  set pMultisampleState(value) {
    if (value !== null && value.constructor === VkPipelineMultisampleStateCreateInfo) {
      value.flush();
      this._pMultisampleState = value;
      this.memoryViewBigInt64[0x9] = value.memoryAddress;
      
    } else if (value === null) {
      this._pMultisampleState = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pMultisampleState': Expected 'VkPipelineMultisampleStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pDepthStencilState() {
    return this._pDepthStencilState;
  }
  set pDepthStencilState(value) {
    if (value !== null && value.constructor === VkPipelineDepthStencilStateCreateInfo) {
      value.flush();
      this._pDepthStencilState = value;
      this.memoryViewBigInt64[0xA] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDepthStencilState = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pDepthStencilState': Expected 'VkPipelineDepthStencilStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pColorBlendState() {
    return this._pColorBlendState;
  }
  set pColorBlendState(value) {
    if (value !== null && value.constructor === VkPipelineColorBlendStateCreateInfo) {
      value.flush();
      this._pColorBlendState = value;
      this.memoryViewBigInt64[0xB] = value.memoryAddress;
      
    } else if (value === null) {
      this._pColorBlendState = null;
      this.memoryViewBigInt64[0xB] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pColorBlendState': Expected 'VkPipelineColorBlendStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get pDynamicState() {
    return this._pDynamicState;
  }
  set pDynamicState(value) {
    if (value !== null && value.constructor === VkPipelineDynamicStateCreateInfo) {
      value.flush();
      this._pDynamicState = value;
      this.memoryViewBigInt64[0xC] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDynamicState = null;
      this.memoryViewBigInt64[0xC] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pDynamicState': Expected 'VkPipelineDynamicStateCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get layout() {
    return this._layout;
  }
  set layout(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryViewBigInt64[0xD] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._layout = null;
      this.memoryViewBigInt64[0xD] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.layout': Expected 'VkPipelineLayout' but got '" + value.constructor.name + "'");
    }
  }
  get renderPass() {
    return this._renderPass;
  }
  set renderPass(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryViewBigInt64[0xE] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._renderPass = null;
      this.memoryViewBigInt64[0xE] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.renderPass': Expected 'VkRenderPass' but got '" + value.constructor.name + "'");
    }
  }
  get subpass() {
    return this.memoryViewUint32[0x1E];
  }
  set subpass(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.subpass': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1E] = value;
  }
  get basePipelineHandle() {
    return this._basePipelineHandle;
  }
  set basePipelineHandle(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryViewBigInt64[0x10] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryViewBigInt64[0x10] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.basePipelineHandle': Expected 'VkPipeline' but got '" + value.constructor.name + "'");
    }
  }
  get basePipelineIndex() {
    return this.memoryViewInt32[0x22];
  }
  set basePipelineIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.basePipelineIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x22] = value;
  }
  
};

VkGraphicsPipelineCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStages !== null) {
    let array = this._pStages;
    if (array.length !== this.stageCount) {
      throw new RangeError("Invalid array length, expected length of 'stageCount' for 'VkGraphicsPipelineCreateInfo.pStages'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkPipelineShaderStageCreateInfo) {
        throw new TypeError("Invalid type for 'VkGraphicsPipelineCreateInfo.pStages[" + ii + "]': Expected 'VkPipelineShaderStageCreateInfo' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pStagesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkGraphicsPipelineCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkGraphicsPipelineCreateInfo.byteLength = 0x90;

VkGraphicsPipelineCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  stageCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pStages: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pVertexInputState: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  pInputAssemblyState: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  pTessellationState: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  pViewportState: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  pRasterizationState: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x8
  }),
  pMultisampleState: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x8
  }),
  pDepthStencilState: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x8
  }),
  pColorBlendState: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x8
  }),
  pDynamicState: Object.freeze({
    byteOffset: 0x60,
    byteLength: 0x8
  }),
  layout: Object.freeze({
    byteOffset: 0x68,
    byteLength: 0x8
  }),
  renderPass: Object.freeze({
    byteOffset: 0x70,
    byteLength: 0x8
  }),
  subpass: Object.freeze({
    byteOffset: 0x78,
    byteLength: 0x4
  }),
  basePipelineHandle: Object.freeze({
    byteOffset: 0x80,
    byteLength: 0x8
  }),
  basePipelineIndex: Object.freeze({
    byteOffset: 0x88,
    byteLength: 0x4
  }),
});
/** VkPipelineCacheCreateInfo **/
class VkPipelineCacheCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pInitialData = null;
    this.sType = 0x11;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.initialDataSize !== void 0) this.initialDataSize = opts.initialDataSize;
      if (opts.pInitialData !== void 0) this.pInitialData = opts.pInitialData;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineCacheCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get initialDataSize() {
    return this.memoryViewBigInt64[0x3];
  }
  set initialDataSize(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.initialDataSize': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x3] = value;
  }
  get pInitialData() {
    return this._pInitialData;
  }
  set pInitialData(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pInitialData = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pInitialData = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCacheCreateInfo.pInitialData': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineCacheCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCacheCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineCacheCreateInfo.byteLength = 0x28;

VkPipelineCacheCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  initialDataSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pInitialData: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkPushConstantRange **/
class VkPushConstantRange {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.size !== void 0) this.size = opts.size;
      
    }
  }
  get stageFlags() {
    return this.memoryViewInt32[0x0];
  }
  set stageFlags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPushConstantRange.stageFlags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get offset() {
    return this.memoryViewUint32[0x1];
  }
  set offset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPushConstantRange.offset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get size() {
    return this.memoryViewUint32[0x2];
  }
  set size(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPushConstantRange.size': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  
};

VkPushConstantRange.prototype.flush = function flush() {
  
  return true;
};

VkPushConstantRange.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPushConstantRange.byteLength = 0xC;

VkPushConstantRange.memoryLayout = Object.freeze({
  stageFlags: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  offset: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  size: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkPipelineLayoutCreateInfo **/
class VkPipelineLayoutCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pSetLayouts = null;
    this._pSetLayoutsNative = null;
    
    this._pPushConstantRanges = null;
    this._pPushConstantRangesNative = null;
    this.sType = 0x1E;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.setLayoutCount !== void 0) this.setLayoutCount = opts.setLayoutCount;
      if (opts.pSetLayouts !== void 0) this.pSetLayouts = opts.pSetLayouts;
      if (opts.pushConstantRangeCount !== void 0) this.pushConstantRangeCount = opts.pushConstantRangeCount;
      if (opts.pPushConstantRanges !== void 0) this.pPushConstantRanges = opts.pPushConstantRanges;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineLayoutCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get setLayoutCount() {
    return this.memoryViewUint32[0x5];
  }
  set setLayoutCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.setLayoutCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pSetLayouts() {
    return this._pSetLayouts;
  }
  set pSetLayouts(value) {
    if (value !== null && value.constructor === Array) {
      this._pSetLayouts = value;
    } else if (value === null) {
      this._pSetLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pSetLayouts': Expected 'Array VkDescriptorSetLayout' but got '" + value.constructor.name + "'");
    }
  }
  get pushConstantRangeCount() {
    return this.memoryViewUint32[0x8];
  }
  set pushConstantRangeCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pushConstantRangeCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pPushConstantRanges() {
    return this._pPushConstantRanges;
  }
  set pPushConstantRanges(value) {
    if (value !== null && value.constructor === Array) {
      this._pPushConstantRanges = value;
    } else if (value === null) {
      this._pPushConstantRanges = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pPushConstantRanges': Expected 'Array VkPushConstantRange' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineLayoutCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSetLayouts !== null) {
    let array = this._pSetLayouts;
    if (array.length !== this.setLayoutCount) {
      throw new RangeError("Invalid array length, expected length of 'setLayoutCount' for 'VkPipelineLayoutCreateInfo.pSetLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDescriptorSetLayout) {
        throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pSetLayouts[" + ii + "]': Expected 'VkDescriptorSetLayout' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSetLayoutsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pPushConstantRanges !== null) {
    let array = this._pPushConstantRanges;
    if (array.length !== this.pushConstantRangeCount) {
      throw new RangeError("Invalid array length, expected length of 'pushConstantRangeCount' for 'VkPipelineLayoutCreateInfo.pPushConstantRanges'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkPushConstantRange) {
        throw new TypeError("Invalid type for 'VkPipelineLayoutCreateInfo.pPushConstantRanges[" + ii + "]': Expected 'VkPushConstantRange' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pPushConstantRangesNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkPipelineLayoutCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPipelineLayoutCreateInfo.byteLength = 0x30;

VkPipelineLayoutCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  setLayoutCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pSetLayouts: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pushConstantRangeCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pPushConstantRanges: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkSamplerCreateInfo **/
class VkSamplerCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x50) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x50);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    this.sType = 0x1F;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.magFilter !== void 0) this.magFilter = opts.magFilter;
      if (opts.minFilter !== void 0) this.minFilter = opts.minFilter;
      if (opts.mipmapMode !== void 0) this.mipmapMode = opts.mipmapMode;
      if (opts.addressModeU !== void 0) this.addressModeU = opts.addressModeU;
      if (opts.addressModeV !== void 0) this.addressModeV = opts.addressModeV;
      if (opts.addressModeW !== void 0) this.addressModeW = opts.addressModeW;
      if (opts.mipLodBias !== void 0) this.mipLodBias = opts.mipLodBias;
      if (opts.anisotropyEnable !== void 0) this.anisotropyEnable = opts.anisotropyEnable;
      if (opts.maxAnisotropy !== void 0) this.maxAnisotropy = opts.maxAnisotropy;
      if (opts.compareEnable !== void 0) this.compareEnable = opts.compareEnable;
      if (opts.compareOp !== void 0) this.compareOp = opts.compareOp;
      if (opts.minLod !== void 0) this.minLod = opts.minLod;
      if (opts.maxLod !== void 0) this.maxLod = opts.maxLod;
      if (opts.borderColor !== void 0) this.borderColor = opts.borderColor;
      if (opts.unnormalizedCoordinates !== void 0) this.unnormalizedCoordinates = opts.unnormalizedCoordinates;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9D2B61:
        case 0x3B9CC5D1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get magFilter() {
    return this.memoryViewInt32[0x5];
  }
  set magFilter(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.magFilter': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get minFilter() {
    return this.memoryViewInt32[0x6];
  }
  set minFilter(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.minFilter': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get mipmapMode() {
    return this.memoryViewInt32[0x7];
  }
  set mipmapMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.mipmapMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get addressModeU() {
    return this.memoryViewInt32[0x8];
  }
  set addressModeU(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.addressModeU': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get addressModeV() {
    return this.memoryViewInt32[0x9];
  }
  set addressModeV(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.addressModeV': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get addressModeW() {
    return this.memoryViewInt32[0xA];
  }
  set addressModeW(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.addressModeW': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xA] = value;
  }
  get mipLodBias() {
    return this.memoryViewFloat32[0xB];
  }
  set mipLodBias(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.mipLodBias': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xB] = value;
  }
  get anisotropyEnable() {
    return this.memoryViewUint32[0xC] !== 0;
  }
  set anisotropyEnable(value) {
    this.memoryViewUint32[0xC] = value | 0;
  }
  get maxAnisotropy() {
    return this.memoryViewFloat32[0xD];
  }
  set maxAnisotropy(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.maxAnisotropy': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xD] = value;
  }
  get compareEnable() {
    return this.memoryViewUint32[0xE] !== 0;
  }
  set compareEnable(value) {
    this.memoryViewUint32[0xE] = value | 0;
  }
  get compareOp() {
    return this.memoryViewInt32[0xF];
  }
  set compareOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.compareOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xF] = value;
  }
  get minLod() {
    return this.memoryViewFloat32[0x10];
  }
  set minLod(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.minLod': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x10] = value;
  }
  get maxLod() {
    return this.memoryViewFloat32[0x11];
  }
  set maxLod(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.maxLod': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x11] = value;
  }
  get borderColor() {
    return this.memoryViewInt32[0x12];
  }
  set borderColor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerCreateInfo.borderColor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x12] = value;
  }
  get unnormalizedCoordinates() {
    return this.memoryViewUint32[0x13] !== 0;
  }
  set unnormalizedCoordinates(value) {
    this.memoryViewUint32[0x13] = value | 0;
  }
  
};

VkSamplerCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSamplerCreateInfo.byteLength = 0x50;

VkSamplerCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  magFilter: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  minFilter: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  mipmapMode: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  addressModeU: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  addressModeV: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  addressModeW: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  mipLodBias: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  anisotropyEnable: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  maxAnisotropy: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  compareEnable: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  compareOp: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  minLod: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  maxLod: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
  borderColor: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  unnormalizedCoordinates: Object.freeze({
    byteOffset: 0x4C,
    byteLength: 0x4
  }),
});
/** VkCommandPoolCreateInfo **/
class VkCommandPoolCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x27;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandPoolCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCommandPoolCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandPoolCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get queueFamilyIndex() {
    return this.memoryViewUint32[0x5];
  }
  set queueFamilyIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandPoolCreateInfo.queueFamilyIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  
};

VkCommandPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandPoolCreateInfo.byteLength = 0x18;

VkCommandPoolCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  queueFamilyIndex: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkCommandBufferAllocateInfo **/
class VkCommandBufferAllocateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._commandPool = null;
    
    
    this.sType = 0x28;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.commandPool !== void 0) this.commandPool = opts.commandPool;
      if (opts.level !== void 0) this.level = opts.level;
      if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCommandBufferAllocateInfo.pNext' isn't allowed to be filled");
  }
  get commandPool() {
    return this._commandPool;
  }
  set commandPool(value) {
    if (value !== null && value.constructor === VkCommandPool) {
      
      this._commandPool = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._commandPool = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.commandPool': Expected 'VkCommandPool' but got '" + value.constructor.name + "'");
    }
  }
  get level() {
    return this.memoryViewInt32[0x6];
  }
  set level(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.level': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get commandBufferCount() {
    return this.memoryViewUint32[0x7];
  }
  set commandBufferCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferAllocateInfo.commandBufferCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  
};

VkCommandBufferAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandBufferAllocateInfo.byteLength = 0x20;

VkCommandBufferAllocateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  commandPool: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  level: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  commandBufferCount: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkCommandBufferInheritanceInfo **/
class VkCommandBufferInheritanceInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._renderPass = null;
    
    this._framebuffer = null;
    
    
    
    this.sType = 0x29;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
      if (opts.subpass !== void 0) this.subpass = opts.subpass;
      if (opts.framebuffer !== void 0) this.framebuffer = opts.framebuffer;
      if (opts.occlusionQueryEnable !== void 0) this.occlusionQueryEnable = opts.occlusionQueryEnable;
      if (opts.queryFlags !== void 0) this.queryFlags = opts.queryFlags;
      if (opts.pipelineStatistics !== void 0) this.pipelineStatistics = opts.pipelineStatistics;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C0668:
          break;
        default:
          throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pNext'");
    }
  }
  get renderPass() {
    return this._renderPass;
  }
  set renderPass(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._renderPass = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.renderPass': Expected 'VkRenderPass' but got '" + value.constructor.name + "'");
    }
  }
  get subpass() {
    return this.memoryViewUint32[0x6];
  }
  set subpass(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.subpass': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get framebuffer() {
    return this._framebuffer;
  }
  set framebuffer(value) {
    if (value !== null && value.constructor === VkFramebuffer) {
      
      this._framebuffer = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._framebuffer = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.framebuffer': Expected 'VkFramebuffer' but got '" + value.constructor.name + "'");
    }
  }
  get occlusionQueryEnable() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  set occlusionQueryEnable(value) {
    this.memoryViewUint32[0xA] = value | 0;
  }
  get queryFlags() {
    return this.memoryViewInt32[0xB];
  }
  set queryFlags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.queryFlags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xB] = value;
  }
  get pipelineStatistics() {
    return this.memoryViewInt32[0xC];
  }
  set pipelineStatistics(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceInfo.pipelineStatistics': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  
};

VkCommandBufferInheritanceInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferInheritanceInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandBufferInheritanceInfo.byteLength = 0x38;

VkCommandBufferInheritanceInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  renderPass: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  subpass: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  framebuffer: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  occlusionQueryEnable: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  queryFlags: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  pipelineStatistics: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
});
/** VkCommandBufferBeginInfo **/
class VkCommandBufferBeginInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pInheritanceInfo = null;
    this.sType = 0x2A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pInheritanceInfo !== void 0) this.pInheritanceInfo = opts.pInheritanceInfo;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB464:
          break;
        default:
          throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get pInheritanceInfo() {
    return this._pInheritanceInfo;
  }
  set pInheritanceInfo(value) {
    if (value !== null && value.constructor === VkCommandBufferInheritanceInfo) {
      value.flush();
      this._pInheritanceInfo = value;
      this.memoryViewBigInt64[0x3] = value.memoryAddress;
      
    } else if (value === null) {
      this._pInheritanceInfo = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCommandBufferBeginInfo.pInheritanceInfo': Expected 'VkCommandBufferInheritanceInfo' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkCommandBufferBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandBufferBeginInfo.byteLength = 0x20;

VkCommandBufferBeginInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pInheritanceInfo: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkRenderPassBeginInfo **/
class VkRenderPassBeginInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._renderPass = null;
    this._framebuffer = null;
    this._renderArea = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x20 });
    
    this._pClearValues = null;
    this._pClearValuesNative = null;
    this.sType = 0x2B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
      if (opts.framebuffer !== void 0) this.framebuffer = opts.framebuffer;
      if (opts.renderArea !== void 0) this.renderArea = opts.renderArea;
      if (opts.clearValueCount !== void 0) this.clearValueCount = opts.clearValueCount;
      if (opts.pClearValues !== void 0) this.pClearValues = opts.pClearValues;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB463:
        case 0x3B9CF899:
          break;
        default:
          throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pNext'");
    }
  }
  get renderPass() {
    return this._renderPass;
  }
  set renderPass(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._renderPass = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.renderPass': Expected 'VkRenderPass' but got '" + value.constructor.name + "'");
    }
  }
  get framebuffer() {
    return this._framebuffer;
  }
  set framebuffer(value) {
    if (value !== null && value.constructor === VkFramebuffer) {
      
      this._framebuffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._framebuffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.framebuffer': Expected 'VkFramebuffer' but got '" + value.constructor.name + "'");
    }
  }
  get renderArea() {
    return this._renderArea;
  }
  set renderArea(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._renderArea = value;
      
      
    } else if (value === null) {
      this._renderArea = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.renderArea': Expected 'VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  get clearValueCount() {
    return this.memoryViewUint32[0xC];
  }
  set clearValueCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.clearValueCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pClearValues() {
    return this._pClearValues;
  }
  set pClearValues(value) {
    if (value !== null && value.constructor === Array) {
      this._pClearValues = value;
    } else if (value === null) {
      this._pClearValues = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pClearValues': Expected 'Array VkClearValue' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._renderArea !== null) {
    this._renderArea.flush();
    if (this.memoryBuffer !== this._renderArea.memoryBuffer) {
      let srcView = new Uint8Array(this._renderArea.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x20);
    }
  }
  
  
  if (this._pClearValues !== null) {
    let array = this._pClearValues;
    if (array.length !== this.clearValueCount) {
      throw new RangeError("Invalid array length, expected length of 'clearValueCount' for 'VkRenderPassBeginInfo.pClearValues'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkClearValue) {
        throw new TypeError("Invalid type for 'VkRenderPassBeginInfo.pClearValues[" + ii + "]': Expected 'VkClearValue' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pClearValuesNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  }
  
  return true;
};

VkRenderPassBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkRenderPassBeginInfo.byteLength = 0x40;

VkRenderPassBeginInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  renderPass: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  framebuffer: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  renderArea: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x10
  }),
  clearValueCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pClearValues: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkClearDepthStencilValue **/
class VkClearDepthStencilValue {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.depth !== void 0) this.depth = opts.depth;
      if (opts.stencil !== void 0) this.stencil = opts.stencil;
      
    }
  }
  get depth() {
    return this.memoryViewFloat32[0x0];
  }
  set depth(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearDepthStencilValue.depth': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x0] = value;
  }
  get stencil() {
    return this.memoryViewUint32[0x1];
  }
  set stencil(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearDepthStencilValue.stencil': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  
};

VkClearDepthStencilValue.prototype.flush = function flush() {
  
  return true;
};

VkClearDepthStencilValue.prototype.reflect = function reflect(memoryAddress) {
  
};

VkClearDepthStencilValue.byteLength = 0x8;

VkClearDepthStencilValue.memoryLayout = Object.freeze({
  depth: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  stencil: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkClearAttachment **/
class VkClearAttachment {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    this._clearValue = new VkClearValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x8 });
    
    if (typeof opts === "object") {
      if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
      if (opts.colorAttachment !== void 0) this.colorAttachment = opts.colorAttachment;
      if (opts.clearValue !== void 0) this.clearValue = opts.clearValue;
      
    }
  }
  get aspectMask() {
    return this.memoryViewInt32[0x0];
  }
  set aspectMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearAttachment.aspectMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get colorAttachment() {
    return this.memoryViewUint32[0x1];
  }
  set colorAttachment(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkClearAttachment.colorAttachment': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get clearValue() {
    return this._clearValue;
  }
  set clearValue(value) {
    if (value !== null && value.constructor === VkClearValue) {
      value.flush();
      this._clearValue = value;
      
      
    } else if (value === null) {
      this._clearValue = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearAttachment.clearValue': Expected 'VkClearValue' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkClearAttachment.prototype.flush = function flush() {
  
  
  if (this._clearValue !== null) {
    this._clearValue.flush();
    if (this.memoryBuffer !== this._clearValue.memoryBuffer) {
      let srcView = new Uint8Array(this._clearValue.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
    }
  }
  
  return true;
};

VkClearAttachment.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkClearAttachment.byteLength = 0x18;

VkClearAttachment.memoryLayout = Object.freeze({
  aspectMask: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  colorAttachment: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  clearValue: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x10
  }),
});
/** VkAttachmentDescription **/
class VkAttachmentDescription {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x24) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x24);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.samples !== void 0) this.samples = opts.samples;
      if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
      if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
      if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
      if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
      if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
      if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
      
    }
  }
  get flags() {
    return this.memoryViewInt32[0x0];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get format() {
    return this.memoryViewInt32[0x1];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get samples() {
    return this.memoryViewInt32[0x2];
  }
  set samples(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.samples': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  get loadOp() {
    return this.memoryViewInt32[0x3];
  }
  set loadOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.loadOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  get storeOp() {
    return this.memoryViewInt32[0x4];
  }
  set storeOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.storeOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get stencilLoadOp() {
    return this.memoryViewInt32[0x5];
  }
  set stencilLoadOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.stencilLoadOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get stencilStoreOp() {
    return this.memoryViewInt32[0x6];
  }
  set stencilStoreOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.stencilStoreOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get initialLayout() {
    return this.memoryViewInt32[0x7];
  }
  set initialLayout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.initialLayout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get finalLayout() {
    return this.memoryViewInt32[0x8];
  }
  set finalLayout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription.finalLayout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkAttachmentDescription.prototype.flush = function flush() {
  
  return true;
};

VkAttachmentDescription.prototype.reflect = function reflect(memoryAddress) {
  
};

VkAttachmentDescription.byteLength = 0x24;

VkAttachmentDescription.memoryLayout = Object.freeze({
  flags: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  format: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  samples: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  loadOp: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  storeOp: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  stencilLoadOp: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  stencilStoreOp: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  initialLayout: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  finalLayout: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkAttachmentReference **/
class VkAttachmentReference {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.attachment !== void 0) this.attachment = opts.attachment;
      if (opts.layout !== void 0) this.layout = opts.layout;
      
    }
  }
  get attachment() {
    return this.memoryViewUint32[0x0];
  }
  set attachment(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference.attachment': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get layout() {
    return this.memoryViewInt32[0x1];
  }
  set layout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference.layout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  
};

VkAttachmentReference.prototype.flush = function flush() {
  
  return true;
};

VkAttachmentReference.prototype.reflect = function reflect(memoryAddress) {
  
};

VkAttachmentReference.byteLength = 0x8;

VkAttachmentReference.memoryLayout = Object.freeze({
  attachment: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  layout: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkSubpassDescription **/
class VkSubpassDescription {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    
    this._pInputAttachments = null;
    this._pInputAttachmentsNative = null;
    
    this._pColorAttachments = null;
    this._pColorAttachmentsNative = null;
    this._pResolveAttachments = null;
    this._pResolveAttachmentsNative = null;
    this._pDepthStencilAttachment = null;
    
    this._pPreserveAttachments = null;
    
    if (typeof opts === "object") {
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
      if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
      if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
      if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
      if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
      if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
      if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
      if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
      if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
      
    }
  }
  get flags() {
    return this.memoryViewInt32[0x0];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pipelineBindPoint() {
    return this.memoryViewInt32[0x1];
  }
  set pipelineBindPoint(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pipelineBindPoint': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get inputAttachmentCount() {
    return this.memoryViewUint32[0x2];
  }
  set inputAttachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.inputAttachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get pInputAttachments() {
    return this._pInputAttachments;
  }
  set pInputAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pInputAttachments = value;
    } else if (value === null) {
      this._pInputAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pInputAttachments': Expected 'Array VkAttachmentReference' but got '" + value.constructor.name + "'");
    }
  }
  get colorAttachmentCount() {
    return this.memoryViewUint32[0x6];
  }
  set colorAttachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.colorAttachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pColorAttachments() {
    return this._pColorAttachments;
  }
  set pColorAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pColorAttachments = value;
    } else if (value === null) {
      this._pColorAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pColorAttachments': Expected 'Array VkAttachmentReference' but got '" + value.constructor.name + "'");
    }
  }
  get pResolveAttachments() {
    return this._pResolveAttachments;
  }
  set pResolveAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pResolveAttachments = value;
    } else if (value === null) {
      this._pResolveAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pResolveAttachments': Expected 'Array VkAttachmentReference' but got '" + value.constructor.name + "'");
    }
  }
  get pDepthStencilAttachment() {
    return this._pDepthStencilAttachment;
  }
  set pDepthStencilAttachment(value) {
    if (value !== null && value.constructor === VkAttachmentReference) {
      value.flush();
      this._pDepthStencilAttachment = value;
      this.memoryViewBigInt64[0x6] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDepthStencilAttachment = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pDepthStencilAttachment': Expected 'VkAttachmentReference' but got '" + value.constructor.name + "'");
    }
  }
  get preserveAttachmentCount() {
    return this.memoryViewUint32[0xE];
  }
  set preserveAttachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription.preserveAttachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xE] = value;
  }
  get pPreserveAttachments() {
    return this._pPreserveAttachments;
  }
  set pPreserveAttachments(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pPreserveAttachments = value;
      this.memoryViewBigInt64[0x8] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pPreserveAttachments = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription.pPreserveAttachments': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSubpassDescription.prototype.flush = function flush() {
  
  
  if (this._pInputAttachments !== null) {
    let array = this._pInputAttachments;
    if (array.length !== this.inputAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'inputAttachmentCount' for 'VkSubpassDescription.pInputAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentReference) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pInputAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pInputAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x2] = nativeArray.address;
  }
  
  
  if (this._pColorAttachments !== null) {
    let array = this._pColorAttachments;
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription.pColorAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentReference) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pColorAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pColorAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  
  if (this._pResolveAttachments !== null) {
    let array = this._pResolveAttachments;
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription.pResolveAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentReference) {
        throw new TypeError("Invalid type for 'VkSubpassDescription.pResolveAttachments[" + ii + "]': Expected 'VkAttachmentReference' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pResolveAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkSubpassDescription.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkSubpassDescription.byteLength = 0x48;

VkSubpassDescription.memoryLayout = Object.freeze({
  flags: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pipelineBindPoint: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  inputAttachmentCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  pInputAttachments: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  colorAttachmentCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pColorAttachments: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  pResolveAttachments: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  pDepthStencilAttachment: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  preserveAttachmentCount: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  pPreserveAttachments: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x8
  }),
});
/** VkSubpassDependency **/
class VkSubpassDependency {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1C) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1C) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x1C);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
      if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
      if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
      if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
      if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
      if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
      if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
      
    }
  }
  get srcSubpass() {
    return this.memoryViewUint32[0x0];
  }
  set srcSubpass(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.srcSubpass': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get dstSubpass() {
    return this.memoryViewUint32[0x1];
  }
  set dstSubpass(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.dstSubpass': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get srcStageMask() {
    return this.memoryViewInt32[0x2];
  }
  set srcStageMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.srcStageMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  get dstStageMask() {
    return this.memoryViewInt32[0x3];
  }
  set dstStageMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.dstStageMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  get srcAccessMask() {
    return this.memoryViewInt32[0x4];
  }
  set srcAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.srcAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get dstAccessMask() {
    return this.memoryViewInt32[0x5];
  }
  set dstAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.dstAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get dependencyFlags() {
    return this.memoryViewInt32[0x6];
  }
  set dependencyFlags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency.dependencyFlags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  
};

VkSubpassDependency.prototype.flush = function flush() {
  
  return true;
};

VkSubpassDependency.prototype.reflect = function reflect(memoryAddress) {
  
};

VkSubpassDependency.byteLength = 0x1C;

VkSubpassDependency.memoryLayout = Object.freeze({
  srcSubpass: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  dstSubpass: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  srcStageMask: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  dstStageMask: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  srcAccessMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  dstAccessMask: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  dependencyFlags: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkRenderPassCreateInfo **/
class VkRenderPassCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pAttachments = null;
    this._pAttachmentsNative = null;
    
    this._pSubpasses = null;
    this._pSubpassesNative = null;
    
    this._pDependencies = null;
    this._pDependenciesNative = null;
    this.sType = 0x26;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
      if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
      if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
      if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
      if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
      if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9B9908:
        case 0x3B9C9309:
        case 0x3B9E1D92:
          break;
        default:
          throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get attachmentCount() {
    return this.memoryViewUint32[0x5];
  }
  set attachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.attachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pAttachments() {
    return this._pAttachments;
  }
  set pAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pAttachments': Expected 'Array VkAttachmentDescription' but got '" + value.constructor.name + "'");
    }
  }
  get subpassCount() {
    return this.memoryViewUint32[0x8];
  }
  set subpassCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.subpassCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pSubpasses() {
    return this._pSubpasses;
  }
  set pSubpasses(value) {
    if (value !== null && value.constructor === Array) {
      this._pSubpasses = value;
    } else if (value === null) {
      this._pSubpasses = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pSubpasses': Expected 'Array VkSubpassDescription' but got '" + value.constructor.name + "'");
    }
  }
  get dependencyCount() {
    return this.memoryViewUint32[0xC];
  }
  set dependencyCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.dependencyCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pDependencies() {
    return this._pDependencies;
  }
  set pDependencies(value) {
    if (value !== null && value.constructor === Array) {
      this._pDependencies = value;
    } else if (value === null) {
      this._pDependencies = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pDependencies': Expected 'Array VkSubpassDependency' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentDescription) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pAttachments[" + ii + "]': Expected 'VkAttachmentDescription' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pSubpasses !== null) {
    let array = this._pSubpasses;
    if (array.length !== this.subpassCount) {
      throw new RangeError("Invalid array length, expected length of 'subpassCount' for 'VkRenderPassCreateInfo.pSubpasses'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSubpassDescription) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pSubpasses[" + ii + "]': Expected 'VkSubpassDescription' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSubpassesNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  
  if (this._pDependencies !== null) {
    let array = this._pDependencies;
    if (array.length !== this.dependencyCount) {
      throw new RangeError("Invalid array length, expected length of 'dependencyCount' for 'VkRenderPassCreateInfo.pDependencies'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSubpassDependency) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo.pDependencies[" + ii + "]': Expected 'VkSubpassDependency' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pDependenciesNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  }
  
  return true;
};

VkRenderPassCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkRenderPassCreateInfo.byteLength = 0x40;

VkRenderPassCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  attachmentCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pAttachments: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  subpassCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pSubpasses: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  dependencyCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pDependencies: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkEventCreateInfo **/
class VkEventCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0xA;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkEventCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkEventCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkEventCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkEventCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkEventCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkEventCreateInfo.byteLength = 0x18;

VkEventCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkFenceCreateInfo **/
class VkFenceCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9C8368:
        case 0x3B9C8751:
          break;
        default:
          throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFenceCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkFenceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFenceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkFenceCreateInfo.byteLength = 0x18;

VkFenceCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceFeatures **/
class VkPhysicalDeviceFeatures {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xDC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xDC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.robustBufferAccess !== void 0) this.robustBufferAccess = opts.robustBufferAccess;
      if (opts.fullDrawIndexUint32 !== void 0) this.fullDrawIndexUint32 = opts.fullDrawIndexUint32;
      if (opts.imageCubeArray !== void 0) this.imageCubeArray = opts.imageCubeArray;
      if (opts.independentBlend !== void 0) this.independentBlend = opts.independentBlend;
      if (opts.geometryShader !== void 0) this.geometryShader = opts.geometryShader;
      if (opts.tessellationShader !== void 0) this.tessellationShader = opts.tessellationShader;
      if (opts.sampleRateShading !== void 0) this.sampleRateShading = opts.sampleRateShading;
      if (opts.dualSrcBlend !== void 0) this.dualSrcBlend = opts.dualSrcBlend;
      if (opts.logicOp !== void 0) this.logicOp = opts.logicOp;
      if (opts.multiDrawIndirect !== void 0) this.multiDrawIndirect = opts.multiDrawIndirect;
      if (opts.drawIndirectFirstInstance !== void 0) this.drawIndirectFirstInstance = opts.drawIndirectFirstInstance;
      if (opts.depthClamp !== void 0) this.depthClamp = opts.depthClamp;
      if (opts.depthBiasClamp !== void 0) this.depthBiasClamp = opts.depthBiasClamp;
      if (opts.fillModeNonSolid !== void 0) this.fillModeNonSolid = opts.fillModeNonSolid;
      if (opts.depthBounds !== void 0) this.depthBounds = opts.depthBounds;
      if (opts.wideLines !== void 0) this.wideLines = opts.wideLines;
      if (opts.largePoints !== void 0) this.largePoints = opts.largePoints;
      if (opts.alphaToOne !== void 0) this.alphaToOne = opts.alphaToOne;
      if (opts.multiViewport !== void 0) this.multiViewport = opts.multiViewport;
      if (opts.samplerAnisotropy !== void 0) this.samplerAnisotropy = opts.samplerAnisotropy;
      if (opts.textureCompressionETC2 !== void 0) this.textureCompressionETC2 = opts.textureCompressionETC2;
      if (opts.textureCompressionASTC_LDR !== void 0) this.textureCompressionASTC_LDR = opts.textureCompressionASTC_LDR;
      if (opts.textureCompressionBC !== void 0) this.textureCompressionBC = opts.textureCompressionBC;
      if (opts.occlusionQueryPrecise !== void 0) this.occlusionQueryPrecise = opts.occlusionQueryPrecise;
      if (opts.pipelineStatisticsQuery !== void 0) this.pipelineStatisticsQuery = opts.pipelineStatisticsQuery;
      if (opts.vertexPipelineStoresAndAtomics !== void 0) this.vertexPipelineStoresAndAtomics = opts.vertexPipelineStoresAndAtomics;
      if (opts.fragmentStoresAndAtomics !== void 0) this.fragmentStoresAndAtomics = opts.fragmentStoresAndAtomics;
      if (opts.shaderTessellationAndGeometryPointSize !== void 0) this.shaderTessellationAndGeometryPointSize = opts.shaderTessellationAndGeometryPointSize;
      if (opts.shaderImageGatherExtended !== void 0) this.shaderImageGatherExtended = opts.shaderImageGatherExtended;
      if (opts.shaderStorageImageExtendedFormats !== void 0) this.shaderStorageImageExtendedFormats = opts.shaderStorageImageExtendedFormats;
      if (opts.shaderStorageImageMultisample !== void 0) this.shaderStorageImageMultisample = opts.shaderStorageImageMultisample;
      if (opts.shaderStorageImageReadWithoutFormat !== void 0) this.shaderStorageImageReadWithoutFormat = opts.shaderStorageImageReadWithoutFormat;
      if (opts.shaderStorageImageWriteWithoutFormat !== void 0) this.shaderStorageImageWriteWithoutFormat = opts.shaderStorageImageWriteWithoutFormat;
      if (opts.shaderUniformBufferArrayDynamicIndexing !== void 0) this.shaderUniformBufferArrayDynamicIndexing = opts.shaderUniformBufferArrayDynamicIndexing;
      if (opts.shaderSampledImageArrayDynamicIndexing !== void 0) this.shaderSampledImageArrayDynamicIndexing = opts.shaderSampledImageArrayDynamicIndexing;
      if (opts.shaderStorageBufferArrayDynamicIndexing !== void 0) this.shaderStorageBufferArrayDynamicIndexing = opts.shaderStorageBufferArrayDynamicIndexing;
      if (opts.shaderStorageImageArrayDynamicIndexing !== void 0) this.shaderStorageImageArrayDynamicIndexing = opts.shaderStorageImageArrayDynamicIndexing;
      if (opts.shaderClipDistance !== void 0) this.shaderClipDistance = opts.shaderClipDistance;
      if (opts.shaderCullDistance !== void 0) this.shaderCullDistance = opts.shaderCullDistance;
      if (opts.shaderFloat64 !== void 0) this.shaderFloat64 = opts.shaderFloat64;
      if (opts.shaderInt64 !== void 0) this.shaderInt64 = opts.shaderInt64;
      if (opts.shaderInt16 !== void 0) this.shaderInt16 = opts.shaderInt16;
      if (opts.shaderResourceResidency !== void 0) this.shaderResourceResidency = opts.shaderResourceResidency;
      if (opts.shaderResourceMinLod !== void 0) this.shaderResourceMinLod = opts.shaderResourceMinLod;
      if (opts.sparseBinding !== void 0) this.sparseBinding = opts.sparseBinding;
      if (opts.sparseResidencyBuffer !== void 0) this.sparseResidencyBuffer = opts.sparseResidencyBuffer;
      if (opts.sparseResidencyImage2D !== void 0) this.sparseResidencyImage2D = opts.sparseResidencyImage2D;
      if (opts.sparseResidencyImage3D !== void 0) this.sparseResidencyImage3D = opts.sparseResidencyImage3D;
      if (opts.sparseResidency2Samples !== void 0) this.sparseResidency2Samples = opts.sparseResidency2Samples;
      if (opts.sparseResidency4Samples !== void 0) this.sparseResidency4Samples = opts.sparseResidency4Samples;
      if (opts.sparseResidency8Samples !== void 0) this.sparseResidency8Samples = opts.sparseResidency8Samples;
      if (opts.sparseResidency16Samples !== void 0) this.sparseResidency16Samples = opts.sparseResidency16Samples;
      if (opts.sparseResidencyAliased !== void 0) this.sparseResidencyAliased = opts.sparseResidencyAliased;
      if (opts.variableMultisampleRate !== void 0) this.variableMultisampleRate = opts.variableMultisampleRate;
      if (opts.inheritedQueries !== void 0) this.inheritedQueries = opts.inheritedQueries;
      
    }
  }
  get robustBufferAccess() {
    return this.memoryViewUint32[0x0] !== 0;
  }
  set robustBufferAccess(value) {
    this.memoryViewUint32[0x0] = value | 0;
  }
  get fullDrawIndexUint32() {
    return this.memoryViewUint32[0x1] !== 0;
  }
  set fullDrawIndexUint32(value) {
    this.memoryViewUint32[0x1] = value | 0;
  }
  get imageCubeArray() {
    return this.memoryViewUint32[0x2] !== 0;
  }
  set imageCubeArray(value) {
    this.memoryViewUint32[0x2] = value | 0;
  }
  get independentBlend() {
    return this.memoryViewUint32[0x3] !== 0;
  }
  set independentBlend(value) {
    this.memoryViewUint32[0x3] = value | 0;
  }
  get geometryShader() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set geometryShader(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get tessellationShader() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set tessellationShader(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get sampleRateShading() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set sampleRateShading(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  get dualSrcBlend() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  set dualSrcBlend(value) {
    this.memoryViewUint32[0x7] = value | 0;
  }
  get logicOp() {
    return this.memoryViewUint32[0x8] !== 0;
  }
  set logicOp(value) {
    this.memoryViewUint32[0x8] = value | 0;
  }
  get multiDrawIndirect() {
    return this.memoryViewUint32[0x9] !== 0;
  }
  set multiDrawIndirect(value) {
    this.memoryViewUint32[0x9] = value | 0;
  }
  get drawIndirectFirstInstance() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  set drawIndirectFirstInstance(value) {
    this.memoryViewUint32[0xA] = value | 0;
  }
  get depthClamp() {
    return this.memoryViewUint32[0xB] !== 0;
  }
  set depthClamp(value) {
    this.memoryViewUint32[0xB] = value | 0;
  }
  get depthBiasClamp() {
    return this.memoryViewUint32[0xC] !== 0;
  }
  set depthBiasClamp(value) {
    this.memoryViewUint32[0xC] = value | 0;
  }
  get fillModeNonSolid() {
    return this.memoryViewUint32[0xD] !== 0;
  }
  set fillModeNonSolid(value) {
    this.memoryViewUint32[0xD] = value | 0;
  }
  get depthBounds() {
    return this.memoryViewUint32[0xE] !== 0;
  }
  set depthBounds(value) {
    this.memoryViewUint32[0xE] = value | 0;
  }
  get wideLines() {
    return this.memoryViewUint32[0xF] !== 0;
  }
  set wideLines(value) {
    this.memoryViewUint32[0xF] = value | 0;
  }
  get largePoints() {
    return this.memoryViewUint32[0x10] !== 0;
  }
  set largePoints(value) {
    this.memoryViewUint32[0x10] = value | 0;
  }
  get alphaToOne() {
    return this.memoryViewUint32[0x11] !== 0;
  }
  set alphaToOne(value) {
    this.memoryViewUint32[0x11] = value | 0;
  }
  get multiViewport() {
    return this.memoryViewUint32[0x12] !== 0;
  }
  set multiViewport(value) {
    this.memoryViewUint32[0x12] = value | 0;
  }
  get samplerAnisotropy() {
    return this.memoryViewUint32[0x13] !== 0;
  }
  set samplerAnisotropy(value) {
    this.memoryViewUint32[0x13] = value | 0;
  }
  get textureCompressionETC2() {
    return this.memoryViewUint32[0x14] !== 0;
  }
  set textureCompressionETC2(value) {
    this.memoryViewUint32[0x14] = value | 0;
  }
  get textureCompressionASTC_LDR() {
    return this.memoryViewUint32[0x15] !== 0;
  }
  set textureCompressionASTC_LDR(value) {
    this.memoryViewUint32[0x15] = value | 0;
  }
  get textureCompressionBC() {
    return this.memoryViewUint32[0x16] !== 0;
  }
  set textureCompressionBC(value) {
    this.memoryViewUint32[0x16] = value | 0;
  }
  get occlusionQueryPrecise() {
    return this.memoryViewUint32[0x17] !== 0;
  }
  set occlusionQueryPrecise(value) {
    this.memoryViewUint32[0x17] = value | 0;
  }
  get pipelineStatisticsQuery() {
    return this.memoryViewUint32[0x18] !== 0;
  }
  set pipelineStatisticsQuery(value) {
    this.memoryViewUint32[0x18] = value | 0;
  }
  get vertexPipelineStoresAndAtomics() {
    return this.memoryViewUint32[0x19] !== 0;
  }
  set vertexPipelineStoresAndAtomics(value) {
    this.memoryViewUint32[0x19] = value | 0;
  }
  get fragmentStoresAndAtomics() {
    return this.memoryViewUint32[0x1A] !== 0;
  }
  set fragmentStoresAndAtomics(value) {
    this.memoryViewUint32[0x1A] = value | 0;
  }
  get shaderTessellationAndGeometryPointSize() {
    return this.memoryViewUint32[0x1B] !== 0;
  }
  set shaderTessellationAndGeometryPointSize(value) {
    this.memoryViewUint32[0x1B] = value | 0;
  }
  get shaderImageGatherExtended() {
    return this.memoryViewUint32[0x1C] !== 0;
  }
  set shaderImageGatherExtended(value) {
    this.memoryViewUint32[0x1C] = value | 0;
  }
  get shaderStorageImageExtendedFormats() {
    return this.memoryViewUint32[0x1D] !== 0;
  }
  set shaderStorageImageExtendedFormats(value) {
    this.memoryViewUint32[0x1D] = value | 0;
  }
  get shaderStorageImageMultisample() {
    return this.memoryViewUint32[0x1E] !== 0;
  }
  set shaderStorageImageMultisample(value) {
    this.memoryViewUint32[0x1E] = value | 0;
  }
  get shaderStorageImageReadWithoutFormat() {
    return this.memoryViewUint32[0x1F] !== 0;
  }
  set shaderStorageImageReadWithoutFormat(value) {
    this.memoryViewUint32[0x1F] = value | 0;
  }
  get shaderStorageImageWriteWithoutFormat() {
    return this.memoryViewUint32[0x20] !== 0;
  }
  set shaderStorageImageWriteWithoutFormat(value) {
    this.memoryViewUint32[0x20] = value | 0;
  }
  get shaderUniformBufferArrayDynamicIndexing() {
    return this.memoryViewUint32[0x21] !== 0;
  }
  set shaderUniformBufferArrayDynamicIndexing(value) {
    this.memoryViewUint32[0x21] = value | 0;
  }
  get shaderSampledImageArrayDynamicIndexing() {
    return this.memoryViewUint32[0x22] !== 0;
  }
  set shaderSampledImageArrayDynamicIndexing(value) {
    this.memoryViewUint32[0x22] = value | 0;
  }
  get shaderStorageBufferArrayDynamicIndexing() {
    return this.memoryViewUint32[0x23] !== 0;
  }
  set shaderStorageBufferArrayDynamicIndexing(value) {
    this.memoryViewUint32[0x23] = value | 0;
  }
  get shaderStorageImageArrayDynamicIndexing() {
    return this.memoryViewUint32[0x24] !== 0;
  }
  set shaderStorageImageArrayDynamicIndexing(value) {
    this.memoryViewUint32[0x24] = value | 0;
  }
  get shaderClipDistance() {
    return this.memoryViewUint32[0x25] !== 0;
  }
  set shaderClipDistance(value) {
    this.memoryViewUint32[0x25] = value | 0;
  }
  get shaderCullDistance() {
    return this.memoryViewUint32[0x26] !== 0;
  }
  set shaderCullDistance(value) {
    this.memoryViewUint32[0x26] = value | 0;
  }
  get shaderFloat64() {
    return this.memoryViewUint32[0x27] !== 0;
  }
  set shaderFloat64(value) {
    this.memoryViewUint32[0x27] = value | 0;
  }
  get shaderInt64() {
    return this.memoryViewUint32[0x28] !== 0;
  }
  set shaderInt64(value) {
    this.memoryViewUint32[0x28] = value | 0;
  }
  get shaderInt16() {
    return this.memoryViewUint32[0x29] !== 0;
  }
  set shaderInt16(value) {
    this.memoryViewUint32[0x29] = value | 0;
  }
  get shaderResourceResidency() {
    return this.memoryViewUint32[0x2A] !== 0;
  }
  set shaderResourceResidency(value) {
    this.memoryViewUint32[0x2A] = value | 0;
  }
  get shaderResourceMinLod() {
    return this.memoryViewUint32[0x2B] !== 0;
  }
  set shaderResourceMinLod(value) {
    this.memoryViewUint32[0x2B] = value | 0;
  }
  get sparseBinding() {
    return this.memoryViewUint32[0x2C] !== 0;
  }
  set sparseBinding(value) {
    this.memoryViewUint32[0x2C] = value | 0;
  }
  get sparseResidencyBuffer() {
    return this.memoryViewUint32[0x2D] !== 0;
  }
  set sparseResidencyBuffer(value) {
    this.memoryViewUint32[0x2D] = value | 0;
  }
  get sparseResidencyImage2D() {
    return this.memoryViewUint32[0x2E] !== 0;
  }
  set sparseResidencyImage2D(value) {
    this.memoryViewUint32[0x2E] = value | 0;
  }
  get sparseResidencyImage3D() {
    return this.memoryViewUint32[0x2F] !== 0;
  }
  set sparseResidencyImage3D(value) {
    this.memoryViewUint32[0x2F] = value | 0;
  }
  get sparseResidency2Samples() {
    return this.memoryViewUint32[0x30] !== 0;
  }
  set sparseResidency2Samples(value) {
    this.memoryViewUint32[0x30] = value | 0;
  }
  get sparseResidency4Samples() {
    return this.memoryViewUint32[0x31] !== 0;
  }
  set sparseResidency4Samples(value) {
    this.memoryViewUint32[0x31] = value | 0;
  }
  get sparseResidency8Samples() {
    return this.memoryViewUint32[0x32] !== 0;
  }
  set sparseResidency8Samples(value) {
    this.memoryViewUint32[0x32] = value | 0;
  }
  get sparseResidency16Samples() {
    return this.memoryViewUint32[0x33] !== 0;
  }
  set sparseResidency16Samples(value) {
    this.memoryViewUint32[0x33] = value | 0;
  }
  get sparseResidencyAliased() {
    return this.memoryViewUint32[0x34] !== 0;
  }
  set sparseResidencyAliased(value) {
    this.memoryViewUint32[0x34] = value | 0;
  }
  get variableMultisampleRate() {
    return this.memoryViewUint32[0x35] !== 0;
  }
  set variableMultisampleRate(value) {
    this.memoryViewUint32[0x35] = value | 0;
  }
  get inheritedQueries() {
    return this.memoryViewUint32[0x36] !== 0;
  }
  set inheritedQueries(value) {
    this.memoryViewUint32[0x36] = value | 0;
  }
  
};

VkPhysicalDeviceFeatures.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceFeatures.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPhysicalDeviceFeatures.byteLength = 0xDC;

VkPhysicalDeviceFeatures.memoryLayout = Object.freeze({
  robustBufferAccess: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  fullDrawIndexUint32: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  imageCubeArray: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  independentBlend: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  geometryShader: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  tessellationShader: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  sampleRateShading: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  dualSrcBlend: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  logicOp: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  multiDrawIndirect: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  drawIndirectFirstInstance: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  depthClamp: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  depthBiasClamp: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  fillModeNonSolid: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  depthBounds: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  wideLines: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  largePoints: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  alphaToOne: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
  multiViewport: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  samplerAnisotropy: Object.freeze({
    byteOffset: 0x4C,
    byteLength: 0x4
  }),
  textureCompressionETC2: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
  textureCompressionASTC_LDR: Object.freeze({
    byteOffset: 0x54,
    byteLength: 0x4
  }),
  textureCompressionBC: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x4
  }),
  occlusionQueryPrecise: Object.freeze({
    byteOffset: 0x5C,
    byteLength: 0x4
  }),
  pipelineStatisticsQuery: Object.freeze({
    byteOffset: 0x60,
    byteLength: 0x4
  }),
  vertexPipelineStoresAndAtomics: Object.freeze({
    byteOffset: 0x64,
    byteLength: 0x4
  }),
  fragmentStoresAndAtomics: Object.freeze({
    byteOffset: 0x68,
    byteLength: 0x4
  }),
  shaderTessellationAndGeometryPointSize: Object.freeze({
    byteOffset: 0x6C,
    byteLength: 0x4
  }),
  shaderImageGatherExtended: Object.freeze({
    byteOffset: 0x70,
    byteLength: 0x4
  }),
  shaderStorageImageExtendedFormats: Object.freeze({
    byteOffset: 0x74,
    byteLength: 0x4
  }),
  shaderStorageImageMultisample: Object.freeze({
    byteOffset: 0x78,
    byteLength: 0x4
  }),
  shaderStorageImageReadWithoutFormat: Object.freeze({
    byteOffset: 0x7C,
    byteLength: 0x4
  }),
  shaderStorageImageWriteWithoutFormat: Object.freeze({
    byteOffset: 0x80,
    byteLength: 0x4
  }),
  shaderUniformBufferArrayDynamicIndexing: Object.freeze({
    byteOffset: 0x84,
    byteLength: 0x4
  }),
  shaderSampledImageArrayDynamicIndexing: Object.freeze({
    byteOffset: 0x88,
    byteLength: 0x4
  }),
  shaderStorageBufferArrayDynamicIndexing: Object.freeze({
    byteOffset: 0x8C,
    byteLength: 0x4
  }),
  shaderStorageImageArrayDynamicIndexing: Object.freeze({
    byteOffset: 0x90,
    byteLength: 0x4
  }),
  shaderClipDistance: Object.freeze({
    byteOffset: 0x94,
    byteLength: 0x4
  }),
  shaderCullDistance: Object.freeze({
    byteOffset: 0x98,
    byteLength: 0x4
  }),
  shaderFloat64: Object.freeze({
    byteOffset: 0x9C,
    byteLength: 0x4
  }),
  shaderInt64: Object.freeze({
    byteOffset: 0xA0,
    byteLength: 0x4
  }),
  shaderInt16: Object.freeze({
    byteOffset: 0xA4,
    byteLength: 0x4
  }),
  shaderResourceResidency: Object.freeze({
    byteOffset: 0xA8,
    byteLength: 0x4
  }),
  shaderResourceMinLod: Object.freeze({
    byteOffset: 0xAC,
    byteLength: 0x4
  }),
  sparseBinding: Object.freeze({
    byteOffset: 0xB0,
    byteLength: 0x4
  }),
  sparseResidencyBuffer: Object.freeze({
    byteOffset: 0xB4,
    byteLength: 0x4
  }),
  sparseResidencyImage2D: Object.freeze({
    byteOffset: 0xB8,
    byteLength: 0x4
  }),
  sparseResidencyImage3D: Object.freeze({
    byteOffset: 0xBC,
    byteLength: 0x4
  }),
  sparseResidency2Samples: Object.freeze({
    byteOffset: 0xC0,
    byteLength: 0x4
  }),
  sparseResidency4Samples: Object.freeze({
    byteOffset: 0xC4,
    byteLength: 0x4
  }),
  sparseResidency8Samples: Object.freeze({
    byteOffset: 0xC8,
    byteLength: 0x4
  }),
  sparseResidency16Samples: Object.freeze({
    byteOffset: 0xCC,
    byteLength: 0x4
  }),
  sparseResidencyAliased: Object.freeze({
    byteOffset: 0xD0,
    byteLength: 0x4
  }),
  variableMultisampleRate: Object.freeze({
    byteOffset: 0xD4,
    byteLength: 0x4
  }),
  inheritedQueries: Object.freeze({
    byteOffset: 0xD8,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceSparseProperties **/
class VkPhysicalDeviceSparseProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x14);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get residencyStandard2DBlockShape() {
    return this.memoryViewUint32[0x0] !== 0;
  }
  get residencyStandard2DMultisampleBlockShape() {
    return this.memoryViewUint32[0x1] !== 0;
  }
  get residencyStandard3DBlockShape() {
    return this.memoryViewUint32[0x2] !== 0;
  }
  get residencyAlignedMipSize() {
    return this.memoryViewUint32[0x3] !== 0;
  }
  get residencyNonResidentStrict() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  
};

VkPhysicalDeviceSparseProperties.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceSparseProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x14));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x14), 0x0);
};

VkPhysicalDeviceSparseProperties.byteLength = 0x14;

VkPhysicalDeviceSparseProperties.memoryLayout = Object.freeze({
  residencyStandard2DBlockShape: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  residencyStandard2DMultisampleBlockShape: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  residencyStandard3DBlockShape: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  residencyAlignedMipSize: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  residencyNonResidentStrict: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceLimits **/
class VkPhysicalDeviceLimits {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1F8) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x1F8) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1F8) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x1F8) / 0x8);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x1F8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x1F8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    this._maxComputeWorkGroupCount = [...Array(3)].fill(0x0);
    
    this._maxComputeWorkGroupSize = [...Array(3)].fill(0x0);
    
    
    
    
    
    
    
    
    this._maxViewportDimensions = [...Array(2)].fill(0x0);
    this._viewportBoundsRange = [...Array(2)].fill(0x0);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    this._pointSizeRange = [...Array(2)].fill(0x0);
    this._lineWidthRange = [...Array(2)].fill(0x0);
    
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get maxImageDimension1D() {
    return this.memoryViewUint32[0x0];
  }
  get maxImageDimension2D() {
    return this.memoryViewUint32[0x1];
  }
  get maxImageDimension3D() {
    return this.memoryViewUint32[0x2];
  }
  get maxImageDimensionCube() {
    return this.memoryViewUint32[0x3];
  }
  get maxImageArrayLayers() {
    return this.memoryViewUint32[0x4];
  }
  get maxTexelBufferElements() {
    return this.memoryViewUint32[0x5];
  }
  get maxUniformBufferRange() {
    return this.memoryViewUint32[0x6];
  }
  get maxStorageBufferRange() {
    return this.memoryViewUint32[0x7];
  }
  get maxPushConstantsSize() {
    return this.memoryViewUint32[0x8];
  }
  get maxMemoryAllocationCount() {
    return this.memoryViewUint32[0x9];
  }
  get maxSamplerAllocationCount() {
    return this.memoryViewUint32[0xA];
  }
  get bufferImageGranularity() {
    return this.memoryViewBigUint64[0x6];
  }
  get sparseAddressSpaceSize() {
    return this.memoryViewBigUint64[0x7];
  }
  get maxBoundDescriptorSets() {
    return this.memoryViewUint32[0x10];
  }
  get maxPerStageDescriptorSamplers() {
    return this.memoryViewUint32[0x11];
  }
  get maxPerStageDescriptorUniformBuffers() {
    return this.memoryViewUint32[0x12];
  }
  get maxPerStageDescriptorStorageBuffers() {
    return this.memoryViewUint32[0x13];
  }
  get maxPerStageDescriptorSampledImages() {
    return this.memoryViewUint32[0x14];
  }
  get maxPerStageDescriptorStorageImages() {
    return this.memoryViewUint32[0x15];
  }
  get maxPerStageDescriptorInputAttachments() {
    return this.memoryViewUint32[0x16];
  }
  get maxPerStageResources() {
    return this.memoryViewUint32[0x17];
  }
  get maxDescriptorSetSamplers() {
    return this.memoryViewUint32[0x18];
  }
  get maxDescriptorSetUniformBuffers() {
    return this.memoryViewUint32[0x19];
  }
  get maxDescriptorSetUniformBuffersDynamic() {
    return this.memoryViewUint32[0x1A];
  }
  get maxDescriptorSetStorageBuffers() {
    return this.memoryViewUint32[0x1B];
  }
  get maxDescriptorSetStorageBuffersDynamic() {
    return this.memoryViewUint32[0x1C];
  }
  get maxDescriptorSetSampledImages() {
    return this.memoryViewUint32[0x1D];
  }
  get maxDescriptorSetStorageImages() {
    return this.memoryViewUint32[0x1E];
  }
  get maxDescriptorSetInputAttachments() {
    return this.memoryViewUint32[0x1F];
  }
  get maxVertexInputAttributes() {
    return this.memoryViewUint32[0x20];
  }
  get maxVertexInputBindings() {
    return this.memoryViewUint32[0x21];
  }
  get maxVertexInputAttributeOffset() {
    return this.memoryViewUint32[0x22];
  }
  get maxVertexInputBindingStride() {
    return this.memoryViewUint32[0x23];
  }
  get maxVertexOutputComponents() {
    return this.memoryViewUint32[0x24];
  }
  get maxTessellationGenerationLevel() {
    return this.memoryViewUint32[0x25];
  }
  get maxTessellationPatchSize() {
    return this.memoryViewUint32[0x26];
  }
  get maxTessellationControlPerVertexInputComponents() {
    return this.memoryViewUint32[0x27];
  }
  get maxTessellationControlPerVertexOutputComponents() {
    return this.memoryViewUint32[0x28];
  }
  get maxTessellationControlPerPatchOutputComponents() {
    return this.memoryViewUint32[0x29];
  }
  get maxTessellationControlTotalOutputComponents() {
    return this.memoryViewUint32[0x2A];
  }
  get maxTessellationEvaluationInputComponents() {
    return this.memoryViewUint32[0x2B];
  }
  get maxTessellationEvaluationOutputComponents() {
    return this.memoryViewUint32[0x2C];
  }
  get maxGeometryShaderInvocations() {
    return this.memoryViewUint32[0x2D];
  }
  get maxGeometryInputComponents() {
    return this.memoryViewUint32[0x2E];
  }
  get maxGeometryOutputComponents() {
    return this.memoryViewUint32[0x2F];
  }
  get maxGeometryOutputVertices() {
    return this.memoryViewUint32[0x30];
  }
  get maxGeometryTotalOutputComponents() {
    return this.memoryViewUint32[0x31];
  }
  get maxFragmentInputComponents() {
    return this.memoryViewUint32[0x32];
  }
  get maxFragmentOutputAttachments() {
    return this.memoryViewUint32[0x33];
  }
  get maxFragmentDualSrcAttachments() {
    return this.memoryViewUint32[0x34];
  }
  get maxFragmentCombinedOutputResources() {
    return this.memoryViewUint32[0x35];
  }
  get maxComputeSharedMemorySize() {
    return this.memoryViewUint32[0x36];
  }
  get maxComputeWorkGroupCount() {
    return [
      this.memoryViewUint32[0x37],
      this.memoryViewUint32[0x38],
      this.memoryViewUint32[0x39]
    ];
  }
  get maxComputeWorkGroupInvocations() {
    return this.memoryViewUint32[0x3A];
  }
  get maxComputeWorkGroupSize() {
    return [
      this.memoryViewUint32[0x3B],
      this.memoryViewUint32[0x3C],
      this.memoryViewUint32[0x3D]
    ];
  }
  get subPixelPrecisionBits() {
    return this.memoryViewUint32[0x3E];
  }
  get subTexelPrecisionBits() {
    return this.memoryViewUint32[0x3F];
  }
  get mipmapPrecisionBits() {
    return this.memoryViewUint32[0x40];
  }
  get maxDrawIndexedIndexValue() {
    return this.memoryViewUint32[0x41];
  }
  get maxDrawIndirectCount() {
    return this.memoryViewUint32[0x42];
  }
  get maxSamplerLodBias() {
    return this.memoryViewFloat32[0x43];
  }
  get maxSamplerAnisotropy() {
    return this.memoryViewFloat32[0x44];
  }
  get maxViewports() {
    return this.memoryViewUint32[0x45];
  }
  get maxViewportDimensions() {
    return [
      this.memoryViewUint32[0x46],
      this.memoryViewUint32[0x47]
    ];
  }
  get viewportBoundsRange() {
    return [
      this.memoryViewFloat32[0x48],
      this.memoryViewFloat32[0x49]
    ];
  }
  get viewportSubPixelBits() {
    return this.memoryViewUint32[0x4A];
  }
  get minMemoryMapAlignment() {
    return this.memoryViewBigInt64[0x26];
  }
  get minTexelBufferOffsetAlignment() {
    return this.memoryViewBigUint64[0x27];
  }
  get minUniformBufferOffsetAlignment() {
    return this.memoryViewBigUint64[0x28];
  }
  get minStorageBufferOffsetAlignment() {
    return this.memoryViewBigUint64[0x29];
  }
  get minTexelOffset() {
    return this.memoryViewInt32[0x54];
  }
  get maxTexelOffset() {
    return this.memoryViewUint32[0x55];
  }
  get minTexelGatherOffset() {
    return this.memoryViewInt32[0x56];
  }
  get maxTexelGatherOffset() {
    return this.memoryViewUint32[0x57];
  }
  get minInterpolationOffset() {
    return this.memoryViewFloat32[0x58];
  }
  get maxInterpolationOffset() {
    return this.memoryViewFloat32[0x59];
  }
  get subPixelInterpolationOffsetBits() {
    return this.memoryViewUint32[0x5A];
  }
  get maxFramebufferWidth() {
    return this.memoryViewUint32[0x5B];
  }
  get maxFramebufferHeight() {
    return this.memoryViewUint32[0x5C];
  }
  get maxFramebufferLayers() {
    return this.memoryViewUint32[0x5D];
  }
  get framebufferColorSampleCounts() {
    return this.memoryViewInt32[0x5E];
  }
  get framebufferDepthSampleCounts() {
    return this.memoryViewInt32[0x5F];
  }
  get framebufferStencilSampleCounts() {
    return this.memoryViewInt32[0x60];
  }
  get framebufferNoAttachmentsSampleCounts() {
    return this.memoryViewInt32[0x61];
  }
  get maxColorAttachments() {
    return this.memoryViewUint32[0x62];
  }
  get sampledImageColorSampleCounts() {
    return this.memoryViewInt32[0x63];
  }
  get sampledImageIntegerSampleCounts() {
    return this.memoryViewInt32[0x64];
  }
  get sampledImageDepthSampleCounts() {
    return this.memoryViewInt32[0x65];
  }
  get sampledImageStencilSampleCounts() {
    return this.memoryViewInt32[0x66];
  }
  get storageImageSampleCounts() {
    return this.memoryViewInt32[0x67];
  }
  get maxSampleMaskWords() {
    return this.memoryViewUint32[0x68];
  }
  get timestampComputeAndGraphics() {
    return this.memoryViewUint32[0x69] !== 0;
  }
  get timestampPeriod() {
    return this.memoryViewFloat32[0x6A];
  }
  get maxClipDistances() {
    return this.memoryViewUint32[0x6B];
  }
  get maxCullDistances() {
    return this.memoryViewUint32[0x6C];
  }
  get maxCombinedClipAndCullDistances() {
    return this.memoryViewUint32[0x6D];
  }
  get discreteQueuePriorities() {
    return this.memoryViewUint32[0x6E];
  }
  get pointSizeRange() {
    return [
      this.memoryViewFloat32[0x6F],
      this.memoryViewFloat32[0x70]
    ];
  }
  get lineWidthRange() {
    return [
      this.memoryViewFloat32[0x71],
      this.memoryViewFloat32[0x72]
    ];
  }
  get pointSizeGranularity() {
    return this.memoryViewFloat32[0x73];
  }
  get lineWidthGranularity() {
    return this.memoryViewFloat32[0x74];
  }
  get strictLines() {
    return this.memoryViewUint32[0x75] !== 0;
  }
  get standardSampleLocations() {
    return this.memoryViewUint32[0x76] !== 0;
  }
  get optimalBufferCopyOffsetAlignment() {
    return this.memoryViewBigUint64[0x3C];
  }
  get optimalBufferCopyRowPitchAlignment() {
    return this.memoryViewBigUint64[0x3D];
  }
  get nonCoherentAtomSize() {
    return this.memoryViewBigUint64[0x3E];
  }
  
};

VkPhysicalDeviceLimits.prototype.flush = function flush() {
  
  return true;
};

VkPhysicalDeviceLimits.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x1F8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x1F8), 0x0);
  
  
  
  
  
  
  
  
  
  
  
  
};

VkPhysicalDeviceLimits.byteLength = 0x1F8;

VkPhysicalDeviceLimits.memoryLayout = Object.freeze({
  maxImageDimension1D: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  maxImageDimension2D: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  maxImageDimension3D: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  maxImageDimensionCube: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  maxImageArrayLayers: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxTexelBufferElements: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  maxUniformBufferRange: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  maxStorageBufferRange: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  maxPushConstantsSize: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  maxMemoryAllocationCount: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  maxSamplerAllocationCount: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  bufferImageGranularity: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  sparseAddressSpaceSize: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  maxBoundDescriptorSets: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  maxPerStageDescriptorSamplers: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
  maxPerStageDescriptorUniformBuffers: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  maxPerStageDescriptorStorageBuffers: Object.freeze({
    byteOffset: 0x4C,
    byteLength: 0x4
  }),
  maxPerStageDescriptorSampledImages: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
  maxPerStageDescriptorStorageImages: Object.freeze({
    byteOffset: 0x54,
    byteLength: 0x4
  }),
  maxPerStageDescriptorInputAttachments: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x4
  }),
  maxPerStageResources: Object.freeze({
    byteOffset: 0x5C,
    byteLength: 0x4
  }),
  maxDescriptorSetSamplers: Object.freeze({
    byteOffset: 0x60,
    byteLength: 0x4
  }),
  maxDescriptorSetUniformBuffers: Object.freeze({
    byteOffset: 0x64,
    byteLength: 0x4
  }),
  maxDescriptorSetUniformBuffersDynamic: Object.freeze({
    byteOffset: 0x68,
    byteLength: 0x4
  }),
  maxDescriptorSetStorageBuffers: Object.freeze({
    byteOffset: 0x6C,
    byteLength: 0x4
  }),
  maxDescriptorSetStorageBuffersDynamic: Object.freeze({
    byteOffset: 0x70,
    byteLength: 0x4
  }),
  maxDescriptorSetSampledImages: Object.freeze({
    byteOffset: 0x74,
    byteLength: 0x4
  }),
  maxDescriptorSetStorageImages: Object.freeze({
    byteOffset: 0x78,
    byteLength: 0x4
  }),
  maxDescriptorSetInputAttachments: Object.freeze({
    byteOffset: 0x7C,
    byteLength: 0x4
  }),
  maxVertexInputAttributes: Object.freeze({
    byteOffset: 0x80,
    byteLength: 0x4
  }),
  maxVertexInputBindings: Object.freeze({
    byteOffset: 0x84,
    byteLength: 0x4
  }),
  maxVertexInputAttributeOffset: Object.freeze({
    byteOffset: 0x88,
    byteLength: 0x4
  }),
  maxVertexInputBindingStride: Object.freeze({
    byteOffset: 0x8C,
    byteLength: 0x4
  }),
  maxVertexOutputComponents: Object.freeze({
    byteOffset: 0x90,
    byteLength: 0x4
  }),
  maxTessellationGenerationLevel: Object.freeze({
    byteOffset: 0x94,
    byteLength: 0x4
  }),
  maxTessellationPatchSize: Object.freeze({
    byteOffset: 0x98,
    byteLength: 0x4
  }),
  maxTessellationControlPerVertexInputComponents: Object.freeze({
    byteOffset: 0x9C,
    byteLength: 0x4
  }),
  maxTessellationControlPerVertexOutputComponents: Object.freeze({
    byteOffset: 0xA0,
    byteLength: 0x4
  }),
  maxTessellationControlPerPatchOutputComponents: Object.freeze({
    byteOffset: 0xA4,
    byteLength: 0x4
  }),
  maxTessellationControlTotalOutputComponents: Object.freeze({
    byteOffset: 0xA8,
    byteLength: 0x4
  }),
  maxTessellationEvaluationInputComponents: Object.freeze({
    byteOffset: 0xAC,
    byteLength: 0x4
  }),
  maxTessellationEvaluationOutputComponents: Object.freeze({
    byteOffset: 0xB0,
    byteLength: 0x4
  }),
  maxGeometryShaderInvocations: Object.freeze({
    byteOffset: 0xB4,
    byteLength: 0x4
  }),
  maxGeometryInputComponents: Object.freeze({
    byteOffset: 0xB8,
    byteLength: 0x4
  }),
  maxGeometryOutputComponents: Object.freeze({
    byteOffset: 0xBC,
    byteLength: 0x4
  }),
  maxGeometryOutputVertices: Object.freeze({
    byteOffset: 0xC0,
    byteLength: 0x4
  }),
  maxGeometryTotalOutputComponents: Object.freeze({
    byteOffset: 0xC4,
    byteLength: 0x4
  }),
  maxFragmentInputComponents: Object.freeze({
    byteOffset: 0xC8,
    byteLength: 0x4
  }),
  maxFragmentOutputAttachments: Object.freeze({
    byteOffset: 0xCC,
    byteLength: 0x4
  }),
  maxFragmentDualSrcAttachments: Object.freeze({
    byteOffset: 0xD0,
    byteLength: 0x4
  }),
  maxFragmentCombinedOutputResources: Object.freeze({
    byteOffset: 0xD4,
    byteLength: 0x4
  }),
  maxComputeSharedMemorySize: Object.freeze({
    byteOffset: 0xD8,
    byteLength: 0x4
  }),
  maxComputeWorkGroupCount: Object.freeze({
    byteOffset: 0xDC,
    byteLength: 0xC
  }),
  maxComputeWorkGroupInvocations: Object.freeze({
    byteOffset: 0xE8,
    byteLength: 0x4
  }),
  maxComputeWorkGroupSize: Object.freeze({
    byteOffset: 0xEC,
    byteLength: 0xC
  }),
  subPixelPrecisionBits: Object.freeze({
    byteOffset: 0xF8,
    byteLength: 0x4
  }),
  subTexelPrecisionBits: Object.freeze({
    byteOffset: 0xFC,
    byteLength: 0x4
  }),
  mipmapPrecisionBits: Object.freeze({
    byteOffset: 0x100,
    byteLength: 0x4
  }),
  maxDrawIndexedIndexValue: Object.freeze({
    byteOffset: 0x104,
    byteLength: 0x4
  }),
  maxDrawIndirectCount: Object.freeze({
    byteOffset: 0x108,
    byteLength: 0x4
  }),
  maxSamplerLodBias: Object.freeze({
    byteOffset: 0x10C,
    byteLength: 0x4
  }),
  maxSamplerAnisotropy: Object.freeze({
    byteOffset: 0x110,
    byteLength: 0x4
  }),
  maxViewports: Object.freeze({
    byteOffset: 0x114,
    byteLength: 0x4
  }),
  maxViewportDimensions: Object.freeze({
    byteOffset: 0x118,
    byteLength: 0x8
  }),
  viewportBoundsRange: Object.freeze({
    byteOffset: 0x120,
    byteLength: 0x8
  }),
  viewportSubPixelBits: Object.freeze({
    byteOffset: 0x128,
    byteLength: 0x4
  }),
  minMemoryMapAlignment: Object.freeze({
    byteOffset: 0x130,
    byteLength: 0x8
  }),
  minTexelBufferOffsetAlignment: Object.freeze({
    byteOffset: 0x138,
    byteLength: 0x8
  }),
  minUniformBufferOffsetAlignment: Object.freeze({
    byteOffset: 0x140,
    byteLength: 0x8
  }),
  minStorageBufferOffsetAlignment: Object.freeze({
    byteOffset: 0x148,
    byteLength: 0x8
  }),
  minTexelOffset: Object.freeze({
    byteOffset: 0x150,
    byteLength: 0x4
  }),
  maxTexelOffset: Object.freeze({
    byteOffset: 0x154,
    byteLength: 0x4
  }),
  minTexelGatherOffset: Object.freeze({
    byteOffset: 0x158,
    byteLength: 0x4
  }),
  maxTexelGatherOffset: Object.freeze({
    byteOffset: 0x15C,
    byteLength: 0x4
  }),
  minInterpolationOffset: Object.freeze({
    byteOffset: 0x160,
    byteLength: 0x4
  }),
  maxInterpolationOffset: Object.freeze({
    byteOffset: 0x164,
    byteLength: 0x4
  }),
  subPixelInterpolationOffsetBits: Object.freeze({
    byteOffset: 0x168,
    byteLength: 0x4
  }),
  maxFramebufferWidth: Object.freeze({
    byteOffset: 0x16C,
    byteLength: 0x4
  }),
  maxFramebufferHeight: Object.freeze({
    byteOffset: 0x170,
    byteLength: 0x4
  }),
  maxFramebufferLayers: Object.freeze({
    byteOffset: 0x174,
    byteLength: 0x4
  }),
  framebufferColorSampleCounts: Object.freeze({
    byteOffset: 0x178,
    byteLength: 0x4
  }),
  framebufferDepthSampleCounts: Object.freeze({
    byteOffset: 0x17C,
    byteLength: 0x4
  }),
  framebufferStencilSampleCounts: Object.freeze({
    byteOffset: 0x180,
    byteLength: 0x4
  }),
  framebufferNoAttachmentsSampleCounts: Object.freeze({
    byteOffset: 0x184,
    byteLength: 0x4
  }),
  maxColorAttachments: Object.freeze({
    byteOffset: 0x188,
    byteLength: 0x4
  }),
  sampledImageColorSampleCounts: Object.freeze({
    byteOffset: 0x18C,
    byteLength: 0x4
  }),
  sampledImageIntegerSampleCounts: Object.freeze({
    byteOffset: 0x190,
    byteLength: 0x4
  }),
  sampledImageDepthSampleCounts: Object.freeze({
    byteOffset: 0x194,
    byteLength: 0x4
  }),
  sampledImageStencilSampleCounts: Object.freeze({
    byteOffset: 0x198,
    byteLength: 0x4
  }),
  storageImageSampleCounts: Object.freeze({
    byteOffset: 0x19C,
    byteLength: 0x4
  }),
  maxSampleMaskWords: Object.freeze({
    byteOffset: 0x1A0,
    byteLength: 0x4
  }),
  timestampComputeAndGraphics: Object.freeze({
    byteOffset: 0x1A4,
    byteLength: 0x4
  }),
  timestampPeriod: Object.freeze({
    byteOffset: 0x1A8,
    byteLength: 0x4
  }),
  maxClipDistances: Object.freeze({
    byteOffset: 0x1AC,
    byteLength: 0x4
  }),
  maxCullDistances: Object.freeze({
    byteOffset: 0x1B0,
    byteLength: 0x4
  }),
  maxCombinedClipAndCullDistances: Object.freeze({
    byteOffset: 0x1B4,
    byteLength: 0x4
  }),
  discreteQueuePriorities: Object.freeze({
    byteOffset: 0x1B8,
    byteLength: 0x4
  }),
  pointSizeRange: Object.freeze({
    byteOffset: 0x1BC,
    byteLength: 0x8
  }),
  lineWidthRange: Object.freeze({
    byteOffset: 0x1C4,
    byteLength: 0x8
  }),
  pointSizeGranularity: Object.freeze({
    byteOffset: 0x1CC,
    byteLength: 0x4
  }),
  lineWidthGranularity: Object.freeze({
    byteOffset: 0x1D0,
    byteLength: 0x4
  }),
  strictLines: Object.freeze({
    byteOffset: 0x1D4,
    byteLength: 0x4
  }),
  standardSampleLocations: Object.freeze({
    byteOffset: 0x1D8,
    byteLength: 0x4
  }),
  optimalBufferCopyOffsetAlignment: Object.freeze({
    byteOffset: 0x1E0,
    byteLength: 0x8
  }),
  optimalBufferCopyRowPitchAlignment: Object.freeze({
    byteOffset: 0x1E8,
    byteLength: 0x8
  }),
  nonCoherentAtomSize: Object.freeze({
    byteOffset: 0x1F0,
    byteLength: 0x8
  }),
});
/** VkSemaphoreCreateInfo **/
class VkSemaphoreCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BF6C8:
        case 0x3B9BFAB1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkSemaphoreCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSemaphoreCreateInfo.byteLength = 0x18;

VkSemaphoreCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkQueryPoolCreateInfo **/
class VkQueryPoolCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this.sType = 0xB;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.queryType !== void 0) this.queryType = opts.queryType;
      if (opts.queryCount !== void 0) this.queryCount = opts.queryCount;
      if (opts.pipelineStatistics !== void 0) this.pipelineStatistics = opts.pipelineStatistics;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkQueryPoolCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get queryType() {
    return this.memoryViewInt32[0x5];
  }
  set queryType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.queryType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get queryCount() {
    return this.memoryViewUint32[0x6];
  }
  set queryCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.queryCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pipelineStatistics() {
    return this.memoryViewInt32[0x7];
  }
  set pipelineStatistics(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueryPoolCreateInfo.pipelineStatistics': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  
};

VkQueryPoolCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueryPoolCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkQueryPoolCreateInfo.byteLength = 0x20;

VkQueryPoolCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  queryType: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  queryCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pipelineStatistics: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkFramebufferCreateInfo **/
class VkFramebufferCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._renderPass = null;
    
    this._pAttachments = null;
    this._pAttachmentsNative = null;
    
    
    
    this.sType = 0x25;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.renderPass !== void 0) this.renderPass = opts.renderPass;
      if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
      if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
      if (opts.width !== void 0) this.width = opts.width;
      if (opts.height !== void 0) this.height = opts.height;
      if (opts.layers !== void 0) this.layers = opts.layers;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkFramebufferCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get renderPass() {
    return this._renderPass;
  }
  set renderPass(value) {
    if (value !== null && value.constructor === VkRenderPass) {
      
      this._renderPass = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._renderPass = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.renderPass': Expected 'VkRenderPass' but got '" + value.constructor.name + "'");
    }
  }
  get attachmentCount() {
    return this.memoryViewUint32[0x8];
  }
  set attachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.attachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pAttachments() {
    return this._pAttachments;
  }
  set pAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pAttachments': Expected 'Array VkImageView' but got '" + value.constructor.name + "'");
    }
  }
  get width() {
    return this.memoryViewUint32[0xC];
  }
  set width(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.width': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get height() {
    return this.memoryViewUint32[0xD];
  }
  set height(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.height': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xD] = value;
  }
  get layers() {
    return this.memoryViewUint32[0xE];
  }
  set layers(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.layers': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xE] = value;
  }
  
};

VkFramebufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkFramebufferCreateInfo.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkImageView) {
        throw new TypeError("Invalid type for 'VkFramebufferCreateInfo.pAttachments[" + ii + "]': Expected 'VkImageView' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkFramebufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkFramebufferCreateInfo.byteLength = 0x40;

VkFramebufferCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  renderPass: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  attachmentCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pAttachments: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  width: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  height: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  layers: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
});
/** VkDrawIndirectCommand **/
class VkDrawIndirectCommand {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.vertexCount !== void 0) this.vertexCount = opts.vertexCount;
      if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
      if (opts.firstVertex !== void 0) this.firstVertex = opts.firstVertex;
      if (opts.firstInstance !== void 0) this.firstInstance = opts.firstInstance;
      
    }
  }
  get vertexCount() {
    return this.memoryViewUint32[0x0];
  }
  set vertexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndirectCommand.vertexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get instanceCount() {
    return this.memoryViewUint32[0x1];
  }
  set instanceCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndirectCommand.instanceCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get firstVertex() {
    return this.memoryViewUint32[0x2];
  }
  set firstVertex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndirectCommand.firstVertex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get firstInstance() {
    return this.memoryViewUint32[0x3];
  }
  set firstInstance(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndirectCommand.firstInstance': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x3] = value;
  }
  
};

VkDrawIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDrawIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDrawIndirectCommand.byteLength = 0x10;

VkDrawIndirectCommand.memoryLayout = Object.freeze({
  vertexCount: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  instanceCount: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  firstVertex: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  firstInstance: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
});
/** VkDrawIndexedIndirectCommand **/
class VkDrawIndexedIndirectCommand {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x14);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.indexCount !== void 0) this.indexCount = opts.indexCount;
      if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
      if (opts.firstIndex !== void 0) this.firstIndex = opts.firstIndex;
      if (opts.vertexOffset !== void 0) this.vertexOffset = opts.vertexOffset;
      if (opts.firstInstance !== void 0) this.firstInstance = opts.firstInstance;
      
    }
  }
  get indexCount() {
    return this.memoryViewUint32[0x0];
  }
  set indexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.indexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get instanceCount() {
    return this.memoryViewUint32[0x1];
  }
  set instanceCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.instanceCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get firstIndex() {
    return this.memoryViewUint32[0x2];
  }
  set firstIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.firstIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get vertexOffset() {
    return this.memoryViewInt32[0x3];
  }
  set vertexOffset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.vertexOffset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  get firstInstance() {
    return this.memoryViewUint32[0x4];
  }
  set firstInstance(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawIndexedIndirectCommand.firstInstance': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  
};

VkDrawIndexedIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDrawIndexedIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDrawIndexedIndirectCommand.byteLength = 0x14;

VkDrawIndexedIndirectCommand.memoryLayout = Object.freeze({
  indexCount: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  instanceCount: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  firstIndex: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  vertexOffset: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  firstInstance: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDispatchIndirectCommand **/
class VkDispatchIndirectCommand {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.x !== void 0) this.x = opts.x;
      if (opts.y !== void 0) this.y = opts.y;
      if (opts.z !== void 0) this.z = opts.z;
      
    }
  }
  get x() {
    return this.memoryViewUint32[0x0];
  }
  set x(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDispatchIndirectCommand.x': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get y() {
    return this.memoryViewUint32[0x1];
  }
  set y(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDispatchIndirectCommand.y': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get z() {
    return this.memoryViewUint32[0x2];
  }
  set z(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDispatchIndirectCommand.z': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  
};

VkDispatchIndirectCommand.prototype.flush = function flush() {
  
  return true;
};

VkDispatchIndirectCommand.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDispatchIndirectCommand.byteLength = 0xC;

VkDispatchIndirectCommand.memoryLayout = Object.freeze({
  x: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  y: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  z: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkSubmitInfo **/
class VkSubmitInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
    this._pWaitDstStageMask = null;
    
    this._pCommandBuffers = null;
    this._pCommandBuffersNative = null;
    
    this._pSignalSemaphores = null;
    this._pSignalSemaphoresNative = null;
    this.sType = 0x4;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
      if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
      if (opts.pWaitDstStageMask !== void 0) this.pWaitDstStageMask = opts.pWaitDstStageMask;
      if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
      if (opts.pCommandBuffers !== void 0) this.pCommandBuffers = opts.pCommandBuffers;
      if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
      if (opts.pSignalSemaphores !== void 0) this.pSignalSemaphores = opts.pSignalSemaphores;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubmitInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BAC90:
        case 0x3B9BEEF8:
        case 0x3B9BFAB2:
        case 0x3B9BB465:
        case VkStructureType.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pNext'");
    }
  }
  get waitSemaphoreCount() {
    return this.memoryViewUint32[0x4];
  }
  set waitSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubmitInfo.waitSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pWaitSemaphores() {
    return this._pWaitSemaphores;
  }
  set pWaitSemaphores(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + value.constructor.name + "'");
    }
  }
  get pWaitDstStageMask() {
    return this._pWaitDstStageMask;
  }
  set pWaitDstStageMask(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pWaitDstStageMask = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pWaitDstStageMask = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitDstStageMask': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  get commandBufferCount() {
    return this.memoryViewUint32[0xA];
  }
  set commandBufferCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubmitInfo.commandBufferCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xA] = value;
  }
  get pCommandBuffers() {
    return this._pCommandBuffers;
  }
  set pCommandBuffers(value) {
    if (value !== null && value.constructor === Array) {
      this._pCommandBuffers = value;
    } else if (value === null) {
      this._pCommandBuffers = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pCommandBuffers': Expected 'Array VkCommandBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get signalSemaphoreCount() {
    return this.memoryViewUint32[0xE];
  }
  set signalSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubmitInfo.signalSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xE] = value;
  }
  get pSignalSemaphores() {
    return this._pSignalSemaphores;
  }
  set pSignalSemaphores(value) {
    if (value !== null && value.constructor === Array) {
      this._pSignalSemaphores = value;
    } else if (value === null) {
      this._pSignalSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubmitInfo.pSignalSemaphores': Expected 'Array VkSemaphore' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkSubmitInfo.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSemaphore) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pWaitSemaphoresNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pCommandBuffers !== null) {
    let array = this._pCommandBuffers;
    if (array.length !== this.commandBufferCount) {
      throw new RangeError("Invalid array length, expected length of 'commandBufferCount' for 'VkSubmitInfo.pCommandBuffers'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkCommandBuffer) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pCommandBuffers[" + ii + "]': Expected 'VkCommandBuffer' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pCommandBuffersNative = nativeArray;
    this.memoryViewBigInt64[0x6] = nativeArray.address;
  }
  
  
  if (this._pSignalSemaphores !== null) {
    let array = this._pSignalSemaphores;
    if (array.length !== this.signalSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'signalSemaphoreCount' for 'VkSubmitInfo.pSignalSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSemaphore) {
        throw new TypeError("Invalid type for 'VkSubmitInfo.pSignalSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSignalSemaphoresNative = nativeArray;
    this.memoryViewBigInt64[0x8] = nativeArray.address;
  }
  
  return true;
};

VkSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkSubmitInfo.byteLength = 0x48;

VkSubmitInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  waitSemaphoreCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pWaitSemaphores: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pWaitDstStageMask: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  commandBufferCount: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  pCommandBuffers: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  signalSemaphoreCount: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  pSignalSemaphores: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x8
  }),
});
/** VkDisplayPropertiesKHR **/
class VkDisplayPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._display = null;
    this._displayName = null;
    this._physicalDimensions = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this._physicalResolution = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get display() {
    return this._display;
  }
  get displayName() {
    if (this._displayName !== null) {
      let str = textDecoder.decode(this._displayName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  get physicalDimensions() {
    return this._physicalDimensions;
  }
  get physicalResolution() {
    return this._physicalResolution;
  }
  get supportedTransforms() {
    return this.memoryViewInt32[0x8];
  }
  get planeReorderPossible() {
    return this.memoryViewUint32[0x9] !== 0;
  }
  get persistentContent() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  
};

VkDisplayPropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
  
  
};

VkDisplayPropertiesKHR.byteLength = 0x30;

VkDisplayPropertiesKHR.memoryLayout = Object.freeze({
  display: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  displayName: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  physicalDimensions: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  physicalResolution: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  supportedTransforms: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  planeReorderPossible: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  persistentContent: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
});
/** VkDisplayPlanePropertiesKHR **/
class VkDisplayPlanePropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._currentDisplay = null;
    
    
    if (typeof opts === "object") {
      
    }
  }
  get currentDisplay() {
    return this._currentDisplay;
  }
  get currentStackIndex() {
    return this.memoryViewUint32[0x2];
  }
  
};

VkDisplayPlanePropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPlanePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x10));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x10), 0x0);
};

VkDisplayPlanePropertiesKHR.byteLength = 0x10;

VkDisplayPlanePropertiesKHR.memoryLayout = Object.freeze({
  currentDisplay: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  currentStackIndex: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkDisplayModeParametersKHR **/
class VkDisplayModeParametersKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._visibleRegion = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    
    
    if (typeof opts === "object") {
      if (opts.visibleRegion !== void 0) this.visibleRegion = opts.visibleRegion;
      if (opts.refreshRate !== void 0) this.refreshRate = opts.refreshRate;
      
    }
  }
  get visibleRegion() {
    return this._visibleRegion;
  }
  set visibleRegion(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._visibleRegion = value;
      
      
    } else if (value === null) {
      this._visibleRegion = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayModeParametersKHR.visibleRegion': Expected 'VkExtent2D' but got '" + value.constructor.name + "'");
    }
  }
  get refreshRate() {
    return this.memoryViewUint32[0x2];
  }
  set refreshRate(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayModeParametersKHR.refreshRate': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  
};

VkDisplayModeParametersKHR.prototype.flush = function flush() {
  
  
  if (this._visibleRegion !== null) {
    this._visibleRegion.flush();
    if (this.memoryBuffer !== this._visibleRegion.memoryBuffer) {
      let srcView = new Uint8Array(this._visibleRegion.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  return true;
};

VkDisplayModeParametersKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDisplayModeParametersKHR.byteLength = 0xC;

VkDisplayModeParametersKHR.memoryLayout = Object.freeze({
  visibleRegion: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  refreshRate: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkDisplayModePropertiesKHR **/
class VkDisplayModePropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);

    }
    this._displayMode = null;
    this._parameters = new VkDisplayModeParametersKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x8 });
    
    if (typeof opts === "object") {
      
    }
  }
  get displayMode() {
    return this._displayMode;
  }
  get parameters() {
    return this._parameters;
  }
  
};

VkDisplayModePropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayModePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDisplayModePropertiesKHR.byteLength = 0x18;

VkDisplayModePropertiesKHR.memoryLayout = Object.freeze({
  displayMode: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  parameters: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0xC
  }),
});
/** VkDisplayModeCreateInfoKHR **/
class VkDisplayModeCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._parameters = new VkDisplayModeParametersKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x14 });
    this.sType = 0x3B9AD1D0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.parameters !== void 0) this.parameters = opts.parameters;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayModeCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayModeCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayModeCreateInfoKHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get parameters() {
    return this._parameters;
  }
  set parameters(value) {
    if (value !== null && value.constructor === VkDisplayModeParametersKHR) {
      value.flush();
      this._parameters = value;
      
      
    } else if (value === null) {
      this._parameters = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayModeCreateInfoKHR.parameters': Expected 'VkDisplayModeParametersKHR' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDisplayModeCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._parameters !== null) {
    this._parameters.flush();
    if (this.memoryBuffer !== this._parameters.memoryBuffer) {
      let srcView = new Uint8Array(this._parameters.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x14);
    }
  }
  
  return true;
};

VkDisplayModeCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDisplayModeCreateInfoKHR.byteLength = 0x20;

VkDisplayModeCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  parameters: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0xC
  }),
});
/** VkDisplayPlaneCapabilitiesKHR **/
class VkDisplayPlaneCapabilitiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x44) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x44);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    this._minSrcPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x4 });
    this._maxSrcPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0xC });
    this._minSrcExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x14 });
    this._maxSrcExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x1C });
    this._minDstPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x24 });
    this._maxDstPosition = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x2C });
    this._minDstExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x34 });
    this._maxDstExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x3C });
    
    if (typeof opts === "object") {
      
    }
  }
  get supportedAlpha() {
    return this.memoryViewInt32[0x0];
  }
  get minSrcPosition() {
    return this._minSrcPosition;
  }
  get maxSrcPosition() {
    return this._maxSrcPosition;
  }
  get minSrcExtent() {
    return this._minSrcExtent;
  }
  get maxSrcExtent() {
    return this._maxSrcExtent;
  }
  get minDstPosition() {
    return this._minDstPosition;
  }
  get maxDstPosition() {
    return this._maxDstPosition;
  }
  get minDstExtent() {
    return this._minDstExtent;
  }
  get maxDstExtent() {
    return this._maxDstExtent;
  }
  
};

VkDisplayPlaneCapabilitiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkDisplayPlaneCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x44));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x44), 0x0);
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
};

VkDisplayPlaneCapabilitiesKHR.byteLength = 0x44;

VkDisplayPlaneCapabilitiesKHR.memoryLayout = Object.freeze({
  supportedAlpha: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  minSrcPosition: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x8
  }),
  maxSrcPosition: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x8
  }),
  minSrcExtent: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x8
  }),
  maxSrcExtent: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x8
  }),
  minDstPosition: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x8
  }),
  maxDstPosition: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x8
  }),
  minDstExtent: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x8
  }),
  maxDstExtent: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x8
  }),
});
/** VkDisplaySurfaceCreateInfoKHR **/
class VkDisplaySurfaceCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._displayMode = null;
    
    
    
    
    
    this._imageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x34 });
    this.sType = 0x3B9AD1D1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.displayMode !== void 0) this.displayMode = opts.displayMode;
      if (opts.planeIndex !== void 0) this.planeIndex = opts.planeIndex;
      if (opts.planeStackIndex !== void 0) this.planeStackIndex = opts.planeStackIndex;
      if (opts.transform !== void 0) this.transform = opts.transform;
      if (opts.globalAlpha !== void 0) this.globalAlpha = opts.globalAlpha;
      if (opts.alphaMode !== void 0) this.alphaMode = opts.alphaMode;
      if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplaySurfaceCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get displayMode() {
    return this._displayMode;
  }
  set displayMode(value) {
    if (value !== null && value.constructor === VkDisplayModeKHR) {
      
      this._displayMode = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._displayMode = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.displayMode': Expected 'VkDisplayModeKHR' but got '" + value.constructor.name + "'");
    }
  }
  get planeIndex() {
    return this.memoryViewUint32[0x8];
  }
  set planeIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.planeIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get planeStackIndex() {
    return this.memoryViewUint32[0x9];
  }
  set planeStackIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.planeStackIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x9] = value;
  }
  get transform() {
    return this.memoryViewInt32[0xA];
  }
  set transform(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.transform': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xA] = value;
  }
  get globalAlpha() {
    return this.memoryViewFloat32[0xB];
  }
  set globalAlpha(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.globalAlpha': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xB] = value;
  }
  get alphaMode() {
    return this.memoryViewInt32[0xC];
  }
  set alphaMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.alphaMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  get imageExtent() {
    return this._imageExtent;
  }
  set imageExtent(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplaySurfaceCreateInfoKHR.imageExtent': Expected 'VkExtent2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDisplaySurfaceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._imageExtent !== null) {
    this._imageExtent.flush();
    if (this.memoryBuffer !== this._imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(this._imageExtent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x34);
    }
  }
  
  return true;
};

VkDisplaySurfaceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDisplaySurfaceCreateInfoKHR.byteLength = 0x40;

VkDisplaySurfaceCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  displayMode: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  planeIndex: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  planeStackIndex: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  transform: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  globalAlpha: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  alphaMode: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  imageExtent: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x8
  }),
});
/** VkDisplayPresentInfoKHR **/
class VkDisplayPresentInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._srcRect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this._dstRect = new VkRect2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x20 });
    
    this.sType = 0x3B9AD5B8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.srcRect !== void 0) this.srcRect = opts.srcRect;
      if (opts.dstRect !== void 0) this.dstRect = opts.dstRect;
      if (opts.persistent !== void 0) this.persistent = opts.persistent;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPresentInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayPresentInfoKHR.pNext' isn't allowed to be filled");
  }
  get srcRect() {
    return this._srcRect;
  }
  set srcRect(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._srcRect = value;
      
      
    } else if (value === null) {
      this._srcRect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPresentInfoKHR.srcRect': Expected 'VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  get dstRect() {
    return this._dstRect;
  }
  set dstRect(value) {
    if (value !== null && value.constructor === VkRect2D) {
      value.flush();
      this._dstRect = value;
      
      
    } else if (value === null) {
      this._dstRect = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPresentInfoKHR.dstRect': Expected 'VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  get persistent() {
    return this.memoryViewUint32[0xC] !== 0;
  }
  set persistent(value) {
    this.memoryViewUint32[0xC] = value | 0;
  }
  
};

VkDisplayPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._srcRect !== null) {
    this._srcRect.flush();
    if (this.memoryBuffer !== this._srcRect.memoryBuffer) {
      let srcView = new Uint8Array(this._srcRect.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
    }
  }
  
  
  if (this._dstRect !== null) {
    this._dstRect.flush();
    if (this.memoryBuffer !== this._dstRect.memoryBuffer) {
      let srcView = new Uint8Array(this._dstRect.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x20);
    }
  }
  
  return true;
};

VkDisplayPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkDisplayPresentInfoKHR.byteLength = 0x38;

VkDisplayPresentInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  srcRect: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x10
  }),
  dstRect: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x10
  }),
  persistent: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
});
/** VkSurfaceCapabilitiesKHR **/
class VkSurfaceCapabilitiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x34) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x34) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x34);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    this._currentExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x8 });
    this._minImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this._maxImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get minImageCount() {
    return this.memoryViewUint32[0x0];
  }
  get maxImageCount() {
    return this.memoryViewUint32[0x1];
  }
  get currentExtent() {
    return this._currentExtent;
  }
  get minImageExtent() {
    return this._minImageExtent;
  }
  get maxImageExtent() {
    return this._maxImageExtent;
  }
  get maxImageArrayLayers() {
    return this.memoryViewUint32[0x8];
  }
  get supportedTransforms() {
    return this.memoryViewInt32[0x9];
  }
  get currentTransform() {
    return this.memoryViewInt32[0xA];
  }
  get supportedCompositeAlpha() {
    return this.memoryViewInt32[0xB];
  }
  get supportedUsageFlags() {
    return this.memoryViewInt32[0xC];
  }
  
};

VkSurfaceCapabilitiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkSurfaceCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x34));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x34), 0x0);
  
  
  
  
  
  
};

VkSurfaceCapabilitiesKHR.byteLength = 0x34;

VkSurfaceCapabilitiesKHR.memoryLayout = Object.freeze({
  minImageCount: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  maxImageCount: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  currentExtent: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  minImageExtent: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  maxImageExtent: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  maxImageArrayLayers: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  supportedTransforms: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  currentTransform: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  supportedCompositeAlpha: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  supportedUsageFlags: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
});
/** VkSurfaceFormatKHR **/
class VkSurfaceFormatKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get format() {
    return this.memoryViewInt32[0x0];
  }
  get colorSpace() {
    return this.memoryViewInt32[0x1];
  }
  
};

VkSurfaceFormatKHR.prototype.flush = function flush() {
  
  return true;
};

VkSurfaceFormatKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x8), 0x0);
};

VkSurfaceFormatKHR.byteLength = 0x8;

VkSurfaceFormatKHR.memoryLayout = Object.freeze({
  format: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  colorSpace: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkSwapchainCreateInfoKHR **/
class VkSwapchainCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x68) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x68) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x68);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._surface = null;
    
    
    
    this._imageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x2C });
    
    
    
    
    this._pQueueFamilyIndices = null;
    
    
    
    
    this._oldSwapchain = null;
    this.sType = 0x3B9ACDE8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.surface !== void 0) this.surface = opts.surface;
      if (opts.minImageCount !== void 0) this.minImageCount = opts.minImageCount;
      if (opts.imageFormat !== void 0) this.imageFormat = opts.imageFormat;
      if (opts.imageColorSpace !== void 0) this.imageColorSpace = opts.imageColorSpace;
      if (opts.imageExtent !== void 0) this.imageExtent = opts.imageExtent;
      if (opts.imageArrayLayers !== void 0) this.imageArrayLayers = opts.imageArrayLayers;
      if (opts.imageUsage !== void 0) this.imageUsage = opts.imageUsage;
      if (opts.imageSharingMode !== void 0) this.imageSharingMode = opts.imageSharingMode;
      if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
      if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
      if (opts.preTransform !== void 0) this.preTransform = opts.preTransform;
      if (opts.compositeAlpha !== void 0) this.compositeAlpha = opts.compositeAlpha;
      if (opts.presentMode !== void 0) this.presentMode = opts.presentMode;
      if (opts.clipped !== void 0) this.clipped = opts.clipped;
      if (opts.oldSwapchain !== void 0) this.oldSwapchain = opts.oldSwapchain;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9C2D7B:
        case 0x3B9BB46C:
        case 0x3B9D0838:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get surface() {
    return this._surface;
  }
  set surface(value) {
    if (value !== null && value.constructor === VkSurfaceKHR) {
      
      this._surface = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._surface = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.surface': Expected 'VkSurfaceKHR' but got '" + value.constructor.name + "'");
    }
  }
  get minImageCount() {
    return this.memoryViewUint32[0x8];
  }
  set minImageCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.minImageCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get imageFormat() {
    return this.memoryViewInt32[0x9];
  }
  set imageFormat(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageFormat': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get imageColorSpace() {
    return this.memoryViewInt32[0xA];
  }
  set imageColorSpace(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageColorSpace': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xA] = value;
  }
  get imageExtent() {
    return this._imageExtent;
  }
  set imageExtent(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._imageExtent = value;
      
      
    } else if (value === null) {
      this._imageExtent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageExtent': Expected 'VkExtent2D' but got '" + value.constructor.name + "'");
    }
  }
  get imageArrayLayers() {
    return this.memoryViewUint32[0xD];
  }
  set imageArrayLayers(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageArrayLayers': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xD] = value;
  }
  get imageUsage() {
    return this.memoryViewInt32[0xE];
  }
  set imageUsage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageUsage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xE] = value;
  }
  get imageSharingMode() {
    return this.memoryViewInt32[0xF];
  }
  set imageSharingMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.imageSharingMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xF] = value;
  }
  get queueFamilyIndexCount() {
    return this.memoryViewUint32[0x10];
  }
  set queueFamilyIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.queueFamilyIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x10] = value;
  }
  get pQueueFamilyIndices() {
    return this._pQueueFamilyIndices;
  }
  set pQueueFamilyIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryViewBigInt64[0x9] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get preTransform() {
    return this.memoryViewInt32[0x14];
  }
  set preTransform(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.preTransform': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x14] = value;
  }
  get compositeAlpha() {
    return this.memoryViewInt32[0x15];
  }
  set compositeAlpha(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.compositeAlpha': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x15] = value;
  }
  get presentMode() {
    return this.memoryViewInt32[0x16];
  }
  set presentMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.presentMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x16] = value;
  }
  get clipped() {
    return this.memoryViewUint32[0x17] !== 0;
  }
  set clipped(value) {
    this.memoryViewUint32[0x17] = value | 0;
  }
  get oldSwapchain() {
    return this._oldSwapchain;
  }
  set oldSwapchain(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._oldSwapchain = value;
      
      this.memoryViewBigInt64[0xC] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._oldSwapchain = null;
      this.memoryViewBigInt64[0xC] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSwapchainCreateInfoKHR.oldSwapchain': Expected 'VkSwapchainKHR' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._imageExtent !== null) {
    this._imageExtent.flush();
    if (this.memoryBuffer !== this._imageExtent.memoryBuffer) {
      let srcView = new Uint8Array(this._imageExtent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x2C);
    }
  }
  
  return true;
};

VkSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkSwapchainCreateInfoKHR.byteLength = 0x68;

VkSwapchainCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  surface: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  minImageCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  imageFormat: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  imageColorSpace: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  imageExtent: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x8
  }),
  imageArrayLayers: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  imageUsage: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  imageSharingMode: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  queueFamilyIndexCount: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  pQueueFamilyIndices: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x8
  }),
  preTransform: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
  compositeAlpha: Object.freeze({
    byteOffset: 0x54,
    byteLength: 0x4
  }),
  presentMode: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x4
  }),
  clipped: Object.freeze({
    byteOffset: 0x5C,
    byteLength: 0x4
  }),
  oldSwapchain: Object.freeze({
    byteOffset: 0x60,
    byteLength: 0x8
  }),
});
/** VkPresentInfoKHR **/
class VkPresentInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pWaitSemaphores = null;
    this._pWaitSemaphoresNative = null;
    
    this._pSwapchains = null;
    this._pSwapchainsNative = null;
    this._pImageIndices = null;
    this._pResults = null;
    this.sType = 0x3B9ACDE9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
      if (opts.pWaitSemaphores !== void 0) this.pWaitSemaphores = opts.pWaitSemaphores;
      if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
      if (opts.pSwapchains !== void 0) this.pSwapchains = opts.pSwapchains;
      if (opts.pImageIndices !== void 0) this.pImageIndices = opts.pImageIndices;
      if (opts.pResults !== void 0) this.pResults = opts.pResults;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9AD5B8:
        case 0x3B9C1220:
        case 0x3B9BB46B:
        case 0x3B9C3160:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pNext'");
    }
  }
  get waitSemaphoreCount() {
    return this.memoryViewUint32[0x4];
  }
  set waitSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.waitSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pWaitSemaphores() {
    return this._pWaitSemaphores;
  }
  set pWaitSemaphores(value) {
    if (value !== null && value.constructor === Array) {
      this._pWaitSemaphores = value;
    } else if (value === null) {
      this._pWaitSemaphores = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pWaitSemaphores': Expected 'Array VkSemaphore' but got '" + value.constructor.name + "'");
    }
  }
  get swapchainCount() {
    return this.memoryViewUint32[0x8];
  }
  set swapchainCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.swapchainCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pSwapchains() {
    return this._pSwapchains;
  }
  set pSwapchains(value) {
    if (value !== null && value.constructor === Array) {
      this._pSwapchains = value;
    } else if (value === null) {
      this._pSwapchains = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pSwapchains': Expected 'Array VkSwapchainKHR' but got '" + value.constructor.name + "'");
    }
  }
  get pImageIndices() {
    return this._pImageIndices;
  }
  set pImageIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pImageIndices = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pImageIndices = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pImageIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get pResults() {
    return this._pResults;
  }
  set pResults(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pResults = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pResults = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPresentInfoKHR.pResults': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pWaitSemaphores !== null) {
    let array = this._pWaitSemaphores;
    if (array.length !== this.waitSemaphoreCount) {
      throw new RangeError("Invalid array length, expected length of 'waitSemaphoreCount' for 'VkPresentInfoKHR.pWaitSemaphores'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSemaphore) {
        throw new TypeError("Invalid type for 'VkPresentInfoKHR.pWaitSemaphores[" + ii + "]': Expected 'VkSemaphore' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pWaitSemaphoresNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pSwapchains !== null) {
    let array = this._pSwapchains;
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentInfoKHR.pSwapchains'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSwapchainKHR) {
        throw new TypeError("Invalid type for 'VkPresentInfoKHR.pSwapchains[" + ii + "]': Expected 'VkSwapchainKHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSwapchainsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkPresentInfoKHR.byteLength = 0x40;

VkPresentInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  waitSemaphoreCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pWaitSemaphores: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  swapchainCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pSwapchains: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  pImageIndices: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  pResults: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkDebugReportCallbackCreateInfoEXT **/
class VkDebugReportCallbackCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pUserData = null;
    this.sType = 0x3B9AF4F8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugReportCallbackCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get pUserData() {
    return this._pUserData;
  }
  set pUserData(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugReportCallbackCreateInfoEXT.pUserData': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugReportCallbackCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugReportCallbackCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugReportCallbackCreateInfoEXT.byteLength = 0x28;

VkDebugReportCallbackCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pUserData: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkValidationFlagsEXT **/
class VkValidationFlagsEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDisabledValidationChecks = null;
    this.sType = 0x3B9BB848;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.disabledValidationCheckCount !== void 0) this.disabledValidationCheckCount = opts.disabledValidationCheckCount;
      if (opts.pDisabledValidationChecks !== void 0) this.pDisabledValidationChecks = opts.pDisabledValidationChecks;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFlagsEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkValidationFlagsEXT.pNext' isn't allowed to be filled");
  }
  get disabledValidationCheckCount() {
    return this.memoryViewUint32[0x4];
  }
  set disabledValidationCheckCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFlagsEXT.disabledValidationCheckCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pDisabledValidationChecks() {
    return this._pDisabledValidationChecks;
  }
  set pDisabledValidationChecks(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDisabledValidationChecks = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDisabledValidationChecks = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkValidationFlagsEXT.pDisabledValidationChecks': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkValidationFlagsEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationFlagsEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkValidationFlagsEXT.byteLength = 0x20;

VkValidationFlagsEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  disabledValidationCheckCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDisabledValidationChecks: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkValidationFeaturesEXT **/
class VkValidationFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pEnabledValidationFeatures = null;
    
    this._pDisabledValidationFeatures = null;
    this.sType = 0x3B9E8ED8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.enabledValidationFeatureCount !== void 0) this.enabledValidationFeatureCount = opts.enabledValidationFeatureCount;
      if (opts.pEnabledValidationFeatures !== void 0) this.pEnabledValidationFeatures = opts.pEnabledValidationFeatures;
      if (opts.disabledValidationFeatureCount !== void 0) this.disabledValidationFeatureCount = opts.disabledValidationFeatureCount;
      if (opts.pDisabledValidationFeatures !== void 0) this.pDisabledValidationFeatures = opts.pDisabledValidationFeatures;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkValidationFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get enabledValidationFeatureCount() {
    return this.memoryViewUint32[0x4];
  }
  set enabledValidationFeatureCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.enabledValidationFeatureCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pEnabledValidationFeatures() {
    return this._pEnabledValidationFeatures;
  }
  set pEnabledValidationFeatures(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pEnabledValidationFeatures = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pEnabledValidationFeatures = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.pEnabledValidationFeatures': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  get disabledValidationFeatureCount() {
    return this.memoryViewUint32[0x8];
  }
  set disabledValidationFeatureCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.disabledValidationFeatureCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pDisabledValidationFeatures() {
    return this._pDisabledValidationFeatures;
  }
  set pDisabledValidationFeatures(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pDisabledValidationFeatures = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDisabledValidationFeatures = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkValidationFeaturesEXT.pDisabledValidationFeatures': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkValidationFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkValidationFeaturesEXT.byteLength = 0x30;

VkValidationFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  enabledValidationFeatureCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pEnabledValidationFeatures: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  disabledValidationFeatureCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pDisabledValidationFeatures: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkPipelineRasterizationStateRasterizationOrderAMD **/
class VkPipelineRasterizationStateRasterizationOrderAMD {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9B1050;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.rasterizationOrder !== void 0) this.rasterizationOrder = opts.rasterizationOrder;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateRasterizationOrderAMD.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineRasterizationStateRasterizationOrderAMD.pNext' isn't allowed to be filled");
  }
  get rasterizationOrder() {
    return this.memoryViewInt32[0x4];
  }
  set rasterizationOrder(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateRasterizationOrderAMD.rasterizationOrder': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPipelineRasterizationStateRasterizationOrderAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateRasterizationOrderAMD.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationStateRasterizationOrderAMD.byteLength = 0x18;

VkPipelineRasterizationStateRasterizationOrderAMD.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  rasterizationOrder: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDebugMarkerObjectNameInfoEXT **/
class VkDebugMarkerObjectNameInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pObjectName = null;
    this.sType = 0x3B9B1FF0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.objectType !== void 0) this.objectType = opts.objectType;
      if (opts.object !== void 0) this.object = opts.object;
      if (opts.pObjectName !== void 0) this.pObjectName = opts.pObjectName;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectNameInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugMarkerObjectNameInfoEXT.pNext' isn't allowed to be filled");
  }
  get objectType() {
    return this.memoryViewInt32[0x4];
  }
  set objectType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectNameInfoEXT.objectType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get object() {
    return this.memoryViewBigUint64[0x3];
  }
  set object(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectNameInfoEXT.object': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get pObjectName() {
    if (this._pObjectName !== null) {
      let str = textDecoder.decode(this._pObjectName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pObjectName(value) {
    if (value !== null && value.constructor === String) {
      this._pObjectName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._pObjectName);
    } else if (value === null) {
      this._pObjectName = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectNameInfoEXT.pObjectName': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugMarkerObjectNameInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugMarkerObjectNameInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugMarkerObjectNameInfoEXT.byteLength = 0x28;

VkDebugMarkerObjectNameInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  objectType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  object: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pObjectName: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkDebugMarkerObjectTagInfoEXT **/
class VkDebugMarkerObjectTagInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this._pTag = null;
    this.sType = 0x3B9B1FF1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.objectType !== void 0) this.objectType = opts.objectType;
      if (opts.object !== void 0) this.object = opts.object;
      if (opts.tagName !== void 0) this.tagName = opts.tagName;
      if (opts.tagSize !== void 0) this.tagSize = opts.tagSize;
      if (opts.pTag !== void 0) this.pTag = opts.pTag;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugMarkerObjectTagInfoEXT.pNext' isn't allowed to be filled");
  }
  get objectType() {
    return this.memoryViewInt32[0x4];
  }
  set objectType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.objectType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get object() {
    return this.memoryViewBigUint64[0x3];
  }
  set object(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.object': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get tagName() {
    return this.memoryViewBigUint64[0x4];
  }
  set tagName(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.tagName': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  get tagSize() {
    return this.memoryViewBigInt64[0x5];
  }
  set tagSize(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.tagSize': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x5] = value;
  }
  get pTag() {
    return this._pTag;
  }
  set pTag(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pTag = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pTag = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerObjectTagInfoEXT.pTag': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugMarkerObjectTagInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugMarkerObjectTagInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugMarkerObjectTagInfoEXT.byteLength = 0x38;

VkDebugMarkerObjectTagInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  objectType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  object: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  tagName: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  tagSize: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  pTag: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
});
/** VkDebugMarkerMarkerInfoEXT **/
class VkDebugMarkerMarkerInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._pMarkerName = null;
    this._color = [...Array(4)].fill(0x0);
    this.sType = 0x3B9B1FF2;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.pMarkerName !== void 0) this.pMarkerName = opts.pMarkerName;
      if (opts.color !== void 0) this.color = opts.color;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugMarkerMarkerInfoEXT.pNext' isn't allowed to be filled");
  }
  get pMarkerName() {
    if (this._pMarkerName !== null) {
      let str = textDecoder.decode(this._pMarkerName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pMarkerName(value) {
    if (value !== null && value.constructor === String) {
      this._pMarkerName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x2] = getAddressFromArrayBuffer(this._pMarkerName);
    } else if (value === null) {
      this._pMarkerName = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.pMarkerName': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (value !== null && value.constructor === Array) {
      this._color = value;
    } else if (value === null) {
      this._color = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.color': Expected 'Array float' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugMarkerMarkerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._color !== null) {
    let array = this._color;
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkDebugMarkerMarkerInfoEXT.color'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== Number) {
        throw new TypeError("Invalid type for 'VkDebugMarkerMarkerInfoEXT.color[" + ii + "]': Expected 'Number' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewFloat32[0x6 + ii] = array[ii];
    };
  } else {
    this.memoryViewFloat32[0x6] = 0x0;
  }
  
  return true;
};

VkDebugMarkerMarkerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDebugMarkerMarkerInfoEXT.byteLength = 0x28;

VkDebugMarkerMarkerInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  pMarkerName: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  color: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x10
  }),
});
/** VkDedicatedAllocationImageCreateInfoNV **/
class VkDedicatedAllocationImageCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9B2F90;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.dedicatedAllocation !== void 0) this.dedicatedAllocation = opts.dedicatedAllocation;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationImageCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDedicatedAllocationImageCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get dedicatedAllocation() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set dedicatedAllocation(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkDedicatedAllocationImageCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationImageCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDedicatedAllocationImageCreateInfoNV.byteLength = 0x18;

VkDedicatedAllocationImageCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  dedicatedAllocation: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDedicatedAllocationBufferCreateInfoNV **/
class VkDedicatedAllocationBufferCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9B2F91;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.dedicatedAllocation !== void 0) this.dedicatedAllocation = opts.dedicatedAllocation;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationBufferCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDedicatedAllocationBufferCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get dedicatedAllocation() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set dedicatedAllocation(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkDedicatedAllocationBufferCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationBufferCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDedicatedAllocationBufferCreateInfoNV.byteLength = 0x18;

VkDedicatedAllocationBufferCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  dedicatedAllocation: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDedicatedAllocationMemoryAllocateInfoNV **/
class VkDedicatedAllocationMemoryAllocateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this._buffer = null;
    this.sType = 0x3B9B2F92;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationMemoryAllocateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDedicatedAllocationMemoryAllocateInfoNV.pNext' isn't allowed to be filled");
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationMemoryAllocateInfoNV.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDedicatedAllocationMemoryAllocateInfoNV.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDedicatedAllocationMemoryAllocateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDedicatedAllocationMemoryAllocateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDedicatedAllocationMemoryAllocateInfoNV.byteLength = 0x20;

VkDedicatedAllocationMemoryAllocateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkExternalImageFormatPropertiesNV **/
class VkExternalImageFormatPropertiesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get imageFormatProperties() {
    return this._imageFormatProperties;
  }
  get externalMemoryFeatures() {
    return this.memoryViewInt32[0x8];
  }
  get exportFromImportedHandleTypes() {
    return this.memoryViewInt32[0x9];
  }
  get compatibleHandleTypes() {
    return this.memoryViewInt32[0xA];
  }
  
};

VkExternalImageFormatPropertiesNV.prototype.flush = function flush() {
  
  return true;
};

VkExternalImageFormatPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
};

VkExternalImageFormatPropertiesNV.byteLength = 0x30;

VkExternalImageFormatPropertiesNV.memoryLayout = Object.freeze({
  imageFormatProperties: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x20
  }),
  externalMemoryFeatures: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  exportFromImportedHandleTypes: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  compatibleHandleTypes: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
});
/** VkExternalMemoryImageCreateInfoNV **/
class VkExternalMemoryImageCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BA4C0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalMemoryImageCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfoNV.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExternalMemoryImageCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryImageCreateInfoNV.byteLength = 0x18;

VkExternalMemoryImageCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExportMemoryAllocateInfoNV **/
class VkExportMemoryAllocateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BA4C1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExportMemoryAllocateInfoNV.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfoNV.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExportMemoryAllocateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportMemoryAllocateInfoNV.byteLength = 0x18;

VkExportMemoryAllocateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDeviceGeneratedCommandsFeaturesNVX **/
class VkDeviceGeneratedCommandsFeaturesNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C19F5;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.computeBindingPointSupport !== void 0) this.computeBindingPointSupport = opts.computeBindingPointSupport;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsFeaturesNVX.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGeneratedCommandsFeaturesNVX.pNext' isn't allowed to be filled");
  }
  get computeBindingPointSupport() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set computeBindingPointSupport(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkDeviceGeneratedCommandsFeaturesNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGeneratedCommandsFeaturesNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGeneratedCommandsFeaturesNVX.byteLength = 0x18;

VkDeviceGeneratedCommandsFeaturesNVX.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  computeBindingPointSupport: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDeviceGeneratedCommandsLimitsNVX **/
class VkDeviceGeneratedCommandsLimitsNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    this.sType = 0x3B9C19F4;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.maxIndirectCommandsLayoutTokenCount !== void 0) this.maxIndirectCommandsLayoutTokenCount = opts.maxIndirectCommandsLayoutTokenCount;
      if (opts.maxObjectEntryCounts !== void 0) this.maxObjectEntryCounts = opts.maxObjectEntryCounts;
      if (opts.minSequenceCountBufferOffsetAlignment !== void 0) this.minSequenceCountBufferOffsetAlignment = opts.minSequenceCountBufferOffsetAlignment;
      if (opts.minSequenceIndexBufferOffsetAlignment !== void 0) this.minSequenceIndexBufferOffsetAlignment = opts.minSequenceIndexBufferOffsetAlignment;
      if (opts.minCommandsTokenBufferOffsetAlignment !== void 0) this.minCommandsTokenBufferOffsetAlignment = opts.minCommandsTokenBufferOffsetAlignment;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGeneratedCommandsLimitsNVX.pNext' isn't allowed to be filled");
  }
  get maxIndirectCommandsLayoutTokenCount() {
    return this.memoryViewUint32[0x4];
  }
  set maxIndirectCommandsLayoutTokenCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.maxIndirectCommandsLayoutTokenCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get maxObjectEntryCounts() {
    return this.memoryViewUint32[0x5];
  }
  set maxObjectEntryCounts(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.maxObjectEntryCounts': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get minSequenceCountBufferOffsetAlignment() {
    return this.memoryViewUint32[0x6];
  }
  set minSequenceCountBufferOffsetAlignment(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.minSequenceCountBufferOffsetAlignment': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get minSequenceIndexBufferOffsetAlignment() {
    return this.memoryViewUint32[0x7];
  }
  set minSequenceIndexBufferOffsetAlignment(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.minSequenceIndexBufferOffsetAlignment': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get minCommandsTokenBufferOffsetAlignment() {
    return this.memoryViewUint32[0x8];
  }
  set minCommandsTokenBufferOffsetAlignment(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGeneratedCommandsLimitsNVX.minCommandsTokenBufferOffsetAlignment': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  
};

VkDeviceGeneratedCommandsLimitsNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGeneratedCommandsLimitsNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGeneratedCommandsLimitsNVX.byteLength = 0x28;

VkDeviceGeneratedCommandsLimitsNVX.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxIndirectCommandsLayoutTokenCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxObjectEntryCounts: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  minSequenceCountBufferOffsetAlignment: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  minSequenceIndexBufferOffsetAlignment: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  minCommandsTokenBufferOffsetAlignment: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkIndirectCommandsTokenNVX **/
class VkIndirectCommandsTokenNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._buffer = null;
    
    
    if (typeof opts === "object") {
      if (opts.tokenType !== void 0) this.tokenType = opts.tokenType;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.offset !== void 0) this.offset = opts.offset;
      
    }
  }
  get tokenType() {
    return this.memoryViewInt32[0x0];
  }
  set tokenType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsTokenNVX.tokenType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsTokenNVX.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get offset() {
    return this.memoryViewBigUint64[0x2];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsTokenNVX.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x2] = value;
  }
  
};

VkIndirectCommandsTokenNVX.prototype.flush = function flush() {
  
  return true;
};

VkIndirectCommandsTokenNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkIndirectCommandsTokenNVX.byteLength = 0x18;

VkIndirectCommandsTokenNVX.memoryLayout = Object.freeze({
  tokenType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  buffer: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  offset: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkIndirectCommandsLayoutTokenNVX **/
class VkIndirectCommandsLayoutTokenNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.tokenType !== void 0) this.tokenType = opts.tokenType;
      if (opts.bindingUnit !== void 0) this.bindingUnit = opts.bindingUnit;
      if (opts.dynamicCount !== void 0) this.dynamicCount = opts.dynamicCount;
      if (opts.divisor !== void 0) this.divisor = opts.divisor;
      
    }
  }
  get tokenType() {
    return this.memoryViewInt32[0x0];
  }
  set tokenType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNVX.tokenType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get bindingUnit() {
    return this.memoryViewUint32[0x1];
  }
  set bindingUnit(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNVX.bindingUnit': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get dynamicCount() {
    return this.memoryViewUint32[0x2];
  }
  set dynamicCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNVX.dynamicCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get divisor() {
    return this.memoryViewUint32[0x3];
  }
  set divisor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutTokenNVX.divisor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x3] = value;
  }
  
};

VkIndirectCommandsLayoutTokenNVX.prototype.flush = function flush() {
  
  return true;
};

VkIndirectCommandsLayoutTokenNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkIndirectCommandsLayoutTokenNVX.byteLength = 0x10;

VkIndirectCommandsLayoutTokenNVX.memoryLayout = Object.freeze({
  tokenType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  bindingUnit: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  dynamicCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  divisor: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
});
/** VkIndirectCommandsLayoutCreateInfoNVX **/
class VkIndirectCommandsLayoutCreateInfoNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._pTokens = null;
    this._pTokensNative = null;
    this.sType = 0x3B9C19F1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.tokenCount !== void 0) this.tokenCount = opts.tokenCount;
      if (opts.pTokens !== void 0) this.pTokens = opts.pTokens;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkIndirectCommandsLayoutCreateInfoNVX.pNext' isn't allowed to be filled");
  }
  get pipelineBindPoint() {
    return this.memoryViewInt32[0x4];
  }
  set pipelineBindPoint(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.pipelineBindPoint': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x5];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get tokenCount() {
    return this.memoryViewUint32[0x6];
  }
  set tokenCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.tokenCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pTokens() {
    return this._pTokens;
  }
  set pTokens(value) {
    if (value !== null && value.constructor === Array) {
      this._pTokens = value;
    } else if (value === null) {
      this._pTokens = null;
    } else {
      throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.pTokens': Expected 'Array VkIndirectCommandsLayoutTokenNVX' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkIndirectCommandsLayoutCreateInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pTokens !== null) {
    let array = this._pTokens;
    if (array.length !== this.tokenCount) {
      throw new RangeError("Invalid array length, expected length of 'tokenCount' for 'VkIndirectCommandsLayoutCreateInfoNVX.pTokens'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkIndirectCommandsLayoutTokenNVX) {
        throw new TypeError("Invalid type for 'VkIndirectCommandsLayoutCreateInfoNVX.pTokens[" + ii + "]': Expected 'VkIndirectCommandsLayoutTokenNVX' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pTokensNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  return true;
};

VkIndirectCommandsLayoutCreateInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkIndirectCommandsLayoutCreateInfoNVX.byteLength = 0x28;

VkIndirectCommandsLayoutCreateInfoNVX.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  pipelineBindPoint: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  tokenCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pTokens: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkCmdProcessCommandsInfoNVX **/
class VkCmdProcessCommandsInfoNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x60);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._objectTable = null;
    this._indirectCommandsLayout = null;
    
    this._pIndirectCommandsTokens = null;
    this._pIndirectCommandsTokensNative = null;
    
    this._targetCommandBuffer = null;
    this._sequencesCountBuffer = null;
    
    this._sequencesIndexBuffer = null;
    
    this.sType = 0x3B9C19F2;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.objectTable !== void 0) this.objectTable = opts.objectTable;
      if (opts.indirectCommandsLayout !== void 0) this.indirectCommandsLayout = opts.indirectCommandsLayout;
      if (opts.indirectCommandsTokenCount !== void 0) this.indirectCommandsTokenCount = opts.indirectCommandsTokenCount;
      if (opts.pIndirectCommandsTokens !== void 0) this.pIndirectCommandsTokens = opts.pIndirectCommandsTokens;
      if (opts.maxSequencesCount !== void 0) this.maxSequencesCount = opts.maxSequencesCount;
      if (opts.targetCommandBuffer !== void 0) this.targetCommandBuffer = opts.targetCommandBuffer;
      if (opts.sequencesCountBuffer !== void 0) this.sequencesCountBuffer = opts.sequencesCountBuffer;
      if (opts.sequencesCountOffset !== void 0) this.sequencesCountOffset = opts.sequencesCountOffset;
      if (opts.sequencesIndexBuffer !== void 0) this.sequencesIndexBuffer = opts.sequencesIndexBuffer;
      if (opts.sequencesIndexOffset !== void 0) this.sequencesIndexOffset = opts.sequencesIndexOffset;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCmdProcessCommandsInfoNVX.pNext' isn't allowed to be filled");
  }
  get objectTable() {
    return this._objectTable;
  }
  set objectTable(value) {
    if (value !== null && value.constructor === VkObjectTableNVX) {
      
      this._objectTable = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._objectTable = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.objectTable': Expected 'VkObjectTableNVX' but got '" + value.constructor.name + "'");
    }
  }
  get indirectCommandsLayout() {
    return this._indirectCommandsLayout;
  }
  set indirectCommandsLayout(value) {
    if (value !== null && value.constructor === VkIndirectCommandsLayoutNVX) {
      
      this._indirectCommandsLayout = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._indirectCommandsLayout = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.indirectCommandsLayout': Expected 'VkIndirectCommandsLayoutNVX' but got '" + value.constructor.name + "'");
    }
  }
  get indirectCommandsTokenCount() {
    return this.memoryViewUint32[0x8];
  }
  set indirectCommandsTokenCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.indirectCommandsTokenCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pIndirectCommandsTokens() {
    return this._pIndirectCommandsTokens;
  }
  set pIndirectCommandsTokens(value) {
    if (value !== null && value.constructor === Array) {
      this._pIndirectCommandsTokens = value;
    } else if (value === null) {
      this._pIndirectCommandsTokens = null;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens': Expected 'Array VkIndirectCommandsTokenNVX' but got '" + value.constructor.name + "'");
    }
  }
  get maxSequencesCount() {
    return this.memoryViewUint32[0xC];
  }
  set maxSequencesCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.maxSequencesCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get targetCommandBuffer() {
    return this._targetCommandBuffer;
  }
  set targetCommandBuffer(value) {
    if (value !== null && value.constructor === VkCommandBuffer) {
      
      this._targetCommandBuffer = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._targetCommandBuffer = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.targetCommandBuffer': Expected 'VkCommandBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get sequencesCountBuffer() {
    return this._sequencesCountBuffer;
  }
  set sequencesCountBuffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._sequencesCountBuffer = value;
      
      this.memoryViewBigInt64[0x8] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._sequencesCountBuffer = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sequencesCountBuffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get sequencesCountOffset() {
    return this.memoryViewBigUint64[0x9];
  }
  set sequencesCountOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sequencesCountOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x9] = value;
  }
  get sequencesIndexBuffer() {
    return this._sequencesIndexBuffer;
  }
  set sequencesIndexBuffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._sequencesIndexBuffer = value;
      
      this.memoryViewBigInt64[0xA] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._sequencesIndexBuffer = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sequencesIndexBuffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get sequencesIndexOffset() {
    return this.memoryViewBigUint64[0xB];
  }
  set sequencesIndexOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.sequencesIndexOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0xB] = value;
  }
  
};

VkCmdProcessCommandsInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pIndirectCommandsTokens !== null) {
    let array = this._pIndirectCommandsTokens;
    if (array.length !== this.indirectCommandsTokenCount) {
      throw new RangeError("Invalid array length, expected length of 'indirectCommandsTokenCount' for 'VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkIndirectCommandsTokenNVX) {
        throw new TypeError("Invalid type for 'VkCmdProcessCommandsInfoNVX.pIndirectCommandsTokens[" + ii + "]': Expected 'VkIndirectCommandsTokenNVX' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pIndirectCommandsTokensNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkCmdProcessCommandsInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkCmdProcessCommandsInfoNVX.byteLength = 0x60;

VkCmdProcessCommandsInfoNVX.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  objectTable: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  indirectCommandsLayout: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  indirectCommandsTokenCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pIndirectCommandsTokens: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  maxSequencesCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  targetCommandBuffer: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  sequencesCountBuffer: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x8
  }),
  sequencesCountOffset: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x8
  }),
  sequencesIndexBuffer: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x8
  }),
  sequencesIndexOffset: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x8
  }),
});
/** VkCmdReserveSpaceForCommandsInfoNVX **/
class VkCmdReserveSpaceForCommandsInfoNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._objectTable = null;
    this._indirectCommandsLayout = null;
    
    this.sType = 0x3B9C19F3;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.objectTable !== void 0) this.objectTable = opts.objectTable;
      if (opts.indirectCommandsLayout !== void 0) this.indirectCommandsLayout = opts.indirectCommandsLayout;
      if (opts.maxSequencesCount !== void 0) this.maxSequencesCount = opts.maxSequencesCount;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdReserveSpaceForCommandsInfoNVX.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCmdReserveSpaceForCommandsInfoNVX.pNext' isn't allowed to be filled");
  }
  get objectTable() {
    return this._objectTable;
  }
  set objectTable(value) {
    if (value !== null && value.constructor === VkObjectTableNVX) {
      
      this._objectTable = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._objectTable = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdReserveSpaceForCommandsInfoNVX.objectTable': Expected 'VkObjectTableNVX' but got '" + value.constructor.name + "'");
    }
  }
  get indirectCommandsLayout() {
    return this._indirectCommandsLayout;
  }
  set indirectCommandsLayout(value) {
    if (value !== null && value.constructor === VkIndirectCommandsLayoutNVX) {
      
      this._indirectCommandsLayout = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._indirectCommandsLayout = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCmdReserveSpaceForCommandsInfoNVX.indirectCommandsLayout': Expected 'VkIndirectCommandsLayoutNVX' but got '" + value.constructor.name + "'");
    }
  }
  get maxSequencesCount() {
    return this.memoryViewUint32[0x8];
  }
  set maxSequencesCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCmdReserveSpaceForCommandsInfoNVX.maxSequencesCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  
};

VkCmdReserveSpaceForCommandsInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCmdReserveSpaceForCommandsInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCmdReserveSpaceForCommandsInfoNVX.byteLength = 0x28;

VkCmdReserveSpaceForCommandsInfoNVX.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  objectTable: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  indirectCommandsLayout: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  maxSequencesCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkObjectTableCreateInfoNVX **/
class VkObjectTableCreateInfoNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pObjectEntryTypes = null;
    this._pObjectEntryCounts = null;
    this._pObjectEntryUsageFlags = null;
    
    
    
    
    
    this.sType = 0x3B9C19F0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.objectCount !== void 0) this.objectCount = opts.objectCount;
      if (opts.pObjectEntryTypes !== void 0) this.pObjectEntryTypes = opts.pObjectEntryTypes;
      if (opts.pObjectEntryCounts !== void 0) this.pObjectEntryCounts = opts.pObjectEntryCounts;
      if (opts.pObjectEntryUsageFlags !== void 0) this.pObjectEntryUsageFlags = opts.pObjectEntryUsageFlags;
      if (opts.maxUniformBuffersPerDescriptor !== void 0) this.maxUniformBuffersPerDescriptor = opts.maxUniformBuffersPerDescriptor;
      if (opts.maxStorageBuffersPerDescriptor !== void 0) this.maxStorageBuffersPerDescriptor = opts.maxStorageBuffersPerDescriptor;
      if (opts.maxStorageImagesPerDescriptor !== void 0) this.maxStorageImagesPerDescriptor = opts.maxStorageImagesPerDescriptor;
      if (opts.maxSampledImagesPerDescriptor !== void 0) this.maxSampledImagesPerDescriptor = opts.maxSampledImagesPerDescriptor;
      if (opts.maxPipelineLayouts !== void 0) this.maxPipelineLayouts = opts.maxPipelineLayouts;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkObjectTableCreateInfoNVX.pNext' isn't allowed to be filled");
  }
  get objectCount() {
    return this.memoryViewUint32[0x4];
  }
  set objectCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.objectCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pObjectEntryTypes() {
    return this._pObjectEntryTypes;
  }
  set pObjectEntryTypes(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pObjectEntryTypes = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pObjectEntryTypes = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.pObjectEntryTypes': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  get pObjectEntryCounts() {
    return this._pObjectEntryCounts;
  }
  set pObjectEntryCounts(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pObjectEntryCounts = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pObjectEntryCounts = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.pObjectEntryCounts': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get pObjectEntryUsageFlags() {
    return this._pObjectEntryUsageFlags;
  }
  set pObjectEntryUsageFlags(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pObjectEntryUsageFlags = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pObjectEntryUsageFlags = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.pObjectEntryUsageFlags': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  get maxUniformBuffersPerDescriptor() {
    return this.memoryViewUint32[0xC];
  }
  set maxUniformBuffersPerDescriptor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxUniformBuffersPerDescriptor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get maxStorageBuffersPerDescriptor() {
    return this.memoryViewUint32[0xD];
  }
  set maxStorageBuffersPerDescriptor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxStorageBuffersPerDescriptor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xD] = value;
  }
  get maxStorageImagesPerDescriptor() {
    return this.memoryViewUint32[0xE];
  }
  set maxStorageImagesPerDescriptor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxStorageImagesPerDescriptor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xE] = value;
  }
  get maxSampledImagesPerDescriptor() {
    return this.memoryViewUint32[0xF];
  }
  set maxSampledImagesPerDescriptor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxSampledImagesPerDescriptor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xF] = value;
  }
  get maxPipelineLayouts() {
    return this.memoryViewUint32[0x10];
  }
  set maxPipelineLayouts(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableCreateInfoNVX.maxPipelineLayouts': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x10] = value;
  }
  
};

VkObjectTableCreateInfoNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkObjectTableCreateInfoNVX.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkObjectTableCreateInfoNVX.byteLength = 0x48;

VkObjectTableCreateInfoNVX.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  objectCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pObjectEntryTypes: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pObjectEntryCounts: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  pObjectEntryUsageFlags: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  maxUniformBuffersPerDescriptor: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  maxStorageBuffersPerDescriptor: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  maxStorageImagesPerDescriptor: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  maxSampledImagesPerDescriptor: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  maxPipelineLayouts: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
});
/** VkObjectTableEntryNVX **/
class VkObjectTableEntryNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get type() {
    return this.memoryViewInt32[0x0];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableEntryNVX.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x1];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableEntryNVX.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  
};

VkObjectTableEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTableEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTableEntryNVX.byteLength = 0x8;

VkObjectTableEntryNVX.memoryLayout = Object.freeze({
  type: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkObjectTablePipelineEntryNVX **/
class VkObjectTablePipelineEntryNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    this._pipeline = null;
    
    if (typeof opts === "object") {
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pipeline !== void 0) this.pipeline = opts.pipeline;
      
    }
  }
  get type() {
    return this.memoryViewInt32[0x0];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePipelineEntryNVX.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x1];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePipelineEntryNVX.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get pipeline() {
    return this._pipeline;
  }
  set pipeline(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._pipeline = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipeline = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTablePipelineEntryNVX.pipeline': Expected 'VkPipeline' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkObjectTablePipelineEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTablePipelineEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTablePipelineEntryNVX.byteLength = 0x10;

VkObjectTablePipelineEntryNVX.memoryLayout = Object.freeze({
  type: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  pipeline: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkObjectTableDescriptorSetEntryNVX **/
class VkObjectTableDescriptorSetEntryNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    this._pipelineLayout = null;
    this._descriptorSet = null;
    
    if (typeof opts === "object") {
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
      if (opts.descriptorSet !== void 0) this.descriptorSet = opts.descriptorSet;
      
    }
  }
  get type() {
    return this.memoryViewInt32[0x0];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableDescriptorSetEntryNVX.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x1];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableDescriptorSetEntryNVX.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get pipelineLayout() {
    return this._pipelineLayout;
  }
  set pipelineLayout(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableDescriptorSetEntryNVX.pipelineLayout': Expected 'VkPipelineLayout' but got '" + value.constructor.name + "'");
    }
  }
  get descriptorSet() {
    return this._descriptorSet;
  }
  set descriptorSet(value) {
    if (value !== null && value.constructor === VkDescriptorSet) {
      
      this._descriptorSet = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._descriptorSet = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableDescriptorSetEntryNVX.descriptorSet': Expected 'VkDescriptorSet' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkObjectTableDescriptorSetEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTableDescriptorSetEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTableDescriptorSetEntryNVX.byteLength = 0x18;

VkObjectTableDescriptorSetEntryNVX.memoryLayout = Object.freeze({
  type: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  pipelineLayout: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  descriptorSet: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkObjectTableVertexBufferEntryNVX **/
class VkObjectTableVertexBufferEntryNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    this._buffer = null;
    
    if (typeof opts === "object") {
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      
    }
  }
  get type() {
    return this.memoryViewInt32[0x0];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableVertexBufferEntryNVX.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x1];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableVertexBufferEntryNVX.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableVertexBufferEntryNVX.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkObjectTableVertexBufferEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTableVertexBufferEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTableVertexBufferEntryNVX.byteLength = 0x10;

VkObjectTableVertexBufferEntryNVX.memoryLayout = Object.freeze({
  type: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  buffer: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkObjectTableIndexBufferEntryNVX **/
class VkObjectTableIndexBufferEntryNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    this._buffer = null;
    
    
    if (typeof opts === "object") {
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.indexType !== void 0) this.indexType = opts.indexType;
      
    }
  }
  get type() {
    return this.memoryViewInt32[0x0];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableIndexBufferEntryNVX.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x1];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableIndexBufferEntryNVX.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTableIndexBufferEntryNVX.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get indexType() {
    return this.memoryViewInt32[0x4];
  }
  set indexType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTableIndexBufferEntryNVX.indexType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkObjectTableIndexBufferEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTableIndexBufferEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTableIndexBufferEntryNVX.byteLength = 0x18;

VkObjectTableIndexBufferEntryNVX.memoryLayout = Object.freeze({
  type: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  buffer: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  indexType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkObjectTablePushConstantEntryNVX **/
class VkObjectTablePushConstantEntryNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    this._pipelineLayout = null;
    
    
    if (typeof opts === "object") {
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
      if (opts.stageFlags !== void 0) this.stageFlags = opts.stageFlags;
      
    }
  }
  get type() {
    return this.memoryViewInt32[0x0];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePushConstantEntryNVX.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x1];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePushConstantEntryNVX.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get pipelineLayout() {
    return this._pipelineLayout;
  }
  set pipelineLayout(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryViewBigInt64[0x1] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkObjectTablePushConstantEntryNVX.pipelineLayout': Expected 'VkPipelineLayout' but got '" + value.constructor.name + "'");
    }
  }
  get stageFlags() {
    return this.memoryViewInt32[0x4];
  }
  set stageFlags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkObjectTablePushConstantEntryNVX.stageFlags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkObjectTablePushConstantEntryNVX.prototype.flush = function flush() {
  
  return true;
};

VkObjectTablePushConstantEntryNVX.prototype.reflect = function reflect(memoryAddress) {
  
};

VkObjectTablePushConstantEntryNVX.byteLength = 0x18;

VkObjectTablePushConstantEntryNVX.memoryLayout = Object.freeze({
  type: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  pipelineLayout: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  stageFlags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceFeatures2 **/
class VkPhysicalDeviceFeatures2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xF0) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0xF0) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xF0);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._features = new VkPhysicalDeviceFeatures({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB078;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.features !== void 0) this.features = opts.features;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
      switch (sType) {
          
        case 0x3B9C9EC0:
        case 0x3B9B9909:
        case 0x3B9C0E38:
        case 0x3B9D2B64:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        case 0x3B9D0C20:
        case 0x3B9CE510:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        case 0x3B9C0A50:
        case 0x3B9D3EE9:
        case 0x3B9D7D68:
        case 0x3B9C0669:
        case 0x3B9E0238:
        case 0x3B9D8920:
        case 0x3B9DB032:
        case 0x3B9BCFB9:
        case 0x3B9B3760:
        case 0x3B9D5270:
        case 0x3B9DEACA:
        case 0x3B9B8D50:
        case 0x3B9DDB28:
        case 0x3B9DE2F8:
        case 0x3B9DE6E0:
        case 0x3B9E7380:
        case 0x3B9D4AA1:
        case 0x3B9DDF10:
        case 0x3B9E1D90:
        case 0x3B9E2948:
        case 0x3B9C5870:
        case 0x3B9E6BB0:
        case 0x3B9E8320:
        case 0x3B9E96A8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.pNext'");
    }
  }
  get features() {
    return this._features;
  }
  set features(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._features = value;
      
      
    } else if (value === null) {
      this._features = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2.features': Expected 'VkPhysicalDeviceFeatures' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPhysicalDeviceFeatures2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._features !== null) {
    this._features.flush();
    if (this.memoryBuffer !== this._features.memoryBuffer) {
      let srcView = new Uint8Array(this._features.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
    }
  }
  
  return true;
};

VkPhysicalDeviceFeatures2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPhysicalDeviceFeatures2.byteLength = 0xF0;

VkPhysicalDeviceFeatures2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  features: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xDC
  }),
});
/** VkPhysicalDeviceFeatures2KHR **/
class VkPhysicalDeviceFeatures2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xF0) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0xF0) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xF0);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._features = new VkPhysicalDeviceFeatures({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB078;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.features !== void 0) this.features = opts.features;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9C9EC0:
        case 0x3B9B9909:
        case 0x3B9C0E38:
        case 0x3B9D2B64:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
        case 0x3B9D0C20:
        case 0x3B9CE510:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
        case 0x3B9C0A50:
        case 0x3B9D3EE9:
        case 0x3B9D7D68:
        case 0x3B9C0669:
        case 0x3B9E0238:
        case 0x3B9D8920:
        case 0x3B9DB032:
        case 0x3B9BCFB9:
        case 0x3B9B3760:
        case 0x3B9D5270:
        case 0x3B9DEACA:
        case 0x3B9B8D50:
        case 0x3B9DDB28:
        case 0x3B9DE2F8:
        case 0x3B9DE6E0:
        case 0x3B9E7380:
        case 0x3B9D4AA1:
        case 0x3B9DDF10:
        case 0x3B9E1D90:
        case 0x3B9E2948:
        case 0x3B9C5870:
        case 0x3B9E6BB0:
        case 0x3B9E8320:
        case 0x3B9E96A8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.pNext'");
    }
  }
  get features() {
    return this._features;
  }
  set features(value) {
    if (value !== null && value.constructor === VkPhysicalDeviceFeatures) {
      value.flush();
      this._features = value;
      
      
    } else if (value === null) {
      this._features = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFeatures2KHR.features': Expected 'VkPhysicalDeviceFeatures' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPhysicalDeviceFeatures2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._features !== null) {
    this._features.flush();
    if (this.memoryBuffer !== this._features.memoryBuffer) {
      let srcView = new Uint8Array(this._features.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
    }
  }
  
  return true;
};

VkPhysicalDeviceFeatures2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPhysicalDeviceFeatures2KHR.byteLength = 0xF0;

VkPhysicalDeviceFeatures2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  features: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xDC
  }),
});
/** VkPhysicalDeviceProperties2 **/
class VkPhysicalDeviceProperties2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x348) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x348) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x348);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._properties = new VkPhysicalDeviceProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB079;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9C0280:
        case 0x3B9DC7A0:
        case 0x3B9BDF5C:
        case 0x3B9B990A:
        case 0x3B9C4CB8:
        case 0x3B9C44E8:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        case 0x3B9C9308:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        case 0x3B9CC5D0:
        case 0x3B9CF89B:
        case 0x3B9D0C21:
        case 0x3B9CE511:
        case 0x3B9D5A40:
        case 0x3B9DCB88:
        case 0x3B9D8152:
        case 0x3B9C5488:
        case 0x3B9D9CA8:
        case 0x3B9D3EEA:
        case 0x3B9DB030:
        case 0x3B9E0620:
        case 0x3B9DD358:
        case 0x3B9B3761:
        case 0x3B9D4AA2:
        case 0x3B9DDF11:
        case 0x3B9D4E91:
        case 0x3B9E1D91:
        case 0x3B9E96AA:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2.pNext'");
    }
  }
  get properties() {
    return this._properties;
  }
  
};

VkPhysicalDeviceProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x348));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x348), 0x0);
  
  
  
  
};

VkPhysicalDeviceProperties2.byteLength = 0x348;

VkPhysicalDeviceProperties2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  properties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x338
  }),
});
/** VkPhysicalDeviceProperties2KHR **/
class VkPhysicalDeviceProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x348) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x348) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x348);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._properties = new VkPhysicalDeviceProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB079;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9C0280:
        case 0x3B9DC7A0:
        case 0x3B9BDF5C:
        case 0x3B9B990A:
        case 0x3B9C4CB8:
        case 0x3B9C44E8:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
        case 0x3B9C9308:
        case VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
        case 0x3B9CC5D0:
        case 0x3B9CF89B:
        case 0x3B9D0C21:
        case 0x3B9CE511:
        case 0x3B9D5A40:
        case 0x3B9DCB88:
        case 0x3B9D8152:
        case 0x3B9C5488:
        case 0x3B9D9CA8:
        case 0x3B9D3EEA:
        case 0x3B9DB030:
        case 0x3B9E0620:
        case 0x3B9DD358:
        case 0x3B9B3761:
        case 0x3B9D4AA2:
        case 0x3B9DDF11:
        case 0x3B9D4E91:
        case 0x3B9E1D91:
        case 0x3B9E96AA:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProperties2KHR.pNext'");
    }
  }
  get properties() {
    return this._properties;
  }
  
};

VkPhysicalDeviceProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x348));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x348), 0x0);
  
  
  
  
};

VkPhysicalDeviceProperties2KHR.byteLength = 0x348;

VkPhysicalDeviceProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  properties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x338
  }),
});
/** VkFormatProperties2 **/
class VkFormatProperties2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._formatProperties = new VkFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFormatProperties2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9D3330:
          break;
        default:
          throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFormatProperties2.pNext'");
    }
  }
  get formatProperties() {
    return this._formatProperties;
  }
  
};

VkFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkFormatProperties2.byteLength = 0x20;

VkFormatProperties2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  formatProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xC
  }),
});
/** VkFormatProperties2KHR **/
class VkFormatProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._formatProperties = new VkFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFormatProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9D3330:
          break;
        default:
          throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFormatProperties2KHR.pNext'");
    }
  }
  get formatProperties() {
    return this._formatProperties;
  }
  
};

VkFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkFormatProperties2KHR.byteLength = 0x20;

VkFormatProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  formatProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xC
  }),
});
/** VkImageFormatProperties2 **/
class VkImageFormatProperties2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9BDF59:
        case 0x3B9D2B65:
        case 0x3B9B6A28:
        case 0x3B9CC1E8:
        case 0x3B9D6211:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2.pNext'");
    }
  }
  get imageFormatProperties() {
    return this._imageFormatProperties;
  }
  
};

VkImageFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
  
  
};

VkImageFormatProperties2.byteLength = 0x30;

VkImageFormatProperties2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  imageFormatProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x20
  }),
});
/** VkImageFormatProperties2KHR **/
class VkImageFormatProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._imageFormatProperties = new VkImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9BDF59:
        case 0x3B9D2B65:
        case 0x3B9B6A28:
        case 0x3B9CC1E8:
        case 0x3B9D6211:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatProperties2KHR.pNext'");
    }
  }
  get imageFormatProperties() {
    return this._imageFormatProperties;
  }
  
};

VkImageFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
  
  
};

VkImageFormatProperties2KHR.byteLength = 0x30;

VkImageFormatProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  imageFormatProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x20
  }),
});
/** VkPhysicalDeviceImageFormatInfo2 **/
class VkPhysicalDeviceImageFormatInfo2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    this.sType = 0x3B9BB07C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.tiling !== void 0) this.tiling = opts.tiling;
      if (opts.usage !== void 0) this.usage = opts.usage;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
      switch (sType) {
          
        case 0x3B9BDF58:
        case 0x3B9D0838:
        case 0x3B9D3332:
        case 0x3B9E8AF0:
        case 0x3B9D6210:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.pNext'");
    }
  }
  get format() {
    return this.memoryViewInt32[0x4];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get type() {
    return this.memoryViewInt32[0x5];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get tiling() {
    return this.memoryViewInt32[0x6];
  }
  set tiling(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.tiling': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get usage() {
    return this.memoryViewInt32[0x7];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x8];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkPhysicalDeviceImageFormatInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageFormatInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImageFormatInfo2.byteLength = 0x28;

VkPhysicalDeviceImageFormatInfo2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  format: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  type: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  tiling: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  usage: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceImageFormatInfo2KHR **/
class VkPhysicalDeviceImageFormatInfo2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    this.sType = 0x3B9BB07C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.tiling !== void 0) this.tiling = opts.tiling;
      if (opts.usage !== void 0) this.usage = opts.usage;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9BDF58:
        case 0x3B9D0838:
        case 0x3B9D3332:
        case 0x3B9E8AF0:
        case 0x3B9D6210:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.pNext'");
    }
  }
  get format() {
    return this.memoryViewInt32[0x4];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get type() {
    return this.memoryViewInt32[0x5];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get tiling() {
    return this.memoryViewInt32[0x6];
  }
  set tiling(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.tiling': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get usage() {
    return this.memoryViewInt32[0x7];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x8];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageFormatInfo2KHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkPhysicalDeviceImageFormatInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageFormatInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImageFormatInfo2KHR.byteLength = 0x28;

VkPhysicalDeviceImageFormatInfo2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  format: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  type: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  tiling: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  usage: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkQueueFamilyProperties2 **/
class VkQueueFamilyProperties2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._queueFamilyProperties = new VkQueueFamilyProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07D;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9DEEB1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2.pNext'");
    }
  }
  get queueFamilyProperties() {
    return this._queueFamilyProperties;
  }
  
};

VkQueueFamilyProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkQueueFamilyProperties2.byteLength = 0x28;

VkQueueFamilyProperties2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  queueFamilyProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x18
  }),
});
/** VkQueueFamilyProperties2KHR **/
class VkQueueFamilyProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._queueFamilyProperties = new VkQueueFamilyProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07D;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9DEEB1:
          break;
        default:
          throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkQueueFamilyProperties2KHR.pNext'");
    }
  }
  get queueFamilyProperties() {
    return this._queueFamilyProperties;
  }
  
};

VkQueueFamilyProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkQueueFamilyProperties2KHR.byteLength = 0x28;

VkQueueFamilyProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  queueFamilyProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x18
  }),
});
/** VkPhysicalDeviceMemoryProperties2 **/
class VkPhysicalDeviceMemoryProperties2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x218) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x218) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x218);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._memoryProperties = new VkPhysicalDeviceMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07E;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
      switch (sType) {
          
        case 0x3B9E67C8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2.pNext'");
    }
  }
  get memoryProperties() {
    return this._memoryProperties;
  }
  
};

VkPhysicalDeviceMemoryProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x218));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x218), 0x0);
  
  
  
  
};

VkPhysicalDeviceMemoryProperties2.byteLength = 0x218;

VkPhysicalDeviceMemoryProperties2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x208
  }),
});
/** VkPhysicalDeviceMemoryProperties2KHR **/
class VkPhysicalDeviceMemoryProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x218) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x218) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x218);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._memoryProperties = new VkPhysicalDeviceMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07E;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9E67C8:
          break;
        default:
          throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryProperties2KHR.pNext'");
    }
  }
  get memoryProperties() {
    return this._memoryProperties;
  }
  
};

VkPhysicalDeviceMemoryProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x218));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x218), 0x0);
  
  
  
  
};

VkPhysicalDeviceMemoryProperties2KHR.byteLength = 0x218;

VkPhysicalDeviceMemoryProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x208
  }),
});
/** VkSparseImageFormatProperties2 **/
class VkSparseImageFormatProperties2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._properties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07F;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageFormatProperties2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSparseImageFormatProperties2.pNext' isn't allowed to be filled");
  }
  get properties() {
    return this._properties;
  }
  
};

VkSparseImageFormatProperties2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageFormatProperties2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkSparseImageFormatProperties2.byteLength = 0x28;

VkSparseImageFormatProperties2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  properties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x14
  }),
});
/** VkSparseImageFormatProperties2KHR **/
class VkSparseImageFormatProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._properties = new VkSparseImageFormatProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BB07F;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageFormatProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSparseImageFormatProperties2KHR.pNext' isn't allowed to be filled");
  }
  get properties() {
    return this._properties;
  }
  
};

VkSparseImageFormatProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageFormatProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkSparseImageFormatProperties2KHR.byteLength = 0x28;

VkSparseImageFormatProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  properties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x14
  }),
});
/** VkPhysicalDeviceSparseImageFormatInfo2 **/
class VkPhysicalDeviceSparseImageFormatInfo2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    this.sType = 0x3B9BB080;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.samples !== void 0) this.samples = opts.samples;
      if (opts.usage !== void 0) this.usage = opts.usage;
      if (opts.tiling !== void 0) this.tiling = opts.tiling;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceSparseImageFormatInfo2.pNext' isn't allowed to be filled");
  }
  get format() {
    return this.memoryViewInt32[0x4];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get type() {
    return this.memoryViewInt32[0x5];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get samples() {
    return this.memoryViewInt32[0x6];
  }
  set samples(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.samples': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get usage() {
    return this.memoryViewInt32[0x7];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get tiling() {
    return this.memoryViewInt32[0x8];
  }
  set tiling(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2.tiling': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkPhysicalDeviceSparseImageFormatInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSparseImageFormatInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSparseImageFormatInfo2.byteLength = 0x28;

VkPhysicalDeviceSparseImageFormatInfo2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  format: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  type: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  samples: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  usage: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  tiling: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceSparseImageFormatInfo2KHR **/
class VkPhysicalDeviceSparseImageFormatInfo2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    this.sType = 0x3B9BB080;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.samples !== void 0) this.samples = opts.samples;
      if (opts.usage !== void 0) this.usage = opts.usage;
      if (opts.tiling !== void 0) this.tiling = opts.tiling;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceSparseImageFormatInfo2KHR.pNext' isn't allowed to be filled");
  }
  get format() {
    return this.memoryViewInt32[0x4];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get type() {
    return this.memoryViewInt32[0x5];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get samples() {
    return this.memoryViewInt32[0x6];
  }
  set samples(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.samples': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get usage() {
    return this.memoryViewInt32[0x7];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get tiling() {
    return this.memoryViewInt32[0x8];
  }
  set tiling(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSparseImageFormatInfo2KHR.tiling': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSparseImageFormatInfo2KHR.byteLength = 0x28;

VkPhysicalDeviceSparseImageFormatInfo2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  format: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  type: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  samples: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  usage: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  tiling: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkPhysicalDevicePushDescriptorPropertiesKHR **/
class VkPhysicalDevicePushDescriptorPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C0280;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevicePushDescriptorPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDevicePushDescriptorPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get maxPushDescriptors() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkPhysicalDevicePushDescriptorPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePushDescriptorPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDevicePushDescriptorPropertiesKHR.byteLength = 0x18;

VkPhysicalDevicePushDescriptorPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxPushDescriptors: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkConformanceVersionKHR **/
class VkConformanceVersionKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x4) / 0x1);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x4);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);

    }
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.major !== void 0) this.major = opts.major;
      if (opts.minor !== void 0) this.minor = opts.minor;
      if (opts.subminor !== void 0) this.subminor = opts.subminor;
      if (opts.patch !== void 0) this.patch = opts.patch;
      
    }
  }
  get major() {
    return this.memoryViewUint8[0x0];
  }
  set major(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConformanceVersionKHR.major': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint8[0x0] = value;
  }
  get minor() {
    return this.memoryViewUint8[0x1];
  }
  set minor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConformanceVersionKHR.minor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint8[0x1] = value;
  }
  get subminor() {
    return this.memoryViewUint8[0x2];
  }
  set subminor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConformanceVersionKHR.subminor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint8[0x2] = value;
  }
  get patch() {
    return this.memoryViewUint8[0x3];
  }
  set patch(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConformanceVersionKHR.patch': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint8[0x3] = value;
  }
  
};

VkConformanceVersionKHR.prototype.flush = function flush() {
  
  return true;
};

VkConformanceVersionKHR.prototype.reflect = function reflect(memoryAddress) {
  
};

VkConformanceVersionKHR.byteLength = 0x4;

VkConformanceVersionKHR.memoryLayout = Object.freeze({
  major: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x1
  }),
  minor: Object.freeze({
    byteOffset: 0x1,
    byteLength: 0x1
  }),
  subminor: Object.freeze({
    byteOffset: 0x2,
    byteLength: 0x1
  }),
  patch: Object.freeze({
    byteOffset: 0x3,
    byteLength: 0x1
  }),
});
/** VkPhysicalDeviceDriverPropertiesKHR **/
class VkPhysicalDeviceDriverPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x218) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x218) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x218);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._conformanceVersion = new VkConformanceVersionKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x214 });
    this.sType = 0x3B9DC7A0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDriverPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceDriverPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get driverID() {
    return this.memoryViewInt32[0x4];
  }
  get driverName() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(0x14, 0x128)
    ) || null;
  }
  get driverInfo() {
    return decodeNullTerminatedUTF8String(
      new Uint8Array(this.memoryBuffer).subarray(0x114, 0x328)
    ) || null;
  }
  get conformanceVersion() {
    return this._conformanceVersion;
  }
  
};

VkPhysicalDeviceDriverPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDriverPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x218));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x218), 0x0);
  
  
  
  
};

VkPhysicalDeviceDriverPropertiesKHR.byteLength = 0x218;

VkPhysicalDeviceDriverPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  driverID: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  driverName: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x100
  }),
  driverInfo: Object.freeze({
    byteOffset: 0x114,
    byteLength: 0x100
  }),
  conformanceVersion: Object.freeze({
    byteOffset: 0x214,
    byteLength: 0x4
  }),
});
/** VkPresentRegionsKHR **/
class VkPresentRegionsKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pRegions = null;
    this._pRegionsNative = null;
    this.sType = 0x3B9C1220;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
      if (opts.pRegions !== void 0) this.pRegions = opts.pRegions;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentRegionsKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPresentRegionsKHR.pNext' isn't allowed to be filled");
  }
  get swapchainCount() {
    return this.memoryViewUint32[0x4];
  }
  set swapchainCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentRegionsKHR.swapchainCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pRegions() {
    return this._pRegions;
  }
  set pRegions(value) {
    if (value !== null && value.constructor === Array) {
      this._pRegions = value;
    } else if (value === null) {
      this._pRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentRegionsKHR.pRegions': Expected 'Array VkPresentRegionKHR' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPresentRegionsKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pRegions !== null) {
    let array = this._pRegions;
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentRegionsKHR.pRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkPresentRegionKHR) {
        throw new TypeError("Invalid type for 'VkPresentRegionsKHR.pRegions[" + ii + "]': Expected 'VkPresentRegionKHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pRegionsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkPresentRegionsKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPresentRegionsKHR.byteLength = 0x20;

VkPresentRegionsKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  swapchainCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pRegions: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPresentRegionKHR **/
class VkPresentRegionKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pRectangles = null;
    this._pRectanglesNative = null;
    
    if (typeof opts === "object") {
      if (opts.rectangleCount !== void 0) this.rectangleCount = opts.rectangleCount;
      if (opts.pRectangles !== void 0) this.pRectangles = opts.pRectangles;
      
    }
  }
  get rectangleCount() {
    return this.memoryViewUint32[0x0];
  }
  set rectangleCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentRegionKHR.rectangleCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get pRectangles() {
    return this._pRectangles;
  }
  set pRectangles(value) {
    if (value !== null && value.constructor === Array) {
      this._pRectangles = value;
    } else if (value === null) {
      this._pRectangles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentRegionKHR.pRectangles': Expected 'Array VkRectLayerKHR' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPresentRegionKHR.prototype.flush = function flush() {
  
  
  if (this._pRectangles !== null) {
    let array = this._pRectangles;
    if (array.length !== this.rectangleCount) {
      throw new RangeError("Invalid array length, expected length of 'rectangleCount' for 'VkPresentRegionKHR.pRectangles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRectLayerKHR) {
        throw new TypeError("Invalid type for 'VkPresentRegionKHR.pRectangles[" + ii + "]': Expected 'VkRectLayerKHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pRectanglesNative = nativeArray;
    this.memoryViewBigInt64[0x1] = nativeArray.address;
  }
  
  return true;
};

VkPresentRegionKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPresentRegionKHR.byteLength = 0x10;

VkPresentRegionKHR.memoryLayout = Object.freeze({
  rectangleCount: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pRectangles: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkRectLayerKHR **/
class VkRectLayerKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x14) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x14);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._offset = new VkOffset2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    this._extent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x8 });
    
    
    if (typeof opts === "object") {
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.extent !== void 0) this.extent = opts.extent;
      if (opts.layer !== void 0) this.layer = opts.layer;
      
    }
  }
  get offset() {
    return this._offset;
  }
  set offset(value) {
    if (value !== null && value.constructor === VkOffset2D) {
      value.flush();
      this._offset = value;
      
      
    } else if (value === null) {
      this._offset = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRectLayerKHR.offset': Expected 'VkOffset2D' but got '" + value.constructor.name + "'");
    }
  }
  get extent() {
    return this._extent;
  }
  set extent(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._extent = value;
      
      
    } else if (value === null) {
      this._extent = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRectLayerKHR.extent': Expected 'VkExtent2D' but got '" + value.constructor.name + "'");
    }
  }
  get layer() {
    return this.memoryViewUint32[0x4];
  }
  set layer(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRectLayerKHR.layer': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  
};

VkRectLayerKHR.prototype.flush = function flush() {
  
  
  if (this._offset !== null) {
    this._offset.flush();
    if (this.memoryBuffer !== this._offset.memoryBuffer) {
      let srcView = new Uint8Array(this._offset.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  
  if (this._extent !== null) {
    this._extent.flush();
    if (this.memoryBuffer !== this._extent.memoryBuffer) {
      let srcView = new Uint8Array(this._extent.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
    }
  }
  
  return true;
};

VkRectLayerKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRectLayerKHR.byteLength = 0x14;

VkRectLayerKHR.memoryLayout = Object.freeze({
  offset: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  extent: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  layer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceVariablePointerFeatures **/
class VkPhysicalDeviceVariablePointerFeatures {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9C9EC0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
      if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVariablePointerFeatures.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceVariablePointerFeatures.pNext' isn't allowed to be filled");
  }
  get variablePointersStorageBuffer() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set variablePointersStorageBuffer(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get variablePointers() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set variablePointers(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceVariablePointerFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointerFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVariablePointerFeatures.byteLength = 0x18;

VkPhysicalDeviceVariablePointerFeatures.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  variablePointersStorageBuffer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  variablePointers: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceVariablePointerFeaturesKHR **/
class VkPhysicalDeviceVariablePointerFeaturesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9C9EC0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.variablePointersStorageBuffer !== void 0) this.variablePointersStorageBuffer = opts.variablePointersStorageBuffer;
      if (opts.variablePointers !== void 0) this.variablePointers = opts.variablePointers;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVariablePointerFeaturesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceVariablePointerFeaturesKHR.pNext' isn't allowed to be filled");
  }
  get variablePointersStorageBuffer() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set variablePointersStorageBuffer(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get variablePointers() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set variablePointers(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceVariablePointerFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVariablePointerFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVariablePointerFeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceVariablePointerFeaturesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  variablePointersStorageBuffer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  variablePointers: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkExternalMemoryProperties **/
class VkExternalMemoryProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get externalMemoryFeatures() {
    return this.memoryViewInt32[0x0];
  }
  get exportFromImportedHandleTypes() {
    return this.memoryViewInt32[0x1];
  }
  get compatibleHandleTypes() {
    return this.memoryViewInt32[0x2];
  }
  
};

VkExternalMemoryProperties.prototype.flush = function flush() {
  
  return true;
};

VkExternalMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0xC));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0xC), 0x0);
};

VkExternalMemoryProperties.byteLength = 0xC;

VkExternalMemoryProperties.memoryLayout = Object.freeze({
  externalMemoryFeatures: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  exportFromImportedHandleTypes: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  compatibleHandleTypes: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkExternalMemoryPropertiesKHR **/
class VkExternalMemoryPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get externalMemoryFeatures() {
    return this.memoryViewInt32[0x0];
  }
  get exportFromImportedHandleTypes() {
    return this.memoryViewInt32[0x1];
  }
  get compatibleHandleTypes() {
    return this.memoryViewInt32[0x2];
  }
  
};

VkExternalMemoryPropertiesKHR.prototype.flush = function flush() {
  
  return true;
};

VkExternalMemoryPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0xC));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0xC), 0x0);
};

VkExternalMemoryPropertiesKHR.byteLength = 0xC;

VkExternalMemoryPropertiesKHR.memoryLayout = Object.freeze({
  externalMemoryFeatures: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  exportFromImportedHandleTypes: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  compatibleHandleTypes: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExternalImageFormatInfo **/
class VkPhysicalDeviceExternalImageFormatInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BDF58;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalImageFormatInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalImageFormatInfo.pNext' isn't allowed to be filled");
  }
  get handleType() {
    return this.memoryViewInt32[0x4];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalImageFormatInfo.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPhysicalDeviceExternalImageFormatInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalImageFormatInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalImageFormatInfo.byteLength = 0x18;

VkPhysicalDeviceExternalImageFormatInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExternalImageFormatInfoKHR **/
class VkPhysicalDeviceExternalImageFormatInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BDF58;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalImageFormatInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalImageFormatInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleType() {
    return this.memoryViewInt32[0x4];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalImageFormatInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPhysicalDeviceExternalImageFormatInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalImageFormatInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalImageFormatInfoKHR.byteLength = 0x18;

VkPhysicalDeviceExternalImageFormatInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExternalImageFormatProperties **/
class VkExternalImageFormatProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BDF59;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalImageFormatProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalImageFormatProperties.pNext' isn't allowed to be filled");
  }
  get externalMemoryProperties() {
    return this._externalMemoryProperties;
  }
  
};

VkExternalImageFormatProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkExternalImageFormatProperties.byteLength = 0x20;

VkExternalImageFormatProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  externalMemoryProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xC
  }),
});
/** VkExternalImageFormatPropertiesKHR **/
class VkExternalImageFormatPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BDF59;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalImageFormatPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalImageFormatPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get externalMemoryProperties() {
    return this._externalMemoryProperties;
  }
  
};

VkExternalImageFormatPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalImageFormatPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkExternalImageFormatPropertiesKHR.byteLength = 0x20;

VkExternalImageFormatPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  externalMemoryProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xC
  }),
});
/** VkPhysicalDeviceExternalBufferInfo **/
class VkPhysicalDeviceExternalBufferInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9BDF5A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.usage !== void 0) this.usage = opts.usage;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalBufferInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get usage() {
    return this.memoryViewInt32[0x5];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfo.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get handleType() {
    return this.memoryViewInt32[0x6];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfo.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  
};

VkPhysicalDeviceExternalBufferInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalBufferInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalBufferInfo.byteLength = 0x20;

VkPhysicalDeviceExternalBufferInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  usage: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  handleType: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExternalBufferInfoKHR **/
class VkPhysicalDeviceExternalBufferInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9BDF5A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.usage !== void 0) this.usage = opts.usage;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalBufferInfoKHR.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfoKHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get usage() {
    return this.memoryViewInt32[0x5];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfoKHR.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get handleType() {
    return this.memoryViewInt32[0x6];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalBufferInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  
};

VkPhysicalDeviceExternalBufferInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalBufferInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalBufferInfoKHR.byteLength = 0x20;

VkPhysicalDeviceExternalBufferInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  usage: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  handleType: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkExternalBufferProperties **/
class VkExternalBufferProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BDF5B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalBufferProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalBufferProperties.pNext' isn't allowed to be filled");
  }
  get externalMemoryProperties() {
    return this._externalMemoryProperties;
  }
  
};

VkExternalBufferProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalBufferProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkExternalBufferProperties.byteLength = 0x20;

VkExternalBufferProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  externalMemoryProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xC
  }),
});
/** VkExternalBufferPropertiesKHR **/
class VkExternalBufferPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._externalMemoryProperties = new VkExternalMemoryProperties({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9BDF5B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalBufferPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalBufferPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get externalMemoryProperties() {
    return this._externalMemoryProperties;
  }
  
};

VkExternalBufferPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalBufferPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkExternalBufferPropertiesKHR.byteLength = 0x20;

VkExternalBufferPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  externalMemoryProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0xC
  }),
});
/** VkPhysicalDeviceIDProperties **/
class VkPhysicalDeviceIDProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._deviceUUID = [...Array(16)].fill(0x0);
    this._driverUUID = [...Array(16)].fill(0x0);
    this._deviceLUID = [...Array(8)].fill(0x0);
    
    
    this.sType = 0x3B9BDF5C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceIDProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceIDProperties.pNext' isn't allowed to be filled");
  }
  get deviceUUID() {
    return [
      this.memoryViewUint8[0x10],
      this.memoryViewUint8[0x11],
      this.memoryViewUint8[0x12],
      this.memoryViewUint8[0x13],
      this.memoryViewUint8[0x14],
      this.memoryViewUint8[0x15],
      this.memoryViewUint8[0x16],
      this.memoryViewUint8[0x17],
      this.memoryViewUint8[0x18],
      this.memoryViewUint8[0x19],
      this.memoryViewUint8[0x1A],
      this.memoryViewUint8[0x1B],
      this.memoryViewUint8[0x1C],
      this.memoryViewUint8[0x1D],
      this.memoryViewUint8[0x1E],
      this.memoryViewUint8[0x1F]
    ];
  }
  get driverUUID() {
    return [
      this.memoryViewUint8[0x20],
      this.memoryViewUint8[0x21],
      this.memoryViewUint8[0x22],
      this.memoryViewUint8[0x23],
      this.memoryViewUint8[0x24],
      this.memoryViewUint8[0x25],
      this.memoryViewUint8[0x26],
      this.memoryViewUint8[0x27],
      this.memoryViewUint8[0x28],
      this.memoryViewUint8[0x29],
      this.memoryViewUint8[0x2A],
      this.memoryViewUint8[0x2B],
      this.memoryViewUint8[0x2C],
      this.memoryViewUint8[0x2D],
      this.memoryViewUint8[0x2E],
      this.memoryViewUint8[0x2F]
    ];
  }
  get deviceLUID() {
    return [
      this.memoryViewUint8[0x30],
      this.memoryViewUint8[0x31],
      this.memoryViewUint8[0x32],
      this.memoryViewUint8[0x33],
      this.memoryViewUint8[0x34],
      this.memoryViewUint8[0x35],
      this.memoryViewUint8[0x36],
      this.memoryViewUint8[0x37]
    ];
  }
  get deviceNodeMask() {
    return this.memoryViewUint32[0xE];
  }
  get deviceLUIDValid() {
    return this.memoryViewUint32[0xF] !== 0;
  }
  
};

VkPhysicalDeviceIDProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceIDProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
  
  
  
  
};

VkPhysicalDeviceIDProperties.byteLength = 0x40;

VkPhysicalDeviceIDProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceUUID: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x10
  }),
  driverUUID: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x10
  }),
  deviceLUID: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  deviceNodeMask: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  deviceLUIDValid: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceIDPropertiesKHR **/
class VkPhysicalDeviceIDPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint8 = new Uint8Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x1, (opts.$memoryOffset + 0x40) / 0x1);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint8 = new Uint8Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._deviceUUID = [...Array(16)].fill(0x0);
    this._driverUUID = [...Array(16)].fill(0x0);
    this._deviceLUID = [...Array(8)].fill(0x0);
    
    
    this.sType = 0x3B9BDF5C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceIDPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceIDPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get deviceUUID() {
    return [
      this.memoryViewUint8[0x10],
      this.memoryViewUint8[0x11],
      this.memoryViewUint8[0x12],
      this.memoryViewUint8[0x13],
      this.memoryViewUint8[0x14],
      this.memoryViewUint8[0x15],
      this.memoryViewUint8[0x16],
      this.memoryViewUint8[0x17],
      this.memoryViewUint8[0x18],
      this.memoryViewUint8[0x19],
      this.memoryViewUint8[0x1A],
      this.memoryViewUint8[0x1B],
      this.memoryViewUint8[0x1C],
      this.memoryViewUint8[0x1D],
      this.memoryViewUint8[0x1E],
      this.memoryViewUint8[0x1F]
    ];
  }
  get driverUUID() {
    return [
      this.memoryViewUint8[0x20],
      this.memoryViewUint8[0x21],
      this.memoryViewUint8[0x22],
      this.memoryViewUint8[0x23],
      this.memoryViewUint8[0x24],
      this.memoryViewUint8[0x25],
      this.memoryViewUint8[0x26],
      this.memoryViewUint8[0x27],
      this.memoryViewUint8[0x28],
      this.memoryViewUint8[0x29],
      this.memoryViewUint8[0x2A],
      this.memoryViewUint8[0x2B],
      this.memoryViewUint8[0x2C],
      this.memoryViewUint8[0x2D],
      this.memoryViewUint8[0x2E],
      this.memoryViewUint8[0x2F]
    ];
  }
  get deviceLUID() {
    return [
      this.memoryViewUint8[0x30],
      this.memoryViewUint8[0x31],
      this.memoryViewUint8[0x32],
      this.memoryViewUint8[0x33],
      this.memoryViewUint8[0x34],
      this.memoryViewUint8[0x35],
      this.memoryViewUint8[0x36],
      this.memoryViewUint8[0x37]
    ];
  }
  get deviceNodeMask() {
    return this.memoryViewUint32[0xE];
  }
  get deviceLUIDValid() {
    return this.memoryViewUint32[0xF] !== 0;
  }
  
};

VkPhysicalDeviceIDPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceIDPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
  
  
  
  
};

VkPhysicalDeviceIDPropertiesKHR.byteLength = 0x40;

VkPhysicalDeviceIDPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceUUID: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x10
  }),
  driverUUID: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x10
  }),
  deviceLUID: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  deviceNodeMask: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  deviceLUIDValid: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
});
/** VkExternalMemoryImageCreateInfo **/
class VkExternalMemoryImageCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BE341;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalMemoryImageCreateInfo.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfo.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExternalMemoryImageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryImageCreateInfo.byteLength = 0x18;

VkExternalMemoryImageCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExternalMemoryImageCreateInfoKHR **/
class VkExternalMemoryImageCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BE341;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalMemoryImageCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryImageCreateInfoKHR.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExternalMemoryImageCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryImageCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryImageCreateInfoKHR.byteLength = 0x18;

VkExternalMemoryImageCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExternalMemoryBufferCreateInfo **/
class VkExternalMemoryBufferCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BE340;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryBufferCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalMemoryBufferCreateInfo.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryBufferCreateInfo.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExternalMemoryBufferCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryBufferCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryBufferCreateInfo.byteLength = 0x18;

VkExternalMemoryBufferCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExternalMemoryBufferCreateInfoKHR **/
class VkExternalMemoryBufferCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BE340;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryBufferCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalMemoryBufferCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalMemoryBufferCreateInfoKHR.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExternalMemoryBufferCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalMemoryBufferCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExternalMemoryBufferCreateInfoKHR.byteLength = 0x18;

VkExternalMemoryBufferCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExportMemoryAllocateInfo **/
class VkExportMemoryAllocateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BE342;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExportMemoryAllocateInfo.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfo.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExportMemoryAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportMemoryAllocateInfo.byteLength = 0x18;

VkExportMemoryAllocateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExportMemoryAllocateInfoKHR **/
class VkExportMemoryAllocateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BE342;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExportMemoryAllocateInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportMemoryAllocateInfoKHR.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExportMemoryAllocateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportMemoryAllocateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportMemoryAllocateInfoKHR.byteLength = 0x18;

VkExportMemoryAllocateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkImportMemoryFdInfoKHR **/
class VkImportMemoryFdInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9BEB10;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      if (opts.fd !== void 0) this.fd = opts.fd;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryFdInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImportMemoryFdInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleType() {
    return this.memoryViewInt32[0x4];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryFdInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get fd() {
    return this.memoryViewInt32[0x5];
  }
  set fd(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryFdInfoKHR.fd': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  
};

VkImportMemoryFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportMemoryFdInfoKHR.byteLength = 0x18;

VkImportMemoryFdInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  fd: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkMemoryFdPropertiesKHR **/
class VkMemoryFdPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BEB11;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryFdPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryFdPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get memoryTypeBits() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkMemoryFdPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryFdPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryFdPropertiesKHR.byteLength = 0x18;

VkMemoryFdPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryTypeBits: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkMemoryGetFdInfoKHR **/
class VkMemoryGetFdInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._memory = null;
    
    this.sType = 0x3B9BEB12;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryGetFdInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryGetFdInfoKHR.pNext' isn't allowed to be filled");
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryGetFdInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get handleType() {
    return this.memoryViewInt32[0x6];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryGetFdInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  
};

VkMemoryGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryGetFdInfoKHR.byteLength = 0x20;

VkMemoryGetFdInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memory: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExternalSemaphoreInfo **/
class VkPhysicalDeviceExternalSemaphoreInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BF2E0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalSemaphoreInfo.pNext' isn't allowed to be filled");
  }
  get handleType() {
    return this.memoryViewInt32[0x4];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfo.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPhysicalDeviceExternalSemaphoreInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalSemaphoreInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalSemaphoreInfo.byteLength = 0x18;

VkPhysicalDeviceExternalSemaphoreInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExternalSemaphoreInfoKHR **/
class VkPhysicalDeviceExternalSemaphoreInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BF2E0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalSemaphoreInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleType() {
    return this.memoryViewInt32[0x4];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalSemaphoreInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalSemaphoreInfoKHR.byteLength = 0x18;

VkPhysicalDeviceExternalSemaphoreInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExternalSemaphoreProperties **/
class VkExternalSemaphoreProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9BF2E1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalSemaphoreProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalSemaphoreProperties.pNext' isn't allowed to be filled");
  }
  get exportFromImportedHandleTypes() {
    return this.memoryViewInt32[0x4];
  }
  get compatibleHandleTypes() {
    return this.memoryViewInt32[0x5];
  }
  get externalSemaphoreFeatures() {
    return this.memoryViewInt32[0x6];
  }
  
};

VkExternalSemaphoreProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalSemaphoreProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkExternalSemaphoreProperties.byteLength = 0x20;

VkExternalSemaphoreProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  exportFromImportedHandleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  compatibleHandleTypes: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  externalSemaphoreFeatures: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkExternalSemaphorePropertiesKHR **/
class VkExternalSemaphorePropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9BF2E1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalSemaphorePropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalSemaphorePropertiesKHR.pNext' isn't allowed to be filled");
  }
  get exportFromImportedHandleTypes() {
    return this.memoryViewInt32[0x4];
  }
  get compatibleHandleTypes() {
    return this.memoryViewInt32[0x5];
  }
  get externalSemaphoreFeatures() {
    return this.memoryViewInt32[0x6];
  }
  
};

VkExternalSemaphorePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalSemaphorePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkExternalSemaphorePropertiesKHR.byteLength = 0x20;

VkExternalSemaphorePropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  exportFromImportedHandleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  compatibleHandleTypes: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  externalSemaphoreFeatures: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkExportSemaphoreCreateInfo **/
class VkExportSemaphoreCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BF6C8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExportSemaphoreCreateInfo.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreCreateInfo.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExportSemaphoreCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportSemaphoreCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportSemaphoreCreateInfo.byteLength = 0x18;

VkExportSemaphoreCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExportSemaphoreCreateInfoKHR **/
class VkExportSemaphoreCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BF6C8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExportSemaphoreCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportSemaphoreCreateInfoKHR.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExportSemaphoreCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportSemaphoreCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportSemaphoreCreateInfoKHR.byteLength = 0x18;

VkExportSemaphoreCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkImportSemaphoreFdInfoKHR **/
class VkImportSemaphoreFdInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._semaphore = null;
    
    
    
    this.sType = 0x3B9BFE98;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      if (opts.fd !== void 0) this.fd = opts.fd;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImportSemaphoreFdInfoKHR.pNext' isn't allowed to be filled");
  }
  get semaphore() {
    return this._semaphore;
  }
  set semaphore(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._semaphore = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + value.constructor.name + "'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x6];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get handleType() {
    return this.memoryViewInt32[0x7];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get fd() {
    return this.memoryViewInt32[0x8];
  }
  set fd(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportSemaphoreFdInfoKHR.fd': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkImportSemaphoreFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportSemaphoreFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportSemaphoreFdInfoKHR.byteLength = 0x28;

VkImportSemaphoreFdInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  semaphore: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  handleType: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  fd: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkSemaphoreGetFdInfoKHR **/
class VkSemaphoreGetFdInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._semaphore = null;
    
    this.sType = 0x3B9BFE99;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreGetFdInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSemaphoreGetFdInfoKHR.pNext' isn't allowed to be filled");
  }
  get semaphore() {
    return this._semaphore;
  }
  set semaphore(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._semaphore = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSemaphoreGetFdInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + value.constructor.name + "'");
    }
  }
  get handleType() {
    return this.memoryViewInt32[0x6];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSemaphoreGetFdInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  
};

VkSemaphoreGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSemaphoreGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSemaphoreGetFdInfoKHR.byteLength = 0x20;

VkSemaphoreGetFdInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  semaphore: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExternalFenceInfo **/
class VkPhysicalDeviceExternalFenceInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C7F80;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalFenceInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalFenceInfo.pNext' isn't allowed to be filled");
  }
  get handleType() {
    return this.memoryViewInt32[0x4];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalFenceInfo.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPhysicalDeviceExternalFenceInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalFenceInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalFenceInfo.byteLength = 0x18;

VkPhysicalDeviceExternalFenceInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExternalFenceInfoKHR **/
class VkPhysicalDeviceExternalFenceInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C7F80;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalFenceInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalFenceInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleType() {
    return this.memoryViewInt32[0x4];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalFenceInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPhysicalDeviceExternalFenceInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalFenceInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExternalFenceInfoKHR.byteLength = 0x18;

VkPhysicalDeviceExternalFenceInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExternalFenceProperties **/
class VkExternalFenceProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9C7F81;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalFenceProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalFenceProperties.pNext' isn't allowed to be filled");
  }
  get exportFromImportedHandleTypes() {
    return this.memoryViewInt32[0x4];
  }
  get compatibleHandleTypes() {
    return this.memoryViewInt32[0x5];
  }
  get externalFenceFeatures() {
    return this.memoryViewInt32[0x6];
  }
  
};

VkExternalFenceProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalFenceProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkExternalFenceProperties.byteLength = 0x20;

VkExternalFenceProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  exportFromImportedHandleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  compatibleHandleTypes: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  externalFenceFeatures: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkExternalFencePropertiesKHR **/
class VkExternalFencePropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9C7F81;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExternalFencePropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExternalFencePropertiesKHR.pNext' isn't allowed to be filled");
  }
  get exportFromImportedHandleTypes() {
    return this.memoryViewInt32[0x4];
  }
  get compatibleHandleTypes() {
    return this.memoryViewInt32[0x5];
  }
  get externalFenceFeatures() {
    return this.memoryViewInt32[0x6];
  }
  
};

VkExternalFencePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExternalFencePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkExternalFencePropertiesKHR.byteLength = 0x20;

VkExternalFencePropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  exportFromImportedHandleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  compatibleHandleTypes: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  externalFenceFeatures: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkExportFenceCreateInfo **/
class VkExportFenceCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C8368;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExportFenceCreateInfo.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceCreateInfo.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExportFenceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportFenceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportFenceCreateInfo.byteLength = 0x18;

VkExportFenceCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkExportFenceCreateInfoKHR **/
class VkExportFenceCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C8368;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleTypes !== void 0) this.handleTypes = opts.handleTypes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkExportFenceCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get handleTypes() {
    return this.memoryViewInt32[0x4];
  }
  set handleTypes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkExportFenceCreateInfoKHR.handleTypes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkExportFenceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkExportFenceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkExportFenceCreateInfoKHR.byteLength = 0x18;

VkExportFenceCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleTypes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkImportFenceFdInfoKHR **/
class VkImportFenceFdInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._fence = null;
    
    
    
    this.sType = 0x3B9C8B38;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.fence !== void 0) this.fence = opts.fence;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      if (opts.fd !== void 0) this.fd = opts.fd;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImportFenceFdInfoKHR.pNext' isn't allowed to be filled");
  }
  get fence() {
    return this._fence;
  }
  set fence(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._fence = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.fence': Expected 'VkFence' but got '" + value.constructor.name + "'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x6];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get handleType() {
    return this.memoryViewInt32[0x7];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get fd() {
    return this.memoryViewInt32[0x8];
  }
  set fd(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportFenceFdInfoKHR.fd': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkImportFenceFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportFenceFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportFenceFdInfoKHR.byteLength = 0x28;

VkImportFenceFdInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  fence: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  handleType: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  fd: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkFenceGetFdInfoKHR **/
class VkFenceGetFdInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._fence = null;
    
    this.sType = 0x3B9C8B39;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.fence !== void 0) this.fence = opts.fence;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceGetFdInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkFenceGetFdInfoKHR.pNext' isn't allowed to be filled");
  }
  get fence() {
    return this._fence;
  }
  set fence(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._fence = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkFenceGetFdInfoKHR.fence': Expected 'VkFence' but got '" + value.constructor.name + "'");
    }
  }
  get handleType() {
    return this.memoryViewInt32[0x6];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFenceGetFdInfoKHR.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  
};

VkFenceGetFdInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFenceGetFdInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkFenceGetFdInfoKHR.byteLength = 0x20;

VkFenceGetFdInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  fence: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceMultiviewFeatures **/
class VkPhysicalDeviceMultiviewFeatures {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9B9909;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.multiview !== void 0) this.multiview = opts.multiview;
      if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
      if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewFeatures.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMultiviewFeatures.pNext' isn't allowed to be filled");
  }
  get multiview() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set multiview(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get multiviewGeometryShader() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set multiviewGeometryShader(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get multiviewTessellationShader() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set multiviewTessellationShader(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  
};

VkPhysicalDeviceMultiviewFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceMultiviewFeatures.byteLength = 0x20;

VkPhysicalDeviceMultiviewFeatures.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  multiview: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  multiviewGeometryShader: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  multiviewTessellationShader: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceMultiviewFeaturesKHR **/
class VkPhysicalDeviceMultiviewFeaturesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9B9909;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.multiview !== void 0) this.multiview = opts.multiview;
      if (opts.multiviewGeometryShader !== void 0) this.multiviewGeometryShader = opts.multiviewGeometryShader;
      if (opts.multiviewTessellationShader !== void 0) this.multiviewTessellationShader = opts.multiviewTessellationShader;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewFeaturesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMultiviewFeaturesKHR.pNext' isn't allowed to be filled");
  }
  get multiview() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set multiview(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get multiviewGeometryShader() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set multiviewGeometryShader(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get multiviewTessellationShader() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set multiviewTessellationShader(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  
};

VkPhysicalDeviceMultiviewFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceMultiviewFeaturesKHR.byteLength = 0x20;

VkPhysicalDeviceMultiviewFeaturesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  multiview: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  multiviewGeometryShader: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  multiviewTessellationShader: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceMultiviewProperties **/
class VkPhysicalDeviceMultiviewProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9B990A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMultiviewProperties.pNext' isn't allowed to be filled");
  }
  get maxMultiviewViewCount() {
    return this.memoryViewUint32[0x4];
  }
  get maxMultiviewInstanceIndex() {
    return this.memoryViewUint32[0x5];
  }
  
};

VkPhysicalDeviceMultiviewProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceMultiviewProperties.byteLength = 0x18;

VkPhysicalDeviceMultiviewProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxMultiviewViewCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxMultiviewInstanceIndex: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceMultiviewPropertiesKHR **/
class VkPhysicalDeviceMultiviewPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9B990A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMultiviewPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get maxMultiviewViewCount() {
    return this.memoryViewUint32[0x4];
  }
  get maxMultiviewInstanceIndex() {
    return this.memoryViewUint32[0x5];
  }
  
};

VkPhysicalDeviceMultiviewPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceMultiviewPropertiesKHR.byteLength = 0x18;

VkPhysicalDeviceMultiviewPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxMultiviewViewCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxMultiviewInstanceIndex: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkRenderPassMultiviewCreateInfo **/
class VkRenderPassMultiviewCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pViewMasks = null;
    
    this._pViewOffsets = null;
    
    this._pCorrelationMasks = null;
    this.sType = 0x3B9B9908;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
      if (opts.pViewMasks !== void 0) this.pViewMasks = opts.pViewMasks;
      if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
      if (opts.pViewOffsets !== void 0) this.pViewOffsets = opts.pViewOffsets;
      if (opts.correlationMaskCount !== void 0) this.correlationMaskCount = opts.correlationMaskCount;
      if (opts.pCorrelationMasks !== void 0) this.pCorrelationMasks = opts.pCorrelationMasks;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRenderPassMultiviewCreateInfo.pNext' isn't allowed to be filled");
  }
  get subpassCount() {
    return this.memoryViewUint32[0x4];
  }
  set subpassCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.subpassCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pViewMasks() {
    return this._pViewMasks;
  }
  set pViewMasks(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pViewMasks = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewMasks = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pViewMasks': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get dependencyCount() {
    return this.memoryViewUint32[0x8];
  }
  set dependencyCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.dependencyCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pViewOffsets() {
    return this._pViewOffsets;
  }
  set pViewOffsets(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewOffsets = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewOffsets = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pViewOffsets': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  get correlationMaskCount() {
    return this.memoryViewUint32[0xC];
  }
  set correlationMaskCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.correlationMaskCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pCorrelationMasks() {
    return this._pCorrelationMasks;
  }
  set pCorrelationMasks(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelationMasks = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCorrelationMasks = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfo.pCorrelationMasks': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassMultiviewCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRenderPassMultiviewCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkRenderPassMultiviewCreateInfo.byteLength = 0x40;

VkRenderPassMultiviewCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  subpassCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pViewMasks: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  dependencyCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pViewOffsets: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  correlationMaskCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pCorrelationMasks: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkRenderPassMultiviewCreateInfoKHR **/
class VkRenderPassMultiviewCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pViewMasks = null;
    
    this._pViewOffsets = null;
    
    this._pCorrelationMasks = null;
    this.sType = 0x3B9B9908;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
      if (opts.pViewMasks !== void 0) this.pViewMasks = opts.pViewMasks;
      if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
      if (opts.pViewOffsets !== void 0) this.pViewOffsets = opts.pViewOffsets;
      if (opts.correlationMaskCount !== void 0) this.correlationMaskCount = opts.correlationMaskCount;
      if (opts.pCorrelationMasks !== void 0) this.pCorrelationMasks = opts.pCorrelationMasks;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRenderPassMultiviewCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get subpassCount() {
    return this.memoryViewUint32[0x4];
  }
  set subpassCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.subpassCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pViewMasks() {
    return this._pViewMasks;
  }
  set pViewMasks(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pViewMasks = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewMasks = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pViewMasks': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get dependencyCount() {
    return this.memoryViewUint32[0x8];
  }
  set dependencyCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.dependencyCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pViewOffsets() {
    return this._pViewOffsets;
  }
  set pViewOffsets(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewOffsets = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewOffsets = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pViewOffsets': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  get correlationMaskCount() {
    return this.memoryViewUint32[0xC];
  }
  set correlationMaskCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.correlationMaskCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pCorrelationMasks() {
    return this._pCorrelationMasks;
  }
  set pCorrelationMasks(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelationMasks = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCorrelationMasks = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassMultiviewCreateInfoKHR.pCorrelationMasks': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassMultiviewCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRenderPassMultiviewCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkRenderPassMultiviewCreateInfoKHR.byteLength = 0x40;

VkRenderPassMultiviewCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  subpassCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pViewMasks: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  dependencyCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pViewOffsets: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  correlationMaskCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pCorrelationMasks: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkSurfaceCapabilities2EXT **/
class VkSurfaceCapabilities2EXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._currentExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    this._minImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x20 });
    this._maxImageExtent = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x28 });
    
    
    
    
    
    
    this.sType = 0x3B9C2990;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceCapabilities2EXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSurfaceCapabilities2EXT.pNext' isn't allowed to be filled");
  }
  get minImageCount() {
    return this.memoryViewUint32[0x4];
  }
  get maxImageCount() {
    return this.memoryViewUint32[0x5];
  }
  get currentExtent() {
    return this._currentExtent;
  }
  get minImageExtent() {
    return this._minImageExtent;
  }
  get maxImageExtent() {
    return this._maxImageExtent;
  }
  get maxImageArrayLayers() {
    return this.memoryViewUint32[0xC];
  }
  get supportedTransforms() {
    return this.memoryViewInt32[0xD];
  }
  get currentTransform() {
    return this.memoryViewInt32[0xE];
  }
  get supportedCompositeAlpha() {
    return this.memoryViewInt32[0xF];
  }
  get supportedUsageFlags() {
    return this.memoryViewInt32[0x10];
  }
  get supportedSurfaceCounters() {
    return this.memoryViewInt32[0x11];
  }
  
};

VkSurfaceCapabilities2EXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceCapabilities2EXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x48));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x48), 0x0);
  
  
  
  
  
  
  
  
};

VkSurfaceCapabilities2EXT.byteLength = 0x48;

VkSurfaceCapabilities2EXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  minImageCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxImageCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  currentExtent: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  minImageExtent: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  maxImageExtent: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  maxImageArrayLayers: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  supportedTransforms: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  currentTransform: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  supportedCompositeAlpha: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  supportedUsageFlags: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  supportedSurfaceCounters: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
});
/** VkDisplayPowerInfoEXT **/
class VkDisplayPowerInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C2D78;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.powerState !== void 0) this.powerState = opts.powerState;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPowerInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayPowerInfoEXT.pNext' isn't allowed to be filled");
  }
  get powerState() {
    return this.memoryViewInt32[0x4];
  }
  set powerState(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPowerInfoEXT.powerState': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkDisplayPowerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPowerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDisplayPowerInfoEXT.byteLength = 0x18;

VkDisplayPowerInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  powerState: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDeviceEventInfoEXT **/
class VkDeviceEventInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C2D79;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceEvent !== void 0) this.deviceEvent = opts.deviceEvent;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceEventInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceEventInfoEXT.pNext' isn't allowed to be filled");
  }
  get deviceEvent() {
    return this.memoryViewInt32[0x4];
  }
  set deviceEvent(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceEventInfoEXT.deviceEvent': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkDeviceEventInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceEventInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceEventInfoEXT.byteLength = 0x18;

VkDeviceEventInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceEvent: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDisplayEventInfoEXT **/
class VkDisplayEventInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C2D7A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.displayEvent !== void 0) this.displayEvent = opts.displayEvent;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayEventInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayEventInfoEXT.pNext' isn't allowed to be filled");
  }
  get displayEvent() {
    return this.memoryViewInt32[0x4];
  }
  set displayEvent(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayEventInfoEXT.displayEvent': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkDisplayEventInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayEventInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDisplayEventInfoEXT.byteLength = 0x18;

VkDisplayEventInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  displayEvent: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkSwapchainCounterCreateInfoEXT **/
class VkSwapchainCounterCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C2D7B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.surfaceCounters !== void 0) this.surfaceCounters = opts.surfaceCounters;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCounterCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSwapchainCounterCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get surfaceCounters() {
    return this.memoryViewInt32[0x4];
  }
  set surfaceCounters(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSwapchainCounterCreateInfoEXT.surfaceCounters': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkSwapchainCounterCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSwapchainCounterCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSwapchainCounterCreateInfoEXT.byteLength = 0x18;

VkSwapchainCounterCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  surfaceCounters: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceGroupProperties **/
class VkPhysicalDeviceGroupProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x120) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x120) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x120) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x120);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._physicalDevices = null;
    
    this.sType = 0x3B9BDB70;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceGroupProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceGroupProperties.pNext' isn't allowed to be filled");
  }
  get physicalDeviceCount() {
    return this.memoryViewUint32[0x4];
  }
  get physicalDevices() {
    return this._physicalDevices;
  }
  get subsetAllocation() {
    return this.memoryViewUint32[0x46] !== 0;
  }
  
};

VkPhysicalDeviceGroupProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceGroupProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x120));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x120), 0x0);
  
  
  
  
};

VkPhysicalDeviceGroupProperties.byteLength = 0x120;

VkPhysicalDeviceGroupProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  physicalDeviceCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  physicalDevices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x100
  }),
  subsetAllocation: Object.freeze({
    byteOffset: 0x118,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceGroupPropertiesKHR **/
class VkPhysicalDeviceGroupPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x120) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x120) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x120) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x120);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._physicalDevices = null;
    
    this.sType = 0x3B9BDB70;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceGroupPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceGroupPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get physicalDeviceCount() {
    return this.memoryViewUint32[0x4];
  }
  get physicalDevices() {
    return this._physicalDevices;
  }
  get subsetAllocation() {
    return this.memoryViewUint32[0x46] !== 0;
  }
  
};

VkPhysicalDeviceGroupPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceGroupPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x120));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x120), 0x0);
  
  
  
  
};

VkPhysicalDeviceGroupPropertiesKHR.byteLength = 0x120;

VkPhysicalDeviceGroupPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  physicalDeviceCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  physicalDevices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x100
  }),
  subsetAllocation: Object.freeze({
    byteOffset: 0x118,
    byteLength: 0x4
  }),
});
/** VkMemoryAllocateFlagsInfo **/
class VkMemoryAllocateFlagsInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9BB460;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryAllocateFlagsInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get deviceMask() {
    return this.memoryViewUint32[0x5];
  }
  set deviceMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfo.deviceMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  
};

VkMemoryAllocateFlagsInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateFlagsInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryAllocateFlagsInfo.byteLength = 0x18;

VkMemoryAllocateFlagsInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  deviceMask: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkMemoryAllocateFlagsInfoKHR **/
class VkMemoryAllocateFlagsInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9BB460;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryAllocateFlagsInfoKHR.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfoKHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get deviceMask() {
    return this.memoryViewUint32[0x5];
  }
  set deviceMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryAllocateFlagsInfoKHR.deviceMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  
};

VkMemoryAllocateFlagsInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryAllocateFlagsInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryAllocateFlagsInfoKHR.byteLength = 0x18;

VkMemoryAllocateFlagsInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  deviceMask: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkBindBufferMemoryInfo **/
class VkBindBufferMemoryInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._buffer = null;
    this._memory = null;
    
    this.sType = 0x3B9D2F48;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB46D:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.pNext'");
    }
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get memoryOffset() {
    return this.memoryViewBigUint64[0x4];
  }
  set memoryOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfo.memoryOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  
};

VkBindBufferMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindBufferMemoryInfo.byteLength = 0x28;

VkBindBufferMemoryInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  memory: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  memoryOffset: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkBindBufferMemoryInfoKHR **/
class VkBindBufferMemoryInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._buffer = null;
    this._memory = null;
    
    this.sType = 0x3B9D2F48;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9BB46D:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.pNext'");
    }
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get memoryOffset() {
    return this.memoryViewBigUint64[0x4];
  }
  set memoryOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryInfoKHR.memoryOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  
};

VkBindBufferMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindBufferMemoryInfoKHR.byteLength = 0x28;

VkBindBufferMemoryInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  memory: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  memoryOffset: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkBindBufferMemoryDeviceGroupInfo **/
class VkBindBufferMemoryDeviceGroupInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDeviceIndices = null;
    this.sType = 0x3B9BB46D;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
      if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBindBufferMemoryDeviceGroupInfo.pNext' isn't allowed to be filled");
  }
  get deviceIndexCount() {
    return this.memoryViewUint32[0x4];
  }
  set deviceIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfo.deviceIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pDeviceIndices() {
    return this._pDeviceIndices;
  }
  set pDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfo.pDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBindBufferMemoryDeviceGroupInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryDeviceGroupInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindBufferMemoryDeviceGroupInfo.byteLength = 0x20;

VkBindBufferMemoryDeviceGroupInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceIndexCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDeviceIndices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkBindBufferMemoryDeviceGroupInfoKHR **/
class VkBindBufferMemoryDeviceGroupInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDeviceIndices = null;
    this.sType = 0x3B9BB46D;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
      if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBindBufferMemoryDeviceGroupInfoKHR.pNext' isn't allowed to be filled");
  }
  get deviceIndexCount() {
    return this.memoryViewUint32[0x4];
  }
  set deviceIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfoKHR.deviceIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pDeviceIndices() {
    return this._pDeviceIndices;
  }
  set pDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindBufferMemoryDeviceGroupInfoKHR.pDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBindBufferMemoryDeviceGroupInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindBufferMemoryDeviceGroupInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindBufferMemoryDeviceGroupInfoKHR.byteLength = 0x20;

VkBindBufferMemoryDeviceGroupInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceIndexCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDeviceIndices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkBindImageMemoryInfo **/
class VkBindImageMemoryInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this._memory = null;
    
    this.sType = 0x3B9D2F49;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
      switch (sType) {
          
        case 0x3B9BB46E:
        case 0x3B9BB469:
        case 0x3B9D2B62:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.pNext'");
    }
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get memoryOffset() {
    return this.memoryViewBigUint64[0x4];
  }
  set memoryOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfo.memoryOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  
};

VkBindImageMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImageMemoryInfo.byteLength = 0x28;

VkBindImageMemoryInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  memory: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  memoryOffset: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkBindImageMemoryInfoKHR **/
class VkBindImageMemoryInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this._memory = null;
    
    this.sType = 0x3B9D2F49;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9BB46E:
        case 0x3B9BB469:
        case 0x3B9D2B62:
          break;
        default:
          throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.pNext'");
    }
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get memoryOffset() {
    return this.memoryViewBigUint64[0x4];
  }
  set memoryOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryInfoKHR.memoryOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  
};

VkBindImageMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImageMemoryInfoKHR.byteLength = 0x28;

VkBindImageMemoryInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  memory: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  memoryOffset: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkBindImageMemoryDeviceGroupInfo **/
class VkBindImageMemoryDeviceGroupInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDeviceIndices = null;
    
    this._pSplitInstanceBindRegions = null;
    this._pSplitInstanceBindRegionsNative = null;
    this.sType = 0x3B9BB46E;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
      if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
      if (opts.splitInstanceBindRegionCount !== void 0) this.splitInstanceBindRegionCount = opts.splitInstanceBindRegionCount;
      if (opts.pSplitInstanceBindRegions !== void 0) this.pSplitInstanceBindRegions = opts.pSplitInstanceBindRegions;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBindImageMemoryDeviceGroupInfo.pNext' isn't allowed to be filled");
  }
  get deviceIndexCount() {
    return this.memoryViewUint32[0x4];
  }
  set deviceIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.deviceIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pDeviceIndices() {
    return this._pDeviceIndices;
  }
  set pDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get splitInstanceBindRegionCount() {
    return this.memoryViewUint32[0x8];
  }
  set splitInstanceBindRegionCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.splitInstanceBindRegionCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pSplitInstanceBindRegions() {
    return this._pSplitInstanceBindRegions;
  }
  set pSplitInstanceBindRegions(value) {
    if (value !== null && value.constructor === Array) {
      this._pSplitInstanceBindRegions = value;
    } else if (value === null) {
      this._pSplitInstanceBindRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions': Expected 'Array VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBindImageMemoryDeviceGroupInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSplitInstanceBindRegions !== null) {
    let array = this._pSplitInstanceBindRegions;
    if (array.length !== this.splitInstanceBindRegionCount) {
      throw new RangeError("Invalid array length, expected length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRect2D) {
        throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfo.pSplitInstanceBindRegions[" + ii + "]': Expected 'VkRect2D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSplitInstanceBindRegionsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkBindImageMemoryDeviceGroupInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkBindImageMemoryDeviceGroupInfo.byteLength = 0x30;

VkBindImageMemoryDeviceGroupInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceIndexCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDeviceIndices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  splitInstanceBindRegionCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pSplitInstanceBindRegions: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkBindImageMemoryDeviceGroupInfoKHR **/
class VkBindImageMemoryDeviceGroupInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDeviceIndices = null;
    
    this._pSplitInstanceBindRegions = null;
    this._pSplitInstanceBindRegionsNative = null;
    this.sType = 0x3B9BB46E;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
      if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
      if (opts.splitInstanceBindRegionCount !== void 0) this.splitInstanceBindRegionCount = opts.splitInstanceBindRegionCount;
      if (opts.pSplitInstanceBindRegions !== void 0) this.pSplitInstanceBindRegions = opts.pSplitInstanceBindRegions;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBindImageMemoryDeviceGroupInfoKHR.pNext' isn't allowed to be filled");
  }
  get deviceIndexCount() {
    return this.memoryViewUint32[0x4];
  }
  set deviceIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.deviceIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pDeviceIndices() {
    return this._pDeviceIndices;
  }
  set pDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get splitInstanceBindRegionCount() {
    return this.memoryViewUint32[0x8];
  }
  set splitInstanceBindRegionCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.splitInstanceBindRegionCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pSplitInstanceBindRegions() {
    return this._pSplitInstanceBindRegions;
  }
  set pSplitInstanceBindRegions(value) {
    if (value !== null && value.constructor === Array) {
      this._pSplitInstanceBindRegions = value;
    } else if (value === null) {
      this._pSplitInstanceBindRegions = null;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions': Expected 'Array VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBindImageMemoryDeviceGroupInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pSplitInstanceBindRegions !== null) {
    let array = this._pSplitInstanceBindRegions;
    if (array.length !== this.splitInstanceBindRegionCount) {
      throw new RangeError("Invalid array length, expected length of 'splitInstanceBindRegionCount' for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRect2D) {
        throw new TypeError("Invalid type for 'VkBindImageMemoryDeviceGroupInfoKHR.pSplitInstanceBindRegions[" + ii + "]': Expected 'VkRect2D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSplitInstanceBindRegionsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkBindImageMemoryDeviceGroupInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkBindImageMemoryDeviceGroupInfoKHR.byteLength = 0x30;

VkBindImageMemoryDeviceGroupInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceIndexCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDeviceIndices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  splitInstanceBindRegionCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pSplitInstanceBindRegions: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkDeviceGroupRenderPassBeginInfo **/
class VkDeviceGroupRenderPassBeginInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pDeviceRenderAreas = null;
    this._pDeviceRenderAreasNative = null;
    this.sType = 0x3B9BB463;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
      if (opts.deviceRenderAreaCount !== void 0) this.deviceRenderAreaCount = opts.deviceRenderAreaCount;
      if (opts.pDeviceRenderAreas !== void 0) this.pDeviceRenderAreas = opts.pDeviceRenderAreas;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupRenderPassBeginInfo.pNext' isn't allowed to be filled");
  }
  get deviceMask() {
    return this.memoryViewUint32[0x4];
  }
  set deviceMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.deviceMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get deviceRenderAreaCount() {
    return this.memoryViewUint32[0x5];
  }
  set deviceRenderAreaCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.deviceRenderAreaCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pDeviceRenderAreas() {
    return this._pDeviceRenderAreas;
  }
  set pDeviceRenderAreas(value) {
    if (value !== null && value.constructor === Array) {
      this._pDeviceRenderAreas = value;
    } else if (value === null) {
      this._pDeviceRenderAreas = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas': Expected 'Array VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDeviceGroupRenderPassBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDeviceRenderAreas !== null) {
    let array = this._pDeviceRenderAreas;
    if (array.length !== this.deviceRenderAreaCount) {
      throw new RangeError("Invalid array length, expected length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRect2D) {
        throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfo.pDeviceRenderAreas[" + ii + "]': Expected 'VkRect2D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pDeviceRenderAreasNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkDeviceGroupRenderPassBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDeviceGroupRenderPassBeginInfo.byteLength = 0x20;

VkDeviceGroupRenderPassBeginInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  deviceRenderAreaCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pDeviceRenderAreas: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDeviceGroupRenderPassBeginInfoKHR **/
class VkDeviceGroupRenderPassBeginInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pDeviceRenderAreas = null;
    this._pDeviceRenderAreasNative = null;
    this.sType = 0x3B9BB463;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
      if (opts.deviceRenderAreaCount !== void 0) this.deviceRenderAreaCount = opts.deviceRenderAreaCount;
      if (opts.pDeviceRenderAreas !== void 0) this.pDeviceRenderAreas = opts.pDeviceRenderAreas;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupRenderPassBeginInfoKHR.pNext' isn't allowed to be filled");
  }
  get deviceMask() {
    return this.memoryViewUint32[0x4];
  }
  set deviceMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.deviceMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get deviceRenderAreaCount() {
    return this.memoryViewUint32[0x5];
  }
  set deviceRenderAreaCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.deviceRenderAreaCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pDeviceRenderAreas() {
    return this._pDeviceRenderAreas;
  }
  set pDeviceRenderAreas(value) {
    if (value !== null && value.constructor === Array) {
      this._pDeviceRenderAreas = value;
    } else if (value === null) {
      this._pDeviceRenderAreas = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas': Expected 'Array VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDeviceGroupRenderPassBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDeviceRenderAreas !== null) {
    let array = this._pDeviceRenderAreas;
    if (array.length !== this.deviceRenderAreaCount) {
      throw new RangeError("Invalid array length, expected length of 'deviceRenderAreaCount' for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRect2D) {
        throw new TypeError("Invalid type for 'VkDeviceGroupRenderPassBeginInfoKHR.pDeviceRenderAreas[" + ii + "]': Expected 'VkRect2D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pDeviceRenderAreasNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkDeviceGroupRenderPassBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDeviceGroupRenderPassBeginInfoKHR.byteLength = 0x20;

VkDeviceGroupRenderPassBeginInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  deviceRenderAreaCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pDeviceRenderAreas: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDeviceGroupCommandBufferBeginInfo **/
class VkDeviceGroupCommandBufferBeginInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BB464;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupCommandBufferBeginInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupCommandBufferBeginInfo.pNext' isn't allowed to be filled");
  }
  get deviceMask() {
    return this.memoryViewUint32[0x4];
  }
  set deviceMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupCommandBufferBeginInfo.deviceMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  
};

VkDeviceGroupCommandBufferBeginInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupCommandBufferBeginInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupCommandBufferBeginInfo.byteLength = 0x18;

VkDeviceGroupCommandBufferBeginInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDeviceGroupCommandBufferBeginInfoKHR **/
class VkDeviceGroupCommandBufferBeginInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BB464;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupCommandBufferBeginInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupCommandBufferBeginInfoKHR.pNext' isn't allowed to be filled");
  }
  get deviceMask() {
    return this.memoryViewUint32[0x4];
  }
  set deviceMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupCommandBufferBeginInfoKHR.deviceMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  
};

VkDeviceGroupCommandBufferBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupCommandBufferBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupCommandBufferBeginInfoKHR.byteLength = 0x18;

VkDeviceGroupCommandBufferBeginInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDeviceGroupSubmitInfo **/
class VkDeviceGroupSubmitInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pWaitSemaphoreDeviceIndices = null;
    
    this._pCommandBufferDeviceMasks = null;
    
    this._pSignalSemaphoreDeviceIndices = null;
    this.sType = 0x3B9BB465;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
      if (opts.pWaitSemaphoreDeviceIndices !== void 0) this.pWaitSemaphoreDeviceIndices = opts.pWaitSemaphoreDeviceIndices;
      if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
      if (opts.pCommandBufferDeviceMasks !== void 0) this.pCommandBufferDeviceMasks = opts.pCommandBufferDeviceMasks;
      if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
      if (opts.pSignalSemaphoreDeviceIndices !== void 0) this.pSignalSemaphoreDeviceIndices = opts.pSignalSemaphoreDeviceIndices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupSubmitInfo.pNext' isn't allowed to be filled");
  }
  get waitSemaphoreCount() {
    return this.memoryViewUint32[0x4];
  }
  set waitSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.waitSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pWaitSemaphoreDeviceIndices() {
    return this._pWaitSemaphoreDeviceIndices;
  }
  set pWaitSemaphoreDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pWaitSemaphoreDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pWaitSemaphoreDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pWaitSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get commandBufferCount() {
    return this.memoryViewUint32[0x8];
  }
  set commandBufferCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.commandBufferCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pCommandBufferDeviceMasks() {
    return this._pCommandBufferDeviceMasks;
  }
  set pCommandBufferDeviceMasks(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCommandBufferDeviceMasks = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCommandBufferDeviceMasks = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pCommandBufferDeviceMasks': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get signalSemaphoreCount() {
    return this.memoryViewUint32[0xC];
  }
  set signalSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.signalSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pSignalSemaphoreDeviceIndices() {
    return this._pSignalSemaphoreDeviceIndices;
  }
  set pSignalSemaphoreDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSignalSemaphoreDeviceIndices = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pSignalSemaphoreDeviceIndices = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfo.pSignalSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDeviceGroupSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupSubmitInfo.byteLength = 0x40;

VkDeviceGroupSubmitInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  waitSemaphoreCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pWaitSemaphoreDeviceIndices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  commandBufferCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pCommandBufferDeviceMasks: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  signalSemaphoreCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pSignalSemaphoreDeviceIndices: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkDeviceGroupSubmitInfoKHR **/
class VkDeviceGroupSubmitInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pWaitSemaphoreDeviceIndices = null;
    
    this._pCommandBufferDeviceMasks = null;
    
    this._pSignalSemaphoreDeviceIndices = null;
    this.sType = 0x3B9BB465;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.waitSemaphoreCount !== void 0) this.waitSemaphoreCount = opts.waitSemaphoreCount;
      if (opts.pWaitSemaphoreDeviceIndices !== void 0) this.pWaitSemaphoreDeviceIndices = opts.pWaitSemaphoreDeviceIndices;
      if (opts.commandBufferCount !== void 0) this.commandBufferCount = opts.commandBufferCount;
      if (opts.pCommandBufferDeviceMasks !== void 0) this.pCommandBufferDeviceMasks = opts.pCommandBufferDeviceMasks;
      if (opts.signalSemaphoreCount !== void 0) this.signalSemaphoreCount = opts.signalSemaphoreCount;
      if (opts.pSignalSemaphoreDeviceIndices !== void 0) this.pSignalSemaphoreDeviceIndices = opts.pSignalSemaphoreDeviceIndices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupSubmitInfoKHR.pNext' isn't allowed to be filled");
  }
  get waitSemaphoreCount() {
    return this.memoryViewUint32[0x4];
  }
  set waitSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.waitSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pWaitSemaphoreDeviceIndices() {
    return this._pWaitSemaphoreDeviceIndices;
  }
  set pWaitSemaphoreDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pWaitSemaphoreDeviceIndices = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pWaitSemaphoreDeviceIndices = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pWaitSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get commandBufferCount() {
    return this.memoryViewUint32[0x8];
  }
  set commandBufferCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.commandBufferCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pCommandBufferDeviceMasks() {
    return this._pCommandBufferDeviceMasks;
  }
  set pCommandBufferDeviceMasks(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCommandBufferDeviceMasks = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCommandBufferDeviceMasks = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pCommandBufferDeviceMasks': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get signalSemaphoreCount() {
    return this.memoryViewUint32[0xC];
  }
  set signalSemaphoreCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.signalSemaphoreCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pSignalSemaphoreDeviceIndices() {
    return this._pSignalSemaphoreDeviceIndices;
  }
  set pSignalSemaphoreDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pSignalSemaphoreDeviceIndices = value;
      this.memoryViewBigInt64[0x7] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pSignalSemaphoreDeviceIndices = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupSubmitInfoKHR.pSignalSemaphoreDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDeviceGroupSubmitInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSubmitInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupSubmitInfoKHR.byteLength = 0x40;

VkDeviceGroupSubmitInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  waitSemaphoreCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pWaitSemaphoreDeviceIndices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  commandBufferCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pCommandBufferDeviceMasks: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  signalSemaphoreCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pSignalSemaphoreDeviceIndices: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
});
/** VkDeviceGroupBindSparseInfo **/
class VkDeviceGroupBindSparseInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9BB466;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.resourceDeviceIndex !== void 0) this.resourceDeviceIndex = opts.resourceDeviceIndex;
      if (opts.memoryDeviceIndex !== void 0) this.memoryDeviceIndex = opts.memoryDeviceIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupBindSparseInfo.pNext' isn't allowed to be filled");
  }
  get resourceDeviceIndex() {
    return this.memoryViewUint32[0x4];
  }
  set resourceDeviceIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfo.resourceDeviceIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get memoryDeviceIndex() {
    return this.memoryViewUint32[0x5];
  }
  set memoryDeviceIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfo.memoryDeviceIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  
};

VkDeviceGroupBindSparseInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupBindSparseInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupBindSparseInfo.byteLength = 0x18;

VkDeviceGroupBindSparseInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  resourceDeviceIndex: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  memoryDeviceIndex: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkDeviceGroupBindSparseInfoKHR **/
class VkDeviceGroupBindSparseInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9BB466;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.resourceDeviceIndex !== void 0) this.resourceDeviceIndex = opts.resourceDeviceIndex;
      if (opts.memoryDeviceIndex !== void 0) this.memoryDeviceIndex = opts.memoryDeviceIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupBindSparseInfoKHR.pNext' isn't allowed to be filled");
  }
  get resourceDeviceIndex() {
    return this.memoryViewUint32[0x4];
  }
  set resourceDeviceIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfoKHR.resourceDeviceIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get memoryDeviceIndex() {
    return this.memoryViewUint32[0x5];
  }
  set memoryDeviceIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupBindSparseInfoKHR.memoryDeviceIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  
};

VkDeviceGroupBindSparseInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupBindSparseInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupBindSparseInfoKHR.byteLength = 0x18;

VkDeviceGroupBindSparseInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  resourceDeviceIndex: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  memoryDeviceIndex: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkDeviceGroupPresentCapabilitiesKHR **/
class VkDeviceGroupPresentCapabilitiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x98) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x98) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x98) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x98);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._presentMask = [...Array(32)].fill(0x0);
    
    this.sType = 0x3B9BB467;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentCapabilitiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupPresentCapabilitiesKHR.pNext' isn't allowed to be filled");
  }
  get presentMask() {
    return [
      this.memoryViewUint32[0x4],
      this.memoryViewUint32[0x5],
      this.memoryViewUint32[0x6],
      this.memoryViewUint32[0x7],
      this.memoryViewUint32[0x8],
      this.memoryViewUint32[0x9],
      this.memoryViewUint32[0xA],
      this.memoryViewUint32[0xB],
      this.memoryViewUint32[0xC],
      this.memoryViewUint32[0xD],
      this.memoryViewUint32[0xE],
      this.memoryViewUint32[0xF],
      this.memoryViewUint32[0x10],
      this.memoryViewUint32[0x11],
      this.memoryViewUint32[0x12],
      this.memoryViewUint32[0x13],
      this.memoryViewUint32[0x14],
      this.memoryViewUint32[0x15],
      this.memoryViewUint32[0x16],
      this.memoryViewUint32[0x17],
      this.memoryViewUint32[0x18],
      this.memoryViewUint32[0x19],
      this.memoryViewUint32[0x1A],
      this.memoryViewUint32[0x1B],
      this.memoryViewUint32[0x1C],
      this.memoryViewUint32[0x1D],
      this.memoryViewUint32[0x1E],
      this.memoryViewUint32[0x1F],
      this.memoryViewUint32[0x20],
      this.memoryViewUint32[0x21],
      this.memoryViewUint32[0x22],
      this.memoryViewUint32[0x23]
    ];
  }
  get modes() {
    return this.memoryViewInt32[0x24];
  }
  
};

VkDeviceGroupPresentCapabilitiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupPresentCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x98));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x98), 0x0);
  
  
  
  
};

VkDeviceGroupPresentCapabilitiesKHR.byteLength = 0x98;

VkDeviceGroupPresentCapabilitiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  presentMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x80
  }),
  modes: Object.freeze({
    byteOffset: 0x90,
    byteLength: 0x4
  }),
});
/** VkImageSwapchainCreateInfoKHR **/
class VkImageSwapchainCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._swapchain = null;
    this.sType = 0x3B9BB468;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSwapchainCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageSwapchainCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get swapchain() {
    return this._swapchain;
  }
  set swapchain(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._swapchain = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageSwapchainCreateInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageSwapchainCreateInfoKHR.byteLength = 0x18;

VkImageSwapchainCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  swapchain: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkBindImageMemorySwapchainInfoKHR **/
class VkBindImageMemorySwapchainInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._swapchain = null;
    
    this.sType = 0x3B9BB469;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
      if (opts.imageIndex !== void 0) this.imageIndex = opts.imageIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemorySwapchainInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBindImageMemorySwapchainInfoKHR.pNext' isn't allowed to be filled");
  }
  get swapchain() {
    return this._swapchain;
  }
  set swapchain(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._swapchain = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindImageMemorySwapchainInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + value.constructor.name + "'");
    }
  }
  get imageIndex() {
    return this.memoryViewUint32[0x6];
  }
  set imageIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImageMemorySwapchainInfoKHR.imageIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  
};

VkBindImageMemorySwapchainInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImageMemorySwapchainInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImageMemorySwapchainInfoKHR.byteLength = 0x20;

VkBindImageMemorySwapchainInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  swapchain: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  imageIndex: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkAcquireNextImageInfoKHR **/
class VkAcquireNextImageInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._swapchain = null;
    
    this._semaphore = null;
    this._fence = null;
    
    this.sType = 0x3B9BB46A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.swapchain !== void 0) this.swapchain = opts.swapchain;
      if (opts.timeout !== void 0) this.timeout = opts.timeout;
      if (opts.semaphore !== void 0) this.semaphore = opts.semaphore;
      if (opts.fence !== void 0) this.fence = opts.fence;
      if (opts.deviceMask !== void 0) this.deviceMask = opts.deviceMask;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkAcquireNextImageInfoKHR.pNext' isn't allowed to be filled");
  }
  get swapchain() {
    return this._swapchain;
  }
  set swapchain(value) {
    if (value !== null && value.constructor === VkSwapchainKHR) {
      
      this._swapchain = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._swapchain = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.swapchain': Expected 'VkSwapchainKHR' but got '" + value.constructor.name + "'");
    }
  }
  get timeout() {
    return this.memoryViewBigUint64[0x3];
  }
  set timeout(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.timeout': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get semaphore() {
    return this._semaphore;
  }
  set semaphore(value) {
    if (value !== null && value.constructor === VkSemaphore) {
      
      this._semaphore = value;
      
      this.memoryViewBigInt64[0x4] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._semaphore = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.semaphore': Expected 'VkSemaphore' but got '" + value.constructor.name + "'");
    }
  }
  get fence() {
    return this._fence;
  }
  set fence(value) {
    if (value !== null && value.constructor === VkFence) {
      
      this._fence = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._fence = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.fence': Expected 'VkFence' but got '" + value.constructor.name + "'");
    }
  }
  get deviceMask() {
    return this.memoryViewUint32[0xC];
  }
  set deviceMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAcquireNextImageInfoKHR.deviceMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  
};

VkAcquireNextImageInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAcquireNextImageInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAcquireNextImageInfoKHR.byteLength = 0x38;

VkAcquireNextImageInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  swapchain: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  timeout: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  semaphore: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  fence: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  deviceMask: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
});
/** VkDeviceGroupPresentInfoKHR **/
class VkDeviceGroupPresentInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDeviceMasks = null;
    
    this.sType = 0x3B9BB46B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
      if (opts.pDeviceMasks !== void 0) this.pDeviceMasks = opts.pDeviceMasks;
      if (opts.mode !== void 0) this.mode = opts.mode;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupPresentInfoKHR.pNext' isn't allowed to be filled");
  }
  get swapchainCount() {
    return this.memoryViewUint32[0x4];
  }
  set swapchainCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.swapchainCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pDeviceMasks() {
    return this._pDeviceMasks;
  }
  set pDeviceMasks(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceMasks = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceMasks = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.pDeviceMasks': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  get mode() {
    return this.memoryViewInt32[0x8];
  }
  set mode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupPresentInfoKHR.mode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkDeviceGroupPresentInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupPresentInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupPresentInfoKHR.byteLength = 0x28;

VkDeviceGroupPresentInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  swapchainCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDeviceMasks: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  mode: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkDeviceGroupDeviceCreateInfo **/
class VkDeviceGroupDeviceCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pPhysicalDevices = null;
    this._pPhysicalDevicesNative = null;
    this.sType = 0x3B9BDB71;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.physicalDeviceCount !== void 0) this.physicalDeviceCount = opts.physicalDeviceCount;
      if (opts.pPhysicalDevices !== void 0) this.pPhysicalDevices = opts.pPhysicalDevices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupDeviceCreateInfo.pNext' isn't allowed to be filled");
  }
  get physicalDeviceCount() {
    return this.memoryViewUint32[0x4];
  }
  set physicalDeviceCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.physicalDeviceCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pPhysicalDevices() {
    return this._pPhysicalDevices;
  }
  set pPhysicalDevices(value) {
    if (value !== null && value.constructor === Array) {
      this._pPhysicalDevices = value;
    } else if (value === null) {
      this._pPhysicalDevices = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices': Expected 'Array VkPhysicalDevice' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDeviceGroupDeviceCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPhysicalDevices !== null) {
    let array = this._pPhysicalDevices;
    if (array.length !== this.physicalDeviceCount) {
      throw new RangeError("Invalid array length, expected length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkPhysicalDevice) {
        throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfo.pPhysicalDevices[" + ii + "]': Expected 'VkPhysicalDevice' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pPhysicalDevicesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkDeviceGroupDeviceCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDeviceGroupDeviceCreateInfo.byteLength = 0x20;

VkDeviceGroupDeviceCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  physicalDeviceCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pPhysicalDevices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDeviceGroupDeviceCreateInfoKHR **/
class VkDeviceGroupDeviceCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pPhysicalDevices = null;
    this._pPhysicalDevicesNative = null;
    this.sType = 0x3B9BDB71;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.physicalDeviceCount !== void 0) this.physicalDeviceCount = opts.physicalDeviceCount;
      if (opts.pPhysicalDevices !== void 0) this.pPhysicalDevices = opts.pPhysicalDevices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupDeviceCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get physicalDeviceCount() {
    return this.memoryViewUint32[0x4];
  }
  set physicalDeviceCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.physicalDeviceCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pPhysicalDevices() {
    return this._pPhysicalDevices;
  }
  set pPhysicalDevices(value) {
    if (value !== null && value.constructor === Array) {
      this._pPhysicalDevices = value;
    } else if (value === null) {
      this._pPhysicalDevices = null;
    } else {
      throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices': Expected 'Array VkPhysicalDevice' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDeviceGroupDeviceCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPhysicalDevices !== null) {
    let array = this._pPhysicalDevices;
    if (array.length !== this.physicalDeviceCount) {
      throw new RangeError("Invalid array length, expected length of 'physicalDeviceCount' for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkPhysicalDevice) {
        throw new TypeError("Invalid type for 'VkDeviceGroupDeviceCreateInfoKHR.pPhysicalDevices[" + ii + "]': Expected 'VkPhysicalDevice' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pPhysicalDevicesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkDeviceGroupDeviceCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDeviceGroupDeviceCreateInfoKHR.byteLength = 0x20;

VkDeviceGroupDeviceCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  physicalDeviceCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pPhysicalDevices: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDeviceGroupSwapchainCreateInfoKHR **/
class VkDeviceGroupSwapchainCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BB46C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.modes !== void 0) this.modes = opts.modes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSwapchainCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceGroupSwapchainCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get modes() {
    return this.memoryViewInt32[0x4];
  }
  set modes(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceGroupSwapchainCreateInfoKHR.modes': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkDeviceGroupSwapchainCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceGroupSwapchainCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceGroupSwapchainCreateInfoKHR.byteLength = 0x18;

VkDeviceGroupSwapchainCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  modes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDescriptorUpdateTemplateEntry **/
class VkDescriptorUpdateTemplateEntry {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
      if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
      if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
      if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.stride !== void 0) this.stride = opts.stride;
      
    }
  }
  get dstBinding() {
    return this.memoryViewUint32[0x0];
  }
  set dstBinding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.dstBinding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get dstArrayElement() {
    return this.memoryViewUint32[0x1];
  }
  set dstArrayElement(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.dstArrayElement': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get descriptorCount() {
    return this.memoryViewUint32[0x2];
  }
  set descriptorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.descriptorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get descriptorType() {
    return this.memoryViewInt32[0x3];
  }
  set descriptorType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.descriptorType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  get offset() {
    return this.memoryViewBigInt64[0x2];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x2] = value;
  }
  get stride() {
    return this.memoryViewBigInt64[0x3];
  }
  set stride(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntry.stride': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x3] = value;
  }
  
};

VkDescriptorUpdateTemplateEntry.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorUpdateTemplateEntry.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorUpdateTemplateEntry.byteLength = 0x20;

VkDescriptorUpdateTemplateEntry.memoryLayout = Object.freeze({
  dstBinding: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  dstArrayElement: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  descriptorCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  descriptorType: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  offset: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  stride: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDescriptorUpdateTemplateEntryKHR **/
class VkDescriptorUpdateTemplateEntryKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.dstBinding !== void 0) this.dstBinding = opts.dstBinding;
      if (opts.dstArrayElement !== void 0) this.dstArrayElement = opts.dstArrayElement;
      if (opts.descriptorCount !== void 0) this.descriptorCount = opts.descriptorCount;
      if (opts.descriptorType !== void 0) this.descriptorType = opts.descriptorType;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.stride !== void 0) this.stride = opts.stride;
      
    }
  }
  get dstBinding() {
    return this.memoryViewUint32[0x0];
  }
  set dstBinding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.dstBinding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get dstArrayElement() {
    return this.memoryViewUint32[0x1];
  }
  set dstArrayElement(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.dstArrayElement': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get descriptorCount() {
    return this.memoryViewUint32[0x2];
  }
  set descriptorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.descriptorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get descriptorType() {
    return this.memoryViewInt32[0x3];
  }
  set descriptorType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.descriptorType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  get offset() {
    return this.memoryViewBigInt64[0x2];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x2] = value;
  }
  get stride() {
    return this.memoryViewBigInt64[0x3];
  }
  set stride(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateEntryKHR.stride': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x3] = value;
  }
  
};

VkDescriptorUpdateTemplateEntryKHR.prototype.flush = function flush() {
  
  return true;
};

VkDescriptorUpdateTemplateEntryKHR.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDescriptorUpdateTemplateEntryKHR.byteLength = 0x20;

VkDescriptorUpdateTemplateEntryKHR.memoryLayout = Object.freeze({
  dstBinding: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  dstArrayElement: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  descriptorCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  descriptorType: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
  offset: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  stride: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDescriptorUpdateTemplateCreateInfo **/
class VkDescriptorUpdateTemplateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pDescriptorUpdateEntries = null;
    this._pDescriptorUpdateEntriesNative = null;
    
    this._descriptorSetLayout = null;
    
    this._pipelineLayout = null;
    
    this.sType = 0x3B9C1608;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.descriptorUpdateEntryCount !== void 0) this.descriptorUpdateEntryCount = opts.descriptorUpdateEntryCount;
      if (opts.pDescriptorUpdateEntries !== void 0) this.pDescriptorUpdateEntries = opts.pDescriptorUpdateEntries;
      if (opts.templateType !== void 0) this.templateType = opts.templateType;
      if (opts.descriptorSetLayout !== void 0) this.descriptorSetLayout = opts.descriptorSetLayout;
      if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
      if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
      if (opts.set !== void 0) this.set = opts.set;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDescriptorUpdateTemplateCreateInfo.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get descriptorUpdateEntryCount() {
    return this.memoryViewUint32[0x5];
  }
  set descriptorUpdateEntryCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.descriptorUpdateEntryCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pDescriptorUpdateEntries() {
    return this._pDescriptorUpdateEntries;
  }
  set pDescriptorUpdateEntries(value) {
    if (value !== null && value.constructor === Array) {
      this._pDescriptorUpdateEntries = value;
    } else if (value === null) {
      this._pDescriptorUpdateEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries': Expected 'Array VkDescriptorUpdateTemplateEntry' but got '" + value.constructor.name + "'");
    }
  }
  get templateType() {
    return this.memoryViewInt32[0x8];
  }
  set templateType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.templateType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get descriptorSetLayout() {
    return this._descriptorSetLayout;
  }
  set descriptorSetLayout(value) {
    if (value !== null && value.constructor === VkDescriptorSetLayout) {
      
      this._descriptorSetLayout = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._descriptorSetLayout = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.descriptorSetLayout': Expected 'VkDescriptorSetLayout' but got '" + value.constructor.name + "'");
    }
  }
  get pipelineBindPoint() {
    return this.memoryViewInt32[0xC];
  }
  set pipelineBindPoint(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pipelineBindPoint': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  get pipelineLayout() {
    return this._pipelineLayout;
  }
  set pipelineLayout(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pipelineLayout': Expected 'VkPipelineLayout' but got '" + value.constructor.name + "'");
    }
  }
  get set() {
    return this.memoryViewUint32[0x10];
  }
  set set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.set': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x10] = value;
  }
  
};

VkDescriptorUpdateTemplateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDescriptorUpdateEntries !== null) {
    let array = this._pDescriptorUpdateEntries;
    if (array.length !== this.descriptorUpdateEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDescriptorUpdateTemplateEntry) {
        throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfo.pDescriptorUpdateEntries[" + ii + "]': Expected 'VkDescriptorUpdateTemplateEntry' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pDescriptorUpdateEntriesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkDescriptorUpdateTemplateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorUpdateTemplateCreateInfo.byteLength = 0x48;

VkDescriptorUpdateTemplateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  descriptorUpdateEntryCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pDescriptorUpdateEntries: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  templateType: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  descriptorSetLayout: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  pipelineBindPoint: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pipelineLayout: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  set: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
});
/** VkDescriptorUpdateTemplateCreateInfoKHR **/
class VkDescriptorUpdateTemplateCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pDescriptorUpdateEntries = null;
    this._pDescriptorUpdateEntriesNative = null;
    
    this._descriptorSetLayout = null;
    
    this._pipelineLayout = null;
    
    this.sType = 0x3B9C1608;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.descriptorUpdateEntryCount !== void 0) this.descriptorUpdateEntryCount = opts.descriptorUpdateEntryCount;
      if (opts.pDescriptorUpdateEntries !== void 0) this.pDescriptorUpdateEntries = opts.pDescriptorUpdateEntries;
      if (opts.templateType !== void 0) this.templateType = opts.templateType;
      if (opts.descriptorSetLayout !== void 0) this.descriptorSetLayout = opts.descriptorSetLayout;
      if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
      if (opts.pipelineLayout !== void 0) this.pipelineLayout = opts.pipelineLayout;
      if (opts.set !== void 0) this.set = opts.set;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDescriptorUpdateTemplateCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get descriptorUpdateEntryCount() {
    return this.memoryViewUint32[0x5];
  }
  set descriptorUpdateEntryCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.descriptorUpdateEntryCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pDescriptorUpdateEntries() {
    return this._pDescriptorUpdateEntries;
  }
  set pDescriptorUpdateEntries(value) {
    if (value !== null && value.constructor === Array) {
      this._pDescriptorUpdateEntries = value;
    } else if (value === null) {
      this._pDescriptorUpdateEntries = null;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries': Expected 'Array VkDescriptorUpdateTemplateEntry' but got '" + value.constructor.name + "'");
    }
  }
  get templateType() {
    return this.memoryViewInt32[0x8];
  }
  set templateType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.templateType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get descriptorSetLayout() {
    return this._descriptorSetLayout;
  }
  set descriptorSetLayout(value) {
    if (value !== null && value.constructor === VkDescriptorSetLayout) {
      
      this._descriptorSetLayout = value;
      
      this.memoryViewBigInt64[0x5] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._descriptorSetLayout = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.descriptorSetLayout': Expected 'VkDescriptorSetLayout' but got '" + value.constructor.name + "'");
    }
  }
  get pipelineBindPoint() {
    return this.memoryViewInt32[0xC];
  }
  set pipelineBindPoint(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pipelineBindPoint': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  get pipelineLayout() {
    return this._pipelineLayout;
  }
  set pipelineLayout(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._pipelineLayout = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._pipelineLayout = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pipelineLayout': Expected 'VkPipelineLayout' but got '" + value.constructor.name + "'");
    }
  }
  get set() {
    return this.memoryViewUint32[0x10];
  }
  set set(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.set': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x10] = value;
  }
  
};

VkDescriptorUpdateTemplateCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDescriptorUpdateEntries !== null) {
    let array = this._pDescriptorUpdateEntries;
    if (array.length !== this.descriptorUpdateEntryCount) {
      throw new RangeError("Invalid array length, expected length of 'descriptorUpdateEntryCount' for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDescriptorUpdateTemplateEntry) {
        throw new TypeError("Invalid type for 'VkDescriptorUpdateTemplateCreateInfoKHR.pDescriptorUpdateEntries[" + ii + "]': Expected 'VkDescriptorUpdateTemplateEntry' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pDescriptorUpdateEntriesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkDescriptorUpdateTemplateCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDescriptorUpdateTemplateCreateInfoKHR.byteLength = 0x48;

VkDescriptorUpdateTemplateCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  descriptorUpdateEntryCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pDescriptorUpdateEntries: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  templateType: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  descriptorSetLayout: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  pipelineBindPoint: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pipelineLayout: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  set: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
});
/** VkXYColorEXT **/
class VkXYColorEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.x !== void 0) this.x = opts.x;
      if (opts.y !== void 0) this.y = opts.y;
      
    }
  }
  get x() {
    return this.memoryViewFloat32[0x0];
  }
  set x(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkXYColorEXT.x': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x0] = value;
  }
  get y() {
    return this.memoryViewFloat32[0x1];
  }
  set y(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkXYColorEXT.y': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x1] = value;
  }
  
};

VkXYColorEXT.prototype.flush = function flush() {
  
  return true;
};

VkXYColorEXT.prototype.reflect = function reflect(memoryAddress) {
  
};

VkXYColorEXT.byteLength = 0x8;

VkXYColorEXT.memoryLayout = Object.freeze({
  x: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  y: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkHdrMetadataEXT **/
class VkHdrMetadataEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._displayPrimaryRed = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this._displayPrimaryGreen = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    this._displayPrimaryBlue = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x20 });
    this._whitePoint = new VkXYColorEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x28 });
    
    
    
    
    this.sType = 0x3B9C6428;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.displayPrimaryRed !== void 0) this.displayPrimaryRed = opts.displayPrimaryRed;
      if (opts.displayPrimaryGreen !== void 0) this.displayPrimaryGreen = opts.displayPrimaryGreen;
      if (opts.displayPrimaryBlue !== void 0) this.displayPrimaryBlue = opts.displayPrimaryBlue;
      if (opts.whitePoint !== void 0) this.whitePoint = opts.whitePoint;
      if (opts.maxLuminance !== void 0) this.maxLuminance = opts.maxLuminance;
      if (opts.minLuminance !== void 0) this.minLuminance = opts.minLuminance;
      if (opts.maxContentLightLevel !== void 0) this.maxContentLightLevel = opts.maxContentLightLevel;
      if (opts.maxFrameAverageLightLevel !== void 0) this.maxFrameAverageLightLevel = opts.maxFrameAverageLightLevel;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkHdrMetadataEXT.pNext' isn't allowed to be filled");
  }
  get displayPrimaryRed() {
    return this._displayPrimaryRed;
  }
  set displayPrimaryRed(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryRed = value;
      
      
    } else if (value === null) {
      this._displayPrimaryRed = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryRed': Expected 'VkXYColorEXT' but got '" + value.constructor.name + "'");
    }
  }
  get displayPrimaryGreen() {
    return this._displayPrimaryGreen;
  }
  set displayPrimaryGreen(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryGreen = value;
      
      
    } else if (value === null) {
      this._displayPrimaryGreen = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryGreen': Expected 'VkXYColorEXT' but got '" + value.constructor.name + "'");
    }
  }
  get displayPrimaryBlue() {
    return this._displayPrimaryBlue;
  }
  set displayPrimaryBlue(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._displayPrimaryBlue = value;
      
      
    } else if (value === null) {
      this._displayPrimaryBlue = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.displayPrimaryBlue': Expected 'VkXYColorEXT' but got '" + value.constructor.name + "'");
    }
  }
  get whitePoint() {
    return this._whitePoint;
  }
  set whitePoint(value) {
    if (value !== null && value.constructor === VkXYColorEXT) {
      value.flush();
      this._whitePoint = value;
      
      
    } else if (value === null) {
      this._whitePoint = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.whitePoint': Expected 'VkXYColorEXT' but got '" + value.constructor.name + "'");
    }
  }
  get maxLuminance() {
    return this.memoryViewFloat32[0xC];
  }
  set maxLuminance(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.maxLuminance': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xC] = value;
  }
  get minLuminance() {
    return this.memoryViewFloat32[0xD];
  }
  set minLuminance(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.minLuminance': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xD] = value;
  }
  get maxContentLightLevel() {
    return this.memoryViewFloat32[0xE];
  }
  set maxContentLightLevel(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.maxContentLightLevel': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xE] = value;
  }
  get maxFrameAverageLightLevel() {
    return this.memoryViewFloat32[0xF];
  }
  set maxFrameAverageLightLevel(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkHdrMetadataEXT.maxFrameAverageLightLevel': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0xF] = value;
  }
  
};

VkHdrMetadataEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._displayPrimaryRed !== null) {
    this._displayPrimaryRed.flush();
    if (this.memoryBuffer !== this._displayPrimaryRed.memoryBuffer) {
      let srcView = new Uint8Array(this._displayPrimaryRed.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
    }
  }
  
  
  if (this._displayPrimaryGreen !== null) {
    this._displayPrimaryGreen.flush();
    if (this.memoryBuffer !== this._displayPrimaryGreen.memoryBuffer) {
      let srcView = new Uint8Array(this._displayPrimaryGreen.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
    }
  }
  
  
  if (this._displayPrimaryBlue !== null) {
    this._displayPrimaryBlue.flush();
    if (this.memoryBuffer !== this._displayPrimaryBlue.memoryBuffer) {
      let srcView = new Uint8Array(this._displayPrimaryBlue.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x20);
    }
  }
  
  
  if (this._whitePoint !== null) {
    this._whitePoint.flush();
    if (this.memoryBuffer !== this._whitePoint.memoryBuffer) {
      let srcView = new Uint8Array(this._whitePoint.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x28);
    }
  }
  
  return true;
};

VkHdrMetadataEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
  
  
};

VkHdrMetadataEXT.byteLength = 0x40;

VkHdrMetadataEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  displayPrimaryRed: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  displayPrimaryGreen: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  displayPrimaryBlue: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  whitePoint: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  maxLuminance: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  minLuminance: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  maxContentLightLevel: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  maxFrameAverageLightLevel: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
});
/** VkRefreshCycleDurationGOOGLE **/
class VkRefreshCycleDurationGOOGLE {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x8) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    
    if (typeof opts === "object") {
      
    }
  }
  get refreshDuration() {
    return this.memoryViewBigUint64[0x0];
  }
  
};

VkRefreshCycleDurationGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkRefreshCycleDurationGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x8));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x8), 0x0);
};

VkRefreshCycleDurationGOOGLE.byteLength = 0x8;

VkRefreshCycleDurationGOOGLE.memoryLayout = Object.freeze({
  refreshDuration: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
});
/** VkPastPresentationTimingGOOGLE **/
class VkPastPresentationTimingGOOGLE {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get presentID() {
    return this.memoryViewUint32[0x0];
  }
  get desiredPresentTime() {
    return this.memoryViewBigUint64[0x1];
  }
  get actualPresentTime() {
    return this.memoryViewBigUint64[0x2];
  }
  get earliestPresentTime() {
    return this.memoryViewBigUint64[0x3];
  }
  get presentMargin() {
    return this.memoryViewBigUint64[0x4];
  }
  
};

VkPastPresentationTimingGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkPastPresentationTimingGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
};

VkPastPresentationTimingGOOGLE.byteLength = 0x28;

VkPastPresentationTimingGOOGLE.memoryLayout = Object.freeze({
  presentID: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  desiredPresentTime: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  actualPresentTime: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  earliestPresentTime: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  presentMargin: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkPresentTimesInfoGOOGLE **/
class VkPresentTimesInfoGOOGLE {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pTimes = null;
    this._pTimesNative = null;
    this.sType = 0x3B9C3160;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.swapchainCount !== void 0) this.swapchainCount = opts.swapchainCount;
      if (opts.pTimes !== void 0) this.pTimes = opts.pTimes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPresentTimesInfoGOOGLE.pNext' isn't allowed to be filled");
  }
  get swapchainCount() {
    return this.memoryViewUint32[0x4];
  }
  set swapchainCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.swapchainCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pTimes() {
    return this._pTimes;
  }
  set pTimes(value) {
    if (value !== null && value.constructor === Array) {
      this._pTimes = value;
    } else if (value === null) {
      this._pTimes = null;
    } else {
      throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.pTimes': Expected 'Array VkPresentTimeGOOGLE' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPresentTimesInfoGOOGLE.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pTimes !== null) {
    let array = this._pTimes;
    if (array.length !== this.swapchainCount) {
      throw new RangeError("Invalid array length, expected length of 'swapchainCount' for 'VkPresentTimesInfoGOOGLE.pTimes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkPresentTimeGOOGLE) {
        throw new TypeError("Invalid type for 'VkPresentTimesInfoGOOGLE.pTimes[" + ii + "]': Expected 'VkPresentTimeGOOGLE' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pTimesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkPresentTimesInfoGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPresentTimesInfoGOOGLE.byteLength = 0x20;

VkPresentTimesInfoGOOGLE.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  swapchainCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pTimes: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPresentTimeGOOGLE **/
class VkPresentTimeGOOGLE {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.presentID !== void 0) this.presentID = opts.presentID;
      if (opts.desiredPresentTime !== void 0) this.desiredPresentTime = opts.desiredPresentTime;
      
    }
  }
  get presentID() {
    return this.memoryViewUint32[0x0];
  }
  set presentID(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPresentTimeGOOGLE.presentID': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get desiredPresentTime() {
    return this.memoryViewBigUint64[0x1];
  }
  set desiredPresentTime(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkPresentTimeGOOGLE.desiredPresentTime': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x1] = value;
  }
  
};

VkPresentTimeGOOGLE.prototype.flush = function flush() {
  
  return true;
};

VkPresentTimeGOOGLE.prototype.reflect = function reflect(memoryAddress) {
  
};

VkPresentTimeGOOGLE.byteLength = 0x10;

VkPresentTimeGOOGLE.memoryLayout = Object.freeze({
  presentID: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  desiredPresentTime: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkMacOSSurfaceCreateInfoMVK **/
class VkMacOSSurfaceCreateInfoMVK {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pView = null;
    this.sType = 0x3B9CAA78;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pView !== void 0) this.pView = opts.pView;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMacOSSurfaceCreateInfoMVK.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMacOSSurfaceCreateInfoMVK.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMacOSSurfaceCreateInfoMVK.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get pView() {
    return this._pView;
  }
  set pView(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pView = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pView = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMacOSSurfaceCreateInfoMVK.pView': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkMacOSSurfaceCreateInfoMVK.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMacOSSurfaceCreateInfoMVK.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMacOSSurfaceCreateInfoMVK.byteLength = 0x20;

VkMacOSSurfaceCreateInfoMVK.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pView: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkViewportWScalingNV **/
class VkViewportWScalingNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.xcoeff !== void 0) this.xcoeff = opts.xcoeff;
      if (opts.ycoeff !== void 0) this.ycoeff = opts.ycoeff;
      
    }
  }
  get xcoeff() {
    return this.memoryViewFloat32[0x0];
  }
  set xcoeff(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportWScalingNV.xcoeff': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x0] = value;
  }
  get ycoeff() {
    return this.memoryViewFloat32[0x1];
  }
  set ycoeff(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportWScalingNV.ycoeff': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x1] = value;
  }
  
};

VkViewportWScalingNV.prototype.flush = function flush() {
  
  return true;
};

VkViewportWScalingNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkViewportWScalingNV.byteLength = 0x8;

VkViewportWScalingNV.memoryLayout = Object.freeze({
  xcoeff: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  ycoeff: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkPipelineViewportWScalingStateCreateInfoNV **/
class VkPipelineViewportWScalingStateCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pViewportWScalings = null;
    this._pViewportWScalingsNative = null;
    this.sType = 0x3B9C1DD8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.viewportWScalingEnable !== void 0) this.viewportWScalingEnable = opts.viewportWScalingEnable;
      if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
      if (opts.pViewportWScalings !== void 0) this.pViewportWScalings = opts.pViewportWScalings;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineViewportWScalingStateCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get viewportWScalingEnable() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set viewportWScalingEnable(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get viewportCount() {
    return this.memoryViewUint32[0x5];
  }
  set viewportCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.viewportCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pViewportWScalings() {
    return this._pViewportWScalings;
  }
  set pViewportWScalings(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewportWScalings = value;
    } else if (value === null) {
      this._pViewportWScalings = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings': Expected 'Array VkViewportWScalingNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineViewportWScalingStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewportWScalings !== null) {
    let array = this._pViewportWScalings;
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkViewportWScalingNV) {
        throw new TypeError("Invalid type for 'VkPipelineViewportWScalingStateCreateInfoNV.pViewportWScalings[" + ii + "]': Expected 'VkViewportWScalingNV' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pViewportWScalingsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkPipelineViewportWScalingStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportWScalingStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportWScalingStateCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  viewportWScalingEnable: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  viewportCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pViewportWScalings: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkViewportSwizzleNV **/
class VkViewportSwizzleNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    
    if (typeof opts === "object") {
      if (opts.x !== void 0) this.x = opts.x;
      if (opts.y !== void 0) this.y = opts.y;
      if (opts.z !== void 0) this.z = opts.z;
      if (opts.w !== void 0) this.w = opts.w;
      
    }
  }
  get x() {
    return this.memoryViewInt32[0x0];
  }
  set x(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportSwizzleNV.x': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get y() {
    return this.memoryViewInt32[0x1];
  }
  set y(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportSwizzleNV.y': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x1] = value;
  }
  get z() {
    return this.memoryViewInt32[0x2];
  }
  set z(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportSwizzleNV.z': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  get w() {
    return this.memoryViewInt32[0x3];
  }
  set w(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkViewportSwizzleNV.w': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x3] = value;
  }
  
};

VkViewportSwizzleNV.prototype.flush = function flush() {
  
  return true;
};

VkViewportSwizzleNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkViewportSwizzleNV.byteLength = 0x10;

VkViewportSwizzleNV.memoryLayout = Object.freeze({
  x: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  y: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  z: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  w: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
});
/** VkPipelineViewportSwizzleStateCreateInfoNV **/
class VkPipelineViewportSwizzleStateCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pViewportSwizzles = null;
    this._pViewportSwizzlesNative = null;
    this.sType = 0x3B9C48D0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
      if (opts.pViewportSwizzles !== void 0) this.pViewportSwizzles = opts.pViewportSwizzles;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineViewportSwizzleStateCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get viewportCount() {
    return this.memoryViewUint32[0x5];
  }
  set viewportCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.viewportCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pViewportSwizzles() {
    return this._pViewportSwizzles;
  }
  set pViewportSwizzles(value) {
    if (value !== null && value.constructor === Array) {
      this._pViewportSwizzles = value;
    } else if (value === null) {
      this._pViewportSwizzles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles': Expected 'Array VkViewportSwizzleNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineViewportSwizzleStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pViewportSwizzles !== null) {
    let array = this._pViewportSwizzles;
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkViewportSwizzleNV) {
        throw new TypeError("Invalid type for 'VkPipelineViewportSwizzleStateCreateInfoNV.pViewportSwizzles[" + ii + "]': Expected 'VkViewportSwizzleNV' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pViewportSwizzlesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkPipelineViewportSwizzleStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportSwizzleStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportSwizzleStateCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  viewportCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pViewportSwizzles: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceDiscardRectanglePropertiesEXT **/
class VkPhysicalDeviceDiscardRectanglePropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C4CB8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDiscardRectanglePropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceDiscardRectanglePropertiesEXT.pNext' isn't allowed to be filled");
  }
  get maxDiscardRectangles() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceDiscardRectanglePropertiesEXT.byteLength = 0x18;

VkPhysicalDeviceDiscardRectanglePropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxDiscardRectangles: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPipelineDiscardRectangleStateCreateInfoEXT **/
class VkPipelineDiscardRectangleStateCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._pDiscardRectangles = null;
    this._pDiscardRectanglesNative = null;
    this.sType = 0x3B9C4CB9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.discardRectangleMode !== void 0) this.discardRectangleMode = opts.discardRectangleMode;
      if (opts.discardRectangleCount !== void 0) this.discardRectangleCount = opts.discardRectangleCount;
      if (opts.pDiscardRectangles !== void 0) this.pDiscardRectangles = opts.pDiscardRectangles;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineDiscardRectangleStateCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get discardRectangleMode() {
    return this.memoryViewInt32[0x5];
  }
  set discardRectangleMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get discardRectangleCount() {
    return this.memoryViewUint32[0x6];
  }
  set discardRectangleCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.discardRectangleCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pDiscardRectangles() {
    return this._pDiscardRectangles;
  }
  set pDiscardRectangles(value) {
    if (value !== null && value.constructor === Array) {
      this._pDiscardRectangles = value;
    } else if (value === null) {
      this._pDiscardRectangles = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles': Expected 'Array VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineDiscardRectangleStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pDiscardRectangles !== null) {
    let array = this._pDiscardRectangles;
    if (array.length !== this.discardRectangleCount) {
      throw new RangeError("Invalid array length, expected length of 'discardRectangleCount' for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRect2D) {
        throw new TypeError("Invalid type for 'VkPipelineDiscardRectangleStateCreateInfoEXT.pDiscardRectangles[" + ii + "]': Expected 'VkRect2D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pDiscardRectanglesNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  return true;
};

VkPipelineDiscardRectangleStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineDiscardRectangleStateCreateInfoEXT.byteLength = 0x28;

VkPipelineDiscardRectangleStateCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  discardRectangleMode: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  discardRectangleCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pDiscardRectangles: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX **/
class VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C44E8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.pNext' isn't allowed to be filled");
  }
  get perViewPositionAllComponents() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.byteLength = 0x18;

VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  perViewPositionAllComponents: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkInputAttachmentAspectReference **/
class VkInputAttachmentAspectReference {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.subpass !== void 0) this.subpass = opts.subpass;
      if (opts.inputAttachmentIndex !== void 0) this.inputAttachmentIndex = opts.inputAttachmentIndex;
      if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
      
    }
  }
  get subpass() {
    return this.memoryViewUint32[0x0];
  }
  set subpass(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReference.subpass': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get inputAttachmentIndex() {
    return this.memoryViewUint32[0x1];
  }
  set inputAttachmentIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReference.inputAttachmentIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get aspectMask() {
    return this.memoryViewInt32[0x2];
  }
  set aspectMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReference.aspectMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  
};

VkInputAttachmentAspectReference.prototype.flush = function flush() {
  
  return true;
};

VkInputAttachmentAspectReference.prototype.reflect = function reflect(memoryAddress) {
  
};

VkInputAttachmentAspectReference.byteLength = 0xC;

VkInputAttachmentAspectReference.memoryLayout = Object.freeze({
  subpass: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  inputAttachmentIndex: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  aspectMask: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkInputAttachmentAspectReferenceKHR **/
class VkInputAttachmentAspectReferenceKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.subpass !== void 0) this.subpass = opts.subpass;
      if (opts.inputAttachmentIndex !== void 0) this.inputAttachmentIndex = opts.inputAttachmentIndex;
      if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
      
    }
  }
  get subpass() {
    return this.memoryViewUint32[0x0];
  }
  set subpass(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReferenceKHR.subpass': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get inputAttachmentIndex() {
    return this.memoryViewUint32[0x1];
  }
  set inputAttachmentIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReferenceKHR.inputAttachmentIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get aspectMask() {
    return this.memoryViewInt32[0x2];
  }
  set aspectMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkInputAttachmentAspectReferenceKHR.aspectMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x2] = value;
  }
  
};

VkInputAttachmentAspectReferenceKHR.prototype.flush = function flush() {
  
  return true;
};

VkInputAttachmentAspectReferenceKHR.prototype.reflect = function reflect(memoryAddress) {
  
};

VkInputAttachmentAspectReferenceKHR.byteLength = 0xC;

VkInputAttachmentAspectReferenceKHR.memoryLayout = Object.freeze({
  subpass: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  inputAttachmentIndex: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  aspectMask: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkRenderPassInputAttachmentAspectCreateInfo **/
class VkRenderPassInputAttachmentAspectCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pAspectReferences = null;
    this._pAspectReferencesNative = null;
    this.sType = 0x3B9C9309;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.aspectReferenceCount !== void 0) this.aspectReferenceCount = opts.aspectReferenceCount;
      if (opts.pAspectReferences !== void 0) this.pAspectReferences = opts.pAspectReferences;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRenderPassInputAttachmentAspectCreateInfo.pNext' isn't allowed to be filled");
  }
  get aspectReferenceCount() {
    return this.memoryViewUint32[0x4];
  }
  set aspectReferenceCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.aspectReferenceCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pAspectReferences() {
    return this._pAspectReferences;
  }
  set pAspectReferences(value) {
    if (value !== null && value.constructor === Array) {
      this._pAspectReferences = value;
    } else if (value === null) {
      this._pAspectReferences = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences': Expected 'Array VkInputAttachmentAspectReference' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassInputAttachmentAspectCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAspectReferences !== null) {
    let array = this._pAspectReferences;
    if (array.length !== this.aspectReferenceCount) {
      throw new RangeError("Invalid array length, expected length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkInputAttachmentAspectReference) {
        throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfo.pAspectReferences[" + ii + "]': Expected 'VkInputAttachmentAspectReference' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pAspectReferencesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkRenderPassInputAttachmentAspectCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRenderPassInputAttachmentAspectCreateInfo.byteLength = 0x20;

VkRenderPassInputAttachmentAspectCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  aspectReferenceCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pAspectReferences: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkRenderPassInputAttachmentAspectCreateInfoKHR **/
class VkRenderPassInputAttachmentAspectCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pAspectReferences = null;
    this._pAspectReferencesNative = null;
    this.sType = 0x3B9C9309;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.aspectReferenceCount !== void 0) this.aspectReferenceCount = opts.aspectReferenceCount;
      if (opts.pAspectReferences !== void 0) this.pAspectReferences = opts.pAspectReferences;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRenderPassInputAttachmentAspectCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get aspectReferenceCount() {
    return this.memoryViewUint32[0x4];
  }
  set aspectReferenceCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.aspectReferenceCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pAspectReferences() {
    return this._pAspectReferences;
  }
  set pAspectReferences(value) {
    if (value !== null && value.constructor === Array) {
      this._pAspectReferences = value;
    } else if (value === null) {
      this._pAspectReferences = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences': Expected 'Array VkInputAttachmentAspectReference' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAspectReferences !== null) {
    let array = this._pAspectReferences;
    if (array.length !== this.aspectReferenceCount) {
      throw new RangeError("Invalid array length, expected length of 'aspectReferenceCount' for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkInputAttachmentAspectReference) {
        throw new TypeError("Invalid type for 'VkRenderPassInputAttachmentAspectCreateInfoKHR.pAspectReferences[" + ii + "]': Expected 'VkInputAttachmentAspectReference' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pAspectReferencesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRenderPassInputAttachmentAspectCreateInfoKHR.byteLength = 0x20;

VkRenderPassInputAttachmentAspectCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  aspectReferenceCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pAspectReferences: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceSurfaceInfo2KHR **/
class VkPhysicalDeviceSurfaceInfo2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._surface = null;
    this.sType = 0x3B9C9AD8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.surface !== void 0) this.surface = opts.surface;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceSurfaceInfo2KHR.pNext' isn't allowed to be filled");
  }
  get surface() {
    return this._surface;
  }
  set surface(value) {
    if (value !== null && value.constructor === VkSurfaceKHR) {
      
      this._surface = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._surface = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSurfaceInfo2KHR.surface': Expected 'VkSurfaceKHR' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPhysicalDeviceSurfaceInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSurfaceInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSurfaceInfo2KHR.byteLength = 0x18;

VkPhysicalDeviceSurfaceInfo2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  surface: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkSurfaceCapabilities2KHR **/
class VkSurfaceCapabilities2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._surfaceCapabilities = new VkSurfaceCapabilitiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9C9AD9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9C7B98:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSurfaceCapabilities2KHR.pNext'");
    }
  }
  get surfaceCapabilities() {
    return this._surfaceCapabilities;
  }
  
};

VkSurfaceCapabilities2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceCapabilities2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x48));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x48), 0x0);
  
  
  
  
};

VkSurfaceCapabilities2KHR.byteLength = 0x48;

VkSurfaceCapabilities2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  surfaceCapabilities: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x34
  }),
});
/** VkSurfaceFormat2KHR **/
class VkSurfaceFormat2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._surfaceFormat = new VkSurfaceFormatKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9C9ADA;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSurfaceFormat2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSurfaceFormat2KHR.pNext' isn't allowed to be filled");
  }
  get surfaceFormat() {
    return this._surfaceFormat;
  }
  
};

VkSurfaceFormat2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSurfaceFormat2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
  
  
};

VkSurfaceFormat2KHR.byteLength = 0x18;

VkSurfaceFormat2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  surfaceFormat: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkDisplayProperties2KHR **/
class VkDisplayProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._displayProperties = new VkDisplayPropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9CA2A8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayProperties2KHR.pNext' isn't allowed to be filled");
  }
  get displayProperties() {
    return this._displayProperties;
  }
  
};

VkDisplayProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
};

VkDisplayProperties2KHR.byteLength = 0x40;

VkDisplayProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  displayProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x30
  }),
});
/** VkDisplayPlaneProperties2KHR **/
class VkDisplayPlaneProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._displayPlaneProperties = new VkDisplayPlanePropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9CA2A9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPlaneProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayPlaneProperties2KHR.pNext' isn't allowed to be filled");
  }
  get displayPlaneProperties() {
    return this._displayPlaneProperties;
  }
  
};

VkDisplayPlaneProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkDisplayPlaneProperties2KHR.byteLength = 0x20;

VkDisplayPlaneProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  displayPlaneProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x10
  }),
});
/** VkDisplayModeProperties2KHR **/
class VkDisplayModeProperties2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._displayModeProperties = new VkDisplayModePropertiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9CA2AA;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayModeProperties2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayModeProperties2KHR.pNext' isn't allowed to be filled");
  }
  get displayModeProperties() {
    return this._displayModeProperties;
  }
  
};

VkDisplayModeProperties2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayModeProperties2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkDisplayModeProperties2KHR.byteLength = 0x28;

VkDisplayModeProperties2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  displayModeProperties: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x18
  }),
});
/** VkDisplayPlaneInfo2KHR **/
class VkDisplayPlaneInfo2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._mode = null;
    
    this.sType = 0x3B9CA2AB;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.mode !== void 0) this.mode = opts.mode;
      if (opts.planeIndex !== void 0) this.planeIndex = opts.planeIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPlaneInfo2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayPlaneInfo2KHR.pNext' isn't allowed to be filled");
  }
  get mode() {
    return this._mode;
  }
  set mode(value) {
    if (value !== null && value.constructor === VkDisplayModeKHR) {
      
      this._mode = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._mode = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDisplayPlaneInfo2KHR.mode': Expected 'VkDisplayModeKHR' but got '" + value.constructor.name + "'");
    }
  }
  get planeIndex() {
    return this.memoryViewUint32[0x6];
  }
  set planeIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPlaneInfo2KHR.planeIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  
};

VkDisplayPlaneInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDisplayPlaneInfo2KHR.byteLength = 0x20;

VkDisplayPlaneInfo2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  mode: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  planeIndex: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkDisplayPlaneCapabilities2KHR **/
class VkDisplayPlaneCapabilities2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x58);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._capabilities = new VkDisplayPlaneCapabilitiesKHR({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9CA2AC;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDisplayPlaneCapabilities2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDisplayPlaneCapabilities2KHR.pNext' isn't allowed to be filled");
  }
  get capabilities() {
    return this._capabilities;
  }
  
};

VkDisplayPlaneCapabilities2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDisplayPlaneCapabilities2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x58));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x58), 0x0);
  
  
  
  
};

VkDisplayPlaneCapabilities2KHR.byteLength = 0x58;

VkDisplayPlaneCapabilities2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  capabilities: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x44
  }),
});
/** VkSharedPresentSurfaceCapabilitiesKHR **/
class VkSharedPresentSurfaceCapabilitiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C7B98;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSharedPresentSurfaceCapabilitiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSharedPresentSurfaceCapabilitiesKHR.pNext' isn't allowed to be filled");
  }
  get sharedPresentSupportedUsageFlags() {
    return this.memoryViewInt32[0x4];
  }
  
};

VkSharedPresentSurfaceCapabilitiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSharedPresentSurfaceCapabilitiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkSharedPresentSurfaceCapabilitiesKHR.byteLength = 0x18;

VkSharedPresentSurfaceCapabilitiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  sharedPresentSupportedUsageFlags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDevice16BitStorageFeatures **/
class VkPhysicalDevice16BitStorageFeatures {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this.sType = 0x3B9C0E38;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
      if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
      if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
      if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevice16BitStorageFeatures.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDevice16BitStorageFeatures.pNext' isn't allowed to be filled");
  }
  get storageBuffer16BitAccess() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set storageBuffer16BitAccess(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get uniformAndStorageBuffer16BitAccess() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set uniformAndStorageBuffer16BitAccess(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get storagePushConstant16() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set storagePushConstant16(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  get storageInputOutput16() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  set storageInputOutput16(value) {
    this.memoryViewUint32[0x7] = value | 0;
  }
  
};

VkPhysicalDevice16BitStorageFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice16BitStorageFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDevice16BitStorageFeatures.byteLength = 0x20;

VkPhysicalDevice16BitStorageFeatures.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  storageBuffer16BitAccess: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  uniformAndStorageBuffer16BitAccess: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  storagePushConstant16: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  storageInputOutput16: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkPhysicalDevice16BitStorageFeaturesKHR **/
class VkPhysicalDevice16BitStorageFeaturesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this.sType = 0x3B9C0E38;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.storageBuffer16BitAccess !== void 0) this.storageBuffer16BitAccess = opts.storageBuffer16BitAccess;
      if (opts.uniformAndStorageBuffer16BitAccess !== void 0) this.uniformAndStorageBuffer16BitAccess = opts.uniformAndStorageBuffer16BitAccess;
      if (opts.storagePushConstant16 !== void 0) this.storagePushConstant16 = opts.storagePushConstant16;
      if (opts.storageInputOutput16 !== void 0) this.storageInputOutput16 = opts.storageInputOutput16;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevice16BitStorageFeaturesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDevice16BitStorageFeaturesKHR.pNext' isn't allowed to be filled");
  }
  get storageBuffer16BitAccess() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set storageBuffer16BitAccess(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get uniformAndStorageBuffer16BitAccess() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set uniformAndStorageBuffer16BitAccess(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get storagePushConstant16() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set storagePushConstant16(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  get storageInputOutput16() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  set storageInputOutput16(value) {
    this.memoryViewUint32[0x7] = value | 0;
  }
  
};

VkPhysicalDevice16BitStorageFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice16BitStorageFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDevice16BitStorageFeaturesKHR.byteLength = 0x20;

VkPhysicalDevice16BitStorageFeaturesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  storageBuffer16BitAccess: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  uniformAndStorageBuffer16BitAccess: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  storagePushConstant16: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  storageInputOutput16: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceSubgroupProperties **/
class VkPhysicalDeviceSubgroupProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSubgroupProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceSubgroupProperties.pNext' isn't allowed to be filled");
  }
  get subgroupSize() {
    return this.memoryViewUint32[0x4];
  }
  get supportedStages() {
    return this.memoryViewInt32[0x5];
  }
  get supportedOperations() {
    return this.memoryViewInt32[0x6];
  }
  get quadOperationsInAllStages() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  
};

VkPhysicalDeviceSubgroupProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSubgroupProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceSubgroupProperties.byteLength = 0x20;

VkPhysicalDeviceSubgroupProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  subgroupSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  supportedStages: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  supportedOperations: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  quadOperationsInAllStages: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkBufferMemoryRequirementsInfo2 **/
class VkBufferMemoryRequirementsInfo2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._buffer = null;
    this.sType = 0x3B9D0450;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBufferMemoryRequirementsInfo2.pNext' isn't allowed to be filled");
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBufferMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferMemoryRequirementsInfo2.byteLength = 0x18;

VkBufferMemoryRequirementsInfo2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkBufferMemoryRequirementsInfo2KHR **/
class VkBufferMemoryRequirementsInfo2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._buffer = null;
    this.sType = 0x3B9D0450;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBufferMemoryRequirementsInfo2KHR.pNext' isn't allowed to be filled");
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferMemoryRequirementsInfo2KHR.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBufferMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferMemoryRequirementsInfo2KHR.byteLength = 0x18;

VkBufferMemoryRequirementsInfo2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkImageMemoryRequirementsInfo2 **/
class VkImageMemoryRequirementsInfo2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this.sType = 0x3B9D0451;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
      switch (sType) {
          
        case 0x3B9D2B63:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.pNext'");
    }
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageMemoryRequirementsInfo2.byteLength = 0x18;

VkImageMemoryRequirementsInfo2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkImageMemoryRequirementsInfo2KHR **/
class VkImageMemoryRequirementsInfo2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this.sType = 0x3B9D0451;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9D2B63:
          break;
        default:
          throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.pNext'");
    }
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageMemoryRequirementsInfo2KHR.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageMemoryRequirementsInfo2KHR.byteLength = 0x18;

VkImageMemoryRequirementsInfo2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkImageSparseMemoryRequirementsInfo2 **/
class VkImageSparseMemoryRequirementsInfo2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this.sType = 0x3B9D0452;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageSparseMemoryRequirementsInfo2.pNext' isn't allowed to be filled");
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageSparseMemoryRequirementsInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSparseMemoryRequirementsInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageSparseMemoryRequirementsInfo2.byteLength = 0x18;

VkImageSparseMemoryRequirementsInfo2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkImageSparseMemoryRequirementsInfo2KHR **/
class VkImageSparseMemoryRequirementsInfo2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this.sType = 0x3B9D0452;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageSparseMemoryRequirementsInfo2KHR.pNext' isn't allowed to be filled");
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageSparseMemoryRequirementsInfo2KHR.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageSparseMemoryRequirementsInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageSparseMemoryRequirementsInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageSparseMemoryRequirementsInfo2KHR.byteLength = 0x18;

VkImageSparseMemoryRequirementsInfo2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkMemoryRequirements2 **/
class VkMemoryRequirements2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._memoryRequirements = new VkMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9D0453;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
      switch (sType) {
          
        case 0x3B9CBA18:
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2.pNext'");
    }
  }
  get memoryRequirements() {
    return this._memoryRequirements;
  }
  
};

VkMemoryRequirements2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryRequirements2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkMemoryRequirements2.byteLength = 0x28;

VkMemoryRequirements2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryRequirements: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x18
  }),
});
/** VkMemoryRequirements2KHR **/
class VkMemoryRequirements2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._memoryRequirements = new VkMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9D0453;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9CBA18:
          break;
        default:
          throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryRequirements2KHR.pNext'");
    }
  }
  get memoryRequirements() {
    return this._memoryRequirements;
  }
  
};

VkMemoryRequirements2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryRequirements2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
};

VkMemoryRequirements2KHR.byteLength = 0x28;

VkMemoryRequirements2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryRequirements: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x18
  }),
});
/** VkSparseImageMemoryRequirements2 **/
class VkSparseImageMemoryRequirements2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._memoryRequirements = new VkSparseImageMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9D0454;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryRequirements2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSparseImageMemoryRequirements2.pNext' isn't allowed to be filled");
  }
  get memoryRequirements() {
    return this._memoryRequirements;
  }
  
};

VkSparseImageMemoryRequirements2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageMemoryRequirements2.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
};

VkSparseImageMemoryRequirements2.byteLength = 0x40;

VkSparseImageMemoryRequirements2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryRequirements: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x30
  }),
});
/** VkSparseImageMemoryRequirements2KHR **/
class VkSparseImageMemoryRequirements2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._memoryRequirements = new VkSparseImageMemoryRequirements({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9D0454;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSparseImageMemoryRequirements2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSparseImageMemoryRequirements2KHR.pNext' isn't allowed to be filled");
  }
  get memoryRequirements() {
    return this._memoryRequirements;
  }
  
};

VkSparseImageMemoryRequirements2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSparseImageMemoryRequirements2KHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
  
  
};

VkSparseImageMemoryRequirements2KHR.byteLength = 0x40;

VkSparseImageMemoryRequirements2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryRequirements: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x30
  }),
});
/** VkPhysicalDevicePointClippingProperties **/
class VkPhysicalDevicePointClippingProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C9308;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevicePointClippingProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDevicePointClippingProperties.pNext' isn't allowed to be filled");
  }
  get pointClippingBehavior() {
    return this.memoryViewInt32[0x4];
  }
  
};

VkPhysicalDevicePointClippingProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePointClippingProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDevicePointClippingProperties.byteLength = 0x18;

VkPhysicalDevicePointClippingProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  pointClippingBehavior: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDevicePointClippingPropertiesKHR **/
class VkPhysicalDevicePointClippingPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C9308;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevicePointClippingPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDevicePointClippingPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get pointClippingBehavior() {
    return this.memoryViewInt32[0x4];
  }
  
};

VkPhysicalDevicePointClippingPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePointClippingPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDevicePointClippingPropertiesKHR.byteLength = 0x18;

VkPhysicalDevicePointClippingPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  pointClippingBehavior: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkMemoryDedicatedRequirements **/
class VkMemoryDedicatedRequirements {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9CBA18;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedRequirements.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryDedicatedRequirements.pNext' isn't allowed to be filled");
  }
  get prefersDedicatedAllocation() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  get requiresDedicatedAllocation() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  
};

VkMemoryDedicatedRequirements.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedRequirements.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryDedicatedRequirements.byteLength = 0x18;

VkMemoryDedicatedRequirements.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  prefersDedicatedAllocation: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  requiresDedicatedAllocation: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkMemoryDedicatedRequirementsKHR **/
class VkMemoryDedicatedRequirementsKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9CBA18;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedRequirementsKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryDedicatedRequirementsKHR.pNext' isn't allowed to be filled");
  }
  get prefersDedicatedAllocation() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  get requiresDedicatedAllocation() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  
};

VkMemoryDedicatedRequirementsKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedRequirementsKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryDedicatedRequirementsKHR.byteLength = 0x18;

VkMemoryDedicatedRequirementsKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  prefersDedicatedAllocation: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  requiresDedicatedAllocation: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkMemoryDedicatedAllocateInfo **/
class VkMemoryDedicatedAllocateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this._buffer = null;
    this.sType = 0x3B9CBA19;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryDedicatedAllocateInfo.pNext' isn't allowed to be filled");
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfo.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfo.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkMemoryDedicatedAllocateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedAllocateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryDedicatedAllocateInfo.byteLength = 0x20;

VkMemoryDedicatedAllocateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkMemoryDedicatedAllocateInfoKHR **/
class VkMemoryDedicatedAllocateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._image = null;
    this._buffer = null;
    this.sType = 0x3B9CBA19;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.image !== void 0) this.image = opts.image;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryDedicatedAllocateInfoKHR.pNext' isn't allowed to be filled");
  }
  get image() {
    return this._image;
  }
  set image(value) {
    if (value !== null && value.constructor === VkImage) {
      
      this._image = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._image = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfoKHR.image': Expected 'VkImage' but got '" + value.constructor.name + "'");
    }
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkMemoryDedicatedAllocateInfoKHR.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkMemoryDedicatedAllocateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryDedicatedAllocateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryDedicatedAllocateInfoKHR.byteLength = 0x20;

VkMemoryDedicatedAllocateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  image: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkImageViewUsageCreateInfo **/
class VkImageViewUsageCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C930A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.usage !== void 0) this.usage = opts.usage;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewUsageCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageViewUsageCreateInfo.pNext' isn't allowed to be filled");
  }
  get usage() {
    return this.memoryViewInt32[0x4];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewUsageCreateInfo.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkImageViewUsageCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewUsageCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageViewUsageCreateInfo.byteLength = 0x18;

VkImageViewUsageCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  usage: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkImageViewUsageCreateInfoKHR **/
class VkImageViewUsageCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C930A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.usage !== void 0) this.usage = opts.usage;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewUsageCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageViewUsageCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get usage() {
    return this.memoryViewInt32[0x4];
  }
  set usage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewUsageCreateInfoKHR.usage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkImageViewUsageCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewUsageCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageViewUsageCreateInfoKHR.byteLength = 0x18;

VkImageViewUsageCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  usage: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPipelineTessellationDomainOriginStateCreateInfo **/
class VkPipelineTessellationDomainOriginStateCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C930B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.domainOrigin !== void 0) this.domainOrigin = opts.domainOrigin;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationDomainOriginStateCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineTessellationDomainOriginStateCreateInfo.pNext' isn't allowed to be filled");
  }
  get domainOrigin() {
    return this.memoryViewInt32[0x4];
  }
  set domainOrigin(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationDomainOriginStateCreateInfo.domainOrigin': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPipelineTessellationDomainOriginStateCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationDomainOriginStateCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineTessellationDomainOriginStateCreateInfo.byteLength = 0x18;

VkPipelineTessellationDomainOriginStateCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  domainOrigin: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPipelineTessellationDomainOriginStateCreateInfoKHR **/
class VkPipelineTessellationDomainOriginStateCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C930B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.domainOrigin !== void 0) this.domainOrigin = opts.domainOrigin;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationDomainOriginStateCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineTessellationDomainOriginStateCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get domainOrigin() {
    return this.memoryViewInt32[0x4];
  }
  set domainOrigin(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineTessellationDomainOriginStateCreateInfoKHR.domainOrigin': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineTessellationDomainOriginStateCreateInfoKHR.byteLength = 0x18;

VkPipelineTessellationDomainOriginStateCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  domainOrigin: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkSamplerYcbcrConversionInfo **/
class VkSamplerYcbcrConversionInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._conversion = null;
    this.sType = 0x3B9D2B61;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.conversion !== void 0) this.conversion = opts.conversion;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSamplerYcbcrConversionInfo.pNext' isn't allowed to be filled");
  }
  get conversion() {
    return this._conversion;
  }
  set conversion(value) {
    if (value !== null && value.constructor === VkSamplerYcbcrConversion) {
      
      this._conversion = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._conversion = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfo.conversion': Expected 'VkSamplerYcbcrConversion' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSamplerYcbcrConversionInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSamplerYcbcrConversionInfo.byteLength = 0x18;

VkSamplerYcbcrConversionInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  conversion: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkSamplerYcbcrConversionInfoKHR **/
class VkSamplerYcbcrConversionInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._conversion = null;
    this.sType = 0x3B9D2B61;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.conversion !== void 0) this.conversion = opts.conversion;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSamplerYcbcrConversionInfoKHR.pNext' isn't allowed to be filled");
  }
  get conversion() {
    return this._conversion;
  }
  set conversion(value) {
    if (value !== null && value.constructor === VkSamplerYcbcrConversion) {
      
      this._conversion = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._conversion = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionInfoKHR.conversion': Expected 'VkSamplerYcbcrConversion' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSamplerYcbcrConversionInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSamplerYcbcrConversionInfoKHR.byteLength = 0x18;

VkSamplerYcbcrConversionInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  conversion: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkSamplerYcbcrConversionCreateInfo **/
class VkSamplerYcbcrConversionCreateInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x1C });
    
    
    
    
    this.sType = 0x3B9D2B60;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.ycbcrModel !== void 0) this.ycbcrModel = opts.ycbcrModel;
      if (opts.ycbcrRange !== void 0) this.ycbcrRange = opts.ycbcrRange;
      if (opts.components !== void 0) this.components = opts.components;
      if (opts.xChromaOffset !== void 0) this.xChromaOffset = opts.xChromaOffset;
      if (opts.yChromaOffset !== void 0) this.yChromaOffset = opts.yChromaOffset;
      if (opts.chromaFilter !== void 0) this.chromaFilter = opts.chromaFilter;
      if (opts.forceExplicitReconstruction !== void 0) this.forceExplicitReconstruction = opts.forceExplicitReconstruction;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
      switch (sType) {
          
        case 0x3B9CC1ED:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.pNext'");
    }
  }
  get format() {
    return this.memoryViewInt32[0x4];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get ycbcrModel() {
    return this.memoryViewInt32[0x5];
  }
  set ycbcrModel(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.ycbcrModel': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get ycbcrRange() {
    return this.memoryViewInt32[0x6];
  }
  set ycbcrRange(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.ycbcrRange': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get components() {
    return this._components;
  }
  set components(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.components': Expected 'VkComponentMapping' but got '" + value.constructor.name + "'");
    }
  }
  get xChromaOffset() {
    return this.memoryViewInt32[0xB];
  }
  set xChromaOffset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.xChromaOffset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xB] = value;
  }
  get yChromaOffset() {
    return this.memoryViewInt32[0xC];
  }
  set yChromaOffset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.yChromaOffset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  get chromaFilter() {
    return this.memoryViewInt32[0xD];
  }
  set chromaFilter(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfo.chromaFilter': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xD] = value;
  }
  get forceExplicitReconstruction() {
    return this.memoryViewUint32[0xE] !== 0;
  }
  set forceExplicitReconstruction(value) {
    this.memoryViewUint32[0xE] = value | 0;
  }
  
};

VkSamplerYcbcrConversionCreateInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    this._components.flush();
    if (this.memoryBuffer !== this._components.memoryBuffer) {
      let srcView = new Uint8Array(this._components.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
    }
  }
  
  return true;
};

VkSamplerYcbcrConversionCreateInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkSamplerYcbcrConversionCreateInfo.byteLength = 0x40;

VkSamplerYcbcrConversionCreateInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  format: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  ycbcrModel: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  ycbcrRange: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  components: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x10
  }),
  xChromaOffset: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  yChromaOffset: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  chromaFilter: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  forceExplicitReconstruction: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
});
/** VkSamplerYcbcrConversionCreateInfoKHR **/
class VkSamplerYcbcrConversionCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._components = new VkComponentMapping({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x1C });
    
    
    
    
    this.sType = 0x3B9D2B60;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.ycbcrModel !== void 0) this.ycbcrModel = opts.ycbcrModel;
      if (opts.ycbcrRange !== void 0) this.ycbcrRange = opts.ycbcrRange;
      if (opts.components !== void 0) this.components = opts.components;
      if (opts.xChromaOffset !== void 0) this.xChromaOffset = opts.xChromaOffset;
      if (opts.yChromaOffset !== void 0) this.yChromaOffset = opts.yChromaOffset;
      if (opts.chromaFilter !== void 0) this.chromaFilter = opts.chromaFilter;
      if (opts.forceExplicitReconstruction !== void 0) this.forceExplicitReconstruction = opts.forceExplicitReconstruction;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
      switch (sType) {
          
        case 0x3B9CC1ED:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.pNext'");
    }
  }
  get format() {
    return this.memoryViewInt32[0x4];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get ycbcrModel() {
    return this.memoryViewInt32[0x5];
  }
  set ycbcrModel(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.ycbcrModel': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get ycbcrRange() {
    return this.memoryViewInt32[0x6];
  }
  set ycbcrRange(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.ycbcrRange': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get components() {
    return this._components;
  }
  set components(value) {
    if (value !== null && value.constructor === VkComponentMapping) {
      value.flush();
      this._components = value;
      
      
    } else if (value === null) {
      this._components = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.components': Expected 'VkComponentMapping' but got '" + value.constructor.name + "'");
    }
  }
  get xChromaOffset() {
    return this.memoryViewInt32[0xB];
  }
  set xChromaOffset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.xChromaOffset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xB] = value;
  }
  get yChromaOffset() {
    return this.memoryViewInt32[0xC];
  }
  set yChromaOffset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.yChromaOffset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  get chromaFilter() {
    return this.memoryViewInt32[0xD];
  }
  set chromaFilter(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionCreateInfoKHR.chromaFilter': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xD] = value;
  }
  get forceExplicitReconstruction() {
    return this.memoryViewUint32[0xE] !== 0;
  }
  set forceExplicitReconstruction(value) {
    this.memoryViewUint32[0xE] = value | 0;
  }
  
};

VkSamplerYcbcrConversionCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._components !== null) {
    this._components.flush();
    if (this.memoryBuffer !== this._components.memoryBuffer) {
      let srcView = new Uint8Array(this._components.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x1C);
    }
  }
  
  return true;
};

VkSamplerYcbcrConversionCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkSamplerYcbcrConversionCreateInfoKHR.byteLength = 0x40;

VkSamplerYcbcrConversionCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  format: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  ycbcrModel: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  ycbcrRange: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  components: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x10
  }),
  xChromaOffset: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  yChromaOffset: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  chromaFilter: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  forceExplicitReconstruction: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
});
/** VkBindImagePlaneMemoryInfo **/
class VkBindImagePlaneMemoryInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D2B62;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImagePlaneMemoryInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBindImagePlaneMemoryInfo.pNext' isn't allowed to be filled");
  }
  get planeAspect() {
    return this.memoryViewInt32[0x4];
  }
  set planeAspect(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImagePlaneMemoryInfo.planeAspect': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkBindImagePlaneMemoryInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImagePlaneMemoryInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImagePlaneMemoryInfo.byteLength = 0x18;

VkBindImagePlaneMemoryInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  planeAspect: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkBindImagePlaneMemoryInfoKHR **/
class VkBindImagePlaneMemoryInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D2B62;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImagePlaneMemoryInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBindImagePlaneMemoryInfoKHR.pNext' isn't allowed to be filled");
  }
  get planeAspect() {
    return this.memoryViewInt32[0x4];
  }
  set planeAspect(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindImagePlaneMemoryInfoKHR.planeAspect': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkBindImagePlaneMemoryInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindImagePlaneMemoryInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindImagePlaneMemoryInfoKHR.byteLength = 0x18;

VkBindImagePlaneMemoryInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  planeAspect: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkImagePlaneMemoryRequirementsInfo **/
class VkImagePlaneMemoryRequirementsInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D2B63;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImagePlaneMemoryRequirementsInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImagePlaneMemoryRequirementsInfo.pNext' isn't allowed to be filled");
  }
  get planeAspect() {
    return this.memoryViewInt32[0x4];
  }
  set planeAspect(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImagePlaneMemoryRequirementsInfo.planeAspect': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkImagePlaneMemoryRequirementsInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImagePlaneMemoryRequirementsInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImagePlaneMemoryRequirementsInfo.byteLength = 0x18;

VkImagePlaneMemoryRequirementsInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  planeAspect: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkImagePlaneMemoryRequirementsInfoKHR **/
class VkImagePlaneMemoryRequirementsInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D2B63;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.planeAspect !== void 0) this.planeAspect = opts.planeAspect;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImagePlaneMemoryRequirementsInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImagePlaneMemoryRequirementsInfoKHR.pNext' isn't allowed to be filled");
  }
  get planeAspect() {
    return this.memoryViewInt32[0x4];
  }
  set planeAspect(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImagePlaneMemoryRequirementsInfoKHR.planeAspect': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkImagePlaneMemoryRequirementsInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImagePlaneMemoryRequirementsInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImagePlaneMemoryRequirementsInfoKHR.byteLength = 0x18;

VkImagePlaneMemoryRequirementsInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  planeAspect: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceSamplerYcbcrConversionFeatures **/
class VkPhysicalDeviceSamplerYcbcrConversionFeatures {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D2B64;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSamplerYcbcrConversionFeatures.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceSamplerYcbcrConversionFeatures.pNext' isn't allowed to be filled");
  }
  get samplerYcbcrConversion() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set samplerYcbcrConversion(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSamplerYcbcrConversionFeatures.byteLength = 0x18;

VkPhysicalDeviceSamplerYcbcrConversionFeatures.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  samplerYcbcrConversion: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR **/
class VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D2B64;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.samplerYcbcrConversion !== void 0) this.samplerYcbcrConversion = opts.samplerYcbcrConversion;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.pNext' isn't allowed to be filled");
  }
  get samplerYcbcrConversion() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set samplerYcbcrConversion(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  samplerYcbcrConversion: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkSamplerYcbcrConversionImageFormatProperties **/
class VkSamplerYcbcrConversionImageFormatProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D2B65;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionImageFormatProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSamplerYcbcrConversionImageFormatProperties.pNext' isn't allowed to be filled");
  }
  get combinedImageSamplerDescriptorCount() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkSamplerYcbcrConversionImageFormatProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionImageFormatProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkSamplerYcbcrConversionImageFormatProperties.byteLength = 0x18;

VkSamplerYcbcrConversionImageFormatProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  combinedImageSamplerDescriptorCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkSamplerYcbcrConversionImageFormatPropertiesKHR **/
class VkSamplerYcbcrConversionImageFormatPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D2B65;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerYcbcrConversionImageFormatPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSamplerYcbcrConversionImageFormatPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get combinedImageSamplerDescriptorCount() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkSamplerYcbcrConversionImageFormatPropertiesKHR.byteLength = 0x18;

VkSamplerYcbcrConversionImageFormatPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  combinedImageSamplerDescriptorCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkTextureLODGatherFormatPropertiesAMD **/
class VkTextureLODGatherFormatPropertiesAMD {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9B6A28;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkTextureLODGatherFormatPropertiesAMD.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkTextureLODGatherFormatPropertiesAMD.pNext' isn't allowed to be filled");
  }
  get supportsTextureGatherLODBiasAMD() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  
};

VkTextureLODGatherFormatPropertiesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkTextureLODGatherFormatPropertiesAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkTextureLODGatherFormatPropertiesAMD.byteLength = 0x18;

VkTextureLODGatherFormatPropertiesAMD.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  supportsTextureGatherLODBiasAMD: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkConditionalRenderingBeginInfoEXT **/
class VkConditionalRenderingBeginInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._buffer = null;
    
    
    this.sType = 0x3B9C066A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      if (opts.offset !== void 0) this.offset = opts.offset;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkConditionalRenderingBeginInfoEXT.pNext' isn't allowed to be filled");
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get offset() {
    return this.memoryViewBigUint64[0x3];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x8];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkConditionalRenderingBeginInfoEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  
};

VkConditionalRenderingBeginInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkConditionalRenderingBeginInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkConditionalRenderingBeginInfoEXT.byteLength = 0x28;

VkConditionalRenderingBeginInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  offset: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkProtectedSubmitInfo **/
class VkProtectedSubmitInfo {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = VkStructureType.VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.protectedSubmit !== void 0) this.protectedSubmit = opts.protectedSubmit;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkProtectedSubmitInfo.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkProtectedSubmitInfo.pNext' isn't allowed to be filled");
  }
  get protectedSubmit() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set protectedSubmit(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkProtectedSubmitInfo.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkProtectedSubmitInfo.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkProtectedSubmitInfo.byteLength = 0x18;

VkProtectedSubmitInfo.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  protectedSubmit: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceProtectedMemoryFeatures **/
class VkPhysicalDeviceProtectedMemoryFeatures {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.protectedMemory !== void 0) this.protectedMemory = opts.protectedMemory;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProtectedMemoryFeatures.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceProtectedMemoryFeatures.pNext' isn't allowed to be filled");
  }
  get protectedMemory() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set protectedMemory(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceProtectedMemoryFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProtectedMemoryFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceProtectedMemoryFeatures.byteLength = 0x18;

VkPhysicalDeviceProtectedMemoryFeatures.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  protectedMemory: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceProtectedMemoryProperties **/
class VkPhysicalDeviceProtectedMemoryProperties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceProtectedMemoryProperties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceProtectedMemoryProperties.pNext' isn't allowed to be filled");
  }
  get protectedNoFault() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  
};

VkPhysicalDeviceProtectedMemoryProperties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceProtectedMemoryProperties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceProtectedMemoryProperties.byteLength = 0x18;

VkPhysicalDeviceProtectedMemoryProperties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  protectedNoFault: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDeviceQueueInfo2 **/
class VkDeviceQueueInfo2 {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = VkStructureType.VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.queueFamilyIndex !== void 0) this.queueFamilyIndex = opts.queueFamilyIndex;
      if (opts.queueIndex !== void 0) this.queueIndex = opts.queueIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueInfo2.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceQueueInfo2.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueInfo2.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get queueFamilyIndex() {
    return this.memoryViewUint32[0x5];
  }
  set queueFamilyIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueInfo2.queueFamilyIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get queueIndex() {
    return this.memoryViewUint32[0x6];
  }
  set queueIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueInfo2.queueIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  
};

VkDeviceQueueInfo2.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueInfo2.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceQueueInfo2.byteLength = 0x20;

VkDeviceQueueInfo2.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  queueFamilyIndex: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  queueIndex: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPipelineCoverageToColorStateCreateInfoNV **/
class VkPipelineCoverageToColorStateCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9D1008;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.coverageToColorEnable !== void 0) this.coverageToColorEnable = opts.coverageToColorEnable;
      if (opts.coverageToColorLocation !== void 0) this.coverageToColorLocation = opts.coverageToColorLocation;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageToColorStateCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineCoverageToColorStateCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageToColorStateCreateInfoNV.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get coverageToColorEnable() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set coverageToColorEnable(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get coverageToColorLocation() {
    return this.memoryViewUint32[0x6];
  }
  set coverageToColorLocation(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageToColorStateCreateInfoNV.coverageToColorLocation': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  
};

VkPipelineCoverageToColorStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCoverageToColorStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineCoverageToColorStateCreateInfoNV.byteLength = 0x20;

VkPipelineCoverageToColorStateCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  coverageToColorEnable: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  coverageToColorLocation: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT **/
class VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9CC5D0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get filterMinmaxSingleComponentFormats() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  get filterMinmaxImageComponentMapping() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.byteLength = 0x18;

VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  filterMinmaxSingleComponentFormats: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  filterMinmaxImageComponentMapping: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkSampleLocationEXT **/
class VkSampleLocationEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.x !== void 0) this.x = opts.x;
      if (opts.y !== void 0) this.y = opts.y;
      
    }
  }
  get x() {
    return this.memoryViewFloat32[0x0];
  }
  set x(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationEXT.x': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x0] = value;
  }
  get y() {
    return this.memoryViewFloat32[0x1];
  }
  set y(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationEXT.y': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x1] = value;
  }
  
};

VkSampleLocationEXT.prototype.flush = function flush() {
  
  return true;
};

VkSampleLocationEXT.prototype.reflect = function reflect(memoryAddress) {
  
};

VkSampleLocationEXT.byteLength = 0x8;

VkSampleLocationEXT.memoryLayout = Object.freeze({
  x: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  y: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkSampleLocationsInfoEXT **/
class VkSampleLocationsInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._sampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x14 });
    
    this._pSampleLocations = null;
    this._pSampleLocationsNative = null;
    this.sType = 0x3B9CF898;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.sampleLocationsPerPixel !== void 0) this.sampleLocationsPerPixel = opts.sampleLocationsPerPixel;
      if (opts.sampleLocationGridSize !== void 0) this.sampleLocationGridSize = opts.sampleLocationGridSize;
      if (opts.sampleLocationsCount !== void 0) this.sampleLocationsCount = opts.sampleLocationsCount;
      if (opts.pSampleLocations !== void 0) this.pSampleLocations = opts.pSampleLocations;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSampleLocationsInfoEXT.pNext' isn't allowed to be filled");
  }
  get sampleLocationsPerPixel() {
    return this.memoryViewInt32[0x4];
  }
  set sampleLocationsPerPixel(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sampleLocationsPerPixel': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get sampleLocationGridSize() {
    return this._sampleLocationGridSize;
  }
  set sampleLocationGridSize(value) {
    if (value !== null && value.constructor === VkExtent2D) {
      value.flush();
      this._sampleLocationGridSize = value;
      
      
    } else if (value === null) {
      this._sampleLocationGridSize = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sampleLocationGridSize': Expected 'VkExtent2D' but got '" + value.constructor.name + "'");
    }
  }
  get sampleLocationsCount() {
    return this.memoryViewUint32[0x7];
  }
  set sampleLocationsCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.sampleLocationsCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get pSampleLocations() {
    return this._pSampleLocations;
  }
  set pSampleLocations(value) {
    if (value !== null && value.constructor === Array) {
      this._pSampleLocations = value;
    } else if (value === null) {
      this._pSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.pSampleLocations': Expected 'Array VkSampleLocationEXT' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSampleLocationsInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._sampleLocationGridSize !== null) {
    this._sampleLocationGridSize.flush();
    if (this.memoryBuffer !== this._sampleLocationGridSize.memoryBuffer) {
      let srcView = new Uint8Array(this._sampleLocationGridSize.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x14);
    }
  }
  
  
  if (this._pSampleLocations !== null) {
    let array = this._pSampleLocations;
    if (array.length !== this.sampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'sampleLocationsCount' for 'VkSampleLocationsInfoEXT.pSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSampleLocationEXT) {
        throw new TypeError("Invalid type for 'VkSampleLocationsInfoEXT.pSampleLocations[" + ii + "]': Expected 'VkSampleLocationEXT' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSampleLocationsNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  return true;
};

VkSampleLocationsInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkSampleLocationsInfoEXT.byteLength = 0x28;

VkSampleLocationsInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  sampleLocationsPerPixel: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  sampleLocationGridSize: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x8
  }),
  sampleLocationsCount: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  pSampleLocations: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkAttachmentSampleLocationsEXT **/
class VkAttachmentSampleLocationsEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x8 });
    
    if (typeof opts === "object") {
      if (opts.attachmentIndex !== void 0) this.attachmentIndex = opts.attachmentIndex;
      if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
      
    }
  }
  get attachmentIndex() {
    return this.memoryViewUint32[0x0];
  }
  set attachmentIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentSampleLocationsEXT.attachmentIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get sampleLocationsInfo() {
    return this._sampleLocationsInfo;
  }
  set sampleLocationsInfo(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAttachmentSampleLocationsEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkAttachmentSampleLocationsEXT.prototype.flush = function flush() {
  
  
  if (this._sampleLocationsInfo !== null) {
    this._sampleLocationsInfo.flush();
    if (this.memoryBuffer !== this._sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(this._sampleLocationsInfo.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
    }
  }
  
  return true;
};

VkAttachmentSampleLocationsEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAttachmentSampleLocationsEXT.byteLength = 0x30;

VkAttachmentSampleLocationsEXT.memoryLayout = Object.freeze({
  attachmentIndex: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  sampleLocationsInfo: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x28
  }),
});
/** VkSubpassSampleLocationsEXT **/
class VkSubpassSampleLocationsEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x8 });
    
    if (typeof opts === "object") {
      if (opts.subpassIndex !== void 0) this.subpassIndex = opts.subpassIndex;
      if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
      
    }
  }
  get subpassIndex() {
    return this.memoryViewUint32[0x0];
  }
  set subpassIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassSampleLocationsEXT.subpassIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get sampleLocationsInfo() {
    return this._sampleLocationsInfo;
  }
  set sampleLocationsInfo(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkSubpassSampleLocationsEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSubpassSampleLocationsEXT.prototype.flush = function flush() {
  
  
  if (this._sampleLocationsInfo !== null) {
    this._sampleLocationsInfo.flush();
    if (this.memoryBuffer !== this._sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(this._sampleLocationsInfo.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x8);
    }
  }
  
  return true;
};

VkSubpassSampleLocationsEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassSampleLocationsEXT.byteLength = 0x30;

VkSubpassSampleLocationsEXT.memoryLayout = Object.freeze({
  subpassIndex: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  sampleLocationsInfo: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x28
  }),
});
/** VkRenderPassSampleLocationsBeginInfoEXT **/
class VkRenderPassSampleLocationsBeginInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pAttachmentInitialSampleLocations = null;
    this._pAttachmentInitialSampleLocationsNative = null;
    
    this._pPostSubpassSampleLocations = null;
    this._pPostSubpassSampleLocationsNative = null;
    this.sType = 0x3B9CF899;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.attachmentInitialSampleLocationsCount !== void 0) this.attachmentInitialSampleLocationsCount = opts.attachmentInitialSampleLocationsCount;
      if (opts.pAttachmentInitialSampleLocations !== void 0) this.pAttachmentInitialSampleLocations = opts.pAttachmentInitialSampleLocations;
      if (opts.postSubpassSampleLocationsCount !== void 0) this.postSubpassSampleLocationsCount = opts.postSubpassSampleLocationsCount;
      if (opts.pPostSubpassSampleLocations !== void 0) this.pPostSubpassSampleLocations = opts.pPostSubpassSampleLocations;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRenderPassSampleLocationsBeginInfoEXT.pNext' isn't allowed to be filled");
  }
  get attachmentInitialSampleLocationsCount() {
    return this.memoryViewUint32[0x4];
  }
  set attachmentInitialSampleLocationsCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.attachmentInitialSampleLocationsCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pAttachmentInitialSampleLocations() {
    return this._pAttachmentInitialSampleLocations;
  }
  set pAttachmentInitialSampleLocations(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachmentInitialSampleLocations = value;
    } else if (value === null) {
      this._pAttachmentInitialSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations': Expected 'Array VkAttachmentSampleLocationsEXT' but got '" + value.constructor.name + "'");
    }
  }
  get postSubpassSampleLocationsCount() {
    return this.memoryViewUint32[0x8];
  }
  set postSubpassSampleLocationsCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.postSubpassSampleLocationsCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pPostSubpassSampleLocations() {
    return this._pPostSubpassSampleLocations;
  }
  set pPostSubpassSampleLocations(value) {
    if (value !== null && value.constructor === Array) {
      this._pPostSubpassSampleLocations = value;
    } else if (value === null) {
      this._pPostSubpassSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations': Expected 'Array VkSubpassSampleLocationsEXT' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassSampleLocationsBeginInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachmentInitialSampleLocations !== null) {
    let array = this._pAttachmentInitialSampleLocations;
    if (array.length !== this.attachmentInitialSampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentInitialSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentSampleLocationsEXT) {
        throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pAttachmentInitialSampleLocations[" + ii + "]': Expected 'VkAttachmentSampleLocationsEXT' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pAttachmentInitialSampleLocationsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pPostSubpassSampleLocations !== null) {
    let array = this._pPostSubpassSampleLocations;
    if (array.length !== this.postSubpassSampleLocationsCount) {
      throw new RangeError("Invalid array length, expected length of 'postSubpassSampleLocationsCount' for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSubpassSampleLocationsEXT) {
        throw new TypeError("Invalid type for 'VkRenderPassSampleLocationsBeginInfoEXT.pPostSubpassSampleLocations[" + ii + "]': Expected 'VkSubpassSampleLocationsEXT' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pPostSubpassSampleLocationsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkRenderPassSampleLocationsBeginInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkRenderPassSampleLocationsBeginInfoEXT.byteLength = 0x30;

VkRenderPassSampleLocationsBeginInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  attachmentInitialSampleLocationsCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pAttachmentInitialSampleLocations: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  postSubpassSampleLocationsCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pPostSubpassSampleLocations: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkPipelineSampleLocationsStateCreateInfoEXT **/
class VkPipelineSampleLocationsStateCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._sampleLocationsInfo = new VkSampleLocationsInfoEXT({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    this.sType = 0x3B9CF89A;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.sampleLocationsEnable !== void 0) this.sampleLocationsEnable = opts.sampleLocationsEnable;
      if (opts.sampleLocationsInfo !== void 0) this.sampleLocationsInfo = opts.sampleLocationsInfo;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineSampleLocationsStateCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineSampleLocationsStateCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get sampleLocationsEnable() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set sampleLocationsEnable(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get sampleLocationsInfo() {
    return this._sampleLocationsInfo;
  }
  set sampleLocationsInfo(value) {
    if (value !== null && value.constructor === VkSampleLocationsInfoEXT) {
      value.flush();
      this._sampleLocationsInfo = value;
      
      
    } else if (value === null) {
      this._sampleLocationsInfo = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkPipelineSampleLocationsStateCreateInfoEXT.sampleLocationsInfo': Expected 'VkSampleLocationsInfoEXT' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineSampleLocationsStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._sampleLocationsInfo !== null) {
    this._sampleLocationsInfo.flush();
    if (this.memoryBuffer !== this._sampleLocationsInfo.memoryBuffer) {
      let srcView = new Uint8Array(this._sampleLocationsInfo.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
    }
  }
  
  return true;
};

VkPipelineSampleLocationsStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineSampleLocationsStateCreateInfoEXT.byteLength = 0x40;

VkPipelineSampleLocationsStateCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  sampleLocationsEnable: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  sampleLocationsInfo: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x28
  }),
});
/** VkPhysicalDeviceSampleLocationsPropertiesEXT **/
class VkPhysicalDeviceSampleLocationsPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._maxSampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x14 });
    this._sampleLocationCoordinateRange = [...Array(2)].fill(0x0);
    
    
    this.sType = 0x3B9CF89B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceSampleLocationsPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceSampleLocationsPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get sampleLocationSampleCounts() {
    return this.memoryViewInt32[0x4];
  }
  get maxSampleLocationGridSize() {
    return this._maxSampleLocationGridSize;
  }
  get sampleLocationCoordinateRange() {
    return [
      this.memoryViewFloat32[0x7],
      this.memoryViewFloat32[0x8]
    ];
  }
  get sampleLocationSubPixelBits() {
    return this.memoryViewUint32[0x9];
  }
  get variableSampleLocations() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x30));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x30), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceSampleLocationsPropertiesEXT.byteLength = 0x30;

VkPhysicalDeviceSampleLocationsPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  sampleLocationSampleCounts: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxSampleLocationGridSize: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x8
  }),
  sampleLocationCoordinateRange: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x8
  }),
  sampleLocationSubPixelBits: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  variableSampleLocations: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
});
/** VkMultisamplePropertiesEXT **/
class VkMultisamplePropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._maxSampleLocationGridSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9CF89C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMultisamplePropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMultisamplePropertiesEXT.pNext' isn't allowed to be filled");
  }
  get maxSampleLocationGridSize() {
    return this._maxSampleLocationGridSize;
  }
  
};

VkMultisamplePropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMultisamplePropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
  
  
};

VkMultisamplePropertiesEXT.byteLength = 0x18;

VkMultisamplePropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxSampleLocationGridSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkSamplerReductionModeCreateInfoEXT **/
class VkSamplerReductionModeCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9CC5D1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.reductionMode !== void 0) this.reductionMode = opts.reductionMode;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerReductionModeCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSamplerReductionModeCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get reductionMode() {
    return this.memoryViewInt32[0x4];
  }
  set reductionMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSamplerReductionModeCreateInfoEXT.reductionMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkSamplerReductionModeCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSamplerReductionModeCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSamplerReductionModeCreateInfoEXT.byteLength = 0x18;

VkSamplerReductionModeCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  reductionMode: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT **/
class VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D0C20;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.advancedBlendCoherentOperations !== void 0) this.advancedBlendCoherentOperations = opts.advancedBlendCoherentOperations;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get advancedBlendCoherentOperations() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set advancedBlendCoherentOperations(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  advancedBlendCoherentOperations: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT **/
class VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    this.sType = 0x3B9D0C21;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get advancedBlendMaxColorAttachments() {
    return this.memoryViewUint32[0x4];
  }
  get advancedBlendIndependentBlend() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  get advancedBlendNonPremultipliedSrcColor() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  get advancedBlendNonPremultipliedDstColor() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  get advancedBlendCorrelatedOverlap() {
    return this.memoryViewUint32[0x8] !== 0;
  }
  get advancedBlendAllOperations() {
    return this.memoryViewUint32[0x9] !== 0;
  }
  
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
};

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.byteLength = 0x28;

VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  advancedBlendMaxColorAttachments: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  advancedBlendIndependentBlend: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  advancedBlendNonPremultipliedSrcColor: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  advancedBlendNonPremultipliedDstColor: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  advancedBlendCorrelatedOverlap: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  advancedBlendAllOperations: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
});
/** VkPipelineColorBlendAdvancedStateCreateInfoEXT **/
class VkPipelineColorBlendAdvancedStateCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9D0C22;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.srcPremultiplied !== void 0) this.srcPremultiplied = opts.srcPremultiplied;
      if (opts.dstPremultiplied !== void 0) this.dstPremultiplied = opts.dstPremultiplied;
      if (opts.blendOverlap !== void 0) this.blendOverlap = opts.blendOverlap;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAdvancedStateCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineColorBlendAdvancedStateCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get srcPremultiplied() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set srcPremultiplied(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get dstPremultiplied() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set dstPremultiplied(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get blendOverlap() {
    return this.memoryViewInt32[0x6];
  }
  set blendOverlap(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineColorBlendAdvancedStateCreateInfoEXT.blendOverlap': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineColorBlendAdvancedStateCreateInfoEXT.byteLength = 0x20;

VkPipelineColorBlendAdvancedStateCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  srcPremultiplied: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  dstPremultiplied: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  blendOverlap: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceInlineUniformBlockFeaturesEXT **/
class VkPhysicalDeviceInlineUniformBlockFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9CE510;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.inlineUniformBlock !== void 0) this.inlineUniformBlock = opts.inlineUniformBlock;
      if (opts.descriptorBindingInlineUniformBlockUpdateAfterBind !== void 0) this.descriptorBindingInlineUniformBlockUpdateAfterBind = opts.descriptorBindingInlineUniformBlockUpdateAfterBind;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceInlineUniformBlockFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceInlineUniformBlockFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get inlineUniformBlock() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set inlineUniformBlock(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get descriptorBindingInlineUniformBlockUpdateAfterBind() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set descriptorBindingInlineUniformBlockUpdateAfterBind(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceInlineUniformBlockFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  inlineUniformBlock: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  descriptorBindingInlineUniformBlockUpdateAfterBind: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceInlineUniformBlockPropertiesEXT **/
class VkPhysicalDeviceInlineUniformBlockPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    this.sType = 0x3B9CE511;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceInlineUniformBlockPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceInlineUniformBlockPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get maxInlineUniformBlockSize() {
    return this.memoryViewUint32[0x4];
  }
  get maxPerStageDescriptorInlineUniformBlocks() {
    return this.memoryViewUint32[0x5];
  }
  get maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() {
    return this.memoryViewUint32[0x6];
  }
  get maxDescriptorSetInlineUniformBlocks() {
    return this.memoryViewUint32[0x7];
  }
  get maxDescriptorSetUpdateAfterBindInlineUniformBlocks() {
    return this.memoryViewUint32[0x8];
  }
  
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
};

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.byteLength = 0x28;

VkPhysicalDeviceInlineUniformBlockPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxInlineUniformBlockSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxPerStageDescriptorInlineUniformBlocks: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  maxDescriptorSetInlineUniformBlocks: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindInlineUniformBlocks: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkWriteDescriptorSetInlineUniformBlockEXT **/
class VkWriteDescriptorSetInlineUniformBlockEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pData = null;
    this.sType = 0x3B9CE512;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.dataSize !== void 0) this.dataSize = opts.dataSize;
      if (opts.pData !== void 0) this.pData = opts.pData;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetInlineUniformBlockEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkWriteDescriptorSetInlineUniformBlockEXT.pNext' isn't allowed to be filled");
  }
  get dataSize() {
    return this.memoryViewUint32[0x4];
  }
  set dataSize(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetInlineUniformBlockEXT.dataSize': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pData() {
    return this._pData;
  }
  set pData(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pData = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pData = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetInlineUniformBlockEXT.pData': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkWriteDescriptorSetInlineUniformBlockEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkWriteDescriptorSetInlineUniformBlockEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkWriteDescriptorSetInlineUniformBlockEXT.byteLength = 0x20;

VkWriteDescriptorSetInlineUniformBlockEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  dataSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pData: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDescriptorPoolInlineUniformBlockCreateInfoEXT **/
class VkDescriptorPoolInlineUniformBlockCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9CE513;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.maxInlineUniformBlockBindings !== void 0) this.maxInlineUniformBlockBindings = opts.maxInlineUniformBlockBindings;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolInlineUniformBlockCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDescriptorPoolInlineUniformBlockCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get maxInlineUniformBlockBindings() {
    return this.memoryViewUint32[0x4];
  }
  set maxInlineUniformBlockBindings(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorPoolInlineUniformBlockCreateInfoEXT.maxInlineUniformBlockBindings': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.byteLength = 0x18;

VkDescriptorPoolInlineUniformBlockCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxInlineUniformBlockBindings: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPipelineCoverageModulationStateCreateInfoNV **/
class VkPipelineCoverageModulationStateCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this._pCoverageModulationTable = null;
    this.sType = 0x3B9D1BC0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.coverageModulationMode !== void 0) this.coverageModulationMode = opts.coverageModulationMode;
      if (opts.coverageModulationTableEnable !== void 0) this.coverageModulationTableEnable = opts.coverageModulationTableEnable;
      if (opts.coverageModulationTableCount !== void 0) this.coverageModulationTableCount = opts.coverageModulationTableCount;
      if (opts.pCoverageModulationTable !== void 0) this.pCoverageModulationTable = opts.pCoverageModulationTable;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineCoverageModulationStateCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get coverageModulationMode() {
    return this.memoryViewInt32[0x5];
  }
  set coverageModulationMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get coverageModulationTableEnable() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set coverageModulationTableEnable(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  get coverageModulationTableCount() {
    return this.memoryViewUint32[0x7];
  }
  set coverageModulationTableCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.coverageModulationTableCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get pCoverageModulationTable() {
    return this._pCoverageModulationTable;
  }
  set pCoverageModulationTable(value) {
    if (value !== null && value.constructor === Float32Array) {
      this._pCoverageModulationTable = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCoverageModulationTable = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineCoverageModulationStateCreateInfoNV.pCoverageModulationTable': Expected 'Float32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineCoverageModulationStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineCoverageModulationStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineCoverageModulationStateCreateInfoNV.byteLength = 0x28;

VkPipelineCoverageModulationStateCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  coverageModulationMode: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  coverageModulationTableEnable: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  coverageModulationTableCount: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  pCoverageModulationTable: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkImageFormatListCreateInfoKHR **/
class VkImageFormatListCreateInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pViewFormats = null;
    this.sType = 0x3B9D0838;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.viewFormatCount !== void 0) this.viewFormatCount = opts.viewFormatCount;
      if (opts.pViewFormats !== void 0) this.pViewFormats = opts.pViewFormats;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageFormatListCreateInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageFormatListCreateInfoKHR.pNext' isn't allowed to be filled");
  }
  get viewFormatCount() {
    return this.memoryViewUint32[0x4];
  }
  set viewFormatCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageFormatListCreateInfoKHR.viewFormatCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pViewFormats() {
    return this._pViewFormats;
  }
  set pViewFormats(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pViewFormats = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pViewFormats = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageFormatListCreateInfoKHR.pViewFormats': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageFormatListCreateInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageFormatListCreateInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageFormatListCreateInfoKHR.byteLength = 0x20;

VkImageFormatListCreateInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  viewFormatCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pViewFormats: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkValidationCacheCreateInfoEXT **/
class VkValidationCacheCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pInitialData = null;
    this.sType = 0x3B9D3B00;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.initialDataSize !== void 0) this.initialDataSize = opts.initialDataSize;
      if (opts.pInitialData !== void 0) this.pInitialData = opts.pInitialData;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkValidationCacheCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get initialDataSize() {
    return this.memoryViewBigInt64[0x3];
  }
  set initialDataSize(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.initialDataSize': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x3] = value;
  }
  get pInitialData() {
    return this._pInitialData;
  }
  set pInitialData(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pInitialData = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pInitialData = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkValidationCacheCreateInfoEXT.pInitialData': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkValidationCacheCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkValidationCacheCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkValidationCacheCreateInfoEXT.byteLength = 0x28;

VkValidationCacheCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  initialDataSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pInitialData: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkShaderModuleValidationCacheCreateInfoEXT **/
class VkShaderModuleValidationCacheCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._validationCache = null;
    this.sType = 0x3B9D3B01;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.validationCache !== void 0) this.validationCache = opts.validationCache;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShaderModuleValidationCacheCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkShaderModuleValidationCacheCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get validationCache() {
    return this._validationCache;
  }
  set validationCache(value) {
    if (value !== null && value.constructor === VkValidationCacheEXT) {
      
      this._validationCache = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._validationCache = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkShaderModuleValidationCacheCreateInfoEXT.validationCache': Expected 'VkValidationCacheEXT' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkShaderModuleValidationCacheCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkShaderModuleValidationCacheCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkShaderModuleValidationCacheCreateInfoEXT.byteLength = 0x18;

VkShaderModuleValidationCacheCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  validationCache: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceMaintenance3Properties **/
class VkPhysicalDeviceMaintenance3Properties {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9D5A40;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMaintenance3Properties.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMaintenance3Properties.pNext' isn't allowed to be filled");
  }
  get maxPerSetDescriptors() {
    return this.memoryViewUint32[0x4];
  }
  get maxMemoryAllocationSize() {
    return this.memoryViewBigUint64[0x3];
  }
  
};

VkPhysicalDeviceMaintenance3Properties.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMaintenance3Properties.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceMaintenance3Properties.byteLength = 0x20;

VkPhysicalDeviceMaintenance3Properties.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxPerSetDescriptors: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxMemoryAllocationSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceMaintenance3PropertiesKHR **/
class VkPhysicalDeviceMaintenance3PropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9D5A40;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMaintenance3PropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMaintenance3PropertiesKHR.pNext' isn't allowed to be filled");
  }
  get maxPerSetDescriptors() {
    return this.memoryViewUint32[0x4];
  }
  get maxMemoryAllocationSize() {
    return this.memoryViewBigUint64[0x3];
  }
  
};

VkPhysicalDeviceMaintenance3PropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMaintenance3PropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceMaintenance3PropertiesKHR.byteLength = 0x20;

VkPhysicalDeviceMaintenance3PropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxPerSetDescriptors: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxMemoryAllocationSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDescriptorSetLayoutSupport **/
class VkDescriptorSetLayoutSupport {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D5A41;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
      switch (sType) {
          
        case 0x3B9D3EEC:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupport.pNext'");
    }
  }
  get supported() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  
};

VkDescriptorSetLayoutSupport.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutSupport.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDescriptorSetLayoutSupport.byteLength = 0x18;

VkDescriptorSetLayoutSupport.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  supported: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDescriptorSetLayoutSupportKHR **/
class VkDescriptorSetLayoutSupportKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D5A41;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
      switch (sType) {
          
        case 0x3B9D3EEC:
          break;
        default:
          throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutSupportKHR.pNext'");
    }
  }
  get supported() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  
};

VkDescriptorSetLayoutSupportKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutSupportKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDescriptorSetLayoutSupportKHR.byteLength = 0x18;

VkDescriptorSetLayoutSupportKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  supported: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceShaderDrawParameterFeatures **/
class VkPhysicalDeviceShaderDrawParameterFeatures {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = VkStructureType.VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.shaderDrawParameters !== void 0) this.shaderDrawParameters = opts.shaderDrawParameters;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderDrawParameterFeatures.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceShaderDrawParameterFeatures.pNext' isn't allowed to be filled");
  }
  get shaderDrawParameters() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set shaderDrawParameters(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceShaderDrawParameterFeatures.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderDrawParameterFeatures.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderDrawParameterFeatures.byteLength = 0x18;

VkPhysicalDeviceShaderDrawParameterFeatures.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shaderDrawParameters: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceFloat16Int8FeaturesKHR **/
class VkPhysicalDeviceFloat16Int8FeaturesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9C0A50;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.shaderFloat16 !== void 0) this.shaderFloat16 = opts.shaderFloat16;
      if (opts.shaderInt8 !== void 0) this.shaderInt8 = opts.shaderInt8;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFloat16Int8FeaturesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceFloat16Int8FeaturesKHR.pNext' isn't allowed to be filled");
  }
  get shaderFloat16() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set shaderFloat16(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get shaderInt8() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set shaderInt8(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceFloat16Int8FeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceFloat16Int8FeaturesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shaderFloat16: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  shaderInt8: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceFloatControlsPropertiesKHR **/
class VkPhysicalDeviceFloatControlsPropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x58);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    this.sType = 0x3B9DCB88;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFloatControlsPropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceFloatControlsPropertiesKHR.pNext' isn't allowed to be filled");
  }
  get separateDenormSettings() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  get separateRoundingModeSettings() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  get shaderSignedZeroInfNanPreserveFloat16() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  get shaderSignedZeroInfNanPreserveFloat32() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  get shaderSignedZeroInfNanPreserveFloat64() {
    return this.memoryViewUint32[0x8] !== 0;
  }
  get shaderDenormPreserveFloat16() {
    return this.memoryViewUint32[0x9] !== 0;
  }
  get shaderDenormPreserveFloat32() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  get shaderDenormPreserveFloat64() {
    return this.memoryViewUint32[0xB] !== 0;
  }
  get shaderDenormFlushToZeroFloat16() {
    return this.memoryViewUint32[0xC] !== 0;
  }
  get shaderDenormFlushToZeroFloat32() {
    return this.memoryViewUint32[0xD] !== 0;
  }
  get shaderDenormFlushToZeroFloat64() {
    return this.memoryViewUint32[0xE] !== 0;
  }
  get shaderRoundingModeRTEFloat16() {
    return this.memoryViewUint32[0xF] !== 0;
  }
  get shaderRoundingModeRTEFloat32() {
    return this.memoryViewUint32[0x10] !== 0;
  }
  get shaderRoundingModeRTEFloat64() {
    return this.memoryViewUint32[0x11] !== 0;
  }
  get shaderRoundingModeRTZFloat16() {
    return this.memoryViewUint32[0x12] !== 0;
  }
  get shaderRoundingModeRTZFloat32() {
    return this.memoryViewUint32[0x13] !== 0;
  }
  get shaderRoundingModeRTZFloat64() {
    return this.memoryViewUint32[0x14] !== 0;
  }
  
};

VkPhysicalDeviceFloatControlsPropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFloatControlsPropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x58));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x58), 0x0);
  
  
};

VkPhysicalDeviceFloatControlsPropertiesKHR.byteLength = 0x58;

VkPhysicalDeviceFloatControlsPropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  separateDenormSettings: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  separateRoundingModeSettings: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  shaderSignedZeroInfNanPreserveFloat16: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  shaderSignedZeroInfNanPreserveFloat32: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  shaderSignedZeroInfNanPreserveFloat64: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  shaderDenormPreserveFloat16: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  shaderDenormPreserveFloat32: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  shaderDenormPreserveFloat64: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  shaderDenormFlushToZeroFloat16: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  shaderDenormFlushToZeroFloat32: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  shaderDenormFlushToZeroFloat64: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  shaderRoundingModeRTEFloat16: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  shaderRoundingModeRTEFloat32: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  shaderRoundingModeRTEFloat64: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
  shaderRoundingModeRTZFloat16: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  shaderRoundingModeRTZFloat32: Object.freeze({
    byteOffset: 0x4C,
    byteLength: 0x4
  }),
  shaderRoundingModeRTZFloat64: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
});
/** VkShaderResourceUsageAMD **/
class VkShaderResourceUsageAMD {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get numUsedVgprs() {
    return this.memoryViewUint32[0x0];
  }
  get numUsedSgprs() {
    return this.memoryViewUint32[0x1];
  }
  get ldsSizePerLocalWorkGroup() {
    return this.memoryViewUint32[0x2];
  }
  get ldsUsageSizeInBytes() {
    return this.memoryViewBigInt64[0x2];
  }
  get scratchMemUsageInBytes() {
    return this.memoryViewBigInt64[0x3];
  }
  
};

VkShaderResourceUsageAMD.prototype.flush = function flush() {
  
  return true;
};

VkShaderResourceUsageAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
};

VkShaderResourceUsageAMD.byteLength = 0x20;

VkShaderResourceUsageAMD.memoryLayout = Object.freeze({
  numUsedVgprs: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  numUsedSgprs: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  ldsSizePerLocalWorkGroup: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  ldsUsageSizeInBytes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  scratchMemUsageInBytes: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkShaderStatisticsInfoAMD **/
class VkShaderStatisticsInfoAMD {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._resourceUsage = new VkShaderResourceUsageAMD({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x8 });
    
    
    
    
    this._computeWorkGroupSize = [...Array(3)].fill(0x0);
    
    if (typeof opts === "object") {
      
    }
  }
  get shaderStageMask() {
    return this.memoryViewInt32[0x0];
  }
  get resourceUsage() {
    return this._resourceUsage;
  }
  get numPhysicalVgprs() {
    return this.memoryViewUint32[0xA];
  }
  get numPhysicalSgprs() {
    return this.memoryViewUint32[0xB];
  }
  get numAvailableVgprs() {
    return this.memoryViewUint32[0xC];
  }
  get numAvailableSgprs() {
    return this.memoryViewUint32[0xD];
  }
  get computeWorkGroupSize() {
    return [
      this.memoryViewUint32[0xE],
      this.memoryViewUint32[0xF],
      this.memoryViewUint32[0x10]
    ];
  }
  
};

VkShaderStatisticsInfoAMD.prototype.flush = function flush() {
  
  return true;
};

VkShaderStatisticsInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x48));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x48), 0x0);
  
  
  
  
};

VkShaderStatisticsInfoAMD.byteLength = 0x48;

VkShaderStatisticsInfoAMD.memoryLayout = Object.freeze({
  shaderStageMask: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  resourceUsage: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x20
  }),
  numPhysicalVgprs: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  numPhysicalSgprs: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  numAvailableVgprs: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  numAvailableSgprs: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  computeWorkGroupSize: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0xC
  }),
});
/** VkDeviceQueueGlobalPriorityCreateInfoEXT **/
class VkDeviceQueueGlobalPriorityCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D71B0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.globalPriority !== void 0) this.globalPriority = opts.globalPriority;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueGlobalPriorityCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceQueueGlobalPriorityCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get globalPriority() {
    return this.memoryViewInt32[0x4];
  }
  set globalPriority(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceQueueGlobalPriorityCreateInfoEXT.globalPriority': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceQueueGlobalPriorityCreateInfoEXT.byteLength = 0x18;

VkDeviceQueueGlobalPriorityCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  globalPriority: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDebugUtilsObjectNameInfoEXT **/
class VkDebugUtilsObjectNameInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pObjectName = null;
    this.sType = 0x3B9CBE00;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.objectType !== void 0) this.objectType = opts.objectType;
      if (opts.objectHandle !== void 0) this.objectHandle = opts.objectHandle;
      if (opts.pObjectName !== void 0) this.pObjectName = opts.pObjectName;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectNameInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugUtilsObjectNameInfoEXT.pNext' isn't allowed to be filled");
  }
  get objectType() {
    return this.memoryViewInt32[0x4];
  }
  set objectType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectNameInfoEXT.objectType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get objectHandle() {
    return this.memoryViewBigUint64[0x3];
  }
  set objectHandle(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectNameInfoEXT.objectHandle': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get pObjectName() {
    if (this._pObjectName !== null) {
      let str = textDecoder.decode(this._pObjectName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pObjectName(value) {
    if (value !== null && value.constructor === String) {
      this._pObjectName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(this._pObjectName);
    } else if (value === null) {
      this._pObjectName = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectNameInfoEXT.pObjectName': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugUtilsObjectNameInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsObjectNameInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugUtilsObjectNameInfoEXT.byteLength = 0x28;

VkDebugUtilsObjectNameInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  objectType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  objectHandle: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  pObjectName: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkDebugUtilsObjectTagInfoEXT **/
class VkDebugUtilsObjectTagInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this._pTag = null;
    this.sType = 0x3B9CBE01;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.objectType !== void 0) this.objectType = opts.objectType;
      if (opts.objectHandle !== void 0) this.objectHandle = opts.objectHandle;
      if (opts.tagName !== void 0) this.tagName = opts.tagName;
      if (opts.tagSize !== void 0) this.tagSize = opts.tagSize;
      if (opts.pTag !== void 0) this.pTag = opts.pTag;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugUtilsObjectTagInfoEXT.pNext' isn't allowed to be filled");
  }
  get objectType() {
    return this.memoryViewInt32[0x4];
  }
  set objectType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.objectType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get objectHandle() {
    return this.memoryViewBigUint64[0x3];
  }
  set objectHandle(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.objectHandle': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get tagName() {
    return this.memoryViewBigUint64[0x4];
  }
  set tagName(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.tagName': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  get tagSize() {
    return this.memoryViewBigInt64[0x5];
  }
  set tagSize(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.tagSize': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigInt64[0x5] = value;
  }
  get pTag() {
    return this._pTag;
  }
  set pTag(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pTag = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pTag = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsObjectTagInfoEXT.pTag': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugUtilsObjectTagInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsObjectTagInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugUtilsObjectTagInfoEXT.byteLength = 0x38;

VkDebugUtilsObjectTagInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  objectType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  objectHandle: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  tagName: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  tagSize: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  pTag: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
});
/** VkDebugUtilsLabelEXT **/
class VkDebugUtilsLabelEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._pLabelName = null;
    this._color = [...Array(4)].fill(0x0);
    this.sType = 0x3B9CBE02;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.pLabelName !== void 0) this.pLabelName = opts.pLabelName;
      if (opts.color !== void 0) this.color = opts.color;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugUtilsLabelEXT.pNext' isn't allowed to be filled");
  }
  get pLabelName() {
    if (this._pLabelName !== null) {
      let str = textDecoder.decode(this._pLabelName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pLabelName(value) {
    if (value !== null && value.constructor === String) {
      this._pLabelName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x2] = getAddressFromArrayBuffer(this._pLabelName);
    } else if (value === null) {
      this._pLabelName = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.pLabelName': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (value !== null && value.constructor === Array) {
      this._color = value;
    } else if (value === null) {
      this._color = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.color': Expected 'Array float' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugUtilsLabelEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._color !== null) {
    let array = this._color;
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkDebugUtilsLabelEXT.color'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== Number) {
        throw new TypeError("Invalid type for 'VkDebugUtilsLabelEXT.color[" + ii + "]': Expected 'Number' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewFloat32[0x6 + ii] = array[ii];
    };
  } else {
    this.memoryViewFloat32[0x6] = 0x0;
  }
  
  return true;
};

VkDebugUtilsLabelEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkDebugUtilsLabelEXT.byteLength = 0x28;

VkDebugUtilsLabelEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  pLabelName: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  color: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x10
  }),
});
/** VkDebugUtilsMessengerCreateInfoEXT **/
class VkDebugUtilsMessengerCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._pUserData = null;
    this.sType = 0x3B9CBE04;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.messageSeverity !== void 0) this.messageSeverity = opts.messageSeverity;
      if (opts.messageType !== void 0) this.messageType = opts.messageType;
      if (opts.pUserData !== void 0) this.pUserData = opts.pUserData;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugUtilsMessengerCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get messageSeverity() {
    return this.memoryViewInt32[0x5];
  }
  set messageSeverity(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.messageSeverity': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get messageType() {
    return this.memoryViewInt32[0x6];
  }
  set messageType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.messageType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get pUserData() {
    return this._pUserData;
  }
  set pUserData(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pUserData = value;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pUserData = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCreateInfoEXT.pUserData': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugUtilsMessengerCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDebugUtilsMessengerCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDebugUtilsMessengerCreateInfoEXT.byteLength = 0x30;

VkDebugUtilsMessengerCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  messageSeverity: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  messageType: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pUserData: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
});
/** VkDebugUtilsMessengerCallbackDataEXT **/
class VkDebugUtilsMessengerCallbackDataEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x60);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pMessageIdName = null;
    
    this._pMessage = null;
    
    this._pQueueLabels = null;
    this._pQueueLabelsNative = null;
    
    this._pCmdBufLabels = null;
    this._pCmdBufLabelsNative = null;
    
    this._pObjects = null;
    this._pObjectsNative = null;
    this.sType = 0x3B9CBE03;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pMessageIdName !== void 0) this.pMessageIdName = opts.pMessageIdName;
      if (opts.messageIdNumber !== void 0) this.messageIdNumber = opts.messageIdNumber;
      if (opts.pMessage !== void 0) this.pMessage = opts.pMessage;
      if (opts.queueLabelCount !== void 0) this.queueLabelCount = opts.queueLabelCount;
      if (opts.pQueueLabels !== void 0) this.pQueueLabels = opts.pQueueLabels;
      if (opts.cmdBufLabelCount !== void 0) this.cmdBufLabelCount = opts.cmdBufLabelCount;
      if (opts.pCmdBufLabels !== void 0) this.pCmdBufLabels = opts.pCmdBufLabels;
      if (opts.objectCount !== void 0) this.objectCount = opts.objectCount;
      if (opts.pObjects !== void 0) this.pObjects = opts.pObjects;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDebugUtilsMessengerCallbackDataEXT.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get pMessageIdName() {
    if (this._pMessageIdName !== null) {
      let str = textDecoder.decode(this._pMessageIdName);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pMessageIdName(value) {
    if (value !== null && value.constructor === String) {
      this._pMessageIdName = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(this._pMessageIdName);
    } else if (value === null) {
      this._pMessageIdName = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pMessageIdName': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  get messageIdNumber() {
    return this.memoryViewInt32[0x8];
  }
  set messageIdNumber(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.messageIdNumber': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get pMessage() {
    if (this._pMessage !== null) {
      let str = textDecoder.decode(this._pMessage);
      return str.substr(0, str.length - 1);
    } else {
      return null;
    }
  }
  set pMessage(value) {
    if (value !== null && value.constructor === String) {
      this._pMessage = textEncoder.encode(value + NULLT).buffer;
      this.memoryViewBigInt64[0x5] = getAddressFromArrayBuffer(this._pMessage);
    } else if (value === null) {
      this._pMessage = null;
      this.memoryViewBigInt64[0x5] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pMessage': Expected 'String' but got '" + value.constructor.name + "'");
    }
  }
  get queueLabelCount() {
    return this.memoryViewUint32[0xC];
  }
  set queueLabelCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.queueLabelCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pQueueLabels() {
    return this._pQueueLabels;
  }
  set pQueueLabels(value) {
    if (value !== null && value.constructor === Array) {
      this._pQueueLabels = value;
    } else if (value === null) {
      this._pQueueLabels = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels': Expected 'Array VkDebugUtilsLabelEXT' but got '" + value.constructor.name + "'");
    }
  }
  get cmdBufLabelCount() {
    return this.memoryViewUint32[0x10];
  }
  set cmdBufLabelCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.cmdBufLabelCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x10] = value;
  }
  get pCmdBufLabels() {
    return this._pCmdBufLabels;
  }
  set pCmdBufLabels(value) {
    if (value !== null && value.constructor === Array) {
      this._pCmdBufLabels = value;
    } else if (value === null) {
      this._pCmdBufLabels = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels': Expected 'Array VkDebugUtilsLabelEXT' but got '" + value.constructor.name + "'");
    }
  }
  get objectCount() {
    return this.memoryViewUint32[0x14];
  }
  set objectCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.objectCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x14] = value;
  }
  get pObjects() {
    return this._pObjects;
  }
  set pObjects(value) {
    if (value !== null && value.constructor === Array) {
      this._pObjects = value;
    } else if (value === null) {
      this._pObjects = null;
    } else {
      throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects': Expected 'Array VkDebugUtilsObjectNameInfoEXT' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDebugUtilsMessengerCallbackDataEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pQueueLabels !== null) {
    let array = this._pQueueLabels;
    if (array.length !== this.queueLabelCount) {
      throw new RangeError("Invalid array length, expected length of 'queueLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDebugUtilsLabelEXT) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pQueueLabels[" + ii + "]': Expected 'VkDebugUtilsLabelEXT' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pQueueLabelsNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  }
  
  
  if (this._pCmdBufLabels !== null) {
    let array = this._pCmdBufLabels;
    if (array.length !== this.cmdBufLabelCount) {
      throw new RangeError("Invalid array length, expected length of 'cmdBufLabelCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDebugUtilsLabelEXT) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pCmdBufLabels[" + ii + "]': Expected 'VkDebugUtilsLabelEXT' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pCmdBufLabelsNative = nativeArray;
    this.memoryViewBigInt64[0x9] = nativeArray.address;
  }
  
  
  if (this._pObjects !== null) {
    let array = this._pObjects;
    if (array.length !== this.objectCount) {
      throw new RangeError("Invalid array length, expected length of 'objectCount' for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkDebugUtilsObjectNameInfoEXT) {
        throw new TypeError("Invalid type for 'VkDebugUtilsMessengerCallbackDataEXT.pObjects[" + ii + "]': Expected 'VkDebugUtilsObjectNameInfoEXT' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pObjectsNative = nativeArray;
    this.memoryViewBigInt64[0xB] = nativeArray.address;
  }
  
  return true;
};

VkDebugUtilsMessengerCallbackDataEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkDebugUtilsMessengerCallbackDataEXT.byteLength = 0x60;

VkDebugUtilsMessengerCallbackDataEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pMessageIdName: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  messageIdNumber: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pMessage: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  queueLabelCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pQueueLabels: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  cmdBufLabelCount: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  pCmdBufLabels: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x8
  }),
  objectCount: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
  pObjects: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x8
  }),
});
/** VkImportMemoryHostPointerInfoEXT **/
class VkImportMemoryHostPointerInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pHostPointer = null;
    this.sType = 0x3B9D8150;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.handleType !== void 0) this.handleType = opts.handleType;
      if (opts.pHostPointer !== void 0) this.pHostPointer = opts.pHostPointer;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryHostPointerInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImportMemoryHostPointerInfoEXT.pNext' isn't allowed to be filled");
  }
  get handleType() {
    return this.memoryViewInt32[0x4];
  }
  set handleType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImportMemoryHostPointerInfoEXT.handleType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get pHostPointer() {
    return this._pHostPointer;
  }
  set pHostPointer(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pHostPointer = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pHostPointer = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImportMemoryHostPointerInfoEXT.pHostPointer': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImportMemoryHostPointerInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImportMemoryHostPointerInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImportMemoryHostPointerInfoEXT.byteLength = 0x20;

VkImportMemoryHostPointerInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  handleType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pHostPointer: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkMemoryHostPointerPropertiesEXT **/
class VkMemoryHostPointerPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D8151;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryHostPointerPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryHostPointerPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get memoryTypeBits() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkMemoryHostPointerPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryHostPointerPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkMemoryHostPointerPropertiesEXT.byteLength = 0x18;

VkMemoryHostPointerPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryTypeBits: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExternalMemoryHostPropertiesEXT **/
class VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D8152;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExternalMemoryHostPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExternalMemoryHostPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get minImportedHostPointerAlignment() {
    return this.memoryViewBigUint64[0x2];
  }
  
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.byteLength = 0x18;

VkPhysicalDeviceExternalMemoryHostPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  minImportedHostPointerAlignment: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceConservativeRasterizationPropertiesEXT **/
class VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    this.sType = 0x3B9C5488;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceConservativeRasterizationPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceConservativeRasterizationPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get primitiveOverestimationSize() {
    return this.memoryViewFloat32[0x4];
  }
  get maxExtraPrimitiveOverestimationSize() {
    return this.memoryViewFloat32[0x5];
  }
  get extraPrimitiveOverestimationSizeGranularity() {
    return this.memoryViewFloat32[0x6];
  }
  get primitiveUnderestimation() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  get conservativePointAndLineRasterization() {
    return this.memoryViewUint32[0x8] !== 0;
  }
  get degenerateTrianglesRasterized() {
    return this.memoryViewUint32[0x9] !== 0;
  }
  get degenerateLinesRasterized() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  get fullyCoveredFragmentShaderInputVariable() {
    return this.memoryViewUint32[0xB] !== 0;
  }
  get conservativeRasterizationPostDepthCoverage() {
    return this.memoryViewUint32[0xC] !== 0;
  }
  
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x38));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x38), 0x0);
  
  
};

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.byteLength = 0x38;

VkPhysicalDeviceConservativeRasterizationPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  primitiveOverestimationSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxExtraPrimitiveOverestimationSize: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  extraPrimitiveOverestimationSizeGranularity: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  primitiveUnderestimation: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  conservativePointAndLineRasterization: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  degenerateTrianglesRasterized: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  degenerateLinesRasterized: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  fullyCoveredFragmentShaderInputVariable: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  conservativeRasterizationPostDepthCoverage: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
});
/** VkCalibratedTimestampInfoEXT **/
class VkCalibratedTimestampInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D98C0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.timeDomain !== void 0) this.timeDomain = opts.timeDomain;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCalibratedTimestampInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCalibratedTimestampInfoEXT.pNext' isn't allowed to be filled");
  }
  get timeDomain() {
    return this.memoryViewInt32[0x4];
  }
  set timeDomain(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCalibratedTimestampInfoEXT.timeDomain': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkCalibratedTimestampInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCalibratedTimestampInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCalibratedTimestampInfoEXT.byteLength = 0x18;

VkCalibratedTimestampInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  timeDomain: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceShaderCorePropertiesAMD **/
class VkPhysicalDeviceShaderCorePropertiesAMD {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x48) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x48) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x48);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    this.sType = 0x3B9D9CA8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderCorePropertiesAMD.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceShaderCorePropertiesAMD.pNext' isn't allowed to be filled");
  }
  get shaderEngineCount() {
    return this.memoryViewUint32[0x4];
  }
  get shaderArraysPerEngineCount() {
    return this.memoryViewUint32[0x5];
  }
  get computeUnitsPerShaderArray() {
    return this.memoryViewUint32[0x6];
  }
  get simdPerComputeUnit() {
    return this.memoryViewUint32[0x7];
  }
  get wavefrontsPerSimd() {
    return this.memoryViewUint32[0x8];
  }
  get wavefrontSize() {
    return this.memoryViewUint32[0x9];
  }
  get sgprsPerSimd() {
    return this.memoryViewUint32[0xA];
  }
  get minSgprAllocation() {
    return this.memoryViewUint32[0xB];
  }
  get maxSgprAllocation() {
    return this.memoryViewUint32[0xC];
  }
  get sgprAllocationGranularity() {
    return this.memoryViewUint32[0xD];
  }
  get vgprsPerSimd() {
    return this.memoryViewUint32[0xE];
  }
  get minVgprAllocation() {
    return this.memoryViewUint32[0xF];
  }
  get maxVgprAllocation() {
    return this.memoryViewUint32[0x10];
  }
  get vgprAllocationGranularity() {
    return this.memoryViewUint32[0x11];
  }
  
};

VkPhysicalDeviceShaderCorePropertiesAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderCorePropertiesAMD.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x48));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x48), 0x0);
  
  
};

VkPhysicalDeviceShaderCorePropertiesAMD.byteLength = 0x48;

VkPhysicalDeviceShaderCorePropertiesAMD.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shaderEngineCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  shaderArraysPerEngineCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  computeUnitsPerShaderArray: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  simdPerComputeUnit: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  wavefrontsPerSimd: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  wavefrontSize: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  sgprsPerSimd: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  minSgprAllocation: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  maxSgprAllocation: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  sgprAllocationGranularity: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  vgprsPerSimd: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  minVgprAllocation: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  maxVgprAllocation: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  vgprAllocationGranularity: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
});
/** VkPipelineRasterizationConservativeStateCreateInfoEXT **/
class VkPipelineRasterizationConservativeStateCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9C5489;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.conservativeRasterizationMode !== void 0) this.conservativeRasterizationMode = opts.conservativeRasterizationMode;
      if (opts.extraPrimitiveOverestimationSize !== void 0) this.extraPrimitiveOverestimationSize = opts.extraPrimitiveOverestimationSize;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineRasterizationConservativeStateCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get conservativeRasterizationMode() {
    return this.memoryViewInt32[0x5];
  }
  set conservativeRasterizationMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.conservativeRasterizationMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get extraPrimitiveOverestimationSize() {
    return this.memoryViewFloat32[0x6];
  }
  set extraPrimitiveOverestimationSize(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationConservativeStateCreateInfoEXT.extraPrimitiveOverestimationSize': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x6] = value;
  }
  
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationConservativeStateCreateInfoEXT.byteLength = 0x20;

VkPipelineRasterizationConservativeStateCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  conservativeRasterizationMode: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  extraPrimitiveOverestimationSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceDescriptorIndexingFeaturesEXT **/
class VkPhysicalDeviceDescriptorIndexingFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x60);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    this.sType = 0x3B9D3EE9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.shaderInputAttachmentArrayDynamicIndexing !== void 0) this.shaderInputAttachmentArrayDynamicIndexing = opts.shaderInputAttachmentArrayDynamicIndexing;
      if (opts.shaderUniformTexelBufferArrayDynamicIndexing !== void 0) this.shaderUniformTexelBufferArrayDynamicIndexing = opts.shaderUniformTexelBufferArrayDynamicIndexing;
      if (opts.shaderStorageTexelBufferArrayDynamicIndexing !== void 0) this.shaderStorageTexelBufferArrayDynamicIndexing = opts.shaderStorageTexelBufferArrayDynamicIndexing;
      if (opts.shaderUniformBufferArrayNonUniformIndexing !== void 0) this.shaderUniformBufferArrayNonUniformIndexing = opts.shaderUniformBufferArrayNonUniformIndexing;
      if (opts.shaderSampledImageArrayNonUniformIndexing !== void 0) this.shaderSampledImageArrayNonUniformIndexing = opts.shaderSampledImageArrayNonUniformIndexing;
      if (opts.shaderStorageBufferArrayNonUniformIndexing !== void 0) this.shaderStorageBufferArrayNonUniformIndexing = opts.shaderStorageBufferArrayNonUniformIndexing;
      if (opts.shaderStorageImageArrayNonUniformIndexing !== void 0) this.shaderStorageImageArrayNonUniformIndexing = opts.shaderStorageImageArrayNonUniformIndexing;
      if (opts.shaderInputAttachmentArrayNonUniformIndexing !== void 0) this.shaderInputAttachmentArrayNonUniformIndexing = opts.shaderInputAttachmentArrayNonUniformIndexing;
      if (opts.shaderUniformTexelBufferArrayNonUniformIndexing !== void 0) this.shaderUniformTexelBufferArrayNonUniformIndexing = opts.shaderUniformTexelBufferArrayNonUniformIndexing;
      if (opts.shaderStorageTexelBufferArrayNonUniformIndexing !== void 0) this.shaderStorageTexelBufferArrayNonUniformIndexing = opts.shaderStorageTexelBufferArrayNonUniformIndexing;
      if (opts.descriptorBindingUniformBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformBufferUpdateAfterBind = opts.descriptorBindingUniformBufferUpdateAfterBind;
      if (opts.descriptorBindingSampledImageUpdateAfterBind !== void 0) this.descriptorBindingSampledImageUpdateAfterBind = opts.descriptorBindingSampledImageUpdateAfterBind;
      if (opts.descriptorBindingStorageImageUpdateAfterBind !== void 0) this.descriptorBindingStorageImageUpdateAfterBind = opts.descriptorBindingStorageImageUpdateAfterBind;
      if (opts.descriptorBindingStorageBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageBufferUpdateAfterBind = opts.descriptorBindingStorageBufferUpdateAfterBind;
      if (opts.descriptorBindingUniformTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingUniformTexelBufferUpdateAfterBind = opts.descriptorBindingUniformTexelBufferUpdateAfterBind;
      if (opts.descriptorBindingStorageTexelBufferUpdateAfterBind !== void 0) this.descriptorBindingStorageTexelBufferUpdateAfterBind = opts.descriptorBindingStorageTexelBufferUpdateAfterBind;
      if (opts.descriptorBindingUpdateUnusedWhilePending !== void 0) this.descriptorBindingUpdateUnusedWhilePending = opts.descriptorBindingUpdateUnusedWhilePending;
      if (opts.descriptorBindingPartiallyBound !== void 0) this.descriptorBindingPartiallyBound = opts.descriptorBindingPartiallyBound;
      if (opts.descriptorBindingVariableDescriptorCount !== void 0) this.descriptorBindingVariableDescriptorCount = opts.descriptorBindingVariableDescriptorCount;
      if (opts.runtimeDescriptorArray !== void 0) this.runtimeDescriptorArray = opts.runtimeDescriptorArray;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDescriptorIndexingFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceDescriptorIndexingFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get shaderInputAttachmentArrayDynamicIndexing() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set shaderInputAttachmentArrayDynamicIndexing(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get shaderUniformTexelBufferArrayDynamicIndexing() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set shaderUniformTexelBufferArrayDynamicIndexing(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get shaderStorageTexelBufferArrayDynamicIndexing() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set shaderStorageTexelBufferArrayDynamicIndexing(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  get shaderUniformBufferArrayNonUniformIndexing() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  set shaderUniformBufferArrayNonUniformIndexing(value) {
    this.memoryViewUint32[0x7] = value | 0;
  }
  get shaderSampledImageArrayNonUniformIndexing() {
    return this.memoryViewUint32[0x8] !== 0;
  }
  set shaderSampledImageArrayNonUniformIndexing(value) {
    this.memoryViewUint32[0x8] = value | 0;
  }
  get shaderStorageBufferArrayNonUniformIndexing() {
    return this.memoryViewUint32[0x9] !== 0;
  }
  set shaderStorageBufferArrayNonUniformIndexing(value) {
    this.memoryViewUint32[0x9] = value | 0;
  }
  get shaderStorageImageArrayNonUniformIndexing() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  set shaderStorageImageArrayNonUniformIndexing(value) {
    this.memoryViewUint32[0xA] = value | 0;
  }
  get shaderInputAttachmentArrayNonUniformIndexing() {
    return this.memoryViewUint32[0xB] !== 0;
  }
  set shaderInputAttachmentArrayNonUniformIndexing(value) {
    this.memoryViewUint32[0xB] = value | 0;
  }
  get shaderUniformTexelBufferArrayNonUniformIndexing() {
    return this.memoryViewUint32[0xC] !== 0;
  }
  set shaderUniformTexelBufferArrayNonUniformIndexing(value) {
    this.memoryViewUint32[0xC] = value | 0;
  }
  get shaderStorageTexelBufferArrayNonUniformIndexing() {
    return this.memoryViewUint32[0xD] !== 0;
  }
  set shaderStorageTexelBufferArrayNonUniformIndexing(value) {
    this.memoryViewUint32[0xD] = value | 0;
  }
  get descriptorBindingUniformBufferUpdateAfterBind() {
    return this.memoryViewUint32[0xE] !== 0;
  }
  set descriptorBindingUniformBufferUpdateAfterBind(value) {
    this.memoryViewUint32[0xE] = value | 0;
  }
  get descriptorBindingSampledImageUpdateAfterBind() {
    return this.memoryViewUint32[0xF] !== 0;
  }
  set descriptorBindingSampledImageUpdateAfterBind(value) {
    this.memoryViewUint32[0xF] = value | 0;
  }
  get descriptorBindingStorageImageUpdateAfterBind() {
    return this.memoryViewUint32[0x10] !== 0;
  }
  set descriptorBindingStorageImageUpdateAfterBind(value) {
    this.memoryViewUint32[0x10] = value | 0;
  }
  get descriptorBindingStorageBufferUpdateAfterBind() {
    return this.memoryViewUint32[0x11] !== 0;
  }
  set descriptorBindingStorageBufferUpdateAfterBind(value) {
    this.memoryViewUint32[0x11] = value | 0;
  }
  get descriptorBindingUniformTexelBufferUpdateAfterBind() {
    return this.memoryViewUint32[0x12] !== 0;
  }
  set descriptorBindingUniformTexelBufferUpdateAfterBind(value) {
    this.memoryViewUint32[0x12] = value | 0;
  }
  get descriptorBindingStorageTexelBufferUpdateAfterBind() {
    return this.memoryViewUint32[0x13] !== 0;
  }
  set descriptorBindingStorageTexelBufferUpdateAfterBind(value) {
    this.memoryViewUint32[0x13] = value | 0;
  }
  get descriptorBindingUpdateUnusedWhilePending() {
    return this.memoryViewUint32[0x14] !== 0;
  }
  set descriptorBindingUpdateUnusedWhilePending(value) {
    this.memoryViewUint32[0x14] = value | 0;
  }
  get descriptorBindingPartiallyBound() {
    return this.memoryViewUint32[0x15] !== 0;
  }
  set descriptorBindingPartiallyBound(value) {
    this.memoryViewUint32[0x15] = value | 0;
  }
  get descriptorBindingVariableDescriptorCount() {
    return this.memoryViewUint32[0x16] !== 0;
  }
  set descriptorBindingVariableDescriptorCount(value) {
    this.memoryViewUint32[0x16] = value | 0;
  }
  get runtimeDescriptorArray() {
    return this.memoryViewUint32[0x17] !== 0;
  }
  set runtimeDescriptorArray(value) {
    this.memoryViewUint32[0x17] = value | 0;
  }
  
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.byteLength = 0x60;

VkPhysicalDeviceDescriptorIndexingFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shaderInputAttachmentArrayDynamicIndexing: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  shaderUniformTexelBufferArrayDynamicIndexing: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  shaderStorageTexelBufferArrayDynamicIndexing: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  shaderUniformBufferArrayNonUniformIndexing: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  shaderSampledImageArrayNonUniformIndexing: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  shaderStorageBufferArrayNonUniformIndexing: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  shaderStorageImageArrayNonUniformIndexing: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  shaderInputAttachmentArrayNonUniformIndexing: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  shaderUniformTexelBufferArrayNonUniformIndexing: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  shaderStorageTexelBufferArrayNonUniformIndexing: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  descriptorBindingUniformBufferUpdateAfterBind: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  descriptorBindingSampledImageUpdateAfterBind: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  descriptorBindingStorageImageUpdateAfterBind: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  descriptorBindingStorageBufferUpdateAfterBind: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
  descriptorBindingUniformTexelBufferUpdateAfterBind: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  descriptorBindingStorageTexelBufferUpdateAfterBind: Object.freeze({
    byteOffset: 0x4C,
    byteLength: 0x4
  }),
  descriptorBindingUpdateUnusedWhilePending: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
  descriptorBindingPartiallyBound: Object.freeze({
    byteOffset: 0x54,
    byteLength: 0x4
  }),
  descriptorBindingVariableDescriptorCount: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x4
  }),
  runtimeDescriptorArray: Object.freeze({
    byteOffset: 0x5C,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceDescriptorIndexingPropertiesEXT **/
class VkPhysicalDeviceDescriptorIndexingPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x70) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x70) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x70) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x70);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    this.sType = 0x3B9D3EEA;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDescriptorIndexingPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceDescriptorIndexingPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get maxUpdateAfterBindDescriptorsInAllPools() {
    return this.memoryViewUint32[0x4];
  }
  get shaderUniformBufferArrayNonUniformIndexingNative() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  get shaderSampledImageArrayNonUniformIndexingNative() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  get shaderStorageBufferArrayNonUniformIndexingNative() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  get shaderStorageImageArrayNonUniformIndexingNative() {
    return this.memoryViewUint32[0x8] !== 0;
  }
  get shaderInputAttachmentArrayNonUniformIndexingNative() {
    return this.memoryViewUint32[0x9] !== 0;
  }
  get robustBufferAccessUpdateAfterBind() {
    return this.memoryViewUint32[0xA] !== 0;
  }
  get quadDivergentImplicitLod() {
    return this.memoryViewUint32[0xB] !== 0;
  }
  get maxPerStageDescriptorUpdateAfterBindSamplers() {
    return this.memoryViewUint32[0xC];
  }
  get maxPerStageDescriptorUpdateAfterBindUniformBuffers() {
    return this.memoryViewUint32[0xD];
  }
  get maxPerStageDescriptorUpdateAfterBindStorageBuffers() {
    return this.memoryViewUint32[0xE];
  }
  get maxPerStageDescriptorUpdateAfterBindSampledImages() {
    return this.memoryViewUint32[0xF];
  }
  get maxPerStageDescriptorUpdateAfterBindStorageImages() {
    return this.memoryViewUint32[0x10];
  }
  get maxPerStageDescriptorUpdateAfterBindInputAttachments() {
    return this.memoryViewUint32[0x11];
  }
  get maxPerStageUpdateAfterBindResources() {
    return this.memoryViewUint32[0x12];
  }
  get maxDescriptorSetUpdateAfterBindSamplers() {
    return this.memoryViewUint32[0x13];
  }
  get maxDescriptorSetUpdateAfterBindUniformBuffers() {
    return this.memoryViewUint32[0x14];
  }
  get maxDescriptorSetUpdateAfterBindUniformBuffersDynamic() {
    return this.memoryViewUint32[0x15];
  }
  get maxDescriptorSetUpdateAfterBindStorageBuffers() {
    return this.memoryViewUint32[0x16];
  }
  get maxDescriptorSetUpdateAfterBindStorageBuffersDynamic() {
    return this.memoryViewUint32[0x17];
  }
  get maxDescriptorSetUpdateAfterBindSampledImages() {
    return this.memoryViewUint32[0x18];
  }
  get maxDescriptorSetUpdateAfterBindStorageImages() {
    return this.memoryViewUint32[0x19];
  }
  get maxDescriptorSetUpdateAfterBindInputAttachments() {
    return this.memoryViewUint32[0x1A];
  }
  
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x70));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x70), 0x0);
  
  
};

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.byteLength = 0x70;

VkPhysicalDeviceDescriptorIndexingPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxUpdateAfterBindDescriptorsInAllPools: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  shaderUniformBufferArrayNonUniformIndexingNative: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  shaderSampledImageArrayNonUniformIndexingNative: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  shaderStorageBufferArrayNonUniformIndexingNative: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  shaderStorageImageArrayNonUniformIndexingNative: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  shaderInputAttachmentArrayNonUniformIndexingNative: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  robustBufferAccessUpdateAfterBind: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  quadDivergentImplicitLod: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  maxPerStageDescriptorUpdateAfterBindSamplers: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  maxPerStageDescriptorUpdateAfterBindUniformBuffers: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  maxPerStageDescriptorUpdateAfterBindStorageBuffers: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
  maxPerStageDescriptorUpdateAfterBindSampledImages: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  maxPerStageDescriptorUpdateAfterBindStorageImages: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  maxPerStageDescriptorUpdateAfterBindInputAttachments: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
  maxPerStageUpdateAfterBindResources: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindSamplers: Object.freeze({
    byteOffset: 0x4C,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindUniformBuffers: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: Object.freeze({
    byteOffset: 0x54,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindStorageBuffers: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: Object.freeze({
    byteOffset: 0x5C,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindSampledImages: Object.freeze({
    byteOffset: 0x60,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindStorageImages: Object.freeze({
    byteOffset: 0x64,
    byteLength: 0x4
  }),
  maxDescriptorSetUpdateAfterBindInputAttachments: Object.freeze({
    byteOffset: 0x68,
    byteLength: 0x4
  }),
});
/** VkDescriptorSetLayoutBindingFlagsCreateInfoEXT **/
class VkDescriptorSetLayoutBindingFlagsCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pBindingFlags = null;
    this.sType = 0x3B9D3EE8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.bindingCount !== void 0) this.bindingCount = opts.bindingCount;
      if (opts.pBindingFlags !== void 0) this.pBindingFlags = opts.pBindingFlags;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get bindingCount() {
    return this.memoryViewUint32[0x4];
  }
  set bindingCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.bindingCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pBindingFlags() {
    return this._pBindingFlags;
  }
  set pBindingFlags(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pBindingFlags = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pBindingFlags = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.pBindingFlags': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.byteLength = 0x20;

VkDescriptorSetLayoutBindingFlagsCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  bindingCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pBindingFlags: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDescriptorSetVariableDescriptorCountAllocateInfoEXT **/
class VkDescriptorSetVariableDescriptorCountAllocateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDescriptorCounts = null;
    this.sType = 0x3B9D3EEB;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.descriptorSetCount !== void 0) this.descriptorSetCount = opts.descriptorSetCount;
      if (opts.pDescriptorCounts !== void 0) this.pDescriptorCounts = opts.pDescriptorCounts;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pNext' isn't allowed to be filled");
  }
  get descriptorSetCount() {
    return this.memoryViewUint32[0x4];
  }
  set descriptorSetCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.descriptorSetCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pDescriptorCounts() {
    return this._pDescriptorCounts;
  }
  set pDescriptorCounts(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDescriptorCounts = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDescriptorCounts = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.pDescriptorCounts': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.byteLength = 0x20;

VkDescriptorSetVariableDescriptorCountAllocateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  descriptorSetCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDescriptorCounts: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDescriptorSetVariableDescriptorCountLayoutSupportEXT **/
class VkDescriptorSetVariableDescriptorCountLayoutSupportEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D3EEC;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.pNext' isn't allowed to be filled");
  }
  get maxVariableDescriptorCount() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.byteLength = 0x18;

VkDescriptorSetVariableDescriptorCountLayoutSupportEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxVariableDescriptorCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkAttachmentDescription2KHR **/
class VkAttachmentDescription2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    this.sType = 0x3B9C73C8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.format !== void 0) this.format = opts.format;
      if (opts.samples !== void 0) this.samples = opts.samples;
      if (opts.loadOp !== void 0) this.loadOp = opts.loadOp;
      if (opts.storeOp !== void 0) this.storeOp = opts.storeOp;
      if (opts.stencilLoadOp !== void 0) this.stencilLoadOp = opts.stencilLoadOp;
      if (opts.stencilStoreOp !== void 0) this.stencilStoreOp = opts.stencilStoreOp;
      if (opts.initialLayout !== void 0) this.initialLayout = opts.initialLayout;
      if (opts.finalLayout !== void 0) this.finalLayout = opts.finalLayout;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkAttachmentDescription2KHR.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get format() {
    return this.memoryViewInt32[0x5];
  }
  set format(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.format': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get samples() {
    return this.memoryViewInt32[0x6];
  }
  set samples(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.samples': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get loadOp() {
    return this.memoryViewInt32[0x7];
  }
  set loadOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.loadOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get storeOp() {
    return this.memoryViewInt32[0x8];
  }
  set storeOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.storeOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get stencilLoadOp() {
    return this.memoryViewInt32[0x9];
  }
  set stencilLoadOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.stencilLoadOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get stencilStoreOp() {
    return this.memoryViewInt32[0xA];
  }
  set stencilStoreOp(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.stencilStoreOp': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xA] = value;
  }
  get initialLayout() {
    return this.memoryViewInt32[0xB];
  }
  set initialLayout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.initialLayout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xB] = value;
  }
  get finalLayout() {
    return this.memoryViewInt32[0xC];
  }
  set finalLayout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentDescription2KHR.finalLayout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  
};

VkAttachmentDescription2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentDescription2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAttachmentDescription2KHR.byteLength = 0x38;

VkAttachmentDescription2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  format: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  samples: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  loadOp: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  storeOp: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  stencilLoadOp: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  stencilStoreOp: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  initialLayout: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  finalLayout: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
});
/** VkAttachmentReference2KHR **/
class VkAttachmentReference2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9C73C9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.attachment !== void 0) this.attachment = opts.attachment;
      if (opts.layout !== void 0) this.layout = opts.layout;
      if (opts.aspectMask !== void 0) this.aspectMask = opts.aspectMask;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkAttachmentReference2KHR.pNext' isn't allowed to be filled");
  }
  get attachment() {
    return this.memoryViewUint32[0x4];
  }
  set attachment(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.attachment': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get layout() {
    return this.memoryViewInt32[0x5];
  }
  set layout(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.layout': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get aspectMask() {
    return this.memoryViewInt32[0x6];
  }
  set aspectMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAttachmentReference2KHR.aspectMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  
};

VkAttachmentReference2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAttachmentReference2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAttachmentReference2KHR.byteLength = 0x20;

VkAttachmentReference2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  attachment: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  layout: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  aspectMask: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkSubpassDescription2KHR **/
class VkSubpassDescription2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x58);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this._pInputAttachments = null;
    this._pInputAttachmentsNative = null;
    
    this._pColorAttachments = null;
    this._pColorAttachmentsNative = null;
    this._pResolveAttachments = null;
    this._pResolveAttachmentsNative = null;
    this._pDepthStencilAttachment = null;
    
    this._pPreserveAttachments = null;
    this.sType = 0x3B9C73CA;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.pipelineBindPoint !== void 0) this.pipelineBindPoint = opts.pipelineBindPoint;
      if (opts.viewMask !== void 0) this.viewMask = opts.viewMask;
      if (opts.inputAttachmentCount !== void 0) this.inputAttachmentCount = opts.inputAttachmentCount;
      if (opts.pInputAttachments !== void 0) this.pInputAttachments = opts.pInputAttachments;
      if (opts.colorAttachmentCount !== void 0) this.colorAttachmentCount = opts.colorAttachmentCount;
      if (opts.pColorAttachments !== void 0) this.pColorAttachments = opts.pColorAttachments;
      if (opts.pResolveAttachments !== void 0) this.pResolveAttachments = opts.pResolveAttachments;
      if (opts.pDepthStencilAttachment !== void 0) this.pDepthStencilAttachment = opts.pDepthStencilAttachment;
      if (opts.preserveAttachmentCount !== void 0) this.preserveAttachmentCount = opts.preserveAttachmentCount;
      if (opts.pPreserveAttachments !== void 0) this.pPreserveAttachments = opts.pPreserveAttachments;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    if (value !== null && (value instanceof Object)) {
      let {sType} = value;
      if (sType <= -1) throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
      switch (sType) {
          
        case 0x3B9DD359:
          break;
        default:
          throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
      };
      this._pNext = value;
      this.memoryViewBigInt64[0x1] = value.memoryAddress;
    } else if (value === null) {
      this._pNext = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pNext'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get pipelineBindPoint() {
    return this.memoryViewInt32[0x5];
  }
  set pipelineBindPoint(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pipelineBindPoint': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get viewMask() {
    return this.memoryViewUint32[0x6];
  }
  set viewMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.viewMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get inputAttachmentCount() {
    return this.memoryViewUint32[0x7];
  }
  set inputAttachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.inputAttachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get pInputAttachments() {
    return this._pInputAttachments;
  }
  set pInputAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pInputAttachments = value;
    } else if (value === null) {
      this._pInputAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pInputAttachments': Expected 'Array VkAttachmentReference2KHR' but got '" + value.constructor.name + "'");
    }
  }
  get colorAttachmentCount() {
    return this.memoryViewUint32[0xA];
  }
  set colorAttachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.colorAttachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xA] = value;
  }
  get pColorAttachments() {
    return this._pColorAttachments;
  }
  set pColorAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pColorAttachments = value;
    } else if (value === null) {
      this._pColorAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pColorAttachments': Expected 'Array VkAttachmentReference2KHR' but got '" + value.constructor.name + "'");
    }
  }
  get pResolveAttachments() {
    return this._pResolveAttachments;
  }
  set pResolveAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pResolveAttachments = value;
    } else if (value === null) {
      this._pResolveAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pResolveAttachments': Expected 'Array VkAttachmentReference2KHR' but got '" + value.constructor.name + "'");
    }
  }
  get pDepthStencilAttachment() {
    return this._pDepthStencilAttachment;
  }
  set pDepthStencilAttachment(value) {
    if (value !== null && value.constructor === VkAttachmentReference2KHR) {
      value.flush();
      this._pDepthStencilAttachment = value;
      this.memoryViewBigInt64[0x8] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDepthStencilAttachment = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pDepthStencilAttachment': Expected 'VkAttachmentReference2KHR' but got '" + value.constructor.name + "'");
    }
  }
  get preserveAttachmentCount() {
    return this.memoryViewUint32[0x12];
  }
  set preserveAttachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.preserveAttachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x12] = value;
  }
  get pPreserveAttachments() {
    return this._pPreserveAttachments;
  }
  set pPreserveAttachments(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pPreserveAttachments = value;
      this.memoryViewBigInt64[0xA] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pPreserveAttachments = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pPreserveAttachments': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSubpassDescription2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pInputAttachments !== null) {
    let array = this._pInputAttachments;
    if (array.length !== this.inputAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'inputAttachmentCount' for 'VkSubpassDescription2KHR.pInputAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentReference2KHR) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pInputAttachments[" + ii + "]': Expected 'VkAttachmentReference2KHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pInputAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  
  if (this._pColorAttachments !== null) {
    let array = this._pColorAttachments;
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pColorAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentReference2KHR) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pColorAttachments[" + ii + "]': Expected 'VkAttachmentReference2KHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pColorAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x6] = nativeArray.address;
  }
  
  
  if (this._pResolveAttachments !== null) {
    let array = this._pResolveAttachments;
    if (array.length !== this.colorAttachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'colorAttachmentCount' for 'VkSubpassDescription2KHR.pResolveAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentReference2KHR) {
        throw new TypeError("Invalid type for 'VkSubpassDescription2KHR.pResolveAttachments[" + ii + "]': Expected 'VkAttachmentReference2KHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pResolveAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  }
  
  return true;
};

VkSubpassDescription2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkSubpassDescription2KHR.byteLength = 0x58;

VkSubpassDescription2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pipelineBindPoint: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  viewMask: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  inputAttachmentCount: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  pInputAttachments: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  colorAttachmentCount: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  pColorAttachments: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  pResolveAttachments: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  pDepthStencilAttachment: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x8
  }),
  preserveAttachmentCount: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  pPreserveAttachments: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x8
  }),
});
/** VkSubpassDependency2KHR **/
class VkSubpassDependency2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    this.sType = 0x3B9C73CB;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.srcSubpass !== void 0) this.srcSubpass = opts.srcSubpass;
      if (opts.dstSubpass !== void 0) this.dstSubpass = opts.dstSubpass;
      if (opts.srcStageMask !== void 0) this.srcStageMask = opts.srcStageMask;
      if (opts.dstStageMask !== void 0) this.dstStageMask = opts.dstStageMask;
      if (opts.srcAccessMask !== void 0) this.srcAccessMask = opts.srcAccessMask;
      if (opts.dstAccessMask !== void 0) this.dstAccessMask = opts.dstAccessMask;
      if (opts.dependencyFlags !== void 0) this.dependencyFlags = opts.dependencyFlags;
      if (opts.viewOffset !== void 0) this.viewOffset = opts.viewOffset;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSubpassDependency2KHR.pNext' isn't allowed to be filled");
  }
  get srcSubpass() {
    return this.memoryViewUint32[0x4];
  }
  set srcSubpass(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.srcSubpass': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get dstSubpass() {
    return this.memoryViewUint32[0x5];
  }
  set dstSubpass(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.dstSubpass': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get srcStageMask() {
    return this.memoryViewInt32[0x6];
  }
  set srcStageMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.srcStageMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get dstStageMask() {
    return this.memoryViewInt32[0x7];
  }
  set dstStageMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.dstStageMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get srcAccessMask() {
    return this.memoryViewInt32[0x8];
  }
  set srcAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.srcAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get dstAccessMask() {
    return this.memoryViewInt32[0x9];
  }
  set dstAccessMask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.dstAccessMask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get dependencyFlags() {
    return this.memoryViewInt32[0xA];
  }
  set dependencyFlags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.dependencyFlags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xA] = value;
  }
  get viewOffset() {
    return this.memoryViewInt32[0xB];
  }
  set viewOffset(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDependency2KHR.viewOffset': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xB] = value;
  }
  
};

VkSubpassDependency2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassDependency2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassDependency2KHR.byteLength = 0x30;

VkSubpassDependency2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  srcSubpass: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  dstSubpass: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  srcStageMask: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  dstStageMask: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  srcAccessMask: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  dstAccessMask: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  dependencyFlags: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  viewOffset: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
});
/** VkRenderPassCreateInfo2KHR **/
class VkRenderPassCreateInfo2KHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x50) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x50);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pAttachments = null;
    this._pAttachmentsNative = null;
    
    this._pSubpasses = null;
    this._pSubpassesNative = null;
    
    this._pDependencies = null;
    this._pDependenciesNative = null;
    
    this._pCorrelatedViewMasks = null;
    this.sType = 0x3B9C73CC;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.attachmentCount !== void 0) this.attachmentCount = opts.attachmentCount;
      if (opts.pAttachments !== void 0) this.pAttachments = opts.pAttachments;
      if (opts.subpassCount !== void 0) this.subpassCount = opts.subpassCount;
      if (opts.pSubpasses !== void 0) this.pSubpasses = opts.pSubpasses;
      if (opts.dependencyCount !== void 0) this.dependencyCount = opts.dependencyCount;
      if (opts.pDependencies !== void 0) this.pDependencies = opts.pDependencies;
      if (opts.correlatedViewMaskCount !== void 0) this.correlatedViewMaskCount = opts.correlatedViewMaskCount;
      if (opts.pCorrelatedViewMasks !== void 0) this.pCorrelatedViewMasks = opts.pCorrelatedViewMasks;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRenderPassCreateInfo2KHR.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get attachmentCount() {
    return this.memoryViewUint32[0x5];
  }
  set attachmentCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.attachmentCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pAttachments() {
    return this._pAttachments;
  }
  set pAttachments(value) {
    if (value !== null && value.constructor === Array) {
      this._pAttachments = value;
    } else if (value === null) {
      this._pAttachments = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pAttachments': Expected 'Array VkAttachmentDescription2KHR' but got '" + value.constructor.name + "'");
    }
  }
  get subpassCount() {
    return this.memoryViewUint32[0x8];
  }
  set subpassCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.subpassCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pSubpasses() {
    return this._pSubpasses;
  }
  set pSubpasses(value) {
    if (value !== null && value.constructor === Array) {
      this._pSubpasses = value;
    } else if (value === null) {
      this._pSubpasses = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pSubpasses': Expected 'Array VkSubpassDescription2KHR' but got '" + value.constructor.name + "'");
    }
  }
  get dependencyCount() {
    return this.memoryViewUint32[0xC];
  }
  set dependencyCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.dependencyCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get pDependencies() {
    return this._pDependencies;
  }
  set pDependencies(value) {
    if (value !== null && value.constructor === Array) {
      this._pDependencies = value;
    } else if (value === null) {
      this._pDependencies = null;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pDependencies': Expected 'Array VkSubpassDependency2KHR' but got '" + value.constructor.name + "'");
    }
  }
  get correlatedViewMaskCount() {
    return this.memoryViewUint32[0x10];
  }
  set correlatedViewMaskCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.correlatedViewMaskCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x10] = value;
  }
  get pCorrelatedViewMasks() {
    return this._pCorrelatedViewMasks;
  }
  set pCorrelatedViewMasks(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pCorrelatedViewMasks = value;
      this.memoryViewBigInt64[0x9] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCorrelatedViewMasks = null;
      this.memoryViewBigInt64[0x9] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pCorrelatedViewMasks': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassCreateInfo2KHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAttachments !== null) {
    let array = this._pAttachments;
    if (array.length !== this.attachmentCount) {
      throw new RangeError("Invalid array length, expected length of 'attachmentCount' for 'VkRenderPassCreateInfo2KHR.pAttachments'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAttachmentDescription2KHR) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pAttachments[" + ii + "]': Expected 'VkAttachmentDescription2KHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pAttachmentsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pSubpasses !== null) {
    let array = this._pSubpasses;
    if (array.length !== this.subpassCount) {
      throw new RangeError("Invalid array length, expected length of 'subpassCount' for 'VkRenderPassCreateInfo2KHR.pSubpasses'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSubpassDescription2KHR) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pSubpasses[" + ii + "]': Expected 'VkSubpassDescription2KHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSubpassesNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  
  if (this._pDependencies !== null) {
    let array = this._pDependencies;
    if (array.length !== this.dependencyCount) {
      throw new RangeError("Invalid array length, expected length of 'dependencyCount' for 'VkRenderPassCreateInfo2KHR.pDependencies'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSubpassDependency2KHR) {
        throw new TypeError("Invalid type for 'VkRenderPassCreateInfo2KHR.pDependencies[" + ii + "]': Expected 'VkSubpassDependency2KHR' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pDependenciesNative = nativeArray;
    this.memoryViewBigInt64[0x7] = nativeArray.address;
  }
  
  return true;
};

VkRenderPassCreateInfo2KHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
  
  
};

VkRenderPassCreateInfo2KHR.byteLength = 0x50;

VkRenderPassCreateInfo2KHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  attachmentCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pAttachments: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  subpassCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pSubpasses: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  dependencyCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  pDependencies: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  correlatedViewMaskCount: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  pCorrelatedViewMasks: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x8
  }),
});
/** VkSubpassBeginInfoKHR **/
class VkSubpassBeginInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C73CD;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.contents !== void 0) this.contents = opts.contents;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassBeginInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSubpassBeginInfoKHR.pNext' isn't allowed to be filled");
  }
  get contents() {
    return this.memoryViewInt32[0x4];
  }
  set contents(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassBeginInfoKHR.contents': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkSubpassBeginInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassBeginInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassBeginInfoKHR.byteLength = 0x18;

VkSubpassBeginInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  contents: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkSubpassEndInfoKHR **/
class VkSubpassEndInfoKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this.sType = 0x3B9C73CE;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassEndInfoKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSubpassEndInfoKHR.pNext' isn't allowed to be filled");
  }
  
};

VkSubpassEndInfoKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassEndInfoKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassEndInfoKHR.byteLength = 0x10;

VkSubpassEndInfoKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkVertexInputBindingDivisorDescriptionEXT **/
class VkVertexInputBindingDivisorDescriptionEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.binding !== void 0) this.binding = opts.binding;
      if (opts.divisor !== void 0) this.divisor = opts.divisor;
      
    }
  }
  get binding() {
    return this.memoryViewUint32[0x0];
  }
  set binding(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDivisorDescriptionEXT.binding': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get divisor() {
    return this.memoryViewUint32[0x1];
  }
  set divisor(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkVertexInputBindingDivisorDescriptionEXT.divisor': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  
};

VkVertexInputBindingDivisorDescriptionEXT.prototype.flush = function flush() {
  
  return true;
};

VkVertexInputBindingDivisorDescriptionEXT.prototype.reflect = function reflect(memoryAddress) {
  
};

VkVertexInputBindingDivisorDescriptionEXT.byteLength = 0x8;

VkVertexInputBindingDivisorDescriptionEXT.memoryLayout = Object.freeze({
  binding: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  divisor: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkPipelineVertexInputDivisorStateCreateInfoEXT **/
class VkPipelineVertexInputDivisorStateCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pVertexBindingDivisors = null;
    this._pVertexBindingDivisorsNative = null;
    this.sType = 0x3B9DB031;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.vertexBindingDivisorCount !== void 0) this.vertexBindingDivisorCount = opts.vertexBindingDivisorCount;
      if (opts.pVertexBindingDivisors !== void 0) this.pVertexBindingDivisors = opts.pVertexBindingDivisors;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineVertexInputDivisorStateCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get vertexBindingDivisorCount() {
    return this.memoryViewUint32[0x4];
  }
  set vertexBindingDivisorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.vertexBindingDivisorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pVertexBindingDivisors() {
    return this._pVertexBindingDivisors;
  }
  set pVertexBindingDivisors(value) {
    if (value !== null && value.constructor === Array) {
      this._pVertexBindingDivisors = value;
    } else if (value === null) {
      this._pVertexBindingDivisors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors': Expected 'Array VkVertexInputBindingDivisorDescriptionEXT' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pVertexBindingDivisors !== null) {
    let array = this._pVertexBindingDivisors;
    if (array.length !== this.vertexBindingDivisorCount) {
      throw new RangeError("Invalid array length, expected length of 'vertexBindingDivisorCount' for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkVertexInputBindingDivisorDescriptionEXT) {
        throw new TypeError("Invalid type for 'VkPipelineVertexInputDivisorStateCreateInfoEXT.pVertexBindingDivisors[" + ii + "]': Expected 'VkVertexInputBindingDivisorDescriptionEXT' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pVertexBindingDivisorsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineVertexInputDivisorStateCreateInfoEXT.byteLength = 0x20;

VkPipelineVertexInputDivisorStateCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  vertexBindingDivisorCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pVertexBindingDivisors: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT **/
class VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9DB030;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get maxVertexAttribDivisor() {
    return this.memoryViewUint32[0x4];
  }
  
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.byteLength = 0x18;

VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxVertexAttribDivisor: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDevicePCIBusInfoPropertiesEXT **/
class VkPhysicalDevicePCIBusInfoPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this.sType = 0x3B9E0620;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevicePCIBusInfoPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDevicePCIBusInfoPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get pciDomain() {
    return this.memoryViewUint32[0x4];
  }
  get pciBus() {
    return this.memoryViewUint32[0x5];
  }
  get pciDevice() {
    return this.memoryViewUint32[0x6];
  }
  get pciFunction() {
    return this.memoryViewUint32[0x7];
  }
  
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDevicePCIBusInfoPropertiesEXT.byteLength = 0x20;

VkPhysicalDevicePCIBusInfoPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  pciDomain: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pciBus: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pciDevice: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pciFunction: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkCommandBufferInheritanceConditionalRenderingInfoEXT **/
class VkCommandBufferInheritanceConditionalRenderingInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C0668;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.conditionalRenderingEnable !== void 0) this.conditionalRenderingEnable = opts.conditionalRenderingEnable;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCommandBufferInheritanceConditionalRenderingInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCommandBufferInheritanceConditionalRenderingInfoEXT.pNext' isn't allowed to be filled");
  }
  get conditionalRenderingEnable() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set conditionalRenderingEnable(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCommandBufferInheritanceConditionalRenderingInfoEXT.byteLength = 0x18;

VkCommandBufferInheritanceConditionalRenderingInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  conditionalRenderingEnable: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDevice8BitStorageFeaturesKHR **/
class VkPhysicalDevice8BitStorageFeaturesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9D7D68;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.storageBuffer8BitAccess !== void 0) this.storageBuffer8BitAccess = opts.storageBuffer8BitAccess;
      if (opts.uniformAndStorageBuffer8BitAccess !== void 0) this.uniformAndStorageBuffer8BitAccess = opts.uniformAndStorageBuffer8BitAccess;
      if (opts.storagePushConstant8 !== void 0) this.storagePushConstant8 = opts.storagePushConstant8;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDevice8BitStorageFeaturesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDevice8BitStorageFeaturesKHR.pNext' isn't allowed to be filled");
  }
  get storageBuffer8BitAccess() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set storageBuffer8BitAccess(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get uniformAndStorageBuffer8BitAccess() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set uniformAndStorageBuffer8BitAccess(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get storagePushConstant8() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set storagePushConstant8(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  
};

VkPhysicalDevice8BitStorageFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDevice8BitStorageFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDevice8BitStorageFeaturesKHR.byteLength = 0x20;

VkPhysicalDevice8BitStorageFeaturesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  storageBuffer8BitAccess: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  uniformAndStorageBuffer8BitAccess: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  storagePushConstant8: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceConditionalRenderingFeaturesEXT **/
class VkPhysicalDeviceConditionalRenderingFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9C0669;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.conditionalRendering !== void 0) this.conditionalRendering = opts.conditionalRendering;
      if (opts.inheritedConditionalRendering !== void 0) this.inheritedConditionalRendering = opts.inheritedConditionalRendering;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceConditionalRenderingFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceConditionalRenderingFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get conditionalRendering() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set conditionalRendering(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get inheritedConditionalRendering() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set inheritedConditionalRendering(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceConditionalRenderingFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceConditionalRenderingFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  conditionalRendering: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  inheritedConditionalRendering: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceVulkanMemoryModelFeaturesKHR **/
class VkPhysicalDeviceVulkanMemoryModelFeaturesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9E0238;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.vulkanMemoryModel !== void 0) this.vulkanMemoryModel = opts.vulkanMemoryModel;
      if (opts.vulkanMemoryModelDeviceScope !== void 0) this.vulkanMemoryModelDeviceScope = opts.vulkanMemoryModelDeviceScope;
      if (opts.vulkanMemoryModelAvailabilityVisibilityChains !== void 0) this.vulkanMemoryModelAvailabilityVisibilityChains = opts.vulkanMemoryModelAvailabilityVisibilityChains;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.pNext' isn't allowed to be filled");
  }
  get vulkanMemoryModel() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set vulkanMemoryModel(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get vulkanMemoryModelDeviceScope() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set vulkanMemoryModelDeviceScope(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get vulkanMemoryModelAvailabilityVisibilityChains() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set vulkanMemoryModelAvailabilityVisibilityChains(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.byteLength = 0x20;

VkPhysicalDeviceVulkanMemoryModelFeaturesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  vulkanMemoryModel: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  vulkanMemoryModelDeviceScope: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  vulkanMemoryModelAvailabilityVisibilityChains: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceShaderAtomicInt64FeaturesKHR **/
class VkPhysicalDeviceShaderAtomicInt64FeaturesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9D8920;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.shaderBufferInt64Atomics !== void 0) this.shaderBufferInt64Atomics = opts.shaderBufferInt64Atomics;
      if (opts.shaderSharedInt64Atomics !== void 0) this.shaderSharedInt64Atomics = opts.shaderSharedInt64Atomics;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.pNext' isn't allowed to be filled");
  }
  get shaderBufferInt64Atomics() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set shaderBufferInt64Atomics(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get shaderSharedInt64Atomics() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set shaderSharedInt64Atomics(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.byteLength = 0x18;

VkPhysicalDeviceShaderAtomicInt64FeaturesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shaderBufferInt64Atomics: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  shaderSharedInt64Atomics: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT **/
class VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9DB032;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.vertexAttributeInstanceRateDivisor !== void 0) this.vertexAttributeInstanceRateDivisor = opts.vertexAttributeInstanceRateDivisor;
      if (opts.vertexAttributeInstanceRateZeroDivisor !== void 0) this.vertexAttributeInstanceRateZeroDivisor = opts.vertexAttributeInstanceRateZeroDivisor;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get vertexAttributeInstanceRateDivisor() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set vertexAttributeInstanceRateDivisor(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get vertexAttributeInstanceRateZeroDivisor() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set vertexAttributeInstanceRateZeroDivisor(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  vertexAttributeInstanceRateDivisor: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  vertexAttributeInstanceRateZeroDivisor: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkQueueFamilyCheckpointPropertiesNV **/
class VkQueueFamilyCheckpointPropertiesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9DEEB1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkQueueFamilyCheckpointPropertiesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkQueueFamilyCheckpointPropertiesNV.pNext' isn't allowed to be filled");
  }
  get checkpointExecutionStageMask() {
    return this.memoryViewInt32[0x4];
  }
  
};

VkQueueFamilyCheckpointPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkQueueFamilyCheckpointPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkQueueFamilyCheckpointPropertiesNV.byteLength = 0x18;

VkQueueFamilyCheckpointPropertiesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  checkpointExecutionStageMask: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkCheckpointDataNV **/
class VkCheckpointDataNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pCheckpointMarker = null;
    this.sType = 0x3B9DEEB0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.pCheckpointMarker !== void 0) this.pCheckpointMarker = opts.pCheckpointMarker;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCheckpointDataNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCheckpointDataNV.pNext' isn't allowed to be filled");
  }
  get stage() {
    return this.memoryViewInt32[0x4];
  }
  get pCheckpointMarker() {
    return this._pCheckpointMarker;
  }
  set pCheckpointMarker(value) {
    if (value !== null && value.constructor === ArrayBuffer) {
      this._pCheckpointMarker = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pCheckpointMarker = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkCheckpointDataNV.pCheckpointMarker': Expected 'ArrayBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkCheckpointDataNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCheckpointDataNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkCheckpointDataNV.byteLength = 0x20;

VkCheckpointDataNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  stage: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pCheckpointMarker: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceDepthStencilResolvePropertiesKHR **/
class VkPhysicalDeviceDepthStencilResolvePropertiesKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this.sType = 0x3B9DD358;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDepthStencilResolvePropertiesKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceDepthStencilResolvePropertiesKHR.pNext' isn't allowed to be filled");
  }
  get supportedDepthResolveModes() {
    return this.memoryViewInt32[0x4];
  }
  get supportedStencilResolveModes() {
    return this.memoryViewInt32[0x5];
  }
  get independentResolveNone() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  get independentResolve() {
    return this.memoryViewUint32[0x7] !== 0;
  }
  
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.byteLength = 0x20;

VkPhysicalDeviceDepthStencilResolvePropertiesKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  supportedDepthResolveModes: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  supportedStencilResolveModes: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  independentResolveNone: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  independentResolve: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkSubpassDescriptionDepthStencilResolveKHR **/
class VkSubpassDescriptionDepthStencilResolveKHR {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pDepthStencilResolveAttachment = null;
    this.sType = 0x3B9DD359;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.depthResolveMode !== void 0) this.depthResolveMode = opts.depthResolveMode;
      if (opts.stencilResolveMode !== void 0) this.stencilResolveMode = opts.stencilResolveMode;
      if (opts.pDepthStencilResolveAttachment !== void 0) this.pDepthStencilResolveAttachment = opts.pDepthStencilResolveAttachment;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkSubpassDescriptionDepthStencilResolveKHR.pNext' isn't allowed to be filled");
  }
  get depthResolveMode() {
    return this.memoryViewInt32[0x4];
  }
  set depthResolveMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.depthResolveMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get stencilResolveMode() {
    return this.memoryViewInt32[0x5];
  }
  set stencilResolveMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.stencilResolveMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get pDepthStencilResolveAttachment() {
    return this._pDepthStencilResolveAttachment;
  }
  set pDepthStencilResolveAttachment(value) {
    if (value !== null && value.constructor === VkAttachmentReference2KHR) {
      value.flush();
      this._pDepthStencilResolveAttachment = value;
      this.memoryViewBigInt64[0x3] = value.memoryAddress;
      
    } else if (value === null) {
      this._pDepthStencilResolveAttachment = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkSubpassDescriptionDepthStencilResolveKHR.pDepthStencilResolveAttachment': Expected 'VkAttachmentReference2KHR' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkSubpassDescriptionDepthStencilResolveKHR.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkSubpassDescriptionDepthStencilResolveKHR.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkSubpassDescriptionDepthStencilResolveKHR.byteLength = 0x20;

VkSubpassDescriptionDepthStencilResolveKHR.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  depthResolveMode: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  stencilResolveMode: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pDepthStencilResolveAttachment: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkImageViewASTCDecodeModeEXT **/
class VkImageViewASTCDecodeModeEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BCFB8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.decodeMode !== void 0) this.decodeMode = opts.decodeMode;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewASTCDecodeModeEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageViewASTCDecodeModeEXT.pNext' isn't allowed to be filled");
  }
  get decodeMode() {
    return this.memoryViewInt32[0x4];
  }
  set decodeMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageViewASTCDecodeModeEXT.decodeMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkImageViewASTCDecodeModeEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageViewASTCDecodeModeEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageViewASTCDecodeModeEXT.byteLength = 0x18;

VkImageViewASTCDecodeModeEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  decodeMode: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceASTCDecodeFeaturesEXT **/
class VkPhysicalDeviceASTCDecodeFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9BCFB9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.decodeModeSharedExponent !== void 0) this.decodeModeSharedExponent = opts.decodeModeSharedExponent;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceASTCDecodeFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceASTCDecodeFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get decodeModeSharedExponent() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set decodeModeSharedExponent(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceASTCDecodeFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceASTCDecodeFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  decodeModeSharedExponent: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceTransformFeedbackFeaturesEXT **/
class VkPhysicalDeviceTransformFeedbackFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9B3760;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.transformFeedback !== void 0) this.transformFeedback = opts.transformFeedback;
      if (opts.geometryStreams !== void 0) this.geometryStreams = opts.geometryStreams;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceTransformFeedbackFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceTransformFeedbackFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get transformFeedback() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set transformFeedback(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get geometryStreams() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set geometryStreams(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceTransformFeedbackFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceTransformFeedbackFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  transformFeedback: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  geometryStreams: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceTransformFeedbackPropertiesEXT **/
class VkPhysicalDeviceTransformFeedbackPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    
    
    this.sType = 0x3B9B3761;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceTransformFeedbackPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceTransformFeedbackPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get maxTransformFeedbackStreams() {
    return this.memoryViewUint32[0x4];
  }
  get maxTransformFeedbackBuffers() {
    return this.memoryViewUint32[0x5];
  }
  get maxTransformFeedbackBufferSize() {
    return this.memoryViewBigUint64[0x3];
  }
  get maxTransformFeedbackStreamDataSize() {
    return this.memoryViewUint32[0x8];
  }
  get maxTransformFeedbackBufferDataSize() {
    return this.memoryViewUint32[0x9];
  }
  get maxTransformFeedbackBufferDataStride() {
    return this.memoryViewUint32[0xA];
  }
  get transformFeedbackQueries() {
    return this.memoryViewUint32[0xB] !== 0;
  }
  get transformFeedbackStreamsLinesTriangles() {
    return this.memoryViewUint32[0xC] !== 0;
  }
  get transformFeedbackRasterizationStreamSelect() {
    return this.memoryViewUint32[0xD] !== 0;
  }
  get transformFeedbackDraw() {
    return this.memoryViewUint32[0xE] !== 0;
  }
  
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
};

VkPhysicalDeviceTransformFeedbackPropertiesEXT.byteLength = 0x40;

VkPhysicalDeviceTransformFeedbackPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxTransformFeedbackStreams: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxTransformFeedbackBuffers: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  maxTransformFeedbackBufferSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  maxTransformFeedbackStreamDataSize: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  maxTransformFeedbackBufferDataSize: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  maxTransformFeedbackBufferDataStride: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  transformFeedbackQueries: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  transformFeedbackStreamsLinesTriangles: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  transformFeedbackRasterizationStreamSelect: Object.freeze({
    byteOffset: 0x34,
    byteLength: 0x4
  }),
  transformFeedbackDraw: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
});
/** VkPipelineRasterizationStateStreamCreateInfoEXT **/
class VkPipelineRasterizationStateStreamCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9B3762;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.rasterizationStream !== void 0) this.rasterizationStream = opts.rasterizationStream;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateStreamCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineRasterizationStateStreamCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateStreamCreateInfoEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get rasterizationStream() {
    return this.memoryViewUint32[0x5];
  }
  set rasterizationStream(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationStateStreamCreateInfoEXT.rasterizationStream': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  
};

VkPipelineRasterizationStateStreamCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationStateStreamCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationStateStreamCreateInfoEXT.byteLength = 0x18;

VkPipelineRasterizationStateStreamCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  rasterizationStream: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV **/
class VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D5270;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.representativeFragmentTest !== void 0) this.representativeFragmentTest = opts.representativeFragmentTest;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.pNext' isn't allowed to be filled");
  }
  get representativeFragmentTest() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set representativeFragmentTest(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  representativeFragmentTest: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPipelineRepresentativeFragmentTestStateCreateInfoNV **/
class VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D5271;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.representativeFragmentTestEnable !== void 0) this.representativeFragmentTestEnable = opts.representativeFragmentTestEnable;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRepresentativeFragmentTestStateCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineRepresentativeFragmentTestStateCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get representativeFragmentTestEnable() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set representativeFragmentTestEnable(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.byteLength = 0x18;

VkPipelineRepresentativeFragmentTestStateCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  representativeFragmentTestEnable: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceExclusiveScissorFeaturesNV **/
class VkPhysicalDeviceExclusiveScissorFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9DEACA;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.exclusiveScissor !== void 0) this.exclusiveScissor = opts.exclusiveScissor;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceExclusiveScissorFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceExclusiveScissorFeaturesNV.pNext' isn't allowed to be filled");
  }
  get exclusiveScissor() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set exclusiveScissor(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceExclusiveScissorFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceExclusiveScissorFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  exclusiveScissor: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPipelineViewportExclusiveScissorStateCreateInfoNV **/
class VkPipelineViewportExclusiveScissorStateCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pExclusiveScissors = null;
    this._pExclusiveScissorsNative = null;
    this.sType = 0x3B9DEAC8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.exclusiveScissorCount !== void 0) this.exclusiveScissorCount = opts.exclusiveScissorCount;
      if (opts.pExclusiveScissors !== void 0) this.pExclusiveScissors = opts.pExclusiveScissors;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get exclusiveScissorCount() {
    return this.memoryViewUint32[0x4];
  }
  set exclusiveScissorCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.exclusiveScissorCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pExclusiveScissors() {
    return this._pExclusiveScissors;
  }
  set pExclusiveScissors(value) {
    if (value !== null && value.constructor === Array) {
      this._pExclusiveScissors = value;
    } else if (value === null) {
      this._pExclusiveScissors = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors': Expected 'Array VkRect2D' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pExclusiveScissors !== null) {
    let array = this._pExclusiveScissors;
    if (array.length !== this.exclusiveScissorCount) {
      throw new RangeError("Invalid array length, expected length of 'exclusiveScissorCount' for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRect2D) {
        throw new TypeError("Invalid type for 'VkPipelineViewportExclusiveScissorStateCreateInfoNV.pExclusiveScissors[" + ii + "]': Expected 'VkRect2D' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pExclusiveScissorsNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportExclusiveScissorStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportExclusiveScissorStateCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  exclusiveScissorCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pExclusiveScissors: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceCornerSampledImageFeaturesNV **/
class VkPhysicalDeviceCornerSampledImageFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9B8D50;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.cornerSampledImage !== void 0) this.cornerSampledImage = opts.cornerSampledImage;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceCornerSampledImageFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceCornerSampledImageFeaturesNV.pNext' isn't allowed to be filled");
  }
  get cornerSampledImage() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set cornerSampledImage(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceCornerSampledImageFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceCornerSampledImageFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  cornerSampledImage: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceComputeShaderDerivativesFeaturesNV **/
class VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9DDB28;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.computeDerivativeGroupQuads !== void 0) this.computeDerivativeGroupQuads = opts.computeDerivativeGroupQuads;
      if (opts.computeDerivativeGroupLinear !== void 0) this.computeDerivativeGroupLinear = opts.computeDerivativeGroupLinear;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.pNext' isn't allowed to be filled");
  }
  get computeDerivativeGroupQuads() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set computeDerivativeGroupQuads(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get computeDerivativeGroupLinear() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set computeDerivativeGroupLinear(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  computeDerivativeGroupQuads: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  computeDerivativeGroupLinear: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV **/
class VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9DE2F8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.fragmentShaderBarycentric !== void 0) this.fragmentShaderBarycentric = opts.fragmentShaderBarycentric;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.pNext' isn't allowed to be filled");
  }
  get fragmentShaderBarycentric() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set fragmentShaderBarycentric(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  fragmentShaderBarycentric: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceShaderImageFootprintFeaturesNV **/
class VkPhysicalDeviceShaderImageFootprintFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9DE6E0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.imageFootprint !== void 0) this.imageFootprint = opts.imageFootprint;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShaderImageFootprintFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceShaderImageFootprintFeaturesNV.pNext' isn't allowed to be filled");
  }
  get imageFootprint() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set imageFootprint(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShaderImageFootprintFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceShaderImageFootprintFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  imageFootprint: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV **/
class VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9E7380;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.dedicatedAllocationImageAliasing !== void 0) this.dedicatedAllocationImageAliasing = opts.dedicatedAllocationImageAliasing;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.pNext' isn't allowed to be filled");
  }
  get dedicatedAllocationImageAliasing() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set dedicatedAllocationImageAliasing(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  dedicatedAllocationImageAliasing: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkShadingRatePaletteNV **/
class VkShadingRatePaletteNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pShadingRatePaletteEntries = null;
    
    if (typeof opts === "object") {
      if (opts.shadingRatePaletteEntryCount !== void 0) this.shadingRatePaletteEntryCount = opts.shadingRatePaletteEntryCount;
      if (opts.pShadingRatePaletteEntries !== void 0) this.pShadingRatePaletteEntries = opts.pShadingRatePaletteEntries;
      
    }
  }
  get shadingRatePaletteEntryCount() {
    return this.memoryViewUint32[0x0];
  }
  set shadingRatePaletteEntryCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkShadingRatePaletteNV.shadingRatePaletteEntryCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get pShadingRatePaletteEntries() {
    return this._pShadingRatePaletteEntries;
  }
  set pShadingRatePaletteEntries(value) {
    if (value !== null && value.constructor === Int32Array) {
      this._pShadingRatePaletteEntries = value;
      this.memoryViewBigInt64[0x1] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pShadingRatePaletteEntries = null;
      this.memoryViewBigInt64[0x1] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkShadingRatePaletteNV.pShadingRatePaletteEntries': Expected 'Int32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkShadingRatePaletteNV.prototype.flush = function flush() {
  
  return true;
};

VkShadingRatePaletteNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkShadingRatePaletteNV.byteLength = 0x10;

VkShadingRatePaletteNV.memoryLayout = Object.freeze({
  shadingRatePaletteEntryCount: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pShadingRatePaletteEntries: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
});
/** VkPipelineViewportShadingRateImageStateCreateInfoNV **/
class VkPipelineViewportShadingRateImageStateCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pShadingRatePalettes = null;
    this._pShadingRatePalettesNative = null;
    this.sType = 0x3B9D4AA0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.shadingRateImageEnable !== void 0) this.shadingRateImageEnable = opts.shadingRateImageEnable;
      if (opts.viewportCount !== void 0) this.viewportCount = opts.viewportCount;
      if (opts.pShadingRatePalettes !== void 0) this.pShadingRatePalettes = opts.pShadingRatePalettes;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineViewportShadingRateImageStateCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get shadingRateImageEnable() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set shadingRateImageEnable(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get viewportCount() {
    return this.memoryViewUint32[0x5];
  }
  set viewportCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.viewportCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pShadingRatePalettes() {
    return this._pShadingRatePalettes;
  }
  set pShadingRatePalettes(value) {
    if (value !== null && value.constructor === Array) {
      this._pShadingRatePalettes = value;
    } else if (value === null) {
      this._pShadingRatePalettes = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes': Expected 'Array VkShadingRatePaletteNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pShadingRatePalettes !== null) {
    let array = this._pShadingRatePalettes;
    if (array.length !== this.viewportCount) {
      throw new RangeError("Invalid array length, expected length of 'viewportCount' for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkShadingRatePaletteNV) {
        throw new TypeError("Invalid type for 'VkPipelineViewportShadingRateImageStateCreateInfoNV.pShadingRatePalettes[" + ii + "]': Expected 'VkShadingRatePaletteNV' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pShadingRatePalettesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportShadingRateImageStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportShadingRateImageStateCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shadingRateImageEnable: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  viewportCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pShadingRatePalettes: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceShadingRateImageFeaturesNV **/
class VkPhysicalDeviceShadingRateImageFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9D4AA1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.shadingRateImage !== void 0) this.shadingRateImage = opts.shadingRateImage;
      if (opts.shadingRateCoarseSampleOrder !== void 0) this.shadingRateCoarseSampleOrder = opts.shadingRateCoarseSampleOrder;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShadingRateImageFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceShadingRateImageFeaturesNV.pNext' isn't allowed to be filled");
  }
  get shadingRateImage() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set shadingRateImage(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get shadingRateCoarseSampleOrder() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set shadingRateCoarseSampleOrder(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceShadingRateImageFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShadingRateImageFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceShadingRateImageFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceShadingRateImageFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shadingRateImage: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  shadingRateCoarseSampleOrder: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceShadingRateImagePropertiesNV **/
class VkPhysicalDeviceShadingRateImagePropertiesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._shadingRateTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    
    
    this.sType = 0x3B9D4AA2;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceShadingRateImagePropertiesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceShadingRateImagePropertiesNV.pNext' isn't allowed to be filled");
  }
  get shadingRateTexelSize() {
    return this._shadingRateTexelSize;
  }
  get shadingRatePaletteSize() {
    return this.memoryViewUint32[0x6];
  }
  get shadingRateMaxCoarseSamples() {
    return this.memoryViewUint32[0x7];
  }
  
};

VkPhysicalDeviceShadingRateImagePropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceShadingRateImagePropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkPhysicalDeviceShadingRateImagePropertiesNV.byteLength = 0x20;

VkPhysicalDeviceShadingRateImagePropertiesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shadingRateTexelSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  shadingRatePaletteSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  shadingRateMaxCoarseSamples: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
});
/** VkCoarseSampleLocationNV **/
class VkCoarseSampleLocationNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xC) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xC);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      if (opts.pixelX !== void 0) this.pixelX = opts.pixelX;
      if (opts.pixelY !== void 0) this.pixelY = opts.pixelY;
      if (opts.sample !== void 0) this.sample = opts.sample;
      
    }
  }
  get pixelX() {
    return this.memoryViewUint32[0x0];
  }
  set pixelX(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleLocationNV.pixelX': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get pixelY() {
    return this.memoryViewUint32[0x1];
  }
  set pixelY(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleLocationNV.pixelY': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get sample() {
    return this.memoryViewUint32[0x2];
  }
  set sample(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleLocationNV.sample': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  
};

VkCoarseSampleLocationNV.prototype.flush = function flush() {
  
  return true;
};

VkCoarseSampleLocationNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkCoarseSampleLocationNV.byteLength = 0xC;

VkCoarseSampleLocationNV.memoryLayout = Object.freeze({
  pixelX: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pixelY: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  sample: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
});
/** VkCoarseSampleOrderCustomNV **/
class VkCoarseSampleOrderCustomNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    this._pSampleLocations = null;
    this._pSampleLocationsNative = null;
    
    if (typeof opts === "object") {
      if (opts.shadingRate !== void 0) this.shadingRate = opts.shadingRate;
      if (opts.sampleCount !== void 0) this.sampleCount = opts.sampleCount;
      if (opts.sampleLocationCount !== void 0) this.sampleLocationCount = opts.sampleLocationCount;
      if (opts.pSampleLocations !== void 0) this.pSampleLocations = opts.pSampleLocations;
      
    }
  }
  get shadingRate() {
    return this.memoryViewInt32[0x0];
  }
  set shadingRate(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.shadingRate': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get sampleCount() {
    return this.memoryViewUint32[0x1];
  }
  set sampleCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.sampleCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  get sampleLocationCount() {
    return this.memoryViewUint32[0x2];
  }
  set sampleLocationCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.sampleLocationCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x2] = value;
  }
  get pSampleLocations() {
    return this._pSampleLocations;
  }
  set pSampleLocations(value) {
    if (value !== null && value.constructor === Array) {
      this._pSampleLocations = value;
    } else if (value === null) {
      this._pSampleLocations = null;
    } else {
      throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.pSampleLocations': Expected 'Array VkCoarseSampleLocationNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkCoarseSampleOrderCustomNV.prototype.flush = function flush() {
  
  
  if (this._pSampleLocations !== null) {
    let array = this._pSampleLocations;
    if (array.length !== this.sampleLocationCount) {
      throw new RangeError("Invalid array length, expected length of 'sampleLocationCount' for 'VkCoarseSampleOrderCustomNV.pSampleLocations'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkCoarseSampleLocationNV) {
        throw new TypeError("Invalid type for 'VkCoarseSampleOrderCustomNV.pSampleLocations[" + ii + "]': Expected 'VkCoarseSampleLocationNV' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pSampleLocationsNative = nativeArray;
    this.memoryViewBigInt64[0x2] = nativeArray.address;
  }
  
  return true;
};

VkCoarseSampleOrderCustomNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCoarseSampleOrderCustomNV.byteLength = 0x18;

VkCoarseSampleOrderCustomNV.memoryLayout = Object.freeze({
  shadingRate: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  sampleCount: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
  sampleLocationCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  pSampleLocations: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkPipelineViewportCoarseSampleOrderStateCreateInfoNV **/
class VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pCustomSampleOrders = null;
    this._pCustomSampleOrdersNative = null;
    this.sType = 0x3B9D4AA5;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.sampleOrderType !== void 0) this.sampleOrderType = opts.sampleOrderType;
      if (opts.customSampleOrderCount !== void 0) this.customSampleOrderCount = opts.customSampleOrderCount;
      if (opts.pCustomSampleOrders !== void 0) this.pCustomSampleOrders = opts.pCustomSampleOrders;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get sampleOrderType() {
    return this.memoryViewInt32[0x4];
  }
  set sampleOrderType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.sampleOrderType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get customSampleOrderCount() {
    return this.memoryViewUint32[0x5];
  }
  set customSampleOrderCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.customSampleOrderCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pCustomSampleOrders() {
    return this._pCustomSampleOrders;
  }
  set pCustomSampleOrders(value) {
    if (value !== null && value.constructor === Array) {
      this._pCustomSampleOrders = value;
    } else if (value === null) {
      this._pCustomSampleOrders = null;
    } else {
      throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders': Expected 'Array VkCoarseSampleOrderCustomNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pCustomSampleOrders !== null) {
    let array = this._pCustomSampleOrders;
    if (array.length !== this.customSampleOrderCount) {
      throw new RangeError("Invalid array length, expected length of 'customSampleOrderCount' for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkCoarseSampleOrderCustomNV) {
        throw new TypeError("Invalid type for 'VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.pCustomSampleOrders[" + ii + "]': Expected 'VkCoarseSampleOrderCustomNV' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pCustomSampleOrdersNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.byteLength = 0x20;

VkPipelineViewportCoarseSampleOrderStateCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  sampleOrderType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  customSampleOrderCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pCustomSampleOrders: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceMeshShaderFeaturesNV **/
class VkPhysicalDeviceMeshShaderFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9DDF10;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.taskShader !== void 0) this.taskShader = opts.taskShader;
      if (opts.meshShader !== void 0) this.meshShader = opts.meshShader;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMeshShaderFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMeshShaderFeaturesNV.pNext' isn't allowed to be filled");
  }
  get taskShader() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set taskShader(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get meshShader() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set meshShader(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceMeshShaderFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMeshShaderFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceMeshShaderFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceMeshShaderFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  taskShader: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  meshShader: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceMeshShaderPropertiesNV **/
class VkPhysicalDeviceMeshShaderPropertiesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x58) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x58) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x58);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._maxTaskWorkGroupSize = [...Array(3)].fill(0x0);
    
    
    
    this._maxMeshWorkGroupSize = [...Array(3)].fill(0x0);
    
    
    
    
    
    
    this.sType = 0x3B9DDF11;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMeshShaderPropertiesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMeshShaderPropertiesNV.pNext' isn't allowed to be filled");
  }
  get maxDrawMeshTasksCount() {
    return this.memoryViewUint32[0x4];
  }
  get maxTaskWorkGroupInvocations() {
    return this.memoryViewUint32[0x5];
  }
  get maxTaskWorkGroupSize() {
    return [
      this.memoryViewUint32[0x6],
      this.memoryViewUint32[0x7],
      this.memoryViewUint32[0x8]
    ];
  }
  get maxTaskTotalMemorySize() {
    return this.memoryViewUint32[0x9];
  }
  get maxTaskOutputCount() {
    return this.memoryViewUint32[0xA];
  }
  get maxMeshWorkGroupInvocations() {
    return this.memoryViewUint32[0xB];
  }
  get maxMeshWorkGroupSize() {
    return [
      this.memoryViewUint32[0xC],
      this.memoryViewUint32[0xD],
      this.memoryViewUint32[0xE]
    ];
  }
  get maxMeshTotalMemorySize() {
    return this.memoryViewUint32[0xF];
  }
  get maxMeshOutputVertices() {
    return this.memoryViewUint32[0x10];
  }
  get maxMeshOutputPrimitives() {
    return this.memoryViewUint32[0x11];
  }
  get maxMeshMultiviewViewCount() {
    return this.memoryViewUint32[0x12];
  }
  get meshOutputPerVertexGranularity() {
    return this.memoryViewUint32[0x13];
  }
  get meshOutputPerPrimitiveGranularity() {
    return this.memoryViewUint32[0x14];
  }
  
};

VkPhysicalDeviceMeshShaderPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMeshShaderPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x58));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x58), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceMeshShaderPropertiesNV.byteLength = 0x58;

VkPhysicalDeviceMeshShaderPropertiesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  maxDrawMeshTasksCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxTaskWorkGroupInvocations: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  maxTaskWorkGroupSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0xC
  }),
  maxTaskTotalMemorySize: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  maxTaskOutputCount: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  maxMeshWorkGroupInvocations: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
  maxMeshWorkGroupSize: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0xC
  }),
  maxMeshTotalMemorySize: Object.freeze({
    byteOffset: 0x3C,
    byteLength: 0x4
  }),
  maxMeshOutputVertices: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x4
  }),
  maxMeshOutputPrimitives: Object.freeze({
    byteOffset: 0x44,
    byteLength: 0x4
  }),
  maxMeshMultiviewViewCount: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  meshOutputPerVertexGranularity: Object.freeze({
    byteOffset: 0x4C,
    byteLength: 0x4
  }),
  meshOutputPerPrimitiveGranularity: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x4
  }),
});
/** VkDrawMeshTasksIndirectCommandNV **/
class VkDrawMeshTasksIndirectCommandNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x8) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    
    
    if (typeof opts === "object") {
      if (opts.taskCount !== void 0) this.taskCount = opts.taskCount;
      if (opts.firstTask !== void 0) this.firstTask = opts.firstTask;
      
    }
  }
  get taskCount() {
    return this.memoryViewUint32[0x0];
  }
  set taskCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawMeshTasksIndirectCommandNV.taskCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x0] = value;
  }
  get firstTask() {
    return this.memoryViewUint32[0x1];
  }
  set firstTask(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrawMeshTasksIndirectCommandNV.firstTask': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x1] = value;
  }
  
};

VkDrawMeshTasksIndirectCommandNV.prototype.flush = function flush() {
  
  return true;
};

VkDrawMeshTasksIndirectCommandNV.prototype.reflect = function reflect(memoryAddress) {
  
};

VkDrawMeshTasksIndirectCommandNV.byteLength = 0x8;

VkDrawMeshTasksIndirectCommandNV.memoryLayout = Object.freeze({
  taskCount: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  firstTask: Object.freeze({
    byteOffset: 0x4,
    byteLength: 0x4
  }),
});
/** VkRayTracingShaderGroupCreateInfoNV **/
class VkRayTracingShaderGroupCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    this.sType = 0x3B9D4E93;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.generalShader !== void 0) this.generalShader = opts.generalShader;
      if (opts.closestHitShader !== void 0) this.closestHitShader = opts.closestHitShader;
      if (opts.anyHitShader !== void 0) this.anyHitShader = opts.anyHitShader;
      if (opts.intersectionShader !== void 0) this.intersectionShader = opts.intersectionShader;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRayTracingShaderGroupCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get type() {
    return this.memoryViewInt32[0x4];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get generalShader() {
    return this.memoryViewUint32[0x5];
  }
  set generalShader(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.generalShader': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get closestHitShader() {
    return this.memoryViewUint32[0x6];
  }
  set closestHitShader(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.closestHitShader': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get anyHitShader() {
    return this.memoryViewUint32[0x7];
  }
  set anyHitShader(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.anyHitShader': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get intersectionShader() {
    return this.memoryViewUint32[0x8];
  }
  set intersectionShader(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingShaderGroupCreateInfoNV.intersectionShader': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  
};

VkRayTracingShaderGroupCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkRayTracingShaderGroupCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkRayTracingShaderGroupCreateInfoNV.byteLength = 0x28;

VkRayTracingShaderGroupCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  type: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  generalShader: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  closestHitShader: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  anyHitShader: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  intersectionShader: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkRayTracingPipelineCreateInfoNV **/
class VkRayTracingPipelineCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x50) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x50) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x50);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pStages = null;
    this._pStagesNative = null;
    
    this._pGroups = null;
    this._pGroupsNative = null;
    
    this._layout = null;
    this._basePipelineHandle = null;
    
    this.sType = 0x3B9D4E88;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.stageCount !== void 0) this.stageCount = opts.stageCount;
      if (opts.pStages !== void 0) this.pStages = opts.pStages;
      if (opts.groupCount !== void 0) this.groupCount = opts.groupCount;
      if (opts.pGroups !== void 0) this.pGroups = opts.pGroups;
      if (opts.maxRecursionDepth !== void 0) this.maxRecursionDepth = opts.maxRecursionDepth;
      if (opts.layout !== void 0) this.layout = opts.layout;
      if (opts.basePipelineHandle !== void 0) this.basePipelineHandle = opts.basePipelineHandle;
      if (opts.basePipelineIndex !== void 0) this.basePipelineIndex = opts.basePipelineIndex;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRayTracingPipelineCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get stageCount() {
    return this.memoryViewUint32[0x5];
  }
  set stageCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.stageCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get pStages() {
    return this._pStages;
  }
  set pStages(value) {
    if (value !== null && value.constructor === Array) {
      this._pStages = value;
    } else if (value === null) {
      this._pStages = null;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pStages': Expected 'Array VkPipelineShaderStageCreateInfo' but got '" + value.constructor.name + "'");
    }
  }
  get groupCount() {
    return this.memoryViewUint32[0x8];
  }
  set groupCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.groupCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get pGroups() {
    return this._pGroups;
  }
  set pGroups(value) {
    if (value !== null && value.constructor === Array) {
      this._pGroups = value;
    } else if (value === null) {
      this._pGroups = null;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pGroups': Expected 'Array VkRayTracingShaderGroupCreateInfoNV' but got '" + value.constructor.name + "'");
    }
  }
  get maxRecursionDepth() {
    return this.memoryViewUint32[0xC];
  }
  set maxRecursionDepth(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.maxRecursionDepth': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xC] = value;
  }
  get layout() {
    return this._layout;
  }
  set layout(value) {
    if (value !== null && value.constructor === VkPipelineLayout) {
      
      this._layout = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._layout = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.layout': Expected 'VkPipelineLayout' but got '" + value.constructor.name + "'");
    }
  }
  get basePipelineHandle() {
    return this._basePipelineHandle;
  }
  set basePipelineHandle(value) {
    if (value !== null && value.constructor === VkPipeline) {
      
      this._basePipelineHandle = value;
      
      this.memoryViewBigInt64[0x8] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._basePipelineHandle = null;
      this.memoryViewBigInt64[0x8] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.basePipelineHandle': Expected 'VkPipeline' but got '" + value.constructor.name + "'");
    }
  }
  get basePipelineIndex() {
    return this.memoryViewInt32[0x12];
  }
  set basePipelineIndex(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.basePipelineIndex': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x12] = value;
  }
  
};

VkRayTracingPipelineCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pStages !== null) {
    let array = this._pStages;
    if (array.length !== this.stageCount) {
      throw new RangeError("Invalid array length, expected length of 'stageCount' for 'VkRayTracingPipelineCreateInfoNV.pStages'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkPipelineShaderStageCreateInfo) {
        throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pStages[" + ii + "]': Expected 'VkPipelineShaderStageCreateInfo' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pStagesNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  
  if (this._pGroups !== null) {
    let array = this._pGroups;
    if (array.length !== this.groupCount) {
      throw new RangeError("Invalid array length, expected length of 'groupCount' for 'VkRayTracingPipelineCreateInfoNV.pGroups'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkRayTracingShaderGroupCreateInfoNV) {
        throw new TypeError("Invalid type for 'VkRayTracingPipelineCreateInfoNV.pGroups[" + ii + "]': Expected 'VkRayTracingShaderGroupCreateInfoNV' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pGroupsNative = nativeArray;
    this.memoryViewBigInt64[0x5] = nativeArray.address;
  }
  
  return true;
};

VkRayTracingPipelineCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkRayTracingPipelineCreateInfoNV.byteLength = 0x50;

VkRayTracingPipelineCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  stageCount: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  pStages: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  groupCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  pGroups: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  maxRecursionDepth: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  layout: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  basePipelineHandle: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x8
  }),
  basePipelineIndex: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
});
/** VkGeometryTrianglesNV **/
class VkGeometryTrianglesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x60) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x60) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x60);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._vertexData = null;
    
    
    
    
    this._indexData = null;
    
    
    
    this._transformData = null;
    
    this.sType = 0x3B9D4E8C;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.vertexData !== void 0) this.vertexData = opts.vertexData;
      if (opts.vertexOffset !== void 0) this.vertexOffset = opts.vertexOffset;
      if (opts.vertexCount !== void 0) this.vertexCount = opts.vertexCount;
      if (opts.vertexStride !== void 0) this.vertexStride = opts.vertexStride;
      if (opts.vertexFormat !== void 0) this.vertexFormat = opts.vertexFormat;
      if (opts.indexData !== void 0) this.indexData = opts.indexData;
      if (opts.indexOffset !== void 0) this.indexOffset = opts.indexOffset;
      if (opts.indexCount !== void 0) this.indexCount = opts.indexCount;
      if (opts.indexType !== void 0) this.indexType = opts.indexType;
      if (opts.transformData !== void 0) this.transformData = opts.transformData;
      if (opts.transformOffset !== void 0) this.transformOffset = opts.transformOffset;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkGeometryTrianglesNV.pNext' isn't allowed to be filled");
  }
  get vertexData() {
    return this._vertexData;
  }
  set vertexData(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._vertexData = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._vertexData = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexData': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get vertexOffset() {
    return this.memoryViewBigUint64[0x3];
  }
  set vertexOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x3] = value;
  }
  get vertexCount() {
    return this.memoryViewUint32[0x8];
  }
  set vertexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x8] = value;
  }
  get vertexStride() {
    return this.memoryViewBigUint64[0x5];
  }
  set vertexStride(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexStride': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x5] = value;
  }
  get vertexFormat() {
    return this.memoryViewInt32[0xC];
  }
  set vertexFormat(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.vertexFormat': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xC] = value;
  }
  get indexData() {
    return this._indexData;
  }
  set indexData(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._indexData = value;
      
      this.memoryViewBigInt64[0x7] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._indexData = null;
      this.memoryViewBigInt64[0x7] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexData': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get indexOffset() {
    return this.memoryViewBigUint64[0x8];
  }
  set indexOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x8] = value;
  }
  get indexCount() {
    return this.memoryViewUint32[0x12];
  }
  set indexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x12] = value;
  }
  get indexType() {
    return this.memoryViewInt32[0x13];
  }
  set indexType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.indexType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x13] = value;
  }
  get transformData() {
    return this._transformData;
  }
  set transformData(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._transformData = value;
      
      this.memoryViewBigInt64[0xA] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._transformData = null;
      this.memoryViewBigInt64[0xA] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.transformData': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get transformOffset() {
    return this.memoryViewBigUint64[0xB];
  }
  set transformOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkGeometryTrianglesNV.transformOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0xB] = value;
  }
  
};

VkGeometryTrianglesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkGeometryTrianglesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkGeometryTrianglesNV.byteLength = 0x60;

VkGeometryTrianglesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  vertexData: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  vertexOffset: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  vertexCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  vertexStride: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  vertexFormat: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x4
  }),
  indexData: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x8
  }),
  indexOffset: Object.freeze({
    byteOffset: 0x40,
    byteLength: 0x8
  }),
  indexCount: Object.freeze({
    byteOffset: 0x48,
    byteLength: 0x4
  }),
  indexType: Object.freeze({
    byteOffset: 0x4C,
    byteLength: 0x4
  }),
  transformData: Object.freeze({
    byteOffset: 0x50,
    byteLength: 0x8
  }),
  transformOffset: Object.freeze({
    byteOffset: 0x58,
    byteLength: 0x8
  }),
});
/** VkGeometryAABBNV **/
class VkGeometryAABBNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._aabbData = null;
    
    
    
    this.sType = 0x3B9D4E8D;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.aabbData !== void 0) this.aabbData = opts.aabbData;
      if (opts.numAABBs !== void 0) this.numAABBs = opts.numAABBs;
      if (opts.stride !== void 0) this.stride = opts.stride;
      if (opts.offset !== void 0) this.offset = opts.offset;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkGeometryAABBNV.pNext' isn't allowed to be filled");
  }
  get aabbData() {
    return this._aabbData;
  }
  set aabbData(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._aabbData = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._aabbData = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.aabbData': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  get numAABBs() {
    return this.memoryViewUint32[0x6];
  }
  set numAABBs(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.numAABBs': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get stride() {
    return this.memoryViewUint32[0x7];
  }
  set stride(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.stride': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get offset() {
    return this.memoryViewBigUint64[0x4];
  }
  set offset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkGeometryAABBNV.offset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  
};

VkGeometryAABBNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkGeometryAABBNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkGeometryAABBNV.byteLength = 0x28;

VkGeometryAABBNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  aabbData: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  numAABBs: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  stride: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  offset: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkGeometryDataNV **/
class VkGeometryDataNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x88);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);

    }
    this._triangles = new VkGeometryTrianglesNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    this._aabbs = new VkGeometryAABBNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x60 });
    
    if (typeof opts === "object") {
      if (opts.triangles !== void 0) this.triangles = opts.triangles;
      if (opts.aabbs !== void 0) this.aabbs = opts.aabbs;
      
    }
  }
  get triangles() {
    return this._triangles;
  }
  set triangles(value) {
    if (value !== null && value.constructor === VkGeometryTrianglesNV) {
      value.flush();
      this._triangles = value;
      
      
    } else if (value === null) {
      this._triangles = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryDataNV.triangles': Expected 'VkGeometryTrianglesNV' but got '" + value.constructor.name + "'");
    }
  }
  get aabbs() {
    return this._aabbs;
  }
  set aabbs(value) {
    if (value !== null && value.constructor === VkGeometryAABBNV) {
      value.flush();
      this._aabbs = value;
      
      
    } else if (value === null) {
      this._aabbs = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryDataNV.aabbs': Expected 'VkGeometryAABBNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkGeometryDataNV.prototype.flush = function flush() {
  
  
  if (this._triangles !== null) {
    this._triangles.flush();
    if (this.memoryBuffer !== this._triangles.memoryBuffer) {
      let srcView = new Uint8Array(this._triangles.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  
  if (this._aabbs !== null) {
    this._aabbs.flush();
    if (this.memoryBuffer !== this._aabbs.memoryBuffer) {
      let srcView = new Uint8Array(this._aabbs.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x60);
    }
  }
  
  return true;
};

VkGeometryDataNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkGeometryDataNV.byteLength = 0x88;

VkGeometryDataNV.memoryLayout = Object.freeze({
  triangles: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x60
  }),
  aabbs: Object.freeze({
    byteOffset: 0x60,
    byteLength: 0x28
  }),
});
/** VkGeometryNV **/
class VkGeometryNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0xA8) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0xA8) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0xA8);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._geometry = new VkGeometryDataNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    
    this.sType = 0x3B9D4E8B;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.geometryType !== void 0) this.geometryType = opts.geometryType;
      if (opts.geometry !== void 0) this.geometry = opts.geometry;
      if (opts.flags !== void 0) this.flags = opts.flags;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkGeometryNV.pNext' isn't allowed to be filled");
  }
  get geometryType() {
    return this.memoryViewInt32[0x4];
  }
  set geometryType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryNV.geometryType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get geometry() {
    return this._geometry;
  }
  set geometry(value) {
    if (value !== null && value.constructor === VkGeometryDataNV) {
      value.flush();
      this._geometry = value;
      
      
    } else if (value === null) {
      this._geometry = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkGeometryNV.geometry': Expected 'VkGeometryDataNV' but got '" + value.constructor.name + "'");
    }
  }
  get flags() {
    return this.memoryViewInt32[0x28];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkGeometryNV.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x28] = value;
  }
  
};

VkGeometryNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._geometry !== null) {
    this._geometry.flush();
    if (this.memoryBuffer !== this._geometry.memoryBuffer) {
      let srcView = new Uint8Array(this._geometry.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
    }
  }
  
  return true;
};

VkGeometryNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkGeometryNV.byteLength = 0xA8;

VkGeometryNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  geometryType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  geometry: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x88
  }),
  flags: Object.freeze({
    byteOffset: 0xA0,
    byteLength: 0x4
  }),
});
/** VkAccelerationStructureInfoNV **/
class VkAccelerationStructureInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    this._pGeometries = null;
    this._pGeometriesNative = null;
    this.sType = 0x3B9D4E94;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.instanceCount !== void 0) this.instanceCount = opts.instanceCount;
      if (opts.geometryCount !== void 0) this.geometryCount = opts.geometryCount;
      if (opts.pGeometries !== void 0) this.pGeometries = opts.pGeometries;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkAccelerationStructureInfoNV.pNext' isn't allowed to be filled");
  }
  get type() {
    return this.memoryViewInt32[0x4];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get flags() {
    return this.memoryViewInt32[0x5];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x5] = value;
  }
  get instanceCount() {
    return this.memoryViewUint32[0x6];
  }
  set instanceCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.instanceCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get geometryCount() {
    return this.memoryViewUint32[0x7];
  }
  set geometryCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.geometryCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get pGeometries() {
    return this._pGeometries;
  }
  set pGeometries(value) {
    if (value !== null && value.constructor === Array) {
      this._pGeometries = value;
    } else if (value === null) {
      this._pGeometries = null;
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.pGeometries': Expected 'Array VkGeometryNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkAccelerationStructureInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pGeometries !== null) {
    let array = this._pGeometries;
    if (array.length !== this.geometryCount) {
      throw new RangeError("Invalid array length, expected length of 'geometryCount' for 'VkAccelerationStructureInfoNV.pGeometries'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkGeometryNV) {
        throw new TypeError("Invalid type for 'VkAccelerationStructureInfoNV.pGeometries[" + ii + "]': Expected 'VkGeometryNV' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pGeometriesNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  return true;
};

VkAccelerationStructureInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkAccelerationStructureInfoNV.byteLength = 0x28;

VkAccelerationStructureInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  type: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  flags: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  instanceCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  geometryCount: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  pGeometries: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkAccelerationStructureCreateInfoNV **/
class VkAccelerationStructureCreateInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._info = new VkAccelerationStructureInfoNV({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    this.sType = 0x3B9D4E89;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.compactedSize !== void 0) this.compactedSize = opts.compactedSize;
      if (opts.info !== void 0) this.info = opts.info;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureCreateInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkAccelerationStructureCreateInfoNV.pNext' isn't allowed to be filled");
  }
  get compactedSize() {
    return this.memoryViewBigUint64[0x2];
  }
  set compactedSize(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureCreateInfoNV.compactedSize': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x2] = value;
  }
  get info() {
    return this._info;
  }
  set info(value) {
    if (value !== null && value.constructor === VkAccelerationStructureInfoNV) {
      value.flush();
      this._info = value;
      
      
    } else if (value === null) {
      this._info = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureCreateInfoNV.info': Expected 'VkAccelerationStructureInfoNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkAccelerationStructureCreateInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._info !== null) {
    this._info.flush();
    if (this.memoryBuffer !== this._info.memoryBuffer) {
      let srcView = new Uint8Array(this._info.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x18);
    }
  }
  
  return true;
};

VkAccelerationStructureCreateInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkAccelerationStructureCreateInfoNV.byteLength = 0x40;

VkAccelerationStructureCreateInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  compactedSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  info: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x28
  }),
});
/** VkBindAccelerationStructureMemoryInfoNV **/
class VkBindAccelerationStructureMemoryInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x38) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x38) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x38);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._accelerationStructure = null;
    this._memory = null;
    
    
    this._pDeviceIndices = null;
    this.sType = 0x3B9D4E8E;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
      if (opts.memory !== void 0) this.memory = opts.memory;
      if (opts.memoryOffset !== void 0) this.memoryOffset = opts.memoryOffset;
      if (opts.deviceIndexCount !== void 0) this.deviceIndexCount = opts.deviceIndexCount;
      if (opts.pDeviceIndices !== void 0) this.pDeviceIndices = opts.pDeviceIndices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBindAccelerationStructureMemoryInfoNV.pNext' isn't allowed to be filled");
  }
  get accelerationStructure() {
    return this._accelerationStructure;
  }
  set accelerationStructure(value) {
    if (value !== null && value.constructor === VkAccelerationStructureNV) {
      
      this._accelerationStructure = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._accelerationStructure = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.accelerationStructure': Expected 'VkAccelerationStructureNV' but got '" + value.constructor.name + "'");
    }
  }
  get memory() {
    return this._memory;
  }
  set memory(value) {
    if (value !== null && value.constructor === VkDeviceMemory) {
      
      this._memory = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._memory = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.memory': Expected 'VkDeviceMemory' but got '" + value.constructor.name + "'");
    }
  }
  get memoryOffset() {
    return this.memoryViewBigUint64[0x4];
  }
  set memoryOffset(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.memoryOffset': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x4] = value;
  }
  get deviceIndexCount() {
    return this.memoryViewUint32[0xA];
  }
  set deviceIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.deviceIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0xA] = value;
  }
  get pDeviceIndices() {
    return this._pDeviceIndices;
  }
  set pDeviceIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pDeviceIndices = value;
      this.memoryViewBigInt64[0x6] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDeviceIndices = null;
      this.memoryViewBigInt64[0x6] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBindAccelerationStructureMemoryInfoNV.pDeviceIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBindAccelerationStructureMemoryInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBindAccelerationStructureMemoryInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBindAccelerationStructureMemoryInfoNV.byteLength = 0x38;

VkBindAccelerationStructureMemoryInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  accelerationStructure: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  memory: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  memoryOffset: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  deviceIndexCount: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  pDeviceIndices: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
});
/** VkWriteDescriptorSetAccelerationStructureNV **/
class VkWriteDescriptorSetAccelerationStructureNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pAccelerationStructures = null;
    this._pAccelerationStructuresNative = null;
    this.sType = 0x3B9D4E8F;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.accelerationStructureCount !== void 0) this.accelerationStructureCount = opts.accelerationStructureCount;
      if (opts.pAccelerationStructures !== void 0) this.pAccelerationStructures = opts.pAccelerationStructures;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkWriteDescriptorSetAccelerationStructureNV.pNext' isn't allowed to be filled");
  }
  get accelerationStructureCount() {
    return this.memoryViewUint32[0x4];
  }
  set accelerationStructureCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.accelerationStructureCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pAccelerationStructures() {
    return this._pAccelerationStructures;
  }
  set pAccelerationStructures(value) {
    if (value !== null && value.constructor === Array) {
      this._pAccelerationStructures = value;
    } else if (value === null) {
      this._pAccelerationStructures = null;
    } else {
      throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures': Expected 'Array VkAccelerationStructureNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkWriteDescriptorSetAccelerationStructureNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pAccelerationStructures !== null) {
    let array = this._pAccelerationStructures;
    if (array.length !== this.accelerationStructureCount) {
      throw new RangeError("Invalid array length, expected length of 'accelerationStructureCount' for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkAccelerationStructureNV) {
        throw new TypeError("Invalid type for 'VkWriteDescriptorSetAccelerationStructureNV.pAccelerationStructures[" + ii + "]': Expected 'VkAccelerationStructureNV' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pAccelerationStructuresNative = nativeArray;
    this.memoryViewBigInt64[0x3] = nativeArray.address;
  }
  
  return true;
};

VkWriteDescriptorSetAccelerationStructureNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkWriteDescriptorSetAccelerationStructureNV.byteLength = 0x20;

VkWriteDescriptorSetAccelerationStructureNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  accelerationStructureCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pAccelerationStructures: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkAccelerationStructureMemoryRequirementsInfoNV **/
class VkAccelerationStructureMemoryRequirementsInfoNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._accelerationStructure = null;
    this.sType = 0x3B9D4E90;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.type !== void 0) this.type = opts.type;
      if (opts.accelerationStructure !== void 0) this.accelerationStructure = opts.accelerationStructure;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureMemoryRequirementsInfoNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkAccelerationStructureMemoryRequirementsInfoNV.pNext' isn't allowed to be filled");
  }
  get type() {
    return this.memoryViewInt32[0x4];
  }
  set type(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkAccelerationStructureMemoryRequirementsInfoNV.type': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get accelerationStructure() {
    return this._accelerationStructure;
  }
  set accelerationStructure(value) {
    if (value !== null && value.constructor === VkAccelerationStructureNV) {
      
      this._accelerationStructure = value;
      
      this.memoryViewBigInt64[0x3] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._accelerationStructure = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkAccelerationStructureMemoryRequirementsInfoNV.accelerationStructure': Expected 'VkAccelerationStructureNV' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkAccelerationStructureMemoryRequirementsInfoNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkAccelerationStructureMemoryRequirementsInfoNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkAccelerationStructureMemoryRequirementsInfoNV.byteLength = 0x20;

VkAccelerationStructureMemoryRequirementsInfoNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  type: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  accelerationStructure: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceRayTracingPropertiesNV **/
class VkPhysicalDeviceRayTracingPropertiesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x40) / 0x4);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x40) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x40);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    this.sType = 0x3B9D4E91;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceRayTracingPropertiesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceRayTracingPropertiesNV.pNext' isn't allowed to be filled");
  }
  get shaderGroupHandleSize() {
    return this.memoryViewUint32[0x4];
  }
  get maxRecursionDepth() {
    return this.memoryViewUint32[0x5];
  }
  get maxShaderGroupStride() {
    return this.memoryViewUint32[0x6];
  }
  get shaderGroupBaseAlignment() {
    return this.memoryViewUint32[0x7];
  }
  get maxGeometryCount() {
    return this.memoryViewBigUint64[0x4];
  }
  get maxInstanceCount() {
    return this.memoryViewBigUint64[0x5];
  }
  get maxTriangleCount() {
    return this.memoryViewBigUint64[0x6];
  }
  get maxDescriptorSetAccelerationStructures() {
    return this.memoryViewUint32[0xE];
  }
  
};

VkPhysicalDeviceRayTracingPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceRayTracingPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x40));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x40), 0x0);
  
  
};

VkPhysicalDeviceRayTracingPropertiesNV.byteLength = 0x40;

VkPhysicalDeviceRayTracingPropertiesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  shaderGroupHandleSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  maxRecursionDepth: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  maxShaderGroupStride: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  shaderGroupBaseAlignment: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  maxGeometryCount: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
  maxInstanceCount: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x8
  }),
  maxTriangleCount: Object.freeze({
    byteOffset: 0x30,
    byteLength: 0x8
  }),
  maxDescriptorSetAccelerationStructures: Object.freeze({
    byteOffset: 0x38,
    byteLength: 0x4
  }),
});
/** VkDrmFormatModifierPropertiesListEXT **/
class VkDrmFormatModifierPropertiesListEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDrmFormatModifierProperties = null;
    this._pDrmFormatModifierPropertiesNative = null;
    this.sType = 0x3B9D3330;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDrmFormatModifierPropertiesListEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDrmFormatModifierPropertiesListEXT.pNext' isn't allowed to be filled");
  }
  get drmFormatModifierCount() {
    return this.memoryViewUint32[0x4];
  }
  get pDrmFormatModifierProperties() {
    return this._pDrmFormatModifierProperties;
  }
  
};

VkDrmFormatModifierPropertiesListEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDrmFormatModifierPropertiesListEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
  
  
};

VkDrmFormatModifierPropertiesListEXT.byteLength = 0x20;

VkDrmFormatModifierPropertiesListEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  drmFormatModifierCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDrmFormatModifierProperties: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkDrmFormatModifierPropertiesEXT **/
class VkDrmFormatModifierPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x10) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);

    }
    
    
    
    
    if (typeof opts === "object") {
      
    }
  }
  get drmFormatModifier() {
    return this.memoryViewBigUint64[0x0];
  }
  get drmFormatModifierPlaneCount() {
    return this.memoryViewUint32[0x2];
  }
  get drmFormatModifierTilingFeatures() {
    return this.memoryViewInt32[0x3];
  }
  
};

VkDrmFormatModifierPropertiesEXT.prototype.flush = function flush() {
  
  return true;
};

VkDrmFormatModifierPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x10));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x10), 0x0);
};

VkDrmFormatModifierPropertiesEXT.byteLength = 0x10;

VkDrmFormatModifierPropertiesEXT.memoryLayout = Object.freeze({
  drmFormatModifier: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
  drmFormatModifierPlaneCount: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x4
  }),
  drmFormatModifierTilingFeatures: Object.freeze({
    byteOffset: 0xC,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceImageDrmFormatModifierInfoEXT **/
class VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this._pQueueFamilyIndices = null;
    this.sType = 0x3B9D3332;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.drmFormatModifier !== void 0) this.drmFormatModifier = opts.drmFormatModifier;
      if (opts.sharingMode !== void 0) this.sharingMode = opts.sharingMode;
      if (opts.queueFamilyIndexCount !== void 0) this.queueFamilyIndexCount = opts.queueFamilyIndexCount;
      if (opts.pQueueFamilyIndices !== void 0) this.pQueueFamilyIndices = opts.pQueueFamilyIndices;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.pNext' isn't allowed to be filled");
  }
  get drmFormatModifier() {
    return this.memoryViewBigUint64[0x2];
  }
  set drmFormatModifier(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.drmFormatModifier': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x2] = value;
  }
  get sharingMode() {
    return this.memoryViewInt32[0x6];
  }
  set sharingMode(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.sharingMode': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x6] = value;
  }
  get queueFamilyIndexCount() {
    return this.memoryViewUint32[0x7];
  }
  set queueFamilyIndexCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.queueFamilyIndexCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x7] = value;
  }
  get pQueueFamilyIndices() {
    return this._pQueueFamilyIndices;
  }
  set pQueueFamilyIndices(value) {
    if (value !== null && value.constructor === Uint32Array) {
      this._pQueueFamilyIndices = value;
      this.memoryViewBigInt64[0x4] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pQueueFamilyIndices = null;
      this.memoryViewBigInt64[0x4] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageDrmFormatModifierInfoEXT.pQueueFamilyIndices': Expected 'Uint32Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.byteLength = 0x28;

VkPhysicalDeviceImageDrmFormatModifierInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  drmFormatModifier: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  sharingMode: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  queueFamilyIndexCount: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  pQueueFamilyIndices: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkImageDrmFormatModifierListCreateInfoEXT **/
class VkImageDrmFormatModifierListCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this._pDrmFormatModifiers = null;
    this.sType = 0x3B9D3333;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.drmFormatModifierCount !== void 0) this.drmFormatModifierCount = opts.drmFormatModifierCount;
      if (opts.pDrmFormatModifiers !== void 0) this.pDrmFormatModifiers = opts.pDrmFormatModifiers;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierListCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageDrmFormatModifierListCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get drmFormatModifierCount() {
    return this.memoryViewUint32[0x4];
  }
  set drmFormatModifierCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierListCreateInfoEXT.drmFormatModifierCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get pDrmFormatModifiers() {
    return this._pDrmFormatModifiers;
  }
  set pDrmFormatModifiers(value) {
    if (value !== null && value.constructor === BigUint64Array) {
      this._pDrmFormatModifiers = value;
      this.memoryViewBigInt64[0x3] = getAddressFromArrayBuffer(value.buffer);
    } else if (value === null) {
      this._pDrmFormatModifiers = null;
      this.memoryViewBigInt64[0x3] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierListCreateInfoEXT.pDrmFormatModifiers': Expected 'BigUint64Array' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageDrmFormatModifierListCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageDrmFormatModifierListCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageDrmFormatModifierListCreateInfoEXT.byteLength = 0x20;

VkImageDrmFormatModifierListCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  drmFormatModifierCount: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  pDrmFormatModifiers: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
});
/** VkImageDrmFormatModifierExplicitCreateInfoEXT **/
class VkImageDrmFormatModifierExplicitCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this._pPlaneLayouts = null;
    this._pPlaneLayoutsNative = null;
    this.sType = 0x3B9D3334;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.drmFormatModifier !== void 0) this.drmFormatModifier = opts.drmFormatModifier;
      if (opts.drmFormatModifierPlaneCount !== void 0) this.drmFormatModifierPlaneCount = opts.drmFormatModifierPlaneCount;
      if (opts.pPlaneLayouts !== void 0) this.pPlaneLayouts = opts.pPlaneLayouts;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageDrmFormatModifierExplicitCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get drmFormatModifier() {
    return this.memoryViewBigUint64[0x2];
  }
  set drmFormatModifier(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.drmFormatModifier': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x2] = value;
  }
  get drmFormatModifierPlaneCount() {
    return this.memoryViewUint32[0x6];
  }
  set drmFormatModifierPlaneCount(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.drmFormatModifierPlaneCount': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get pPlaneLayouts() {
    return this._pPlaneLayouts;
  }
  set pPlaneLayouts(value) {
    if (value !== null && value.constructor === Array) {
      this._pPlaneLayouts = value;
    } else if (value === null) {
      this._pPlaneLayouts = null;
    } else {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts': Expected 'Array VkSubresourceLayout' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._pPlaneLayouts !== null) {
    let array = this._pPlaneLayouts;
    if (array.length !== this.drmFormatModifierPlaneCount) {
      throw new RangeError("Invalid array length, expected length of 'drmFormatModifierPlaneCount' for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts'");
      return false;
    }
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== VkSubresourceLayout) {
        throw new TypeError("Invalid type for 'VkImageDrmFormatModifierExplicitCreateInfoEXT.pPlaneLayouts[" + ii + "]': Expected 'VkSubresourceLayout' but got '" + array[ii].constructor.name + "'");
        return false;
      }
      if (!array[ii].flush()) return false;
    };
    
    let nativeArray = new NativeObjectArray(array);
    this._pPlaneLayoutsNative = nativeArray;
    this.memoryViewBigInt64[0x4] = nativeArray.address;
  }
  
  return true;
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkImageDrmFormatModifierExplicitCreateInfoEXT.byteLength = 0x28;

VkImageDrmFormatModifierExplicitCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  drmFormatModifier: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  drmFormatModifierPlaneCount: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  pPlaneLayouts: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x8
  }),
});
/** VkImageDrmFormatModifierPropertiesEXT **/
class VkImageDrmFormatModifierPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D3335;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageDrmFormatModifierPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageDrmFormatModifierPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get drmFormatModifier() {
    return this.memoryViewBigUint64[0x2];
  }
  
};

VkImageDrmFormatModifierPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageDrmFormatModifierPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkImageDrmFormatModifierPropertiesEXT.byteLength = 0x18;

VkImageDrmFormatModifierPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  drmFormatModifier: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkImageStencilUsageCreateInfoEXT **/
class VkImageStencilUsageCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9E8AF0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.stencilUsage !== void 0) this.stencilUsage = opts.stencilUsage;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageStencilUsageCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkImageStencilUsageCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get stencilUsage() {
    return this.memoryViewInt32[0x4];
  }
  set stencilUsage(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkImageStencilUsageCreateInfoEXT.stencilUsage': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkImageStencilUsageCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkImageStencilUsageCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkImageStencilUsageCreateInfoEXT.byteLength = 0x18;

VkImageStencilUsageCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  stencilUsage: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkDeviceMemoryOverallocationCreateInfoAMD **/
class VkDeviceMemoryOverallocationCreateInfoAMD {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9DAC48;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.overallocationBehavior !== void 0) this.overallocationBehavior = opts.overallocationBehavior;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceMemoryOverallocationCreateInfoAMD.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkDeviceMemoryOverallocationCreateInfoAMD.pNext' isn't allowed to be filled");
  }
  get overallocationBehavior() {
    return this.memoryViewInt32[0x4];
  }
  set overallocationBehavior(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkDeviceMemoryOverallocationCreateInfoAMD.overallocationBehavior': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkDeviceMemoryOverallocationCreateInfoAMD.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkDeviceMemoryOverallocationCreateInfoAMD.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkDeviceMemoryOverallocationCreateInfoAMD.byteLength = 0x18;

VkDeviceMemoryOverallocationCreateInfoAMD.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  overallocationBehavior: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceFragmentDensityMapFeaturesEXT **/
class VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9E1D90;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFragmentDensityMapFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceFragmentDensityMapFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get fragmentDensityMap() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  get fragmentDensityMapDynamic() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  get fragmentDensityMapNonSubsampledImages() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x20));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x20), 0x0);
  
  
};

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.byteLength = 0x20;

VkPhysicalDeviceFragmentDensityMapFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  fragmentDensityMap: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  fragmentDensityMapDynamic: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  fragmentDensityMapNonSubsampledImages: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceFragmentDensityMapPropertiesEXT **/
class VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x28) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x28) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x28);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._minFragmentDensityTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this._maxFragmentDensityTexelSize = new VkExtent2D({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x18 });
    
    this.sType = 0x3B9E1D91;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceFragmentDensityMapPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceFragmentDensityMapPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get minFragmentDensityTexelSize() {
    return this._minFragmentDensityTexelSize;
  }
  get maxFragmentDensityTexelSize() {
    return this._maxFragmentDensityTexelSize;
  }
  get fragmentDensityInvocations() {
    return this.memoryViewUint32[0x8] !== 0;
  }
  
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x28));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x28), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.byteLength = 0x28;

VkPhysicalDeviceFragmentDensityMapPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  minFragmentDensityTexelSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
  maxFragmentDensityTexelSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x8
  }),
  fragmentDensityInvocations: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
});
/** VkRenderPassFragmentDensityMapCreateInfoEXT **/
class VkRenderPassFragmentDensityMapCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._fragmentDensityMapAttachment = new VkAttachmentReference({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x10 });
    this.sType = 0x3B9E1D92;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.fragmentDensityMapAttachment !== void 0) this.fragmentDensityMapAttachment = opts.fragmentDensityMapAttachment;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkRenderPassFragmentDensityMapCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkRenderPassFragmentDensityMapCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get fragmentDensityMapAttachment() {
    return this._fragmentDensityMapAttachment;
  }
  set fragmentDensityMapAttachment(value) {
    if (value !== null && value.constructor === VkAttachmentReference) {
      value.flush();
      this._fragmentDensityMapAttachment = value;
      
      
    } else if (value === null) {
      this._fragmentDensityMapAttachment = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkRenderPassFragmentDensityMapCreateInfoEXT.fragmentDensityMapAttachment': Expected 'VkAttachmentReference' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkRenderPassFragmentDensityMapCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  
  if (this._fragmentDensityMapAttachment !== null) {
    this._fragmentDensityMapAttachment.flush();
    if (this.memoryBuffer !== this._fragmentDensityMapAttachment.memoryBuffer) {
      let srcView = new Uint8Array(this._fragmentDensityMapAttachment.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x10);
    }
  }
  
  return true;
};

VkRenderPassFragmentDensityMapCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkRenderPassFragmentDensityMapCreateInfoEXT.byteLength = 0x18;

VkRenderPassFragmentDensityMapCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  fragmentDensityMapAttachment: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceScalarBlockLayoutFeaturesEXT **/
class VkPhysicalDeviceScalarBlockLayoutFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9E2948;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.scalarBlockLayout !== void 0) this.scalarBlockLayout = opts.scalarBlockLayout;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get scalarBlockLayout() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set scalarBlockLayout(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceScalarBlockLayoutFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  scalarBlockLayout: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceDepthClipEnableFeaturesEXT **/
class VkPhysicalDeviceDepthClipEnableFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9C5870;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.depthClipEnable !== void 0) this.depthClipEnable = opts.depthClipEnable;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceDepthClipEnableFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceDepthClipEnableFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get depthClipEnable() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set depthClipEnable(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceDepthClipEnableFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceDepthClipEnableFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  depthClipEnable: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPipelineRasterizationDepthClipStateCreateInfoEXT **/
class VkPipelineRasterizationDepthClipStateCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9C5871;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.flags !== void 0) this.flags = opts.flags;
      if (opts.depthClipEnable !== void 0) this.depthClipEnable = opts.depthClipEnable;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationDepthClipStateCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPipelineRasterizationDepthClipStateCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get flags() {
    return this.memoryViewInt32[0x4];
  }
  set flags(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPipelineRasterizationDepthClipStateCreateInfoEXT.flags': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  get depthClipEnable() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set depthClipEnable(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPipelineRasterizationDepthClipStateCreateInfoEXT.byteLength = 0x18;

VkPipelineRasterizationDepthClipStateCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  flags: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  depthClipEnable: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceMemoryBudgetPropertiesEXT **/
class VkPhysicalDeviceMemoryBudgetPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x110) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x110) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x110) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x110);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._heapBudget = [...Array(16)].fill(0x0);
    this._heapUsage = [...Array(16)].fill(0x0);
    this.sType = 0x3B9E67C8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryBudgetPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMemoryBudgetPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get heapBudget() {
    return [
      this.memoryViewBigUint64[0x2],
      this.memoryViewBigUint64[0x3],
      this.memoryViewBigUint64[0x4],
      this.memoryViewBigUint64[0x5],
      this.memoryViewBigUint64[0x6],
      this.memoryViewBigUint64[0x7],
      this.memoryViewBigUint64[0x8],
      this.memoryViewBigUint64[0x9],
      this.memoryViewBigUint64[0xA],
      this.memoryViewBigUint64[0xB],
      this.memoryViewBigUint64[0xC],
      this.memoryViewBigUint64[0xD],
      this.memoryViewBigUint64[0xE],
      this.memoryViewBigUint64[0xF],
      this.memoryViewBigUint64[0x10],
      this.memoryViewBigUint64[0x11]
    ];
  }
  get heapUsage() {
    return [
      this.memoryViewBigUint64[0x12],
      this.memoryViewBigUint64[0x13],
      this.memoryViewBigUint64[0x14],
      this.memoryViewBigUint64[0x15],
      this.memoryViewBigUint64[0x16],
      this.memoryViewBigUint64[0x17],
      this.memoryViewBigUint64[0x18],
      this.memoryViewBigUint64[0x19],
      this.memoryViewBigUint64[0x1A],
      this.memoryViewBigUint64[0x1B],
      this.memoryViewBigUint64[0x1C],
      this.memoryViewBigUint64[0x1D],
      this.memoryViewBigUint64[0x1E],
      this.memoryViewBigUint64[0x1F],
      this.memoryViewBigUint64[0x20],
      this.memoryViewBigUint64[0x21]
    ];
  }
  
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x110));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x110), 0x0);
  
  
  
  
  
  
};

VkPhysicalDeviceMemoryBudgetPropertiesEXT.byteLength = 0x110;

VkPhysicalDeviceMemoryBudgetPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  heapBudget: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x80
  }),
  heapUsage: Object.freeze({
    byteOffset: 0x90,
    byteLength: 0x80
  }),
});
/** VkPhysicalDeviceMemoryPriorityFeaturesEXT **/
class VkPhysicalDeviceMemoryPriorityFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9E6BB0;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.memoryPriority !== void 0) this.memoryPriority = opts.memoryPriority;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceMemoryPriorityFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceMemoryPriorityFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get memoryPriority() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set memoryPriority(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceMemoryPriorityFeaturesEXT.byteLength = 0x18;

VkPhysicalDeviceMemoryPriorityFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  memoryPriority: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkMemoryPriorityAllocateInfoEXT **/
class VkMemoryPriorityAllocateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9E6BB1;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.priority !== void 0) this.priority = opts.priority;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryPriorityAllocateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkMemoryPriorityAllocateInfoEXT.pNext' isn't allowed to be filled");
  }
  get priority() {
    return this.memoryViewFloat32[0x4];
  }
  set priority(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkMemoryPriorityAllocateInfoEXT.priority': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewFloat32[0x4] = value;
  }
  
};

VkMemoryPriorityAllocateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkMemoryPriorityAllocateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkMemoryPriorityAllocateInfoEXT.byteLength = 0x18;

VkMemoryPriorityAllocateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  priority: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceBufferAddressFeaturesEXT **/
class VkPhysicalDeviceBufferAddressFeaturesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x20) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x20) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x20);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    this.sType = 0x3B9E8320;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.bufferDeviceAddress !== void 0) this.bufferDeviceAddress = opts.bufferDeviceAddress;
      if (opts.bufferDeviceAddressCaptureReplay !== void 0) this.bufferDeviceAddressCaptureReplay = opts.bufferDeviceAddressCaptureReplay;
      if (opts.bufferDeviceAddressMultiDevice !== void 0) this.bufferDeviceAddressMultiDevice = opts.bufferDeviceAddressMultiDevice;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceBufferAddressFeaturesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceBufferAddressFeaturesEXT.pNext' isn't allowed to be filled");
  }
  get bufferDeviceAddress() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set bufferDeviceAddress(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get bufferDeviceAddressCaptureReplay() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set bufferDeviceAddressCaptureReplay(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  get bufferDeviceAddressMultiDevice() {
    return this.memoryViewUint32[0x6] !== 0;
  }
  set bufferDeviceAddressMultiDevice(value) {
    this.memoryViewUint32[0x6] = value | 0;
  }
  
};

VkPhysicalDeviceBufferAddressFeaturesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceBufferAddressFeaturesEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceBufferAddressFeaturesEXT.byteLength = 0x20;

VkPhysicalDeviceBufferAddressFeaturesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  bufferDeviceAddress: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  bufferDeviceAddressCaptureReplay: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  bufferDeviceAddressMultiDevice: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
});
/** VkBufferDeviceAddressInfoEXT **/
class VkBufferDeviceAddressInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    this._buffer = null;
    this.sType = 0x3B9E8321;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.buffer !== void 0) this.buffer = opts.buffer;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBufferDeviceAddressInfoEXT.pNext' isn't allowed to be filled");
  }
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    if (value !== null && value.constructor === VkBuffer) {
      
      this._buffer = value;
      
      this.memoryViewBigInt64[0x2] = value.memoryViewBigInt64[0];
    } else if (value === null) {
      this._buffer = null;
      this.memoryViewBigInt64[0x2] = BI0;
    } else {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressInfoEXT.buffer': Expected 'VkBuffer' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkBufferDeviceAddressInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferDeviceAddressInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferDeviceAddressInfoEXT.byteLength = 0x18;

VkBufferDeviceAddressInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  buffer: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkBufferDeviceAddressCreateInfoEXT **/
class VkBufferDeviceAddressCreateInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewBigUint64 = new BigUint64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9E8322;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.deviceAddress !== void 0) this.deviceAddress = opts.deviceAddress;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressCreateInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkBufferDeviceAddressCreateInfoEXT.pNext' isn't allowed to be filled");
  }
  get deviceAddress() {
    return this.memoryViewBigUint64[0x2];
  }
  set deviceAddress(value) {
    if (typeof value !== "bigint") {
      throw new TypeError("Invalid type for 'VkBufferDeviceAddressCreateInfoEXT.deviceAddress': Expected 'BigInt' but got '" + value.constructor.name + "'");
    }
    this.memoryViewBigUint64[0x2] = value;
  }
  
};

VkBufferDeviceAddressCreateInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkBufferDeviceAddressCreateInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkBufferDeviceAddressCreateInfoEXT.byteLength = 0x18;

VkBufferDeviceAddressCreateInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  deviceAddress: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x8
  }),
});
/** VkPhysicalDeviceImageViewImageFormatInfoEXT **/
class VkPhysicalDeviceImageViewImageFormatInfoEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9D6210;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.imageViewType !== void 0) this.imageViewType = opts.imageViewType;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageViewImageFormatInfoEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceImageViewImageFormatInfoEXT.pNext' isn't allowed to be filled");
  }
  get imageViewType() {
    return this.memoryViewInt32[0x4];
  }
  set imageViewType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceImageViewImageFormatInfoEXT.imageViewType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x4] = value;
  }
  
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceImageViewImageFormatInfoEXT.byteLength = 0x18;

VkPhysicalDeviceImageViewImageFormatInfoEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  imageViewType: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkFilterCubicImageViewImageFormatPropertiesEXT **/
class VkFilterCubicImageViewImageFormatPropertiesEXT {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9D6211;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkFilterCubicImageViewImageFormatPropertiesEXT.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkFilterCubicImageViewImageFormatPropertiesEXT.pNext' isn't allowed to be filled");
  }
  get filterCubic() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  get filterCubicMinmax() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  
};

VkFilterCubicImageViewImageFormatPropertiesEXT.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkFilterCubicImageViewImageFormatPropertiesEXT.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkFilterCubicImageViewImageFormatPropertiesEXT.byteLength = 0x18;

VkFilterCubicImageViewImageFormatPropertiesEXT.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  filterCubic: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  filterCubicMinmax: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceCooperativeMatrixFeaturesNV **/
class VkPhysicalDeviceCooperativeMatrixFeaturesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    this.sType = 0x3B9E96A8;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.cooperativeMatrix !== void 0) this.cooperativeMatrix = opts.cooperativeMatrix;
      if (opts.cooperativeMatrixRobustBufferAccess !== void 0) this.cooperativeMatrixRobustBufferAccess = opts.cooperativeMatrixRobustBufferAccess;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceCooperativeMatrixFeaturesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceCooperativeMatrixFeaturesNV.pNext' isn't allowed to be filled");
  }
  get cooperativeMatrix() {
    return this.memoryViewUint32[0x4] !== 0;
  }
  set cooperativeMatrix(value) {
    this.memoryViewUint32[0x4] = value | 0;
  }
  get cooperativeMatrixRobustBufferAccess() {
    return this.memoryViewUint32[0x5] !== 0;
  }
  set cooperativeMatrixRobustBufferAccess(value) {
    this.memoryViewUint32[0x5] = value | 0;
  }
  
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkPhysicalDeviceCooperativeMatrixFeaturesNV.byteLength = 0x18;

VkPhysicalDeviceCooperativeMatrixFeaturesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  cooperativeMatrix: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  cooperativeMatrixRobustBufferAccess: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
});
/** VkPhysicalDeviceCooperativeMatrixPropertiesNV **/
class VkPhysicalDeviceCooperativeMatrixPropertiesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x18) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x18) / 0x8);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x18);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    this.sType = 0x3B9E96AA;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkPhysicalDeviceCooperativeMatrixPropertiesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkPhysicalDeviceCooperativeMatrixPropertiesNV.pNext' isn't allowed to be filled");
  }
  get cooperativeMatrixSupportedStages() {
    return this.memoryViewInt32[0x4];
  }
  
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  let srcBuffer = getArrayBufferFromAddress(memoryAddress, BigInt(0x18));
  let dstBuffer = this.memoryBuffer;
  let srcView = new Uint8Array(srcBuffer);
  let dstView = new Uint8Array(dstBuffer);
  dstView.set(srcView.subarray(0x0, 0x18), 0x0);
  
  
};

VkPhysicalDeviceCooperativeMatrixPropertiesNV.byteLength = 0x18;

VkPhysicalDeviceCooperativeMatrixPropertiesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  cooperativeMatrixSupportedStages: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
});
/** VkCooperativeMatrixPropertiesNV **/
class VkCooperativeMatrixPropertiesNV {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x8, (opts.$memoryOffset + 0x30) / 0x8);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x30) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x30);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewBigInt64 = new BigInt64Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    
    this._pNext = null;
    
    
    
    
    
    
    
    
    this.sType = 0x3B9E96A9;
    if (typeof opts === "object") {
      if (opts.sType !== void 0) this.sType = opts.sType;
      if (opts.pNext !== void 0) this.pNext = opts.pNext;
      if (opts.MSize !== void 0) this.MSize = opts.MSize;
      if (opts.NSize !== void 0) this.NSize = opts.NSize;
      if (opts.KSize !== void 0) this.KSize = opts.KSize;
      if (opts.AType !== void 0) this.AType = opts.AType;
      if (opts.BType !== void 0) this.BType = opts.BType;
      if (opts.CType !== void 0) this.CType = opts.CType;
      if (opts.DType !== void 0) this.DType = opts.DType;
      if (opts.scope !== void 0) this.scope = opts.scope;
      
    }
  }
  get sType() {
    return this.memoryViewInt32[0x0];
  }
  set sType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.sType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x0] = value;
  }
  get pNext() {
    return this._pNext;
  }
  set pNext(value) {
    throw new TypeError("'VkCooperativeMatrixPropertiesNV.pNext' isn't allowed to be filled");
  }
  get MSize() {
    return this.memoryViewUint32[0x4];
  }
  set MSize(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.MSize': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x4] = value;
  }
  get NSize() {
    return this.memoryViewUint32[0x5];
  }
  set NSize(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.NSize': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x5] = value;
  }
  get KSize() {
    return this.memoryViewUint32[0x6];
  }
  set KSize(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.KSize': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewUint32[0x6] = value;
  }
  get AType() {
    return this.memoryViewInt32[0x7];
  }
  set AType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.AType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x7] = value;
  }
  get BType() {
    return this.memoryViewInt32[0x8];
  }
  set BType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.BType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x8] = value;
  }
  get CType() {
    return this.memoryViewInt32[0x9];
  }
  set CType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.CType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0x9] = value;
  }
  get DType() {
    return this.memoryViewInt32[0xA];
  }
  set DType(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.DType': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xA] = value;
  }
  get scope() {
    return this.memoryViewInt32[0xB];
  }
  set scope(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid type for 'VkCooperativeMatrixPropertiesNV.scope': Expected 'Number' but got '" + value.constructor.name + "'");
    }
    this.memoryViewInt32[0xB] = value;
  }
  
};

VkCooperativeMatrixPropertiesNV.prototype.flush = function flush() {
  
  
  if (this._pNext !== null) {
    if (!this._pNext.flush()) return false;
  }
  
  return true;
};

VkCooperativeMatrixPropertiesNV.prototype.reflect = function reflect(memoryAddress) {
  
  
  
};

VkCooperativeMatrixPropertiesNV.byteLength = 0x30;

VkCooperativeMatrixPropertiesNV.memoryLayout = Object.freeze({
  sType: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x4
  }),
  pNext: Object.freeze({
    byteOffset: 0x8,
    byteLength: 0x8
  }),
  MSize: Object.freeze({
    byteOffset: 0x10,
    byteLength: 0x4
  }),
  NSize: Object.freeze({
    byteOffset: 0x14,
    byteLength: 0x4
  }),
  KSize: Object.freeze({
    byteOffset: 0x18,
    byteLength: 0x4
  }),
  AType: Object.freeze({
    byteOffset: 0x1C,
    byteLength: 0x4
  }),
  BType: Object.freeze({
    byteOffset: 0x20,
    byteLength: 0x4
  }),
  CType: Object.freeze({
    byteOffset: 0x24,
    byteLength: 0x4
  }),
  DType: Object.freeze({
    byteOffset: 0x28,
    byteLength: 0x4
  }),
  scope: Object.freeze({
    byteOffset: 0x2C,
    byteLength: 0x4
  }),
});
/** VkClearColorValue **/
class VkClearColorValue {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer).subarray(opts.$memoryOffset / 0x4, (opts.$memoryOffset + 0x10) / 0x4);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);
      this.memoryViewFloat32 = new Float32Array(this.memoryBuffer);
      this.memoryViewInt32 = new Int32Array(this.memoryBuffer);
      this.memoryViewUint32 = new Uint32Array(this.memoryBuffer);

    }
    this._float32 = null;
    this._int32 = null;
    this._uint32 = null;
    
    if (typeof opts === "object") {
      if (opts.float32 !== void 0) this.float32 = opts.float32;
      if (opts.int32 !== void 0) this.int32 = opts.int32;
      if (opts.uint32 !== void 0) this.uint32 = opts.uint32;
      
    }
  }
  get float32() {
    return this._float32;
  }
  set float32(value) {
    if (value !== null && value.constructor === Array) {
      this._float32 = value;
    } else if (value === null) {
      this._float32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.float32': Expected 'Array float' but got '" + value.constructor.name + "'");
    }
  }
  get int32() {
    return this._int32;
  }
  set int32(value) {
    if (value !== null && value.constructor === Array) {
      this._int32 = value;
    } else if (value === null) {
      this._int32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.int32': Expected 'Array int32_t' but got '" + value.constructor.name + "'");
    }
  }
  get uint32() {
    return this._uint32;
  }
  set uint32(value) {
    if (value !== null && value.constructor === Array) {
      this._uint32 = value;
    } else if (value === null) {
      this._uint32 = null;
    } else {
      throw new TypeError("Invalid type for 'VkClearColorValue.uint32': Expected 'Array uint32_t' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkClearColorValue.prototype.flush = function flush() {
  
  
  if (this._float32 !== null) {
    let array = this._float32;
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.float32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== Number) {
        throw new TypeError("Invalid type for 'VkClearColorValue.float32[" + ii + "]': Expected 'Number' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewFloat32[0x0 + ii] = array[ii];
    };
  } else {
    
  }
  
  
  if (this._int32 !== null) {
    let array = this._int32;
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.int32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== Number) {
        throw new TypeError("Invalid type for 'VkClearColorValue.int32[" + ii + "]': Expected 'Number' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewInt32[0x0 + ii] = array[ii];
    };
  } else {
    
  }
  
  
  if (this._uint32 !== null) {
    let array = this._uint32;
    // validate length
    if (array.length !== 4) {
      throw new RangeError("Invalid array length, expected length of '4' for 'VkClearColorValue.uint32'");
      return false;
    }
    // validate type
    for (let ii = 0; ii < array.length; ++ii) {
      if (array[ii].constructor !== Number) {
        throw new TypeError("Invalid type for 'VkClearColorValue.uint32[" + ii + "]': Expected 'Number' but got '" + array[ii].constructor.name + "'");
        return false;
      }
    };
    for (let ii = 0; ii < array.length; ++ii) {
      this.memoryViewUint32[0x0 + ii] = array[ii];
    };
  } else {
    
  }
  
  return true;
};

VkClearColorValue.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
  
  
};

VkClearColorValue.byteLength = 0x10;

VkClearColorValue.memoryLayout = Object.freeze({
  float32: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x10
  }),
  int32: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x10
  }),
  uint32: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x10
  }),
});
/** VkClearValue **/
class VkClearValue {
  constructor(opts) {
    this.memoryBuffer = null;
    this.memoryAddress = BI0;
    if (typeof opts === "object" && opts.$memoryOffset !== void 0) {
      this.memoryBuffer = opts.$memoryBuffer;
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer) + BigInt(opts.$memoryOffset);

    } else {
      this.memoryBuffer = new ArrayBuffer(0x10);
      this.memoryAddress = getAddressFromArrayBuffer(this.memoryBuffer);

    }
    this._color = new VkClearColorValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    this._depthStencil = new VkClearDepthStencilValue({ $memoryBuffer: this.memoryBuffer, $memoryOffset: 0x0 });
    
    if (typeof opts === "object") {
      if (opts.color !== void 0) this.color = opts.color;
      if (opts.depthStencil !== void 0) this.depthStencil = opts.depthStencil;
      
    }
  }
  get color() {
    return this._color;
  }
  set color(value) {
    if (value !== null && value.constructor === VkClearColorValue) {
      value.flush();
      this._color = value;
      
      
    } else if (value === null) {
      this._color = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearValue.color': Expected 'VkClearColorValue' but got '" + value.constructor.name + "'");
    }
  }
  get depthStencil() {
    return this._depthStencil;
  }
  set depthStencil(value) {
    if (value !== null && value.constructor === VkClearDepthStencilValue) {
      value.flush();
      this._depthStencil = value;
      
      
    } else if (value === null) {
      this._depthStencil = null;
      
    } else {
      throw new TypeError("Invalid type for 'VkClearValue.depthStencil': Expected 'VkClearDepthStencilValue' but got '" + value.constructor.name + "'");
    }
  }
  
};

VkClearValue.prototype.flush = function flush() {
  
  
  if (this._color !== null) {
    this._color.flush();
    if (this.memoryBuffer !== this._color.memoryBuffer) {
      let srcView = new Uint8Array(this._color.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  
  if (this._depthStencil !== null) {
    this._depthStencil.flush();
    if (this.memoryBuffer !== this._depthStencil.memoryBuffer) {
      let srcView = new Uint8Array(this._depthStencil.memoryBuffer);
      let dstView = new Uint8Array(this.memoryBuffer);
      dstView.set(srcView, 0x0);
    }
  }
  
  return true;
};

VkClearValue.prototype.reflect = function reflect(memoryAddress) {
  
  
  
  
  
};

VkClearValue.byteLength = 0x10;

VkClearValue.memoryLayout = Object.freeze({
  color: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x10
  }),
  depthStencil: Object.freeze({
    byteOffset: 0x0,
    byteLength: 0x8
  }),
});

module.exports = {
  ...(nvk.$getVulkanEnumerations()),
  VK_MAKE_VERSION: nvk.VK_MAKE_VERSION,
  VK_VERSION_MAJOR: nvk.VK_VERSION_MAJOR,
  VK_VERSION_MINOR: nvk.VK_VERSION_MINOR,
  VK_VERSION_PATCH: nvk.VK_VERSION_PATCH,
  VK_API_VERSION_1_0: nvk.VK_API_VERSION_1_0,
  VK_API_VERSION_1_1: nvk.VK_API_VERSION_1_1,
  vkUseDevice: nvk.vkUseDevice,
  vkUseInstance: nvk.vkUseInstance,
  VulkanWindow: nvk.VulkanWindow,
  vkCreateInstance: nvk.vkCreateInstance,
  vkDestroyInstance: nvk.vkDestroyInstance,
  vkEnumeratePhysicalDevices: nvk.vkEnumeratePhysicalDevices,
  vkGetDeviceProcAddr: nvk.vkGetDeviceProcAddr,
  vkGetInstanceProcAddr: nvk.vkGetInstanceProcAddr,
  vkGetPhysicalDeviceProperties: nvk.vkGetPhysicalDeviceProperties,
  vkGetPhysicalDeviceQueueFamilyProperties: nvk.vkGetPhysicalDeviceQueueFamilyProperties,
  vkGetPhysicalDeviceMemoryProperties: nvk.vkGetPhysicalDeviceMemoryProperties,
  vkGetPhysicalDeviceFeatures: nvk.vkGetPhysicalDeviceFeatures,
  vkGetPhysicalDeviceFormatProperties: nvk.vkGetPhysicalDeviceFormatProperties,
  vkGetPhysicalDeviceImageFormatProperties: nvk.vkGetPhysicalDeviceImageFormatProperties,
  vkCreateDevice: nvk.vkCreateDevice,
  vkDestroyDevice: nvk.vkDestroyDevice,
  vkEnumerateInstanceVersion: nvk.vkEnumerateInstanceVersion,
  vkEnumerateInstanceLayerProperties: nvk.vkEnumerateInstanceLayerProperties,
  vkEnumerateInstanceExtensionProperties: nvk.vkEnumerateInstanceExtensionProperties,
  vkEnumerateDeviceLayerProperties: nvk.vkEnumerateDeviceLayerProperties,
  vkEnumerateDeviceExtensionProperties: nvk.vkEnumerateDeviceExtensionProperties,
  vkGetDeviceQueue: nvk.vkGetDeviceQueue,
  vkQueueSubmit: nvk.vkQueueSubmit,
  vkQueueWaitIdle: nvk.vkQueueWaitIdle,
  vkDeviceWaitIdle: nvk.vkDeviceWaitIdle,
  vkAllocateMemory: nvk.vkAllocateMemory,
  vkFreeMemory: nvk.vkFreeMemory,
  vkMapMemory: nvk.vkMapMemory,
  vkUnmapMemory: nvk.vkUnmapMemory,
  vkFlushMappedMemoryRanges: nvk.vkFlushMappedMemoryRanges,
  vkInvalidateMappedMemoryRanges: nvk.vkInvalidateMappedMemoryRanges,
  vkGetDeviceMemoryCommitment: nvk.vkGetDeviceMemoryCommitment,
  vkGetBufferMemoryRequirements: nvk.vkGetBufferMemoryRequirements,
  vkBindBufferMemory: nvk.vkBindBufferMemory,
  vkGetImageMemoryRequirements: nvk.vkGetImageMemoryRequirements,
  vkBindImageMemory: nvk.vkBindImageMemory,
  vkGetImageSparseMemoryRequirements: nvk.vkGetImageSparseMemoryRequirements,
  vkGetPhysicalDeviceSparseImageFormatProperties: nvk.vkGetPhysicalDeviceSparseImageFormatProperties,
  vkQueueBindSparse: nvk.vkQueueBindSparse,
  vkCreateFence: nvk.vkCreateFence,
  vkDestroyFence: nvk.vkDestroyFence,
  vkResetFences: nvk.vkResetFences,
  vkGetFenceStatus: nvk.vkGetFenceStatus,
  vkWaitForFences: nvk.vkWaitForFences,
  vkCreateSemaphore: nvk.vkCreateSemaphore,
  vkDestroySemaphore: nvk.vkDestroySemaphore,
  vkCreateEvent: nvk.vkCreateEvent,
  vkDestroyEvent: nvk.vkDestroyEvent,
  vkGetEventStatus: nvk.vkGetEventStatus,
  vkSetEvent: nvk.vkSetEvent,
  vkResetEvent: nvk.vkResetEvent,
  vkCreateQueryPool: nvk.vkCreateQueryPool,
  vkDestroyQueryPool: nvk.vkDestroyQueryPool,
  vkGetQueryPoolResults: nvk.vkGetQueryPoolResults,
  vkCreateBuffer: nvk.vkCreateBuffer,
  vkDestroyBuffer: nvk.vkDestroyBuffer,
  vkCreateBufferView: nvk.vkCreateBufferView,
  vkDestroyBufferView: nvk.vkDestroyBufferView,
  vkCreateImage: nvk.vkCreateImage,
  vkDestroyImage: nvk.vkDestroyImage,
  vkGetImageSubresourceLayout: nvk.vkGetImageSubresourceLayout,
  vkCreateImageView: nvk.vkCreateImageView,
  vkDestroyImageView: nvk.vkDestroyImageView,
  vkCreateShaderModule: nvk.vkCreateShaderModule,
  vkDestroyShaderModule: nvk.vkDestroyShaderModule,
  vkCreatePipelineCache: nvk.vkCreatePipelineCache,
  vkDestroyPipelineCache: nvk.vkDestroyPipelineCache,
  vkGetPipelineCacheData: nvk.vkGetPipelineCacheData,
  vkMergePipelineCaches: nvk.vkMergePipelineCaches,
  vkCreateGraphicsPipelines: nvk.vkCreateGraphicsPipelines,
  vkCreateComputePipelines: nvk.vkCreateComputePipelines,
  vkDestroyPipeline: nvk.vkDestroyPipeline,
  vkCreatePipelineLayout: nvk.vkCreatePipelineLayout,
  vkDestroyPipelineLayout: nvk.vkDestroyPipelineLayout,
  vkCreateSampler: nvk.vkCreateSampler,
  vkDestroySampler: nvk.vkDestroySampler,
  vkCreateDescriptorSetLayout: nvk.vkCreateDescriptorSetLayout,
  vkDestroyDescriptorSetLayout: nvk.vkDestroyDescriptorSetLayout,
  vkCreateDescriptorPool: nvk.vkCreateDescriptorPool,
  vkDestroyDescriptorPool: nvk.vkDestroyDescriptorPool,
  vkResetDescriptorPool: nvk.vkResetDescriptorPool,
  vkAllocateDescriptorSets: nvk.vkAllocateDescriptorSets,
  vkFreeDescriptorSets: nvk.vkFreeDescriptorSets,
  vkUpdateDescriptorSets: nvk.vkUpdateDescriptorSets,
  vkCreateFramebuffer: nvk.vkCreateFramebuffer,
  vkDestroyFramebuffer: nvk.vkDestroyFramebuffer,
  vkCreateRenderPass: nvk.vkCreateRenderPass,
  vkDestroyRenderPass: nvk.vkDestroyRenderPass,
  vkGetRenderAreaGranularity: nvk.vkGetRenderAreaGranularity,
  vkCreateCommandPool: nvk.vkCreateCommandPool,
  vkDestroyCommandPool: nvk.vkDestroyCommandPool,
  vkResetCommandPool: nvk.vkResetCommandPool,
  vkAllocateCommandBuffers: nvk.vkAllocateCommandBuffers,
  vkFreeCommandBuffers: nvk.vkFreeCommandBuffers,
  vkBeginCommandBuffer: nvk.vkBeginCommandBuffer,
  vkEndCommandBuffer: nvk.vkEndCommandBuffer,
  vkResetCommandBuffer: nvk.vkResetCommandBuffer,
  vkCmdBindPipeline: nvk.vkCmdBindPipeline,
  vkCmdSetViewport: nvk.vkCmdSetViewport,
  vkCmdSetScissor: nvk.vkCmdSetScissor,
  vkCmdSetLineWidth: nvk.vkCmdSetLineWidth,
  vkCmdSetDepthBias: nvk.vkCmdSetDepthBias,
  vkCmdSetBlendConstants: nvk.vkCmdSetBlendConstants,
  vkCmdSetDepthBounds: nvk.vkCmdSetDepthBounds,
  vkCmdSetStencilCompareMask: nvk.vkCmdSetStencilCompareMask,
  vkCmdSetStencilWriteMask: nvk.vkCmdSetStencilWriteMask,
  vkCmdSetStencilReference: nvk.vkCmdSetStencilReference,
  vkCmdBindDescriptorSets: nvk.vkCmdBindDescriptorSets,
  vkCmdBindIndexBuffer: nvk.vkCmdBindIndexBuffer,
  vkCmdBindVertexBuffers: nvk.vkCmdBindVertexBuffers,
  vkCmdDraw: nvk.vkCmdDraw,
  vkCmdDrawIndexed: nvk.vkCmdDrawIndexed,
  vkCmdDrawIndirect: nvk.vkCmdDrawIndirect,
  vkCmdDrawIndexedIndirect: nvk.vkCmdDrawIndexedIndirect,
  vkCmdDispatch: nvk.vkCmdDispatch,
  vkCmdDispatchIndirect: nvk.vkCmdDispatchIndirect,
  vkCmdCopyBuffer: nvk.vkCmdCopyBuffer,
  vkCmdCopyImage: nvk.vkCmdCopyImage,
  vkCmdBlitImage: nvk.vkCmdBlitImage,
  vkCmdCopyBufferToImage: nvk.vkCmdCopyBufferToImage,
  vkCmdCopyImageToBuffer: nvk.vkCmdCopyImageToBuffer,
  vkCmdUpdateBuffer: nvk.vkCmdUpdateBuffer,
  vkCmdFillBuffer: nvk.vkCmdFillBuffer,
  vkCmdClearColorImage: nvk.vkCmdClearColorImage,
  vkCmdClearDepthStencilImage: nvk.vkCmdClearDepthStencilImage,
  vkCmdClearAttachments: nvk.vkCmdClearAttachments,
  vkCmdResolveImage: nvk.vkCmdResolveImage,
  vkCmdSetEvent: nvk.vkCmdSetEvent,
  vkCmdResetEvent: nvk.vkCmdResetEvent,
  vkCmdWaitEvents: nvk.vkCmdWaitEvents,
  vkCmdPipelineBarrier: nvk.vkCmdPipelineBarrier,
  vkCmdBeginQuery: nvk.vkCmdBeginQuery,
  vkCmdEndQuery: nvk.vkCmdEndQuery,
  vkCmdBeginConditionalRenderingEXT: nvk.vkCmdBeginConditionalRenderingEXT,
  vkCmdEndConditionalRenderingEXT: nvk.vkCmdEndConditionalRenderingEXT,
  vkCmdResetQueryPool: nvk.vkCmdResetQueryPool,
  vkCmdWriteTimestamp: nvk.vkCmdWriteTimestamp,
  vkCmdCopyQueryPoolResults: nvk.vkCmdCopyQueryPoolResults,
  vkCmdPushConstants: nvk.vkCmdPushConstants,
  vkCmdBeginRenderPass: nvk.vkCmdBeginRenderPass,
  vkCmdNextSubpass: nvk.vkCmdNextSubpass,
  vkCmdEndRenderPass: nvk.vkCmdEndRenderPass,
  vkCmdExecuteCommands: nvk.vkCmdExecuteCommands,
  vkGetPhysicalDeviceDisplayPropertiesKHR: nvk.vkGetPhysicalDeviceDisplayPropertiesKHR,
  vkGetPhysicalDeviceDisplayPlanePropertiesKHR: nvk.vkGetPhysicalDeviceDisplayPlanePropertiesKHR,
  vkGetDisplayPlaneSupportedDisplaysKHR: nvk.vkGetDisplayPlaneSupportedDisplaysKHR,
  vkGetDisplayModePropertiesKHR: nvk.vkGetDisplayModePropertiesKHR,
  vkCreateDisplayModeKHR: nvk.vkCreateDisplayModeKHR,
  vkGetDisplayPlaneCapabilitiesKHR: nvk.vkGetDisplayPlaneCapabilitiesKHR,
  vkCreateDisplayPlaneSurfaceKHR: nvk.vkCreateDisplayPlaneSurfaceKHR,
  vkCreateSharedSwapchainsKHR: nvk.vkCreateSharedSwapchainsKHR,
  vkDestroySurfaceKHR: nvk.vkDestroySurfaceKHR,
  vkGetPhysicalDeviceSurfaceSupportKHR: nvk.vkGetPhysicalDeviceSurfaceSupportKHR,
  vkGetPhysicalDeviceSurfaceCapabilitiesKHR: nvk.vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
  vkGetPhysicalDeviceSurfaceFormatsKHR: nvk.vkGetPhysicalDeviceSurfaceFormatsKHR,
  vkGetPhysicalDeviceSurfacePresentModesKHR: nvk.vkGetPhysicalDeviceSurfacePresentModesKHR,
  vkCreateSwapchainKHR: nvk.vkCreateSwapchainKHR,
  vkDestroySwapchainKHR: nvk.vkDestroySwapchainKHR,
  vkGetSwapchainImagesKHR: nvk.vkGetSwapchainImagesKHR,
  vkAcquireNextImageKHR: nvk.vkAcquireNextImageKHR,
  vkQueuePresentKHR: nvk.vkQueuePresentKHR,
  vkCreateDebugReportCallbackEXT: nvk.vkCreateDebugReportCallbackEXT,
  vkDestroyDebugReportCallbackEXT: nvk.vkDestroyDebugReportCallbackEXT,
  vkDebugReportMessageEXT: nvk.vkDebugReportMessageEXT,
  vkDebugMarkerSetObjectNameEXT: nvk.vkDebugMarkerSetObjectNameEXT,
  vkDebugMarkerSetObjectTagEXT: nvk.vkDebugMarkerSetObjectTagEXT,
  vkCmdDebugMarkerBeginEXT: nvk.vkCmdDebugMarkerBeginEXT,
  vkCmdDebugMarkerEndEXT: nvk.vkCmdDebugMarkerEndEXT,
  vkCmdDebugMarkerInsertEXT: nvk.vkCmdDebugMarkerInsertEXT,
  vkGetPhysicalDeviceExternalImageFormatPropertiesNV: nvk.vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
  vkCmdDrawIndirectCountAMD: nvk.vkCmdDrawIndirectCountAMD,
  vkCmdDrawIndexedIndirectCountAMD: nvk.vkCmdDrawIndexedIndirectCountAMD,
  vkCmdProcessCommandsNVX: nvk.vkCmdProcessCommandsNVX,
  vkCmdReserveSpaceForCommandsNVX: nvk.vkCmdReserveSpaceForCommandsNVX,
  vkCreateIndirectCommandsLayoutNVX: nvk.vkCreateIndirectCommandsLayoutNVX,
  vkDestroyIndirectCommandsLayoutNVX: nvk.vkDestroyIndirectCommandsLayoutNVX,
  vkCreateObjectTableNVX: nvk.vkCreateObjectTableNVX,
  vkDestroyObjectTableNVX: nvk.vkDestroyObjectTableNVX,
  vkRegisterObjectsNVX: nvk.vkRegisterObjectsNVX,
  vkUnregisterObjectsNVX: nvk.vkUnregisterObjectsNVX,
  vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX: nvk.vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX,
  vkGetPhysicalDeviceFeatures2: nvk.vkGetPhysicalDeviceFeatures2,
  vkGetPhysicalDeviceProperties2: nvk.vkGetPhysicalDeviceProperties2,
  vkGetPhysicalDeviceFormatProperties2: nvk.vkGetPhysicalDeviceFormatProperties2,
  vkGetPhysicalDeviceImageFormatProperties2: nvk.vkGetPhysicalDeviceImageFormatProperties2,
  vkGetPhysicalDeviceQueueFamilyProperties2: nvk.vkGetPhysicalDeviceQueueFamilyProperties2,
  vkGetPhysicalDeviceMemoryProperties2: nvk.vkGetPhysicalDeviceMemoryProperties2,
  vkGetPhysicalDeviceSparseImageFormatProperties2: nvk.vkGetPhysicalDeviceSparseImageFormatProperties2,
  vkCmdPushDescriptorSetKHR: nvk.vkCmdPushDescriptorSetKHR,
  vkTrimCommandPool: nvk.vkTrimCommandPool,
  vkGetPhysicalDeviceExternalBufferProperties: nvk.vkGetPhysicalDeviceExternalBufferProperties,
  vkGetMemoryFdKHR: nvk.vkGetMemoryFdKHR,
  vkGetMemoryFdPropertiesKHR: nvk.vkGetMemoryFdPropertiesKHR,
  vkGetPhysicalDeviceExternalSemaphoreProperties: nvk.vkGetPhysicalDeviceExternalSemaphoreProperties,
  vkGetSemaphoreFdKHR: nvk.vkGetSemaphoreFdKHR,
  vkImportSemaphoreFdKHR: nvk.vkImportSemaphoreFdKHR,
  vkGetPhysicalDeviceExternalFenceProperties: nvk.vkGetPhysicalDeviceExternalFenceProperties,
  vkGetFenceFdKHR: nvk.vkGetFenceFdKHR,
  vkImportFenceFdKHR: nvk.vkImportFenceFdKHR,
  vkReleaseDisplayEXT: nvk.vkReleaseDisplayEXT,
  vkDisplayPowerControlEXT: nvk.vkDisplayPowerControlEXT,
  vkRegisterDeviceEventEXT: nvk.vkRegisterDeviceEventEXT,
  vkRegisterDisplayEventEXT: nvk.vkRegisterDisplayEventEXT,
  vkGetSwapchainCounterEXT: nvk.vkGetSwapchainCounterEXT,
  vkGetPhysicalDeviceSurfaceCapabilities2EXT: nvk.vkGetPhysicalDeviceSurfaceCapabilities2EXT,
  vkEnumeratePhysicalDeviceGroups: nvk.vkEnumeratePhysicalDeviceGroups,
  vkGetDeviceGroupPeerMemoryFeatures: nvk.vkGetDeviceGroupPeerMemoryFeatures,
  vkBindBufferMemory2: nvk.vkBindBufferMemory2,
  vkBindImageMemory2: nvk.vkBindImageMemory2,
  vkCmdSetDeviceMask: nvk.vkCmdSetDeviceMask,
  vkGetDeviceGroupPresentCapabilitiesKHR: nvk.vkGetDeviceGroupPresentCapabilitiesKHR,
  vkGetDeviceGroupSurfacePresentModesKHR: nvk.vkGetDeviceGroupSurfacePresentModesKHR,
  vkAcquireNextImage2KHR: nvk.vkAcquireNextImage2KHR,
  vkCmdDispatchBase: nvk.vkCmdDispatchBase,
  vkGetPhysicalDevicePresentRectanglesKHR: nvk.vkGetPhysicalDevicePresentRectanglesKHR,
  vkCreateDescriptorUpdateTemplate: nvk.vkCreateDescriptorUpdateTemplate,
  vkDestroyDescriptorUpdateTemplate: nvk.vkDestroyDescriptorUpdateTemplate,
  vkUpdateDescriptorSetWithTemplate: nvk.vkUpdateDescriptorSetWithTemplate,
  vkCmdPushDescriptorSetWithTemplateKHR: nvk.vkCmdPushDescriptorSetWithTemplateKHR,
  vkSetHdrMetadataEXT: nvk.vkSetHdrMetadataEXT,
  vkGetSwapchainStatusKHR: nvk.vkGetSwapchainStatusKHR,
  vkGetRefreshCycleDurationGOOGLE: nvk.vkGetRefreshCycleDurationGOOGLE,
  vkGetPastPresentationTimingGOOGLE: nvk.vkGetPastPresentationTimingGOOGLE,
  vkCreateMacOSSurfaceMVK: nvk.vkCreateMacOSSurfaceMVK,
  vkCmdSetViewportWScalingNV: nvk.vkCmdSetViewportWScalingNV,
  vkCmdSetDiscardRectangleEXT: nvk.vkCmdSetDiscardRectangleEXT,
  vkCmdSetSampleLocationsEXT: nvk.vkCmdSetSampleLocationsEXT,
  vkGetPhysicalDeviceMultisamplePropertiesEXT: nvk.vkGetPhysicalDeviceMultisamplePropertiesEXT,
  vkGetPhysicalDeviceSurfaceCapabilities2KHR: nvk.vkGetPhysicalDeviceSurfaceCapabilities2KHR,
  vkGetPhysicalDeviceSurfaceFormats2KHR: nvk.vkGetPhysicalDeviceSurfaceFormats2KHR,
  vkGetPhysicalDeviceDisplayProperties2KHR: nvk.vkGetPhysicalDeviceDisplayProperties2KHR,
  vkGetPhysicalDeviceDisplayPlaneProperties2KHR: nvk.vkGetPhysicalDeviceDisplayPlaneProperties2KHR,
  vkGetDisplayModeProperties2KHR: nvk.vkGetDisplayModeProperties2KHR,
  vkGetDisplayPlaneCapabilities2KHR: nvk.vkGetDisplayPlaneCapabilities2KHR,
  vkGetBufferMemoryRequirements2: nvk.vkGetBufferMemoryRequirements2,
  vkGetImageMemoryRequirements2: nvk.vkGetImageMemoryRequirements2,
  vkGetImageSparseMemoryRequirements2: nvk.vkGetImageSparseMemoryRequirements2,
  vkCreateSamplerYcbcrConversion: nvk.vkCreateSamplerYcbcrConversion,
  vkDestroySamplerYcbcrConversion: nvk.vkDestroySamplerYcbcrConversion,
  vkGetDeviceQueue2: nvk.vkGetDeviceQueue2,
  vkCreateValidationCacheEXT: nvk.vkCreateValidationCacheEXT,
  vkDestroyValidationCacheEXT: nvk.vkDestroyValidationCacheEXT,
  vkGetValidationCacheDataEXT: nvk.vkGetValidationCacheDataEXT,
  vkMergeValidationCachesEXT: nvk.vkMergeValidationCachesEXT,
  vkGetDescriptorSetLayoutSupport: nvk.vkGetDescriptorSetLayoutSupport,
  vkGetShaderInfoAMD: nvk.vkGetShaderInfoAMD,
  vkGetPhysicalDeviceCalibrateableTimeDomainsEXT: nvk.vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
  vkGetCalibratedTimestampsEXT: nvk.vkGetCalibratedTimestampsEXT,
  vkSetDebugUtilsObjectNameEXT: nvk.vkSetDebugUtilsObjectNameEXT,
  vkSetDebugUtilsObjectTagEXT: nvk.vkSetDebugUtilsObjectTagEXT,
  vkQueueBeginDebugUtilsLabelEXT: nvk.vkQueueBeginDebugUtilsLabelEXT,
  vkQueueEndDebugUtilsLabelEXT: nvk.vkQueueEndDebugUtilsLabelEXT,
  vkQueueInsertDebugUtilsLabelEXT: nvk.vkQueueInsertDebugUtilsLabelEXT,
  vkCmdBeginDebugUtilsLabelEXT: nvk.vkCmdBeginDebugUtilsLabelEXT,
  vkCmdEndDebugUtilsLabelEXT: nvk.vkCmdEndDebugUtilsLabelEXT,
  vkCmdInsertDebugUtilsLabelEXT: nvk.vkCmdInsertDebugUtilsLabelEXT,
  vkCreateDebugUtilsMessengerEXT: nvk.vkCreateDebugUtilsMessengerEXT,
  vkDestroyDebugUtilsMessengerEXT: nvk.vkDestroyDebugUtilsMessengerEXT,
  vkSubmitDebugUtilsMessageEXT: nvk.vkSubmitDebugUtilsMessageEXT,
  vkGetMemoryHostPointerPropertiesEXT: nvk.vkGetMemoryHostPointerPropertiesEXT,
  vkCmdWriteBufferMarkerAMD: nvk.vkCmdWriteBufferMarkerAMD,
  vkCreateRenderPass2KHR: nvk.vkCreateRenderPass2KHR,
  vkCmdBeginRenderPass2KHR: nvk.vkCmdBeginRenderPass2KHR,
  vkCmdNextSubpass2KHR: nvk.vkCmdNextSubpass2KHR,
  vkCmdEndRenderPass2KHR: nvk.vkCmdEndRenderPass2KHR,
  vkCmdDrawIndirectCountKHR: nvk.vkCmdDrawIndirectCountKHR,
  vkCmdDrawIndexedIndirectCountKHR: nvk.vkCmdDrawIndexedIndirectCountKHR,
  vkCmdSetCheckpointNV: nvk.vkCmdSetCheckpointNV,
  vkGetQueueCheckpointDataNV: nvk.vkGetQueueCheckpointDataNV,
  vkCmdBindTransformFeedbackBuffersEXT: nvk.vkCmdBindTransformFeedbackBuffersEXT,
  vkCmdBeginTransformFeedbackEXT: nvk.vkCmdBeginTransformFeedbackEXT,
  vkCmdEndTransformFeedbackEXT: nvk.vkCmdEndTransformFeedbackEXT,
  vkCmdBeginQueryIndexedEXT: nvk.vkCmdBeginQueryIndexedEXT,
  vkCmdEndQueryIndexedEXT: nvk.vkCmdEndQueryIndexedEXT,
  vkCmdDrawIndirectByteCountEXT: nvk.vkCmdDrawIndirectByteCountEXT,
  vkCmdSetExclusiveScissorNV: nvk.vkCmdSetExclusiveScissorNV,
  vkCmdBindShadingRateImageNV: nvk.vkCmdBindShadingRateImageNV,
  vkCmdSetViewportShadingRatePaletteNV: nvk.vkCmdSetViewportShadingRatePaletteNV,
  vkCmdSetCoarseSampleOrderNV: nvk.vkCmdSetCoarseSampleOrderNV,
  vkCmdDrawMeshTasksNV: nvk.vkCmdDrawMeshTasksNV,
  vkCmdDrawMeshTasksIndirectNV: nvk.vkCmdDrawMeshTasksIndirectNV,
  vkCmdDrawMeshTasksIndirectCountNV: nvk.vkCmdDrawMeshTasksIndirectCountNV,
  vkCompileDeferredNV: nvk.vkCompileDeferredNV,
  vkCreateAccelerationStructureNV: nvk.vkCreateAccelerationStructureNV,
  vkDestroyAccelerationStructureNV: nvk.vkDestroyAccelerationStructureNV,
  vkGetAccelerationStructureMemoryRequirementsNV: nvk.vkGetAccelerationStructureMemoryRequirementsNV,
  vkBindAccelerationStructureMemoryNV: nvk.vkBindAccelerationStructureMemoryNV,
  vkCmdCopyAccelerationStructureNV: nvk.vkCmdCopyAccelerationStructureNV,
  vkCmdWriteAccelerationStructuresPropertiesNV: nvk.vkCmdWriteAccelerationStructuresPropertiesNV,
  vkCmdBuildAccelerationStructureNV: nvk.vkCmdBuildAccelerationStructureNV,
  vkCmdTraceRaysNV: nvk.vkCmdTraceRaysNV,
  vkGetRayTracingShaderGroupHandlesNV: nvk.vkGetRayTracingShaderGroupHandlesNV,
  vkGetAccelerationStructureHandleNV: nvk.vkGetAccelerationStructureHandleNV,
  vkCreateRayTracingPipelinesNV: nvk.vkCreateRayTracingPipelinesNV,
  vkGetImageDrmFormatModifierPropertiesEXT: nvk.vkGetImageDrmFormatModifierPropertiesEXT,
  vkGetBufferDeviceAddressEXT: nvk.vkGetBufferDeviceAddressEXT,
  vkGetPhysicalDeviceCooperativeMatrixPropertiesNV: nvk.vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
  VkInstance,
  VkPhysicalDevice,
  VkDevice,
  VkQueue,
  VkCommandBuffer,
  VkDeviceMemory,
  VkCommandPool,
  VkBuffer,
  VkBufferView,
  VkImage,
  VkImageView,
  VkShaderModule,
  VkPipeline,
  VkPipelineLayout,
  VkSampler,
  VkDescriptorSet,
  VkDescriptorSetLayout,
  VkDescriptorPool,
  VkFence,
  VkSemaphore,
  VkEvent,
  VkQueryPool,
  VkFramebuffer,
  VkRenderPass,
  VkPipelineCache,
  VkObjectTableNVX,
  VkIndirectCommandsLayoutNVX,
  VkDescriptorUpdateTemplate,
  VkSamplerYcbcrConversion,
  VkValidationCacheEXT,
  VkAccelerationStructureNV,
  VkDisplayKHR,
  VkDisplayModeKHR,
  VkSurfaceKHR,
  VkSwapchainKHR,
  VkDebugReportCallbackEXT,
  VkDebugUtilsMessengerEXT,
  VkBaseOutStructure,
  VkBaseInStructure,
  VkOffset2D,
  VkOffset3D,
  VkExtent2D,
  VkExtent3D,
  VkViewport,
  VkRect2D,
  VkClearRect,
  VkComponentMapping,
  VkPhysicalDeviceProperties,
  VkExtensionProperties,
  VkLayerProperties,
  VkApplicationInfo,
  VkAllocationCallbacks,
  VkDeviceQueueCreateInfo,
  VkDeviceCreateInfo,
  VkInstanceCreateInfo,
  VkQueueFamilyProperties,
  VkPhysicalDeviceMemoryProperties,
  VkMemoryAllocateInfo,
  VkMemoryRequirements,
  VkSparseImageFormatProperties,
  VkSparseImageMemoryRequirements,
  VkMemoryType,
  VkMemoryHeap,
  VkMappedMemoryRange,
  VkFormatProperties,
  VkImageFormatProperties,
  VkDescriptorBufferInfo,
  VkDescriptorImageInfo,
  VkWriteDescriptorSet,
  VkCopyDescriptorSet,
  VkBufferCreateInfo,
  VkBufferViewCreateInfo,
  VkImageSubresource,
  VkImageSubresourceLayers,
  VkImageSubresourceRange,
  VkMemoryBarrier,
  VkBufferMemoryBarrier,
  VkImageMemoryBarrier,
  VkImageCreateInfo,
  VkSubresourceLayout,
  VkImageViewCreateInfo,
  VkBufferCopy,
  VkSparseMemoryBind,
  VkSparseImageMemoryBind,
  VkSparseBufferMemoryBindInfo,
  VkSparseImageOpaqueMemoryBindInfo,
  VkSparseImageMemoryBindInfo,
  VkBindSparseInfo,
  VkImageCopy,
  VkImageBlit,
  VkBufferImageCopy,
  VkImageResolve,
  VkShaderModuleCreateInfo,
  VkDescriptorSetLayoutBinding,
  VkDescriptorSetLayoutCreateInfo,
  VkDescriptorPoolSize,
  VkDescriptorPoolCreateInfo,
  VkDescriptorSetAllocateInfo,
  VkSpecializationMapEntry,
  VkSpecializationInfo,
  VkPipelineShaderStageCreateInfo,
  VkComputePipelineCreateInfo,
  VkVertexInputBindingDescription,
  VkVertexInputAttributeDescription,
  VkPipelineVertexInputStateCreateInfo,
  VkPipelineInputAssemblyStateCreateInfo,
  VkPipelineTessellationStateCreateInfo,
  VkPipelineViewportStateCreateInfo,
  VkPipelineRasterizationStateCreateInfo,
  VkPipelineMultisampleStateCreateInfo,
  VkPipelineColorBlendAttachmentState,
  VkPipelineColorBlendStateCreateInfo,
  VkPipelineDynamicStateCreateInfo,
  VkStencilOpState,
  VkPipelineDepthStencilStateCreateInfo,
  VkGraphicsPipelineCreateInfo,
  VkPipelineCacheCreateInfo,
  VkPushConstantRange,
  VkPipelineLayoutCreateInfo,
  VkSamplerCreateInfo,
  VkCommandPoolCreateInfo,
  VkCommandBufferAllocateInfo,
  VkCommandBufferInheritanceInfo,
  VkCommandBufferBeginInfo,
  VkRenderPassBeginInfo,
  VkClearDepthStencilValue,
  VkClearAttachment,
  VkAttachmentDescription,
  VkAttachmentReference,
  VkSubpassDescription,
  VkSubpassDependency,
  VkRenderPassCreateInfo,
  VkEventCreateInfo,
  VkFenceCreateInfo,
  VkPhysicalDeviceFeatures,
  VkPhysicalDeviceSparseProperties,
  VkPhysicalDeviceLimits,
  VkSemaphoreCreateInfo,
  VkQueryPoolCreateInfo,
  VkFramebufferCreateInfo,
  VkDrawIndirectCommand,
  VkDrawIndexedIndirectCommand,
  VkDispatchIndirectCommand,
  VkSubmitInfo,
  VkDisplayPropertiesKHR,
  VkDisplayPlanePropertiesKHR,
  VkDisplayModeParametersKHR,
  VkDisplayModePropertiesKHR,
  VkDisplayModeCreateInfoKHR,
  VkDisplayPlaneCapabilitiesKHR,
  VkDisplaySurfaceCreateInfoKHR,
  VkDisplayPresentInfoKHR,
  VkSurfaceCapabilitiesKHR,
  VkSurfaceFormatKHR,
  VkSwapchainCreateInfoKHR,
  VkPresentInfoKHR,
  VkDebugReportCallbackCreateInfoEXT,
  VkValidationFlagsEXT,
  VkValidationFeaturesEXT,
  VkPipelineRasterizationStateRasterizationOrderAMD,
  VkDebugMarkerObjectNameInfoEXT,
  VkDebugMarkerObjectTagInfoEXT,
  VkDebugMarkerMarkerInfoEXT,
  VkDedicatedAllocationImageCreateInfoNV,
  VkDedicatedAllocationBufferCreateInfoNV,
  VkDedicatedAllocationMemoryAllocateInfoNV,
  VkExternalImageFormatPropertiesNV,
  VkExternalMemoryImageCreateInfoNV,
  VkExportMemoryAllocateInfoNV,
  VkDeviceGeneratedCommandsFeaturesNVX,
  VkDeviceGeneratedCommandsLimitsNVX,
  VkIndirectCommandsTokenNVX,
  VkIndirectCommandsLayoutTokenNVX,
  VkIndirectCommandsLayoutCreateInfoNVX,
  VkCmdProcessCommandsInfoNVX,
  VkCmdReserveSpaceForCommandsInfoNVX,
  VkObjectTableCreateInfoNVX,
  VkObjectTableEntryNVX,
  VkObjectTablePipelineEntryNVX,
  VkObjectTableDescriptorSetEntryNVX,
  VkObjectTableVertexBufferEntryNVX,
  VkObjectTableIndexBufferEntryNVX,
  VkObjectTablePushConstantEntryNVX,
  VkPhysicalDeviceFeatures2,
  VkPhysicalDeviceFeatures2KHR,
  VkPhysicalDeviceProperties2,
  VkPhysicalDeviceProperties2KHR,
  VkFormatProperties2,
  VkFormatProperties2KHR,
  VkImageFormatProperties2,
  VkImageFormatProperties2KHR,
  VkPhysicalDeviceImageFormatInfo2,
  VkPhysicalDeviceImageFormatInfo2KHR,
  VkQueueFamilyProperties2,
  VkQueueFamilyProperties2KHR,
  VkPhysicalDeviceMemoryProperties2,
  VkPhysicalDeviceMemoryProperties2KHR,
  VkSparseImageFormatProperties2,
  VkSparseImageFormatProperties2KHR,
  VkPhysicalDeviceSparseImageFormatInfo2,
  VkPhysicalDeviceSparseImageFormatInfo2KHR,
  VkPhysicalDevicePushDescriptorPropertiesKHR,
  VkConformanceVersionKHR,
  VkPhysicalDeviceDriverPropertiesKHR,
  VkPresentRegionsKHR,
  VkPresentRegionKHR,
  VkRectLayerKHR,
  VkPhysicalDeviceVariablePointerFeatures,
  VkPhysicalDeviceVariablePointerFeaturesKHR,
  VkExternalMemoryProperties,
  VkExternalMemoryPropertiesKHR,
  VkPhysicalDeviceExternalImageFormatInfo,
  VkPhysicalDeviceExternalImageFormatInfoKHR,
  VkExternalImageFormatProperties,
  VkExternalImageFormatPropertiesKHR,
  VkPhysicalDeviceExternalBufferInfo,
  VkPhysicalDeviceExternalBufferInfoKHR,
  VkExternalBufferProperties,
  VkExternalBufferPropertiesKHR,
  VkPhysicalDeviceIDProperties,
  VkPhysicalDeviceIDPropertiesKHR,
  VkExternalMemoryImageCreateInfo,
  VkExternalMemoryImageCreateInfoKHR,
  VkExternalMemoryBufferCreateInfo,
  VkExternalMemoryBufferCreateInfoKHR,
  VkExportMemoryAllocateInfo,
  VkExportMemoryAllocateInfoKHR,
  VkImportMemoryFdInfoKHR,
  VkMemoryFdPropertiesKHR,
  VkMemoryGetFdInfoKHR,
  VkPhysicalDeviceExternalSemaphoreInfo,
  VkPhysicalDeviceExternalSemaphoreInfoKHR,
  VkExternalSemaphoreProperties,
  VkExternalSemaphorePropertiesKHR,
  VkExportSemaphoreCreateInfo,
  VkExportSemaphoreCreateInfoKHR,
  VkImportSemaphoreFdInfoKHR,
  VkSemaphoreGetFdInfoKHR,
  VkPhysicalDeviceExternalFenceInfo,
  VkPhysicalDeviceExternalFenceInfoKHR,
  VkExternalFenceProperties,
  VkExternalFencePropertiesKHR,
  VkExportFenceCreateInfo,
  VkExportFenceCreateInfoKHR,
  VkImportFenceFdInfoKHR,
  VkFenceGetFdInfoKHR,
  VkPhysicalDeviceMultiviewFeatures,
  VkPhysicalDeviceMultiviewFeaturesKHR,
  VkPhysicalDeviceMultiviewProperties,
  VkPhysicalDeviceMultiviewPropertiesKHR,
  VkRenderPassMultiviewCreateInfo,
  VkRenderPassMultiviewCreateInfoKHR,
  VkSurfaceCapabilities2EXT,
  VkDisplayPowerInfoEXT,
  VkDeviceEventInfoEXT,
  VkDisplayEventInfoEXT,
  VkSwapchainCounterCreateInfoEXT,
  VkPhysicalDeviceGroupProperties,
  VkPhysicalDeviceGroupPropertiesKHR,
  VkMemoryAllocateFlagsInfo,
  VkMemoryAllocateFlagsInfoKHR,
  VkBindBufferMemoryInfo,
  VkBindBufferMemoryInfoKHR,
  VkBindBufferMemoryDeviceGroupInfo,
  VkBindBufferMemoryDeviceGroupInfoKHR,
  VkBindImageMemoryInfo,
  VkBindImageMemoryInfoKHR,
  VkBindImageMemoryDeviceGroupInfo,
  VkBindImageMemoryDeviceGroupInfoKHR,
  VkDeviceGroupRenderPassBeginInfo,
  VkDeviceGroupRenderPassBeginInfoKHR,
  VkDeviceGroupCommandBufferBeginInfo,
  VkDeviceGroupCommandBufferBeginInfoKHR,
  VkDeviceGroupSubmitInfo,
  VkDeviceGroupSubmitInfoKHR,
  VkDeviceGroupBindSparseInfo,
  VkDeviceGroupBindSparseInfoKHR,
  VkDeviceGroupPresentCapabilitiesKHR,
  VkImageSwapchainCreateInfoKHR,
  VkBindImageMemorySwapchainInfoKHR,
  VkAcquireNextImageInfoKHR,
  VkDeviceGroupPresentInfoKHR,
  VkDeviceGroupDeviceCreateInfo,
  VkDeviceGroupDeviceCreateInfoKHR,
  VkDeviceGroupSwapchainCreateInfoKHR,
  VkDescriptorUpdateTemplateEntry,
  VkDescriptorUpdateTemplateEntryKHR,
  VkDescriptorUpdateTemplateCreateInfo,
  VkDescriptorUpdateTemplateCreateInfoKHR,
  VkXYColorEXT,
  VkHdrMetadataEXT,
  VkRefreshCycleDurationGOOGLE,
  VkPastPresentationTimingGOOGLE,
  VkPresentTimesInfoGOOGLE,
  VkPresentTimeGOOGLE,
  VkMacOSSurfaceCreateInfoMVK,
  VkViewportWScalingNV,
  VkPipelineViewportWScalingStateCreateInfoNV,
  VkViewportSwizzleNV,
  VkPipelineViewportSwizzleStateCreateInfoNV,
  VkPhysicalDeviceDiscardRectanglePropertiesEXT,
  VkPipelineDiscardRectangleStateCreateInfoEXT,
  VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
  VkInputAttachmentAspectReference,
  VkInputAttachmentAspectReferenceKHR,
  VkRenderPassInputAttachmentAspectCreateInfo,
  VkRenderPassInputAttachmentAspectCreateInfoKHR,
  VkPhysicalDeviceSurfaceInfo2KHR,
  VkSurfaceCapabilities2KHR,
  VkSurfaceFormat2KHR,
  VkDisplayProperties2KHR,
  VkDisplayPlaneProperties2KHR,
  VkDisplayModeProperties2KHR,
  VkDisplayPlaneInfo2KHR,
  VkDisplayPlaneCapabilities2KHR,
  VkSharedPresentSurfaceCapabilitiesKHR,
  VkPhysicalDevice16BitStorageFeatures,
  VkPhysicalDevice16BitStorageFeaturesKHR,
  VkPhysicalDeviceSubgroupProperties,
  VkBufferMemoryRequirementsInfo2,
  VkBufferMemoryRequirementsInfo2KHR,
  VkImageMemoryRequirementsInfo2,
  VkImageMemoryRequirementsInfo2KHR,
  VkImageSparseMemoryRequirementsInfo2,
  VkImageSparseMemoryRequirementsInfo2KHR,
  VkMemoryRequirements2,
  VkMemoryRequirements2KHR,
  VkSparseImageMemoryRequirements2,
  VkSparseImageMemoryRequirements2KHR,
  VkPhysicalDevicePointClippingProperties,
  VkPhysicalDevicePointClippingPropertiesKHR,
  VkMemoryDedicatedRequirements,
  VkMemoryDedicatedRequirementsKHR,
  VkMemoryDedicatedAllocateInfo,
  VkMemoryDedicatedAllocateInfoKHR,
  VkImageViewUsageCreateInfo,
  VkImageViewUsageCreateInfoKHR,
  VkPipelineTessellationDomainOriginStateCreateInfo,
  VkPipelineTessellationDomainOriginStateCreateInfoKHR,
  VkSamplerYcbcrConversionInfo,
  VkSamplerYcbcrConversionInfoKHR,
  VkSamplerYcbcrConversionCreateInfo,
  VkSamplerYcbcrConversionCreateInfoKHR,
  VkBindImagePlaneMemoryInfo,
  VkBindImagePlaneMemoryInfoKHR,
  VkImagePlaneMemoryRequirementsInfo,
  VkImagePlaneMemoryRequirementsInfoKHR,
  VkPhysicalDeviceSamplerYcbcrConversionFeatures,
  VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR,
  VkSamplerYcbcrConversionImageFormatProperties,
  VkSamplerYcbcrConversionImageFormatPropertiesKHR,
  VkTextureLODGatherFormatPropertiesAMD,
  VkConditionalRenderingBeginInfoEXT,
  VkProtectedSubmitInfo,
  VkPhysicalDeviceProtectedMemoryFeatures,
  VkPhysicalDeviceProtectedMemoryProperties,
  VkDeviceQueueInfo2,
  VkPipelineCoverageToColorStateCreateInfoNV,
  VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,
  VkSampleLocationEXT,
  VkSampleLocationsInfoEXT,
  VkAttachmentSampleLocationsEXT,
  VkSubpassSampleLocationsEXT,
  VkRenderPassSampleLocationsBeginInfoEXT,
  VkPipelineSampleLocationsStateCreateInfoEXT,
  VkPhysicalDeviceSampleLocationsPropertiesEXT,
  VkMultisamplePropertiesEXT,
  VkSamplerReductionModeCreateInfoEXT,
  VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
  VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
  VkPipelineColorBlendAdvancedStateCreateInfoEXT,
  VkPhysicalDeviceInlineUniformBlockFeaturesEXT,
  VkPhysicalDeviceInlineUniformBlockPropertiesEXT,
  VkWriteDescriptorSetInlineUniformBlockEXT,
  VkDescriptorPoolInlineUniformBlockCreateInfoEXT,
  VkPipelineCoverageModulationStateCreateInfoNV,
  VkImageFormatListCreateInfoKHR,
  VkValidationCacheCreateInfoEXT,
  VkShaderModuleValidationCacheCreateInfoEXT,
  VkPhysicalDeviceMaintenance3Properties,
  VkPhysicalDeviceMaintenance3PropertiesKHR,
  VkDescriptorSetLayoutSupport,
  VkDescriptorSetLayoutSupportKHR,
  VkPhysicalDeviceShaderDrawParameterFeatures,
  VkPhysicalDeviceFloat16Int8FeaturesKHR,
  VkPhysicalDeviceFloatControlsPropertiesKHR,
  VkShaderResourceUsageAMD,
  VkShaderStatisticsInfoAMD,
  VkDeviceQueueGlobalPriorityCreateInfoEXT,
  VkDebugUtilsObjectNameInfoEXT,
  VkDebugUtilsObjectTagInfoEXT,
  VkDebugUtilsLabelEXT,
  VkDebugUtilsMessengerCreateInfoEXT,
  VkDebugUtilsMessengerCallbackDataEXT,
  VkImportMemoryHostPointerInfoEXT,
  VkMemoryHostPointerPropertiesEXT,
  VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
  VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
  VkCalibratedTimestampInfoEXT,
  VkPhysicalDeviceShaderCorePropertiesAMD,
  VkPipelineRasterizationConservativeStateCreateInfoEXT,
  VkPhysicalDeviceDescriptorIndexingFeaturesEXT,
  VkPhysicalDeviceDescriptorIndexingPropertiesEXT,
  VkDescriptorSetLayoutBindingFlagsCreateInfoEXT,
  VkDescriptorSetVariableDescriptorCountAllocateInfoEXT,
  VkDescriptorSetVariableDescriptorCountLayoutSupportEXT,
  VkAttachmentDescription2KHR,
  VkAttachmentReference2KHR,
  VkSubpassDescription2KHR,
  VkSubpassDependency2KHR,
  VkRenderPassCreateInfo2KHR,
  VkSubpassBeginInfoKHR,
  VkSubpassEndInfoKHR,
  VkVertexInputBindingDivisorDescriptionEXT,
  VkPipelineVertexInputDivisorStateCreateInfoEXT,
  VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,
  VkPhysicalDevicePCIBusInfoPropertiesEXT,
  VkCommandBufferInheritanceConditionalRenderingInfoEXT,
  VkPhysicalDevice8BitStorageFeaturesKHR,
  VkPhysicalDeviceConditionalRenderingFeaturesEXT,
  VkPhysicalDeviceVulkanMemoryModelFeaturesKHR,
  VkPhysicalDeviceShaderAtomicInt64FeaturesKHR,
  VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
  VkQueueFamilyCheckpointPropertiesNV,
  VkCheckpointDataNV,
  VkPhysicalDeviceDepthStencilResolvePropertiesKHR,
  VkSubpassDescriptionDepthStencilResolveKHR,
  VkImageViewASTCDecodeModeEXT,
  VkPhysicalDeviceASTCDecodeFeaturesEXT,
  VkPhysicalDeviceTransformFeedbackFeaturesEXT,
  VkPhysicalDeviceTransformFeedbackPropertiesEXT,
  VkPipelineRasterizationStateStreamCreateInfoEXT,
  VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,
  VkPipelineRepresentativeFragmentTestStateCreateInfoNV,
  VkPhysicalDeviceExclusiveScissorFeaturesNV,
  VkPipelineViewportExclusiveScissorStateCreateInfoNV,
  VkPhysicalDeviceCornerSampledImageFeaturesNV,
  VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,
  VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV,
  VkPhysicalDeviceShaderImageFootprintFeaturesNV,
  VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
  VkShadingRatePaletteNV,
  VkPipelineViewportShadingRateImageStateCreateInfoNV,
  VkPhysicalDeviceShadingRateImageFeaturesNV,
  VkPhysicalDeviceShadingRateImagePropertiesNV,
  VkCoarseSampleLocationNV,
  VkCoarseSampleOrderCustomNV,
  VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
  VkPhysicalDeviceMeshShaderFeaturesNV,
  VkPhysicalDeviceMeshShaderPropertiesNV,
  VkDrawMeshTasksIndirectCommandNV,
  VkRayTracingShaderGroupCreateInfoNV,
  VkRayTracingPipelineCreateInfoNV,
  VkGeometryTrianglesNV,
  VkGeometryAABBNV,
  VkGeometryDataNV,
  VkGeometryNV,
  VkAccelerationStructureInfoNV,
  VkAccelerationStructureCreateInfoNV,
  VkBindAccelerationStructureMemoryInfoNV,
  VkWriteDescriptorSetAccelerationStructureNV,
  VkAccelerationStructureMemoryRequirementsInfoNV,
  VkPhysicalDeviceRayTracingPropertiesNV,
  VkDrmFormatModifierPropertiesListEXT,
  VkDrmFormatModifierPropertiesEXT,
  VkPhysicalDeviceImageDrmFormatModifierInfoEXT,
  VkImageDrmFormatModifierListCreateInfoEXT,
  VkImageDrmFormatModifierExplicitCreateInfoEXT,
  VkImageDrmFormatModifierPropertiesEXT,
  VkImageStencilUsageCreateInfoEXT,
  VkDeviceMemoryOverallocationCreateInfoAMD,
  VkPhysicalDeviceFragmentDensityMapFeaturesEXT,
  VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
  VkRenderPassFragmentDensityMapCreateInfoEXT,
  VkPhysicalDeviceScalarBlockLayoutFeaturesEXT,
  VkPhysicalDeviceDepthClipEnableFeaturesEXT,
  VkPipelineRasterizationDepthClipStateCreateInfoEXT,
  VkPhysicalDeviceMemoryBudgetPropertiesEXT,
  VkPhysicalDeviceMemoryPriorityFeaturesEXT,
  VkMemoryPriorityAllocateInfoEXT,
  VkPhysicalDeviceBufferAddressFeaturesEXT,
  VkBufferDeviceAddressInfoEXT,
  VkBufferDeviceAddressCreateInfoEXT,
  VkPhysicalDeviceImageViewImageFormatInfoEXT,
  VkFilterCubicImageViewImageFormatPropertiesEXT,
  VkPhysicalDeviceCooperativeMatrixFeaturesNV,
  VkPhysicalDeviceCooperativeMatrixPropertiesNV,
  VkCooperativeMatrixPropertiesNV,
  VkClearColorValue,
  VkClearValue
};
