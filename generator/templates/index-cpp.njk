#include <nan.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE

std::string dirname;

#include "index.h"
#include "calls.h"
#include "enums.h"
#include "window.h"

static void createV8ArrayBufferFromMemory(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  if (!(info[0]->IsBigInt())) Nan::ThrowError("First argument must be a BigInt!");
  if (!(info[1]->IsNumber())) Nan::ThrowError("Second argument must be a number!");
  v8::Local<v8::BigInt> arg0 = v8::Local<v8::BigInt>::Cast(info[0]);
  int64_t addr = arg0->Int64Value();
  uint32_t size = Nan::To<uint32_t>(info[1]).FromMaybe(0);
  v8::Local<v8::ArrayBuffer> arr = v8::ArrayBuffer::New(
    v8::Isolate::GetCurrent(),
    reinterpret_cast<void *>(addr),
    size,
    v8::ArrayBufferCreationMode::kExternalized
  );
  info.GetReturnValue().Set(arr);
};

static void _VK_MAKE_VERSION(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  uint32_t major = Nan::To<uint32_t>(info[0]).FromMaybe(0);
  uint32_t minor = Nan::To<uint32_t>(info[1]).FromMaybe(0);
  uint32_t patch = Nan::To<uint32_t>(info[2]).FromMaybe(0);
  info.GetReturnValue().Set(VK_MAKE_VERSION(major, minor, patch));
};

static void _VK_VERSION_MAJOR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  uint32_t version = Nan::To<uint32_t>(info[0]).FromMaybe(0);;
  info.GetReturnValue().Set((uint32_t)(version) >> 22);
};

static void _VK_VERSION_MINOR(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  uint32_t version = Nan::To<uint32_t>(info[0]).FromMaybe(0);;
  info.GetReturnValue().Set(((uint32_t)(version) >> 12) & 0x3ff);
};

static void _VK_VERSION_PATCH(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  uint32_t version = Nan::To<uint32_t>(info[0]).FromMaybe(0);;
  info.GetReturnValue().Set((uint32_t)(version) & 0xfff);
};

static std::string resolveModulePath(v8::Handle<v8::Object> module) {
  std::string addonPath = *v8::String::Utf8Value(
    v8::Isolate::GetCurrent(),
    module->Get(Nan::New("filename").ToLocalChecked()).As<v8::String>()
  );
  std::string path = addonPath.substr(0, addonPath.find_last_of("/\\"));
  return path;
};

static void init(v8::Handle<v8::Object> target, v8::Handle<v8::Object> module) {
  // path to addon
  dirname = resolveModulePath(module);
  // default initializers
  VulkanWindow::Initialize(target);
  // manual initializers
  target->Set(
    Nan::New("createV8ArrayBufferFromMemory").ToLocalChecked(),
    Nan::New<v8::FunctionTemplate>(createV8ArrayBufferFromMemory)->GetFunction()
  );
  target->Set(
    Nan::New("getVulkanEnumerations").ToLocalChecked(),
    Nan::New<v8::FunctionTemplate>(getVulkanEnumerations)->GetFunction()
  );
  // vulkan stubs
  target->Set(
    Nan::New("VK_MAKE_VERSION").ToLocalChecked(),
    Nan::New<v8::FunctionTemplate>(_VK_MAKE_VERSION)->GetFunction()
  );
  target->Set(
    Nan::New("VK_VERSION_MAJOR").ToLocalChecked(),
    Nan::New<v8::FunctionTemplate>(_VK_VERSION_MAJOR)->GetFunction()
  );
  target->Set(
    Nan::New("VK_VERSION_MINOR").ToLocalChecked(),
    Nan::New<v8::FunctionTemplate>(_VK_VERSION_MINOR)->GetFunction()
  );
  target->Set(
    Nan::New("VK_VERSION_PATCH").ToLocalChecked(),
    Nan::New<v8::FunctionTemplate>(_VK_VERSION_PATCH)->GetFunction()
  );
  target->Set(
    Nan::New("VK_API_VERSION_1_0").ToLocalChecked(),
    Nan::New(VK_MAKE_VERSION(1, 0, 0))
  );
  // generated initializers
  {% for incl in includes -%}
  {%- if incl != "" -%}
  _{{ incl }}::Initialize(target);
  {% endif -%}
  {% endfor %}
  {% for call in calls -%}
  target->Set(
    Nan::New("{{ call.name }}").ToLocalChecked(),
    Nan::New<v8::FunctionTemplate>(_{{ call.name }})->GetFunction()
  );
  {% endfor %}
}

NODE_MODULE(myModule, init);
